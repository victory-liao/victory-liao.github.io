<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>伪迹移除 | 1D-ResCNN model to remove artifact</title>
    <url>/2020/10/10/1D-ResCNN-model-to-remove-artifact/</url>
    <content><![CDATA[<h1 id="A-novel-end-to-end-1D-ResCNN-model-to-remove-artifact-from-EEG-signals"><a href="#A-novel-end-to-end-1D-ResCNN-model-to-remove-artifact-from-EEG-signals" class="headerlink" title="A novel end-to-end 1D-ResCNN model to remove artifact from EEG signals"></a>A novel end-to-end 1D-ResCNN model to remove artifact from EEG signals</h1><div>
<b>two stages of end-to-end manner:</b>
<ul>
<li>training stage:an objective function is often adopted to optimize the model parameters.</li>
<li>test stage:the trained 1D-ResCNN model is used as a filter to automatically remove noise from the contaminated EEG signal.</li>
</ul>
</div>
<span id="more"></span>

<div style="background-color:yellowgreen;">
<b backgroundclor="green">1D-ResCNN model‘s advantages:</b>
<ul>
<li>achieves smaller RMSE and better signal-to-noise ratio(SNR).</li>
<li>better noise suppression ability.</li>
<li>the nonlinear characteristics of EEG after denosing are significantly maintained(preserved).</li>
<li>the EEG denosing performance under unknown noise is further improved.</li>  
</ul>
</div>

]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>伪迹移除</category>
      </categories>
      <tags>
        <tag>1D-ResCNN</tag>
        <tag>伪迹移除</tag>
      </tags>
  </entry>
  <entry>
    <title>脑电分类 | 1D卷积和LSTM脑电信号识别</title>
    <url>/2021/07/03/1D%E5%8D%B7%E7%A7%AF%E5%92%8CLSTM%E8%84%91%E7%94%B5%E4%BF%A1%E5%8F%B7%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<h1 id="1D卷积和LSTM脑电信号识别"><a href="#1D卷积和LSTM脑电信号识别" class="headerlink" title="1D卷积和LSTM脑电信号识别"></a>1D卷积和LSTM脑电信号识别</h1><p>这是一个非常重要的文章！！！ This is a very important article!!!</p>
<table>
<thead>
<tr>
<th>模型</th>
<th>框架</th>
<th>准确率</th>
</tr>
</thead>
<tbody><tr>
<td>CNN+LSTM</td>
<td>TensorFlow</td>
<td>70%</td>
</tr>
</tbody></table>
<p><a href="https://blog.csdn.net/zyb228/article/details/109193128">参考资料</a></p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>脑电分类</category>
        <category>网络</category>
        <category>CNN+LSTM</category>
      </categories>
      <tags>
        <tag>脑电分类</tag>
        <tag>LSTM</tag>
        <tag>CNN+LSTM</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 | 23种设计模式总结</title>
    <url>/2021/03/11/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="23种设计模式总结-未完成"><a href="#23种设计模式总结-未完成" class="headerlink" title="23种设计模式总结(未完成)"></a>23种设计模式总结(未完成)</h1><p>以下内容对23中设计模式进行简单介绍：</p>
<span id="more"></span>

<p>1-12设计模式为创建型，13-23设计模式为行为型</p>
<h2 id="1-抽象工厂"><a href="#1-抽象工厂" class="headerlink" title="1.抽象工厂"></a>1.抽象工厂</h2><p>客户类和工厂类分离(判断逻辑和事务处理分开)</p>
<p>客户想抽象工厂请求，抽象工厂再向具体工厂请求生产具体的产品</p>
<p>example:出行方式</p>
<h2 id="2-生成器"><a href="#2-生成器" class="headerlink" title="2.生成器"></a>2.生成器</h2><p>将一个复杂的对象的<b>构建与它的表示分离</b>，使得同样的构建过程有不同的表示</p>
<h2 id="3-工厂方法"><a href="#3-工厂方法" class="headerlink" title="3.工厂方法"></a>3.工厂方法</h2><p>让子类决定实例化哪一个类</p>
<h2 id="4-原型"><a href="#4-原型" class="headerlink" title="4.原型"></a>4.原型</h2><p>example:范文</p>
<h2 id="5-单例"><a href="#5-单例" class="headerlink" title="5.单例"></a>5.单例</h2><p>保证一个类只有一个实力，提供一个访问它的全局访问点</p>
<h2 id="6-适配器"><a href="#6-适配器" class="headerlink" title="6.适配器"></a>6.适配器</h2><p>example:连接电源和笔记本的适配器</p>
<h2 id="7-桥"><a href="#7-桥" class="headerlink" title="7.桥"></a>7.桥</h2><p>抽象部分与实现部分分离</p>
<h2 id="8-组合"><a href="#8-组合" class="headerlink" title="8.组合"></a>8.组合</h2><p>整体-部分的关系，使用户对单个、组合对象的使用具有一致性<br>example:双击打开文件/文件夹</p>
<h2 id="9-装饰"><a href="#9-装饰" class="headerlink" title="9.装饰"></a>9.装饰</h2><p>动态地给一个对象(而不是整个类)添加一些额外的职责<br>example：生日蛋糕</p>
<h2 id="10-外观"><a href="#10-外观" class="headerlink" title="10.外观"></a>10.外观</h2><p>为子系统的一组接口，提供一个统一的接口<br>example: 陕师大主页-各学院网站</p>
<h2 id="11-享元"><a href="#11-享元" class="headerlink" title="11.享元"></a>11.享元</h2><p>以共享的方式高效的支持大量的细粒度对象</p>
<h2 id="12-代理"><a href="#12-代理" class="headerlink" title="12.代理"></a>12.代理</h2><p>example:中国驻美大使馆是中国政府在美国的代理</p>
<h2 id="13-责任链"><a href="#13-责任链" class="headerlink" title="13.责任链"></a>13.责任链</h2><p>example: 提问</p>
<h2 id="14-命令"><a href="#14-命令" class="headerlink" title="14.命令"></a>14.命令</h2><p>将一个请求封装成一个对象</p>
<h2 id="15-解释器"><a href="#15-解释器" class="headerlink" title="15.解释器"></a>15.解释器</h2><h2 id="16-迭代器"><a href="#16-迭代器" class="headerlink" title="16.迭代器"></a>16.迭代器</h2><p>可以顺序访问一个聚合对象中的元素，不必暴露对象的内部表示</p>
<h2 id="17-调停者-中介者"><a href="#17-调停者-中介者" class="headerlink" title="17.调停者/中介者"></a>17.调停者/中介者</h2><p>example:租房子-中介</p>
<h2 id="18-备忘录"><a href="#18-备忘录" class="headerlink" title="18.备忘录"></a>18.备忘录</h2><p>example:游戏记录、系统还原、任务迁移</p>
<h2 id="19-观察者"><a href="#19-观察者" class="headerlink" title="19.观察者"></a>19.观察者</h2><h2 id="20-状态"><a href="#20-状态" class="headerlink" title="20.状态"></a>20.状态</h2><p>允许一个对象在其内部状态改变的时候改变行为，这个对象看上去像是改变了它的类一样</p>
<h2 id="21-策略"><a href="#21-策略" class="headerlink" title="21.策略"></a>21.策略</h2><p>将每一个算法封装到具有共同接口的独立的类<br>example:御敌之策(兵来将挡、水来土掩)、出行方式</p>
<h2 id="22-模板方法"><a href="#22-模板方法" class="headerlink" title="22.模板方法"></a>22.模板方法</h2><p>定义一个算法中操作的股价，将一些步骤延迟到子类中</p>
<h2 id="23-访问者"><a href="#23-访问者" class="headerlink" title="23.访问者"></a>23.访问者</h2><p>数据结构与操作分离</p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>23种设计模式总结</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>python | 50条有趣的python一行代码</title>
    <url>/2021/10/16/50%E6%9D%A1%E6%9C%89%E8%B6%A3%E7%9A%84python%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h1 id="50条有趣的python一行代码！"><a href="#50条有趣的python一行代码！" class="headerlink" title="50条有趣的python一行代码！"></a>50条有趣的python一行代码！</h1><p><a href="https://mp.weixin.qq.com/s/LVEPw7QAPqfLvi151aproQ">50条有趣的python一行代码！</a></p>
<span id="more"></span>
<p>1.字母异位词</p>
<pre><code>from collections import Counter
# Counter: Elements are stored as dictionary keys and their counts are stored as dictionary values.

s1 = &#39;below&#39;
s2 = &#39;elbow&#39;
print(Counter(s1)) # Counter(&#123;&#39;b&#39;: 1, &#39;e&#39;: 1, &#39;l&#39;: 1, &#39;o&#39;: 1, &#39;w&#39;: 1&#125;)

print(&#39;anagram&#39;) if Counter(s1) == Counter(s2) else print(&#39;not an anagram&#39;)
</code></pre>
<p>2.二进制转十进制</p>
<pre><code>decimal = int(&quot;1010&quot;, 2)
print(decimal)
</code></pre>
<p>3.将字符串转换为小写</p>
<pre><code>print(&quot;Hi my name is XiaoF&quot;.lower())
# &#39;hi my name is xiaof&#39;
print(&quot;Hi my name is XiaoF&quot;.casefold())
# &#39;hi my name is xiaof&#39;
</code></pre>
<p>4.将字符串转换为大写</p>
<pre><code>print(&quot;hi my name is XiaoF&quot;.upper())
# &#39;HI MY NAME IS XIAOF&#39;
</code></pre>
<p>5.将字符串转换为字节</p>
<pre><code>print(&quot;convert string to bytes using encode method&quot;.encode())
print(type(&quot;convert string to bytes using encode method&quot;.encode()))
b&#39;convert string to bytes using encode method&#39;
</code></pre>
<p>6.拷贝文件</p>
<pre><code>import shutil
shutil.copyfile(&#39;source.txt&#39;, &#39;dest.txt&#39;)
</code></pre>
<p>7.快速排序</p>
<pre><code>qsort = lambda l: l if len(l) &lt;= 1 else qsort([x for x in l[1:] if x &lt; l[0]]) + [l[0]] + qsort([x for x in l[1:] if x &gt;= l[0]])
print(qsort([1]))
print(qsort([17, 29, 11, 97, 103, 5]))
</code></pre>
<p>8.n个连续数的和</p>
<pre><code>n = 10
print(sum(range(0, n+1)))
# 55
</code></pre>
<p>9.交换两个变量的值</p>
<pre><code>a = 1
b = 2
print(a, b)
a,b = b,a
print(a, b)
</code></pre>
<p>10.斐波纳契数列</p>
<pre><code>fib = lambda x: x if x&lt;=1 else fib(x-1) + fib(x-2)

def fib(x):
    if x &lt;= 1:
        return x
    else:
        return fib(x-1) + fib(x-2)
print(fib(20))
# 6765
</code></pre>
<p>11.将嵌套列表合并为一个列表</p>
<pre><code>main_list = [[0, 1, 2], [11, 12, 13], [52, 53, 54]]

result = [item for sublist in main_list for item in sublist]
print(result)
# [0, 1, 2, 11, 12, 13, 52, 53, 54]
</code></pre>
<p>12.运行一个HTTP服务器</p>
<pre><code>python3 -m http.server 8000
python2 -m SimpleHTTPServer
</code></pre>
<p>13.反转列表</p>
<pre><code>numbers = [0, 1, 2, 11, 12, 13, 52, 53, 54]
print(numbers[::-1])
# [54, 53, 52, 13, 12, 11, 2, 1, 0]
</code></pre>
<p>14.阶乘</p>
<pre><code>import math
fact_5 = math.factorial(5)
print(fact_5)
# 120
</code></pre>
<p>15.在列表推导式中使用for和if</p>
<pre><code>even_list = [number for number in [1, 2, 3, 4] if number % 2 == 0]
print(even_list)
# [2, 4]
</code></pre>
<p>16.列表中最长的字符串</p>
<pre><code>words = [&#39;This&#39;, &#39;is&#39;, &#39;a&#39;, &#39;list&#39;, &#39;of&#39;, &#39;words&#39;]
result = max(words, key=len)
print(result)
# &#39;words&#39;
</code></pre>
<p>17.列表推导式</p>
<pre><code>li = [num for num in range(0, 10)]
print(li)
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>18.集合推导式</p>
<pre><code>num_set = &#123;num for num in range(0, 10)&#125;
print(num_set)
# &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;
</code></pre>
<p>19.字典推导式</p>
<pre><code>dict_numbers = &#123;x: x*x for x in range(1, 5)&#125;
print(dict_numbers)
# &#123;1: 1, 2: 4, 3: 9, 4: 16&#125;
</code></pre>
<p>20.if-else</p>
<pre><code>print(&quot;even&quot;) if 4 % 2==0 else print(&quot;odd&quot;)
</code></pre>
<p>21.无限循环</p>
<pre><code>while 1:0
</code></pre>
<p>22.检查数据类型</p>
<pre><code>print(isinstance(2, int))
# True
print(isinstance(&quot;allwin&quot;, str))
# True
print(isinstance([3, 4, 1997], list))
# True
</code></pre>
<p>23.While循环</p>
<pre><code>a = 5

while a &gt; 0:
    a = a - 1

print(a)
# 0
</code></pre>
<p>24.使用print语句写入文件</p>
<pre><code>print(&quot;Hello, World!&quot;, file=open(&#39;file.txt&#39;, &#39;w&#39;))
# 既可打印出信息，还能将信息保存文件。
</code></pre>
<p>25.计算一个字符在字符串中出现的频率</p>
<pre><code>print(&quot;umbrella&quot;.count(&#39;l&#39;))
# 2
</code></pre>
<p>26.合并列表</p>
<pre><code>list1 = [1, 2, 4]
list2 = [&#39;XiaoF&#39;]
list1.extend(list2)
print(list1)
# [1, 2, 4, &#39;XiaoF&#39;]
</code></pre>
<p>27.合并字典</p>
<pre><code>dict1 = &#123;&#39;name&#39;: &#39;weiwei&#39;, &#39;age&#39;: 23&#125;
dict2 = &#123;&#39;city&#39;: &#39;Beijing&#39;&#125;
dict1.update(dict2)
print(dict1)
# &#123;&#39;name&#39;: &#39;weiwei&#39;, &#39;age&#39;: 23, &#39;city&#39;: &#39;Beijing&#39;&#125;
</code></pre>
<p>28.合并集合</p>
<pre><code>set1 = &#123;0, 1, 2&#125;
set2 = &#123;11, 12, 13&#125;
set1.update(set2)
print(set1)
# &#123;0, 1, 2, 11, 12, 13&#125;
</code></pre>
<p>29.时间戳</p>
<pre><code>import time
print(time.time())
</code></pre>
<p>30.列表中出现次数最多的元素</p>
<pre><code>test_list = [9, 4, 5, 4, 4, 5, 9, 5, 4]
most_frequent_element = max(set(test_list), key=test_list.count)
print(most_frequent_element)
# 4
</code></pre>
<p>31.嵌套列表</p>
<pre><code>numbers = [[num] for num in range(10)]
print(numbers)
# [[0], [1], [2], [3], [4], [5], [6], [7], [8], [9]]
</code></pre>
<p>32.八进制转十进制</p>
<pre><code>print(int(&#39;30&#39;, 8))
# 24
</code></pre>
<p>33.将键值对转换为字典</p>
<pre><code>result = dict(name=&#39;XiaoF&#39;, age=23)
print(result)
# &#123;&#39;name&#39;: &#39;XiaoF&#39;, &#39;age&#39;: 23&#125;
</code></pre>
<p>34.求商和余数</p>
<pre><code>quotient, remainder = divmod(4, 5)
print(quotient, remainder)
# 0 4
# divmod()函数返回当参数1除以参数2时，包含商和余数的元组。
</code></pre>
<p>35.删除列表中的重复项</p>
<pre><code>print(list(set([4, 4, 5, 5, 6])))
# [4, 5, 6]
</code></pre>
<p>36.按升序排序列表</p>
<pre><code>print(sorted([5, 2, 9, 1]))
# [1, 2, 5, 9]
</code></pre>
<p>37.按降序排序列表</p>
<pre><code>print(sorted([5, 2, 9, 1], reverse=True))
# [9, 5, 2, 1]
</code></pre>
<p>38.获取小写字母表</p>
<pre><code>import string
print(string.ascii_lowercase)
print(type(string.ascii_lowercase))
# abcdefghijklmnopqrstuvwxyz
</code></pre>
<p>39.获取大写字母表</p>
<pre><code>import string
print(string.ascii_uppercase)
# ABCDEFGHIJKLMNOPQRSTUVWXYZ
</code></pre>
<p>40.获取0到9字符串</p>
<pre><code>import string
print(string.digits)
# 0123456789
</code></pre>
<p>41.十六进制转十进制</p>
<pre><code>print(int(&#39;da9&#39;, 16))
# 3497
</code></pre>
<p>42.日期时间</p>
<pre><code>import time
print(time.ctime())
# Thu Aug 13 20:00:00 2021
</code></pre>
<p>43.将列表中的字符串转换为整数</p>
<pre><code>print(list(map(int, [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;])))
# [1, 2, 3]
</code></pre>
<p>44.用键对字典进行排序</p>
<pre><code>d = &#123;&#39;one&#39;: 1, &#39;four&#39;: 4, &#39;eight&#39;: 8&#125;
result = &#123;key: d[key] for key in sorted(d.keys())&#125;
print(result)
# &#123;&#39;eight&#39;: 8, &#39;four&#39;: 4, &#39;one&#39;: 1&#125;
</code></pre>
<p>45.用键值对字典进行排序</p>
<pre><code>x = &#123;1: 2, 3: 4, 4: 3, 2: 1, 0: 0&#125;
result = &#123;k: v for k, v in sorted(x.items(), key=lambda item: item[0])&#125;
print(result)
# &#123;0: 0, 2: 1, 1: 2, 4: 3, 3: 4&#125;
</code></pre>
<p>46.列表旋转</p>
<pre><code>li = [1, 2, 3, 4, 5]
# li[n:] + li[:n], 右变左
print(li[2:] + li[:2])
# [3, 4, 5, 1, 2]
# li[-n:] + li[:-n], 左变右
print(li[-1:] + li[:-1])
# [5, 1, 2, 3, 4]
</code></pre>
<p>47.将字符串中的数字移除</p>
<pre><code>message = &#39;&#39;.join(list(filter(lambda x: x.isalpha(), &#39;abc123def4fg56vcg2&#39;)))
print(message)
# abcdeffgvcg
</code></pre>
<p>48.矩阵变换</p>
<pre><code>old_list = [[1, 2, 3], [3, 4, 6], [5, 6, 7]]
result = list(list(x) for x in zip(*old_list))
print(result)
# [[1, 3, 5], [2, 4, 6], [3, 6, 7]]
</code></pre>
<p>49.列表过滤</p>
<pre><code>result = list(filter(lambda x: x % 2 == 0, [1, 2, 3, 4, 5, 6]))
print(result)
# [2, 4, 6]
</code></pre>
<p>50.解包</p>
<pre><code>a, *b, c = [1, 2, 3, 4, 5]
print(a)  # 1
print(b)  # [2, 3, 4]
print(c)  # 5
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python | 68个python内置函数详解</title>
    <url>/2021/10/16/68%E4%B8%AApython%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="68个python内置函数详解"><a href="#68个python内置函数详解" class="headerlink" title="68个python内置函数详解"></a>68个python内置函数详解</h1><p>内置函数就是Python给你提供的，拿来直接用的函数，比如print.，input等。<br>截止到python版本3.6.2 ，python一共提供了68个内置函数，具体如下👇</p>
<pre><code>abs()           dict()        help()         min()         setattr()
all()           dir()         hex()          next()        slice() 
any()           divmod()      id()           object()      sorted() 
ascii()         enumerate()   input()        oct()         staticmethod() 
bin()           eval()        int()          open()        str() 
bool()          exec()        isinstance()   ord()         sum() 
bytearray()     ﬁlter()       issubclass()   pow()         super() 
bytes()         ﬂoat()        iter()         print()       tuple() 
callable()      format()      len()          property()    type() 
chr()           frozenset()   list()         range()       vars() 
classmethod()   getattr()     locals()       repr()        zip() 
compile()       globals()     map()          reversed()    __import__() 
complex()       hasattr()     max()          round() 
delattr()       hash()        memoryview()   set()
</code></pre>
<span id="more"></span>
<p>本文将这68个内置函数综合整理为12大类，正在学习Python基础的读者一定不要错过，建议收藏学习！<br>和数字相关</p>
<ol>
<li>数据类型</li>
</ol>
<p>bool : 布尔型(True,False)<br>int : 整型(整数)<br>float : 浮点型(小数)<br>complex : 复数</p>
<ol start="2">
<li>进制转换</li>
</ol>
<p>bin() 将给的参数转换成二进制<br>otc() 将给的参数转换成八进制<br>hex() 将给的参数转换成十六进制</p>
<pre><code>print(bin(10))  # 二进制:0b1010
print(hex(10))  # 十六进制:0xa
print(oct(10))  # 八进制:0o12
</code></pre>
<ol start="3">
<li>数学运算</li>
</ol>
<p>abs() 返回绝对值<br>divmode() 返回商和余数<br>round() 四舍五入<br>pow(a, b) 求a的b次幂, 如果有三个参数. 则求完次幂后对第三个数取余<br>sum() 求和<br>min() 求最小值<br>max() 求最大值</p>
<pre><code>print(abs(-2))  # 绝对值:2
print(divmod(20,3)) # 求商和余数:(6,2)
print(round(4.50))   # 五舍六入:4
print(round(4.51))   #5
print(pow(10,2,3))  # 如果给了第三个参数. 表示最后取余:1
print(sum([1,2,3,4,5,6,7,8,9,10]))  # 求和:55
print(min(5,3,9,12,7,2))  #求最小值:2
print(max(7,3,15,9,4,13))  #求最大值:15
</code></pre>
<p>和数据结构相关</p>
<ol>
<li>序列</li>
</ol>
<p>（1）列表和元组</p>
<p>list() 将一个可迭代对象转换成列表<br>tuple() 将一个可迭代对象转换成元组</p>
<pre><code>print(list((1,2,3,4,5,6)))  #[1, 2, 3, 4, 5, 6]
print(tuple([1,2,3,4,5,6]))  #(1, 2, 3, 4, 5, 6)
</code></pre>
<p>（2）相关内置函数</p>
<p>reversed() 将一个序列翻转, 返回翻转序列的迭代器<br>slice() 列表的切片</p>
<pre><code>lst = &quot;你好啊&quot;
it = reversed(lst)   # 不会改变原列表. 返回一个迭代器, 设计上的一个规则
print(list(it))  #[&#39;啊&#39;, &#39;好&#39;, &#39;你&#39;]
lst = [1, 2, 3, 4, 5, 6, 7]
print(lst[1:3:1])  #[2,3]
s = slice(1, 3, 1)  #  切片用的
print(lst[s])  #[2,3]
</code></pre>
<p>（3）字符串</p>
<p>str() 将数据转化成字符串</p>
<pre><code>print(str(123)+&#39;456&#39;)  #123456
</code></pre>
<p>format() 与具体数据相关, 用于计算各种小数, 精算等.</p>
<pre><code>s = &quot;hello world!&quot;
print(format(s, &quot;^20&quot;))  #剧中
print(format(s, &quot;&lt;20&quot;))  #左对齐
print(format(s, &quot;&gt;20&quot;))  #右对齐
#     hello world!    
# hello world!        
#         hello world!
print(format(3, &#39;b&#39; ))    # 二进制:11
print(format(97, &#39;c&#39; ))   # 转换成unicode字符:a
print(format(11, &#39;d&#39; ))   # ⼗进制:11
print(format(11, &#39;o&#39; ))   # 八进制:13 
print(format(11, &#39;x&#39; ))   # 十六进制(⼩写字母):b
print(format(11, &#39;X&#39; ))   # 十六进制(大写字母):B
print(format(11, &#39;n&#39; ))   # 和d⼀样:11
print(format(11))         # 和d⼀样:11

print(format(123456789, &#39;e&#39; ))      # 科学计数法. 默认保留6位小数:1.234568e+08
print(format(123456789, &#39;0.2e&#39; ))   # 科学计数法. 保留2位小数(小写):1.23e+08
print(format(123456789, &#39;0.2E&#39; ))   # 科学计数法. 保留2位小数(大写):1.23E+08
print(format(1.23456789, &#39;f&#39; ))     # 小数点计数法. 保留6位小数:1.234568
print(format(1.23456789, &#39;0.2f&#39; ))  # 小数点计数法. 保留2位小数:1.23
print(format(1.23456789, &#39;0.10f&#39;))  # 小数点计数法. 保留10位小数:1.2345678900
print(format(1.23456789e+3, &#39;F&#39;))   # 小数点计数法. 很大的时候输出INF:1234.567890
</code></pre>
<p>bytes() 把字符串转化成bytes类型</p>
<pre><code>bs = bytes(&quot;今天吃饭了吗&quot;, encoding=&quot;utf-8&quot;)
print(bs)  #b&#39;\xe4\xbb\x8a\xe5\xa4\xa9\xe5\x90\x83\xe9\xa5\xad\xe4\xba\x86\xe5\x90\x97&#39;
</code></pre>
<p>bytearray()    返回一个新字节数组. 这个数字的元素是可变的, 并且每个元素的值得范围是[0,256)</p>
<pre><code>ret = bytearray(&quot;alex&quot; ,encoding =&#39;utf-8&#39;)
print(ret[0])  #97
print(ret)  #bytearray(b&#39;alex&#39;)
ret[0] = 65  #把65的位置A赋值给ret[0]
print(str(ret))  #bytearray(b&#39;Alex&#39;)
</code></pre>
<p>ord() 输入字符找带字符编码的位置<br>chr() 输入位置数字找出对应的字符<br>ascii() 是ascii码中的返回该值 不是就返回u</p>
<pre><code>print(ord(&#39;a&#39;))  # 字母a在编码表中的码位:97
print(ord(&#39;中&#39;))  # &#39;中&#39;字在编码表中的位置:20013

print(chr(65))  # 已知码位,求字符是什么:A
print(chr(19999))  #丟

for i in range(65536):  #打印出0到65535的字符
    print(chr(i), end=&quot; &quot;)

print(ascii(&quot;@&quot;))  #&#39;@&#39;
</code></pre>
<p>repr() 返回一个对象的string形式</p>
<pre><code>s = &quot;今天\n吃了%s顿\t饭&quot; % 3
print(s)#今天# 吃了3顿    饭
print(repr(s))   # 原样输出,过滤掉转义字符 \n \t \r 不管百分号%
#&#39;今天\n吃了3顿\t饭&#39;
</code></pre>
<ol start="2">
<li>数据集合</li>
</ol>
<p>字典：dict 创建一个字典</p>
<p>集合：set 创建一个集合</p>
<p>frozenset() 创建一个冻结的集合，冻结的集合不能进行添加和删除操作。<br>3. 相关内置函数</p>
<p>len() 返回一个对象中的元素的个数<br>sorted() 对可迭代对象进行排序操作 (lamda)</p>
<p>语法：sorted(Iterable, key=函数(排序规则), reverse=False)</p>
<p>Iterable: 可迭代对象<br>key: 排序规则(排序函数), 在sorted内部会将可迭代对象中的每一个元素传递给这个函数的参数. 根据函数运算的结果进行排序<br>reverse: 是否是倒叙. True: 倒叙, False: 正序</p>
<pre><code>lst = [5,7,6,12,1,13,9,18,5]
lst.sort()  # sort是list里面的一个方法
print(lst)  #[1, 5, 5, 6, 7, 9, 12, 13, 18]

ll = sorted(lst) # 内置函数. 返回给你一个新列表  新列表是被排序的
print(ll)  #[1, 5, 5, 6, 7, 9, 12, 13, 18]

l2 = sorted(lst,reverse=True)  #倒序
print(l2)  #[18, 13, 12, 9, 7, 6, 5, 5, 1]
</code></pre>
<p>#根据字符串长度给列表排序<br>    lst = [‘one’, ‘two’, ‘three’, ‘four’, ‘five’, ‘six’]<br>    def f(s):<br>        return len(s)<br>    l1 = sorted(lst, key=f, )<br>    print(l1)  #[‘one’, ‘two’, ‘six’, ‘four’, ‘five’, ‘three’]</p>
<p>enumerate() 获取集合的枚举对象</p>
<pre><code>lst = [&#39;one&#39;,&#39;two&#39;,&#39;three&#39;,&#39;four&#39;,&#39;five&#39;]
for index, el in enumerate(lst,1):    # 把索引和元素一起获取,索引默认从0开始. 可以更改
    print(index)
    print(el)
# 1
# one
# 2
# two
# 3
# three
# 4
# four
# 5
# five
</code></pre>
<p>all() 可迭代对象中全部是True, 结果才是True<br>any() 可迭代对象中有一个是True, 结果就是True</p>
<pre><code>print(all([1,&#39;hello&#39;,True,9]))  #True
print(any([0,0,0,False,1,&#39;good&#39;]))  #True
</code></pre>
<p>zip() 函数用于将可迭代的对象作为参数, 将对象中对应的元素打包成一个元组, 然后返回由这些元组组成的列表. 如果各个迭代器的元素个数不一致, 则返回列表长度与最短的对象相同</p>
<pre><code>lst1 = [1, 2, 3, 4, 5, 6]
lst2 = [&#39;醉乡民谣&#39;, &#39;驴得水&#39;, &#39;放牛班的春天&#39;, &#39;美丽人生&#39;, &#39;辩护人&#39;, &#39;被嫌弃的松子的一生&#39;]
lst3 = [&#39;美国&#39;, &#39;中国&#39;, &#39;法国&#39;, &#39;意大利&#39;, &#39;韩国&#39;, &#39;日本&#39;]
print(zip(lst1, lst1, lst3))  #&lt;zip object at 0x00000256CA6C7A88&gt;
for el in zip(lst1, lst2, lst3):
    print(el)
# (1, &#39;醉乡民谣&#39;, &#39;美国&#39;)
# (2, &#39;驴得水&#39;, &#39;中国&#39;)
# (3, &#39;放牛班的春天&#39;, &#39;法国&#39;)
# (4, &#39;美丽人生&#39;, &#39;意大利&#39;)
# (5, &#39;辩护人&#39;, &#39;韩国&#39;)
# (6, &#39;被嫌弃的松子的一生&#39;, &#39;日本&#39;)
</code></pre>
<p>fiter() 过滤 (lamda)</p>
<p>语法：fiter(function. Iterable)</p>
<p>function: 用来筛选的函数. 在ﬁlter中会自动的把iterable中的元素传递给function. 然后根据function返回的True或者False来判断是否保留留此项数据 , Iterable: 可迭代对象</p>
<pre><code>def func(i):    # 判断奇数
    return i % 2 == 1
    lst = [1,2,3,4,5,6,7,8,9]
l1 = filter(func, lst)  #l1是迭代器
print(l1)  #&lt;filter object at 0x000001CE3CA98AC8&gt;
print(list(l1))  #[1, 3, 5, 7, 9]
</code></pre>
<p>map() 会根据提供的函数对指定序列列做映射(lamda)</p>
<p>语法 : map(function, iterable)</p>
<p>可以对可迭代对象中的每一个元素进行映射. 分别去执行 function</p>
<pre><code>def f(i):    return i
lst = [1,2,3,4,5,6,7,]
it = map(f, lst) # 把可迭代对象中的每一个元素传递给前面的函数进行处理. 处理的结果会返回成迭代器print(list(it))  #[1, 2, 3, 4, 5, 6, 7]
</code></pre>
<p>和作用域相关</p>
<p>locals() 返回当前作用域中的名字<br>globals() 返回全局作用域中的名字</p>
<pre><code>def func():
    a = 10
    print(locals())  # 当前作用域中的内容
    print(globals())  # 全局作用域中的内容
    print(&quot;今天内容很多&quot;)
func()
# &#123;&#39;a&#39;: 10&#125;
# &#123;&#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None, &#39;__package__&#39;: None, &#39;__loader__&#39;: 
# &lt;_frozen_importlib_external.SourceFileLoader object at 0x0000026F8D566080&gt;, 
# &#39;__spec__&#39;: None, &#39;__annotations__&#39;: &#123;&#125;, &#39;__builtins__&#39;: &lt;module &#39;builtins&#39; 
# (built-in)&gt;, &#39;__file__&#39;: &#39;D:/pycharm/练习/week03/new14.py&#39;, &#39;__cached__&#39;: None,
#  &#39;func&#39;: &lt;function func at 0x0000026F8D6B97B8&gt;&#125;
# 今天内容很多
</code></pre>
<p>和迭代器生成器相关</p>
<p>range() 生成数据<br>next() 迭代器向下执行一次, 内部实际使⽤用了__ next__()⽅方法返回迭代器的下一个项目<br>iter() 获取迭代器, 内部实际使用的是__ iter__()⽅方法来获取迭代器</p>
<pre><code>for i in range(15,-1,-5):
    print(i)
# 15
# 10
# 5
# 0
lst = [1,2,3,4,5]
it = iter(lst)  #  __iter__()获得迭代器
print(it.__next__())  #1
print(next(it)) #2  __next__()  
print(next(it))  #3
print(next(it))  #4
</code></pre>
<p>字符串类型代码的执行</p>
<p>eval() 执行字符串类型的代码. 并返回最终结果<br>exec() 执行字符串类型的代码<br>compile() 将字符串类型的代码编码. 代码对象能够通过exec语句来执行或者eval()进行求值</p>
<pre><code>s1 = input(&quot;请输入a+b:&quot;)  #输入:8+9
print(eval(s1))  # 17 可以动态的执行代码. 代码必须有返回值
s2 = &quot;for i in range(5): print(i)&quot;
a = exec(s2) # exec 执行代码不返回任何内容

# 0
# 1
# 2
# 3
# 4
print(a)  #None

# 动态执行代码
exec(&quot;&quot;&quot;
def func():
    print(&quot; 我是周杰伦&quot;)
&quot;&quot;&quot; )
func()  #我是周杰伦

code1 = &quot;for i in range(3): print(i)&quot;
com = compile(code1, &quot;&quot;, mode=&quot;exec&quot;)   # compile并不会执行你的代码.只是编译
exec(com)   # 执行编译的结果
# 0
# 1
# 2

code2 = &quot;5+6+7&quot;
com2 = compile(code2, &quot;&quot;, mode=&quot;eval&quot;)
print(eval(com2))  # 18

code3 = &quot;name = input(&#39;请输入你的名字:&#39;)&quot;  #输入:hello
com3 = compile(code3, &quot;&quot;, mode=&quot;single&quot;)
exec(com3)
print(name)  #hello
</code></pre>
<p>输入输出</p>
<p>print() : 打印输出<br>input() : 获取用户输出的内容</p>
<pre><code>print(&quot;hello&quot;, &quot;world&quot;, sep=&quot;*&quot;, end=&quot;@&quot;) # sep:打印出的内容用什么连接,end:以什么为结尾
#hello*world@
</code></pre>
<p>内存相关</p>
<p>hash() : 获取到对象的哈希值(int, str, bool, tuple). hash算法:(1) 目的是唯一性 (2) dict 查找效率非常高, hash表.用空间换的时间 比较耗费内存</p>
<pre><code>s = &#39;alex&#39;print(hash(s))  #-168324845050430382lst = [1, 2, 3, 4, 5]print(hash(lst))  #报错,列表是不可哈希的  id() :  获取到对象的内存地址s = &#39;alex&#39;print(id(s))  #2278345368944
</code></pre>
<p>文件操作相关</p>
<p>open() : 用于打开一个文件, 创建一个文件句柄</p>
<pre><code>f = open(&#39;file&#39;,mode=&#39;r&#39;,encoding=&#39;utf-8&#39;)
f.read()
f.close()
</code></pre>
<p>模块相关</p>
<p>__ import__() : 用于动态加载类和函数</p>
<pre><code># 让用户输入一个要导入的模块
import os
name = input(&quot;请输入你要导入的模块:&quot;)
__import__(name)    # 可以动态导入模块
</code></pre>
<p>帮 助</p>
<p>help() : 函数用于查看函数或模块用途的详细说明</p>
<pre><code>print(help(str))  #查看字符串的用途
</code></pre>
<p>调用相关</p>
<p>callable() : 用于检查一个对象是否是可调用的. 如果返回True, object有可能调用失败, 但如果返回False. 那调用绝对不会成功</p>
<pre><code>a = 10
print(callable(a))  #False  变量a不能被调用
#
def f():
    print(&quot;hello&quot;)
    print(callable(f))   # True 函数是可以被调用的
</code></pre>
<p>查看内置属性</p>
<p>dir() : 查看对象的内置属性, 访问的是对象中的<strong>dir</strong>()方法</p>
<pre><code>print(dir(tuple))  #查看元组的方法
</code></pre>
<p><a href="https://mp.weixin.qq.com/s/RE07ReitUyQDwG2yYcugPQ">68个python内置函数详解!!!</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>内置函数</tag>
      </tags>
  </entry>
  <entry>
    <title>spring | AOP(切面、通知、切入点、切面优先级)</title>
    <url>/2022/03/06/AOP%E9%80%9A%E7%9F%A5%E5%88%87%E9%9D%A2%E5%88%87%E5%85%A5%E7%82%B9%E5%88%87%E9%9D%A2%E4%BC%98%E5%85%88%E7%BA%A7/</url>
    <content><![CDATA[<h1 id="AOP-切面、通知、切入点、切面优先级"><a href="#AOP-切面、通知、切入点、切面优先级" class="headerlink" title="AOP(切面、通知、切入点、切面优先级)"></a>AOP(切面、通知、切入点、切面优先级)</h1><p><strong>示例：</strong><br>1.项目目录<br><img src="/2022/03/06/AOP%E9%80%9A%E7%9F%A5%E5%88%87%E9%9D%A2%E5%88%87%E5%85%A5%E7%82%B9%E5%88%87%E9%9D%A2%E4%BC%98%E5%85%88%E7%BA%A7/1.PNG"></p>
<span id="more"></span>
<p>2.MathI.java(接口)</p>
<pre><code>package com.atguigu.spring.aop;

public interface MathI &#123;
    int add(int i, int j);
    int sub(int i, int j);
    int mul(int i, int j);
    int div(int i, int j);
&#125;
</code></pre>
<p>3.MathImpl.java（实现类）</p>
<pre><code>package com.atguigu.spring.aop;

import org.springframework.stereotype.Component;

@Component
public class MathImpl implements MathI&#123;

    @Override
    public int add(int i, int j) &#123;
        int result = i + j;
        return result;
    &#125;
    
    @Override
    public int sub(int i, int j) &#123;
        int result = i - j;
        return result;
    &#125;

    @Override
    public int mul(int i, int j) &#123;
        int result = i * j;
        return result; 
    &#125;

    @Override
    public int div(int i, int j) &#123;
        int result = i / j;
        return result;
    &#125;
&#125;
</code></pre>
<p>4.MyLoggerAspect.java（切面–&gt;日志）</p>
<pre><code>package com.atguigu.spring.aop;

import java.util.Arrays;
import org.aopalliance.intercept.Joinpoint;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.AfterThrowing;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

@Component
@Aspect//标注当前类为切面
@Order(1)
public class MyLoggerAspect &#123;
    //AspectJ支持的5种类型的通知注解
    
    //重用切入点定义
    @Pointcut(value=&quot;execution(* com.atguigu.spring.aop.*.*(..))&quot;)
    public void test()&#123;
        
    &#125;
    /**
     * @Before：将方法指定为前置通知
     * 必须设置value,其值为切入点表达式
     * 前置通知：作用于方法执行之前
     */
    //前置通知 
//    @Before(value = &quot;execution(public int com.atguigu.spring.aop.MathImpl.add(int, int))&quot;)
//    @Before(value = &quot;execution(public int com.atguigu.spring.aop.MathImpl.*(int,int))&quot;)
//    @Before(value = &quot;execution(* com.atguigu.spring.aop.MathImpl.*(int,int))&quot;)
//    @Before(value = &quot;execution(* com.atguigu.spring.aop.*.*(int,int))&quot;)
//    @Before(value = &quot;execution(* com.atguigu.spring.aop.*.*(..))&quot;)
    @Before(value = &quot;test()&quot;)
    public void beforeMethod(JoinPoint joinPoint)&#123;
        Object[] args = joinPoint.getArgs();//获取方法的参数
        String methodName = joinPoint.getSignature().getName();//获取方法名
        
        System.out.println(&quot;method:&quot; + methodName + &quot;,arguments:&quot; + Arrays.toString(args));
    &#125;
    
    /**
     * @After:将方法标注为后置通知
     * 后置通知：作用于方法的finally语句块，即不管有没有异常都会执行
     */
    //后置通知
    //@After(value = &quot;execution(* com.atguigu.spring.aop.*.*(..))&quot;)
    @After(value = &quot;test()&quot;)
    public void afterMethod()&#123;
        System.out.println(&quot;后置通知&quot;);
    &#125;
    
    /**
     * @AfterReturning：将方法标注为返回通知
     * 返回通知：作用于方法执行之后
     * 要通过returning设置接收方法返回值的变量名
     * 要向在方法中使用，必须在方法的形参中设置和变量名相同的参数名的参数
     */
    @AfterReturning(value = &quot;execution(* com.atguigu.spring.aop.*.*(..))&quot;,returning=&quot;result&quot;)
    public void afterReturing(JoinPoint joinPoint, Object result)&#123;
        String methodName = joinPoint.getSignature().getName();
        System.out.println(&quot;method:&quot; + methodName + &quot;,result:&quot; + result);
    &#125;
    
    /**
     * @AfterThrowing：将方法标注为异常通知（例外通知）
     * 异常通知：作用于方法抛出异常时
     * 可通过throwing设置接受方法返回的异常信息
     * 在参数列表中可通过具体的异常类型，来对指定的异常信息进行操作
     */
    @AfterThrowing(value = &quot;execution(* com.atguigu.spring.aop.*.*(..))&quot;, throwing=&quot;ex&quot;)
    public void afterThrowing(Exception ex)&#123;
        System.out.println(&quot;有异常了,messages&quot;+ex);
    &#125;
    //处理特定异常
//    @AfterThrowing(value = &quot;execution(* com.atguigu.spring.aop.*.*(..))&quot;, throwing=&quot;ex&quot;)
//    public void afterThrowing(NullPointerException ex)&#123;
//        System.out.println(&quot;有异常了,messages&quot;+ex);
//    &#125;
    
    /**
     * @Around：
     */
    @Around(value = &quot;execution(* com.atguigu.spring.aop.*.*(..))&quot;)
    public Object aroundMethod(ProceedingJoinPoint joinPoint)&#123;    
        Object result = null;
        try &#123;
            //前置通知
            System.out.println(&quot;前置通知&quot;);
            result = joinPoint.proceed();//执行方法
            //返回通知
            System.out.println(&quot;返回通知&quot;);
            return result;
        &#125; catch (Throwable e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
            //异常通知
            System.out.println(&quot;异常通知&quot;);
        &#125;finally&#123;
            //后置通知
            System.out.println(&quot;后置通知&quot;);
        &#125;
        return -1;
    &#125;
&#125;
</code></pre>
<p>5.TestHandler.java</p>
<pre><code>package com.atguigu.spring.aop;

import org.springframework.stereotype.Component;

@Component
public class TestHandler &#123;
    public void test()&#123;
        System.out.println(&quot;测试切入点表达式&quot;);
    &#125;
&#125;
</code></pre>
<p>6.TestAspect.java（切面–&gt;另一个切面，用来测试切面优先级）</p>
<pre><code>package com.atguigu.spring.aop;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

@Component
@Aspect
@Order(0)//定义切面作用的优先级，值越小优先级越高，默认值为int的最大值 
public class TestAspect &#123;
    @Before(value=&quot;execution(* com.atguigu.spring.aop.*.*(..))&quot;)
    public void before()&#123;
        System.out.println(&quot;TestAspect====&gt;前置通知&quot;);
    &#125;
&#125;
</code></pre>
<p>7.Test.java（测试类）</p>
<pre><code>package com.atguigu.spring.aop;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test &#123;
    public static void main(String[] args) &#123;
        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;aop.xml&quot;);
        
        MathI math = ac.getBean(&quot;mathImpl&quot;, MathI.class);
        
        int i = math.div(1, 1);
        System.out.println(i);
        
//        TestHandler bean = ac.getBean(&quot;testHandler&quot;, TestHandler.class);
//        bean.test();
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>spring</category>
        <category>AOP(切面、通知、切入点、切面优先级)</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习 | AdaBoost</title>
    <url>/2021/04/17/AdaBoost/</url>
    <content><![CDATA[<h1 id="AdaBoost"><a href="#AdaBoost" class="headerlink" title="AdaBoost"></a>AdaBoost</h1><h2 id="集成方法"><a href="#集成方法" class="headerlink" title="集成方法"></a>集成方法</h2><p>集成方法(ensemble method)/元算法(meta-algorithm):将不同的分类器组合起来的组合结果</p>
<p><b>集成方法的多种形式</b>：<br>1.不同算法的集成<br>2.同一种算法在不同设置下的集成<br>3.数据集不同部分分配给不同分类器之后的集成</p>
<p>基分类器一般采用的是弱可学习（weakly learnable）分类器，通过集成方法，组合成一个强可学习（strongly learnable）分类器</p>
<p><b>弱可学习：</b><br>是指学习的正确率仅略优于随机猜测的多项式学习算法</p>
<p><b>强可学习：</b><br>指正确率较高的多项式学习算法。</p>
<p>集成学习的泛化能力一般比单一的基分类器要好，这是因为大部分基分类器都分类错误的概率远低于单一基分类器的。</p>
<p><b>集成方法主要包括Bagging和Boosting两种方法</b>，Bagging和Boosting都是将已有的分类或回归算法通过一定方式组合起来，形成一个性能更加强大的分类器，更准确的说这是一种分类算法的组装方法，即<b>将弱分类器组装成强分类器</b>的方法。</p>
<h3 id="Bagging"><a href="#Bagging" class="headerlink" title="Bagging"></a>Bagging</h3><h3 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h3><h3 id="Bagging、boosting二者之间的区别"><a href="#Bagging、boosting二者之间的区别" class="headerlink" title="Bagging、boosting二者之间的区别"></a>Bagging、boosting二者之间的区别</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h2 id="AdaBoost-1"><a href="#AdaBoost-1" class="headerlink" title="AdaBoost"></a>AdaBoost</h2><h2 id="分类器性能评价"><a href="#分类器性能评价" class="headerlink" title="分类器性能评价"></a>分类器性能评价</h2><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2>]]></content>
      <categories>
        <category>机器学习</category>
        <category>AdaBoost</category>
      </categories>
      <tags>
        <tag>AdaBoost</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础 | 算法基础</title>
    <url>/2020/10/09/Algorithms-1/</url>
    <content><![CDATA[<h1 id="算法基础"><a href="#算法基础" class="headerlink" title="算法基础"></a>算法基础</h1><h2 id="算法定义"><a href="#算法定义" class="headerlink" title="算法定义"></a>算法定义</h2><p><strong>解决一个具体问题的<strong style="color:red">方法</strong>称为一个算法</strong></p>
<h2 id="算法的特征"><a href="#算法的特征" class="headerlink" title="算法的特征"></a>算法的特征</h2><p>1）确定性：组成算法的每条指令清晰、无歧义<br>2）有限性：算法中每条指令的执行次数有限<br>3）可行性：每条指令是简单的、具体的<br>4）输入：有零个或多个外部量作为算法的输入<br>5）输出：算法产生至少一个量作为输出</p>
<p><strong style="color:blue">算法是程序之灵魂</strong></p>
<span id="more"></span>
<h2 id="算法的优劣"><a href="#算法的优劣" class="headerlink" title="算法的优劣"></a>算法的优劣</h2><ul>
<li><blockquote>
<p>时间复杂度：算法运行所需要的<strong>运算步骤</strong></p>
<blockquote>
<p>通常表示为问题规模n的函数T(n)</p>
</blockquote>
</blockquote>
</li>
<li><blockquote>
<p>空间复杂度：算法运行所需要的<strong>内存单元</strong></p>
<blockquote>
<p>通常表示为问题规模n的函数S(n)</p>
</blockquote>
</blockquote>
</li>
<li><blockquote>
<p>时空特性</p>
</blockquote>
</li>
</ul>
<ul>
<li>稳定性</li>
<li>健壮性（鲁棒性）</li>
<li>可靠性</li>
<li>实现难度</li>
<li>模块化</li>
</ul>
<h2 id="算法的内容"><a href="#算法的内容" class="headerlink" title="算法的内容"></a>算法的内容</h2><ul>
<li><blockquote>
<p>算法设计</p>
<blockquote>
<p>针对具体问题，设计一个解决方案</p>
</blockquote>
</blockquote>
<ul>
<li>正确</li>
<li>步骤尽量少</li>
<li>占用空间尽量少</li>
<li>实现简单</li>
<li>其他</li>
</ul>
</li>
<li><blockquote>
<p>算法分析</p>
<blockquote>
<p>正确性分析-证明（归纳法）<br>  时空效率分析-计数<br>  时空特性分析-经验</p>
</blockquote>
</blockquote>
</li>
</ul>
<p>Example 1:时间效率分析-计数</p>
<pre><code>for(i=1;i&lt;=n;i=2*i)
&#123;
    for(j=1;j&lt;=i;j++)
    &#123;
        laugh++;
    &#125;
&#125;
</code></pre>
<p>result:1+2+…+2^ceil(log2 n) = <strong>2^(ceil(log2 n)+1) - 1</strong></p>
<p>Example 2:Horner 算法</p>
<pre><code>Horner(int a[n],real x)
&#123;
    real p = 0;
    for(i=0;i&lt;=n;i++)
    &#123;   
        p+=p*x*a[n-i];
    &#125;
    return p;
&#125;
</code></pre>
<h2 id="算法时间复杂度分析"><a href="#算法时间复杂度分析" class="headerlink" title="算法时间复杂度分析"></a>算法时间复杂度分析</h2><ul>
<li>最坏情况时间复杂度—T(n)表示算法对规模为n的任意输入所需要的<strong>最大步骤</strong></li>
<li>平均时间复杂度——T(n)表示算法对规模为n的所有<strong>输入所需的步骤的平均值</strong></li>
<li>最好情况时间复杂度—T(n)表示算法对规模为n的任意输入所需要的<strong>最小步骤</strong></li>
<li><blockquote>
<p><strong style="color:red">Big idea:</strong>渐进时间复杂度—当n增大时用T(n)的<strong>主要部分</strong>代替T(n)</p>
<blockquote>
<p>常用在理论分析中   理论分析与实际情况有可能不一致</p>
</blockquote>
</blockquote>
</li>
</ul>
<p>e.g. 对a1 a2 … an-1 an 进行排序<br>最好情况：1 2 … n<br>最坏情况：n n-1 ..1<br>2 1 3 …n n-1</p>
<h2 id="算法设计与分析的步骤"><a href="#算法设计与分析的步骤" class="headerlink" title="算法设计与分析的步骤"></a>算法设计与分析的步骤</h2><ol>
<li>问题的描述（Description）</li>
<li>数据结构的选择(Selection)</li>
<li>算法设计(Design)</li>
<li>算法分析(Analysis)</li>
<li>算法的实现(Implement)</li>
</ol>
<p>Example 3:isPrime </p>
<pre><code>isPrime(n)
&#123;
    for(i=2;i&lt;sqrt(n);i++)
    &#123;
        if(n%i==0) return false
    &#125;
    return true
&#125;
</code></pre>
<p>Example 4:euclid</p>
<pre><code>euclid(int a,int b)
&#123;
    if(b==0) return a;
    else return euclid(b,a%b);
&#125;
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
        <category>算法基础</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础 | 动态规划</title>
    <url>/2020/11/06/Algorithms-3/</url>
    <content><![CDATA[<h1 id="动态规划与分治"><a href="#动态规划与分治" class="headerlink" title="动态规划与分治"></a>动态规划与分治</h1><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>利用问题的解与其子问题的解之间的关系（动态规划方程），以<strong>自底向上</strong>的方式递归地从子问题的<strong>最优解</strong>逐步构造出整个问题的解的算法</p>
<h2 id="分治-Divide-and-Conquer"><a href="#分治-Divide-and-Conquer" class="headerlink" title="分治(Divide and Conquer)"></a>分治(Divide and Conquer)</h2><p>将一个问题<strong>分</strong>为若干个子问题，将这些子问题分别求解；将求出的小规模的子问题的解<strong>合并</strong>为一个更大规模的问题的解，自底向上求出原来问题的解</p>
<h2 id="核心思想：大问题—-gt-小问题"><a href="#核心思想：大问题—-gt-小问题" class="headerlink" title="核心思想：大问题—&gt;小问题"></a>核心思想：大问题—&gt;小问题</h2><h2 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h2><p>分治：自顶向下<br>动态规划：自底向上</p>
<h2 id="动态规划的基本步骤"><a href="#动态规划的基本步骤" class="headerlink" title="动态规划的基本步骤"></a>动态规划的基本步骤</h2><ul>
<li>找出最优解的性质，并刻画其结构特征</li>
<li>建立动态规划方程</li>
<li>以自底向上的方式解动态规划方程</li>
<li>根据计算最优质的时得到的信息构造最优解</li>
</ul> 

<h2 id="Pseudocode"><a href="#Pseudocode" class="headerlink" title="Pseudocode:"></a>Pseudocode:</h2><pre><code>dynamic-program(P)
&#123;
    for(i=1;i&lt;=n;i++)
    &#123;
        compute(solution of each Pi);//解规模为i的各子问题
        use(solution of each Pi) merge(solution of each Pi+1);
        //将规模为i的各子问题的解合并为规模为i+1的问题的解
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
        <category>算法基础</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>伪迹移除 | Artifacts reduction algorithms&#39;s two main ways</title>
    <url>/2020/10/11/Artifacts-reduction-algorithms-two-main-ways/</url>
    <content><![CDATA[<h1 id="Artifacts-reduction-algorithms’s-two-main-ways"><a href="#Artifacts-reduction-algorithms’s-two-main-ways" class="headerlink" title="Artifacts reduction algorithms’s two main ways"></a>Artifacts reduction algorithms’s two main ways</h1><div style>
    <h1 style="color:red">Regression and Filtering Methods</h1>
    <h2 style="color:purple">Regression</h2>
    The regression model use a function to fit the data to smooth the data.    <br>
    Disadvantages:<br>
    1.this method only works for reference channels that are available.<br>
    2.EEG signal being non-linear and non-stationary process,linear regression is not the best choice for analysis in such applications.<br>
    3.it can only be used to treat few particular types of artifact,not all types.
    <h2 style="color:purple">Filtering</h2>
    <h3 style="color:green">linear adaptive filters</h3>
    Note:too sensitive and unstable to adjust the parameters<br>
    <h3 style="color:green">non-linear adaptive filters(include Volterra filters and neural network based adptive filters)</h3>
    Note:stronger processing capabilities and complex calculation<br>
    Disadvantages:<br>
    filters may eliminate useful EEG signals during artifact deletion.<br>
</div>
<span id="more"></span>
<div style>
    <h1 style="color:red">Separate or Decompose EEG Data and Noise Data into Other Domains</h1>
    <h2 style="color:purple">EMD(Empiricla Mode Decomposition)</h2>
    decompose the input signals into multiple empirical modes according to IMF. <br>
    Note:EMD is an empirical and data-driven method<br>
    Disadvantages:<br>
    computationally complex<br>
    may not be suitable for online application<br>
    <h2 style="color:purple">ICA(developed from BSS)</h2>
    separate the ideal signal and noise included in the EEG signal as independent components<br> 
    Disadvantages:<br>
    1.not automatic<br>
    2.requiring human intervention makes results subjective and time 
    consuming<br>
    3.cannot operate on single-channel data<br>
    4.high computational complexity<br>
    <h2 style="color:purple">WT(wavelet transfrom)</h2>
    maps the signal to the wavelet domain.<br>
    According to the wavelet coefficients of signal and noise,they have different properties and mechanisms at different scales,eliminating the wavelet coefficients generated by noise and maximally retaining the coefficients fo real signals.
</div>
    ]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>伪迹移除</category>
      </categories>
      <tags>
        <tag>伪迹移除</tag>
        <tag>EMD</tag>
        <tag>ICA</tag>
      </tags>
  </entry>
  <entry>
    <title>伪迹移除 | Artifact suppression using data adaptive time domain filtering</title>
    <url>/2020/10/10/Artifact-suppression-using-data-adaptive-time-domain-filtering/</url>
    <content><![CDATA[<h1 id="Artifact-suppression-from-EEG-signals-using-data-adaptive-time-domain-filtering"><a href="#Artifact-suppression-from-EEG-signals-using-data-adaptive-time-domain-filtering" class="headerlink" title="Artifact suppression from EEG signals using data adaptive time domain filtering"></a>Artifact suppression from EEG signals using data adaptive time domain filtering</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>This paper presents a <strong style="color:red">data adaptive filtering</strong> approach to separate the EOG artifact from the recorded EEG signal.</p>
<span id="more"></span>
<p><strong style="color:red">Empirical mode decomposition(EMD)</strong> technique is used to implement the <strong style="color:red">time domain filter</strong>.</p>
<p><strong style="color:red">Fractional Gaussian noise(fGn)</strong> is used here as the <strong style="color:red">reference signal</strong> to detect the distinguish feature of EOG signal to be used to separate from EEG.</p>
<p>EMD is applied to the raw EEG and fGn separately to produce a finite number band limited signals named <strong style="color:red">intrinsic mode functions(IMFs)</strong>.</p>
<p>The energies of individual IMFs of fGn and that of raw EEG are compared to derive the energy based threshold for the suppression of EOG effects. </p>
<p>The separation results using EMD based approach is also compared with wavelet thresholding technique. </p>
<p><strong style="color:red">The experimental results show that the data adaptive filtering technique performs better than the wavelet based approach.</strong></p>
<div style="background-color:yellowgreen;">
<b backgroundclor="green">proposed method's advantages</b>
<ul>
<li>efficiently separates the EOG artifact <b>without changing the amplitude and other necessary properties of the EEG signals</b></li>
<li><b>full data adaptive nature</b></li>
</ul>
</div>

<p><strong style="color:yellow"><i>Note:</i></strong></p>
<ul>
<li>Frequency analysis or filtering —–&gt; deal with single channel signal</li>
<li>Frequency regression analysis   —–&gt; suppress the eye-movement artifact</li>
<li>Time-invariant band-pass filtering or Fourier transform(FT) —–&gt; extract the target frequency component(specific frequency range)</li>
<li>classical time-frequency analyzers(FFT based filtering or short-time Fourier transform(STFT)) —–&gt; non-stationary signal<br>Note:will bring the spectral distrotion</li>
<li>PCA:extracts and sort out the principal components according to the influence on the overall data space.<br>Note:It requires some priori knowledge to identify the PC as the artifact</li>
<li>ICA:<br>key word:decompose<br>problem of using ICA:extracted components do not confirm the original scale and sequences.</li>
<li>main limitation of the filtering method:introduce some spectral distortion </li>
<li>EMD:<br>key benefit of using EMD: automatic decomposition and fully data adaptive<br>UEMD:<br>BEMD:suppress EOG artifacts<br>MEMD:multi-variate data analysis</li>
</ul>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>伪迹移除</category>
      </categories>
      <tags>
        <tag>伪迹移除</tag>
      </tags>
  </entry>
  <entry>
    <title>伪迹移除 | Automatic artifacts removal</title>
    <url>/2020/10/10/Automatic-removal-using-ICA-and-the-dipole-model/</url>
    <content><![CDATA[<h1 id="Automatic-removal-of-eye-movement-artifacts-from-the-EEG-using-ICA-and-the-dipole-model"><a href="#Automatic-removal-of-eye-movement-artifacts-from-the-EEG-using-ICA-and-the-dipole-model" class="headerlink" title="Automatic removal of eye movement artifacts from the EEG using ICA and the dipole model"></a>Automatic removal of eye movement artifacts from the EEG using ICA and the dipole model</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>In this study,we proposed and evaluated the use of <strong style="color:red"> Independent Component Analysis(ICA) combining the EEG dipole model</strong> to <strong style="color:red"> automatically remove</strong> eye movement artifacts from the EEG <strong style="color:red">without needing EOG as a reference</strong>.</p>
<span id="more"></span>

<p>We <strong>separated</strong> the EEG data into independent components using the ICA method,and <strong>determined</strong> the source localization of these independent components with a single dipole model.</p>
<p>The EEG signal was <strong>reconstructed</strong> by antomatically excluding those components localized within a preset eye model.</p>
<p>The <strong>experimental results</strong> indicate that the dipole model is very efficient at automatically<br>substracting the eye movement artifacts,while retaining the EEG slow waves and making their<br>interpretation easier.</p>
<h2 id="Methods-Comparison"><a href="#Methods-Comparison" class="headerlink" title="Methods Comparison"></a>Methods Comparison</h2><h3 id="other-methods’s-disadvantages-filter、recording-of-horizontal-and-vertical-EOG"><a href="#other-methods’s-disadvantages-filter、recording-of-horizontal-and-vertical-EOG" class="headerlink" title="other methods’s disadvantages:(filter、recording of horizontal and vertical EOG)"></a>other methods’s disadvantages:(filter、recording of horizontal and vertical EOG)</h3><ul>
<li>used a simple <strong>filtering concept</strong>,simply <strong>ignoring very low frequencies</strong>(below 1.5 or 2 Hz)</li>
<li>would not perform well in the context of a large amount of <strong>frontal slow waves</strong> (EOG recordingwould be contaminated by this slow wave activity)</li>
</ul>
<div style="background-color:yellowgreen;">
<b backgroundclor="green">ICA's advantages:</b>
<ul>
<li>The ICA algorithm is computationally efficient.</li>
<li>better noise suppression ability.</li>
<li>ICA can simultaneously separate the EEG and artifacts into independent components without relying on the availability of reference artifacts.</li>
<li>avoids the problem of mutual contamination between EEG and EOG channels that could not be solved with filters,regression and PCA.</li>  
<li>The corrected EEG can easily be derived by a combination of the components without artifacts.</li>
</ul>
</div>

<h3 id="A-crucial-step-for-ocular-artifact-correction-using-ICA-algorithms"><a href="#A-crucial-step-for-ocular-artifact-correction-using-ICA-algorithms" class="headerlink" title="A crucial step for ocular artifact correction using ICA algorithms:"></a>A crucial step for ocular artifact correction using ICA algorithms:</h3><p>to correctly identify the artifact components among the decomposed indepent components.</p>
<p>Manually identifying:</p>
<ul>
<li>subjective </li>
<li>inconvenient </li>
<li>time consuming</li>
</ul>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>伪迹移除</category>
      </categories>
      <tags>
        <tag>伪迹移除</tag>
        <tag>ICA</tag>
      </tags>
  </entry>
  <entry>
    <title>CNN | BatchNormalization</title>
    <url>/2021/11/15/BatchNormalization/</url>
    <content><![CDATA[<h1 id="BatchNormalization"><a href="#BatchNormalization" class="headerlink" title="BatchNormalization"></a>BatchNormalization</h1><p>由于深度神经网络涉及到很多层的叠加，而每一层的参数更新会导致上层的输入数据分布发生变化，<br>通过层层叠加，高层的输入分布变化会非常剧烈，这就使得高层需要不断去重新适应底层的参数更新。<br>为了训好模型，我们需要非常谨慎地去设定学习率、初始化权重、以及尽可能细致的参数更新策略。<br>也就是随是着网络加深，参数分布不断往激活函数两端移动(梯度变小)，导致反向传播出现梯度消失，收敛困难。<br>原理：可在每层的激活函数前，加入BN，将参数重新拉回0-1正态分布，加速收敛。</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
        <category>CNN</category>
        <category>Batch Normalization</category>
      </categories>
      <tags>
        <tag>Batch Normalization</tag>
        <tag>深度学习</tag>
        <tag>CNN</tag>
      </tags>
  </entry>
  <entry>
    <title>参考文献 | A CNN-LSTM for Motor Imagery EEG Detection</title>
    <url>/2021/11/09/CNNLSTMMotorImageryEEGDetection/</url>
    <content><![CDATA[<h1 id="A-CNN-LSTM-for-Motor-Imagery-EEG-Detection"><a href="#A-CNN-LSTM-for-Motor-Imagery-EEG-Detection" class="headerlink" title="A CNN-LSTM for Motor Imagery EEG Detection"></a>A CNN-LSTM for Motor Imagery EEG Detection</h1><h2 id="Why-CNN-LSTM"><a href="#Why-CNN-LSTM" class="headerlink" title="Why CNN-LSTM?"></a>Why CNN-LSTM?</h2><p>CNN layers detect better the spatial component of the data selecting the best features for us and RNN detect better the temporal component of the data.<br>(CNN layer is used to extract the most relevant features from the brain waves and LSTM is used to classify the time series.)</p>
<span id="more"></span>
<h2 id="Contributions"><a href="#Contributions" class="headerlink" title="Contributions"></a>Contributions</h2><p>1.proposed method of CNN-LSTM.<br>2.discussed the influence of using raw data over using the data split in frequency bands in the model proposed.<br>3.discuss the influence of certain frequency bands activity over other frequency bands.</p>
<h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><p>the 5 types of waves (alpha, beta, theta, delta and gamma) are needed for an accurate classification and the raw data is not enough to ensure the accuracy of the results. </p>
<h2 id="Cite-This"><a href="#Cite-This" class="headerlink" title="Cite This"></a>Cite This</h2><p>F. M. Garcia-Moreno, M. Bermudez-Edo, M. J. Rodríguez-Fórtiz and J. L. Garrido, “A CNN-LSTM Deep Learning Classifier for Motor Imagery EEG Detection Using a Low-invasive and Low-Cost BCI Headband,” 2020 16th International Conference on Intelligent Environments (IE), 2020, pp. 84-91, doi: 10.1109/IE49459.2020.9155016.</p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>脑电分类</category>
        <category>参考文献</category>
      </categories>
      <tags>
        <tag>CNN+LSTM</tag>
        <tag>EEG Classification</tag>
        <tag>EEG</tag>
      </tags>
  </entry>
  <entry>
    <title>脑电分类 | CNNLSTM混合分类脑电信号</title>
    <url>/2021/07/01/CNNLSTM%E6%B7%B7%E5%90%88%E5%88%86%E7%B1%BB%E8%84%91%E7%94%B5%E4%BF%A1%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="使用CNN-LSTM混合深度学习分类基于MUSE采集的运动想象EEG信号"><a href="#使用CNN-LSTM混合深度学习分类基于MUSE采集的运动想象EEG信号" class="headerlink" title="使用CNN-LSTM混合深度学习分类基于MUSE采集的运动想象EEG信号"></a>使用CNN-LSTM混合深度学习分类基于MUSE采集的运动想象EEG信号</h1><table>
<thead>
<tr>
<th>模型</th>
<th>Epochs</th>
<th>训练集大小</th>
<th>验证集大小</th>
<th>训练集准确率</th>
<th>验证集准确率</th>
</tr>
</thead>
<tbody><tr>
<td>CNN+LSTM</td>
<td>300</td>
<td>90%</td>
<td>10%</td>
<td>98.6%</td>
<td>96.5%</td>
</tr>
</tbody></table>
<p><a href="https://blog.csdn.net/zyb228/article/details/109542063">参考资料 Click Here!</a><br><a href="https://ieeexplore.ieee.org/document/9155016">论文地址</a></p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>脑电分类</category>
        <category>网络</category>
        <category>CNN+LSTM</category>
      </categories>
      <tags>
        <tag>脑电分类</tag>
        <tag>LSTM</tag>
        <tag>CNN+LSTM</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | CPU or GPU?</title>
    <url>/2021/06/21/CPU-or-GPU/</url>
    <content><![CDATA[<h1 id="CPU-or-GPU"><a href="#CPU-or-GPU" class="headerlink" title="CPU or GPU?"></a>CPU or GPU?</h1><p>与CPU相比，GPU擅长SIMD(Single Instruction Multiple Data)计算.<br><a href="https://blog.csdn.net/luoyajingfeng2/article/details/90752019">参考资料</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>GPU | CPU和GPU的设计区别</title>
    <url>/2021/10/11/CPU%E5%92%8CGPU%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="CPU和GPU的设计区别"><a href="#CPU和GPU的设计区别" class="headerlink" title="CPU和GPU的设计区别"></a>CPU和GPU的设计区别</h1><p><a href="https://www.cnblogs.com/biglucky/p/4223565.html">点击链接查看CPU和GPU的设计区别！！！</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>GPU</category>
      </categories>
      <tags>
        <tag>GPU</tag>
        <tag>CPU</tag>
      </tags>
  </entry>
  <entry>
    <title>参考文献 | Remaining Useful Life Prediction of Machining Tools by 1D-CNN LSTM Network</title>
    <url>/2021/11/09/CnnLstmForRemainingUsefulLifePrediction/</url>
    <content><![CDATA[<h1 id="Remaining-Useful-Life-Prediction-of-Machining-Tools-by-1D-CNN-LSTM-Network"><a href="#Remaining-Useful-Life-Prediction-of-Machining-Tools-by-1D-CNN-LSTM-Network" class="headerlink" title="Remaining Useful Life Prediction of Machining Tools by 1D-CNN LSTM Network"></a>Remaining Useful Life Prediction of Machining Tools by 1D-CNN LSTM Network</h1><h2 id="Contributions"><a href="#Contributions" class="headerlink" title="Contributions"></a>Contributions</h2><p>use a 1D-CNN LSTM network architecture for machining tools RUL prediction</p>
<h2 id="Problem-Addressing"><a href="#Problem-Addressing" class="headerlink" title="Problem Addressing"></a>Problem Addressing</h2><p>Traditional machine learning algorithms are sometimes difficult to extract hidden information that characterizes the degradation process of the tool.<br>deep learning methods tend to have better effects, as it has powerful adaptive learning and anti-noise ability, and it can automatically extract deep<br> features, which is more versatile than traditional machine learning methods.</p>
<h2 id="Why-CNN-LSTM"><a href="#Why-CNN-LSTM" class="headerlink" title="Why CNN-LSTM?"></a>Why CNN-LSTM?</h2><p>CNN has a its capacity to automatically extract features and LSTM can effectively mine the hidden information in time series.</p>
<p>In fact, we can combine CNN’s high-dimensional feature extraction capacity and LSTM’s advantage on time series problems. After CNN extracts<br>features, we input them into the LSTM for training, then some improvements in accuracy and speed can be achieved.</p>
<p>For time-series problems, one dimensional convolutional neural network (1D-CNN) is more suitable than common convolution neural network. One of the<br>characteristics of the 1D-CNN is that for time-series data, the receptive field moves only in the direction of time, so the local inter-variable correlation can be extracted.</p>
<h2 id="Some-knowledge-points-learned"><a href="#Some-knowledge-points-learned" class="headerlink" title="Some knowledge points learned"></a>Some knowledge points learned</h2><ol>
<li>Each convolutional layer consists of several convolutional units whose parameters are optimized by backpropagation algorithms.</li>
<li>Pooling can effectively reduce the amount of data and increse the calculation speed.</li>
<li>Each unit of RNN is a simple chain structure, it processes the input sequence {x1,x2,…,xT} sequentially to construct a corresponding sequence of hidden states {h1,h2,…,hT}.</li>
<li>The main purpose of the dropout layer is to reduce over-fitting.<h2 id="Ideas"><a href="#Ideas" class="headerlink" title="Ideas"></a>Ideas</h2></li>
<li>compare the results of 1D-CNN,LSTM and 1D-CNN LSTM in own work.</li>
<li>write own paper according to this reference(part of introduction and network description)</li>
<li>Refer to the chart in the article</li>
</ol>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>脑电分类</category>
        <category>参考文献</category>
      </categories>
      <tags>
        <tag>CNN+LSTM</tag>
        <tag>反向传播算法</tag>
      </tags>
  </entry>
  <entry>
    <title>绘图 | ConfusionMatrix</title>
    <url>/2022/03/24/ConfusionMatrix/</url>
    <content><![CDATA[<h1 id="Confusion-Matrix"><a href="#Confusion-Matrix" class="headerlink" title="Confusion Matrix"></a>Confusion Matrix</h1><p><a href="https://www.cnblogs.com/yexionglin/p/11432180.html">混淆矩阵</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>绘图</category>
        <category>Confusion Matrix</category>
      </categories>
      <tags>
        <tag>ConfusionMatrix</tag>
      </tags>
  </entry>
  <entry>
    <title>并发 | CountDownLatch</title>
    <url>/2022/05/30/CountDownLatch/</url>
    <content><![CDATA[<h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><p>CountDownLatch允许一个或多个线程等待其他线程完成操作。<br>例如：</p>
<pre><code>CountDownLatch c = new CountDownLatch(2)；
</code></pre>
<p>CountDownLatch的构造函数接收一个int类型的参数作为计数器，如果你想等待N个点完成，这里就传入N.<br>当我们调用CountDownLatch的countDown方法时，N就会减1，CountDownLatch的await方法会阻塞当前<br>线程，直到N变为0。由于countDown方法可以用在任何地方，所以这里说的<strong>N个点，可以是N个线程，也可以<br>是1个线程里的N个步骤</strong>。<br><strong>注：CountDownLatch的计数器智能使用一次</strong></p>
<span id="more"></span>
<p><strong>示例代码1</strong></p>
<pre><code>package concurrency.countdownlatch;

import java.util.concurrent.CountDownLatch;

public class CountDownLatchTest1 &#123;
    static CountDownLatch c = new CountDownLatch(2);
    
    public static void main(String[] args) throws InterruptedException &#123;
        new Thread(new Runnable()&#123;
            @Override
            public void run() &#123;
                System.out.println(&quot;parser1 finished&quot;);
                c.countDown();
            &#125;
        &#125;).start();
        
        new Thread(new Runnable()&#123;
            @Override
            public void run() &#123;
                System.out.println(&quot;parser2 finished&quot;);
                c.countDown();
            &#125;
        &#125;).start();
        c.await();
        System.out.println(&quot;all parsers finished&quot;);
    &#125;
&#125;
</code></pre>
<p><strong>示例代码2</strong></p>
<pre><code>package concurrency.countdownlatch;

import java.util.concurrent.CountDownLatch;

public class CountDownLatchTest2 &#123;
    static CountDownLatch c = new CountDownLatch(2);
    public static void main(String[] args) throws InterruptedException &#123;
        new Thread(new Runnable()&#123;
            @Override
            public void run() &#123;
                System.out.println(&quot;1&quot;);
                c.countDown();
                System.out.println(&quot;2&quot;);
                c.countDown();
            &#125;
        &#125;).start();
        c.await();
        System.out.println(&quot;3&quot;);
    &#125; 
&#125;
</code></pre>
<p><a href="https://blog.csdn.net/hbtj_1216/article/details/109655995">CountDownLatch</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
        <category>CountDownLatch</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>CountDownLatch</tag>
      </tags>
  </entry>
  <entry>
    <title>并发 | CyclicBarrier用于多线程计算数据并合并计算结果</title>
    <url>/2022/06/07/CyclicBarrier%E7%94%A8%E4%BA%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%A1%E7%AE%97%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%90%88%E5%B9%B6%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%9C/</url>
    <content><![CDATA[<h1 id="CyclicBarrier用于多线程计算数据并合并计算结果"><a href="#CyclicBarrier用于多线程计算数据并合并计算结果" class="headerlink" title="CyclicBarrier用于多线程计算数据并合并计算结果"></a>CyclicBarrier用于多线程计算数据并合并计算结果</h1><p><strong>CyclicBarrier</strong><br>CyclicBarrier让一组线程到达一个屏障（同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，<br>所有被屏障拦截的线程才会继续执行。<br><strong>注：CyclicBarrier的计数器可以使用reset()方法重置</strong></p>
<span id="more"></span>
<p><strong>使用方式1：</strong></p>
<pre><code>package concurrency.cyclicbarrier;

import java.util.concurrent.CyclicBarrier;

public class CyclicBarrierTest &#123;
    static CyclicBarrier c = new CyclicBarrier(2);
    public static void main(String[] args) &#123;
        new Thread(new Runnable()&#123;
            @Override
            public void run()&#123;
                try&#123;
                    c.await();
                &#125;catch(Exception e)&#123;
                    
                &#125;
                System.out.println(1);
            &#125;
        &#125;).start();
        
        try&#123;
            c.await();
        &#125;catch(Exception e)&#123;
            
        &#125;
        System.out.println(2);
    &#125;
&#125;
</code></pre>
<p><strong>使用方式2：</strong></p>
<pre><code>package concurrency.cyclicbarrier;

import java.util.concurrent.CyclicBarrier;

public class CyclicBarrierTest2 &#123;
    static CyclicBarrier c = new CyclicBarrier(2, new A());
    
    public static void main(String[] args) &#123;
        new Thread(new Runnable()&#123;
            @Override
            public void run()&#123;
                try&#123;
                    c.await();
                &#125;catch(Exception e)&#123;
                    
                &#125;
                System.out.println(1);
            &#125;
        &#125;).start();
        
        try&#123;
            c.await();
        &#125;catch(Exception e)&#123;
            
        &#125;
        System.out.println(2);
    &#125;
    
    static class A implements Runnable&#123;
        @Override
        public void run() &#123;
            System.out.println(3);
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>应用场景：</strong> 一个Excel保存了用户所有银行流水，每个Sheet保存一个账户近一年的每笔银行流水，现在<br>需要统计用户的日均银行流水，先用多线程处理每个sheet里的银行流水，都执行完之后，得到每个sheet<br>的日均银行流水，最后，再用barrierAction用这些线程的计算结果，计算出整个Excel的日均银行流水。<br><strong>代码：</strong></p>
<pre><code>package concurrency.cyclicbarrier;

import java.util.Map.Entry;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;

public class BankWaterService implements Runnable&#123;
    //创建4个屏障，处理完之后执行当前类的run方法
    private CyclicBarrier c = new CyclicBarrier(4, this);
    
    //假设只有4个sheet，所以只启动4个线程
    private Executor executor = Executors.newFixedThreadPool(4);
    
    //保存每个sheet计算出的银流结果
    private ConcurrentHashMap&lt;String, Integer&gt; sheetBankWaterCount = new ConcurrentHashMap&lt;String, Integer&gt;();
    
    private void count()&#123;
        for(int i = 0; i &lt; 4; i++)&#123;
            executor.execute(new Runnable()&#123;
                @Override
                public void run() &#123;
                    //计算当前sheet的银流数据，计算代码省略
                    sheetBankWaterCount.put(Thread.currentThread().getName(), 1);
                    //银流计算完成，插入一个屏障
                    try&#123;
                        c.await();
                    &#125;catch(InterruptedException | BrokenBarrierException e)&#123;
                        e.printStackTrace();
                    &#125;
                &#125;
            &#125;);
        &#125;
    &#125;
    
    @Override
    public void run() &#123;
        int result = 0;
        
        //汇总每个sheet计算出的结果
        for(Entry&lt;String, Integer&gt; sheet : sheetBankWaterCount.entrySet())&#123;
            result += sheet.getValue();
        &#125;
        
        //将结果输出
        sheetBankWaterCount.put(&quot;result&quot;, result);
        System.out.println(result);
    &#125;
    
    public static void main(String[] args)&#123;
        BankWaterService bankWaterCount = new BankWaterService();
        bankWaterCount.count();
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>并发</category>
        <category>CyclicBarrier</category>
        <category>CyclicBarrier用于多线程计算数据并合并计算结果</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>CyclicBarrier</tag>
      </tags>
  </entry>
  <entry>
    <title>Django | DTL中的url反向解析</title>
    <url>/2021/07/30/DTL%E4%B8%AD%E7%9A%84url%E5%8F%8D%E5%90%91%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="DTL中的url反向解析"><a href="#DTL中的url反向解析" class="headerlink" title="DTL中的url反向解析"></a>DTL中的url反向解析</h1><p><strong>反向解析：</strong> 根据配置的url来动态生成链接地址<br><strong>语法：</strong> { % url ‘namespace:name’ p1 p2 %}<br><strong>好处：</strong> 如果改变了url配置不需要再去改每一个链接地址</p>
<span id="more"></span>

<h2 id="反向解析举例"><a href="#反向解析举例" class="headerlink" title="反向解析举例"></a>反向解析举例</h2><p>1.注册应用(settings.py)</p>
<pre><code>INSTALLED_APPS = (
    &#39;django.contrib.admin&#39;,
    &#39;django.contrib.auth&#39;,
    &#39;django.contrib.contenttypes&#39;,
    &#39;django.contrib.sessions&#39;,
    &#39;django.contrib.messages&#39;,
    &#39;django.contrib.staticfiles&#39;,
    &#39;app_name&#39;
)
</code></pre>
<p>1.配置主url(project_name/urls.py project_name为项目文件夹)</p>
<pre><code>from django.conf.urls import include, url
from django.contrib import admin

urlpatterns = [
    url(r&#39;^admin/&#39;, include(admin.site.urls)),
    url(r&#39;^&#39;, include(&#39;app_name.urls&#39;, namespace=&#39;app_name&#39;))
]
/*
app_name:创建的应用名，为项目下的应用文件夹
app_name.urls:应用的urls，应用文件夹下的urls.py
*/
</code></pre>
<p>2.配置应用url(app_anme/urls.py)</p>
<pre><code>from django.conf.urls import url
import views

urlpatterns = [
    url(r&#39;^$&#39;, views.index, name=&#39;index&#39;),
    url(r&#39;^(\d+)/(\d+)$&#39;, views.show, name=&#39;show&#39;),
]
</code></pre>
<p>3.定义视图(app_name/views.py)<br>app_name/index.html处于project_name/templates/app_name/</p>
<pre><code>from django.shortcuts import render
from models import *


def index(request):
    context = &#123;&#125;

    return render(request, &#39;app_name/index.html&#39;, context)


def show(request, id1, id2):
    context = &#123;&#39;id1&#39;: id1, &#39;id2&#39;: id2&#125;
    return render(request, &#39;app_name/show.html&#39;, context)
</code></pre>
<p>4.定义模板<br>index.html</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;a href=&quot;&#123;% url 'app_name:show' '123' '456' %&#125;&quot;&gt;显示&lt;/a&gt;
&lt;hr&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>show.html</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&#123;&#123;id1&#125;&#125;
&#123;&#123;id2&#125;&#125;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>5.配置模板路径DIRS（settings.py）<br>模板文件夹templates在project_name文件夹下</p>
<pre><code>TEMPLATES = [
    &#123;
        &#39;BACKEND&#39;: &#39;django.template.backends.django.DjangoTemplates&#39;,
        &#39;DIRS&#39;: [os.path.join(BASE_DIR, &#39;templates&#39;)],
        &#39;APP_DIRS&#39;: True,
        &#39;OPTIONS&#39;: &#123;
            &#39;context_processors&#39;: [
                &#39;django.template.context_processors.debug&#39;,
                &#39;django.template.context_processors.request&#39;,
                &#39;django.contrib.auth.context_processors.auth&#39;,
                &#39;django.contrib.messages.context_processors.messages&#39;,
            ],
        &#125;,
    &#125;,
]
</code></pre>
<p>6.运行服务器，在浏览器地址栏输入 localhost:8000/123/456,请求服务器。</p>
]]></content>
      <categories>
        <category>python</category>
        <category>框架</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>DTL</tag>
      </tags>
  </entry>
  <entry>
    <title>Django | Django中使用MySQL数据库</title>
    <url>/2021/07/25/Django%E4%B8%AD%E4%BD%BF%E7%94%A8MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h1 id="Django中使用MySQL数据库"><a href="#Django中使用MySQL数据库" class="headerlink" title="Django中使用MySQL数据库"></a>Django中使用MySQL数据库</h1><p>1.在虚拟环境中安装mysql包</p>
<pre><code>pip install mysql-python
</code></pre>
<p>2.在mysql中创建数据库</p>
<pre><code>create databases database_name charset=utf8
</code></pre>
<p><b style="color:red">3.在settings.py中修改DATABASES项</b></p>
<pre><code>DATABASES = &#123;
    &#39;default&#39;: &#123;
        &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;,
        &#39;NAME&#39;: &#39;database_name&#39;,
        &#39;USER&#39;: &#39;root&#39;,
        &#39;PASSWORD&#39;: &#39;1234&#39;,
        &#39;HOST&#39;: &#39;localhost&#39;,
        &#39;PORT&#39;: &#39;3306&#39;,
    &#125;
&#125;
</code></pre>
<p>4.开发流程<br>1）在models.py中定义模型类(继承models.Model)</p>
<pre><code>class Example(models.Model):
    field1 = 
    field2 = 
    ...
</code></pre>
<p>2）把应用加入settings.py文件的installed_app项</p>
<pre><code>INSTALLED_APPS = (
    &#39;django.contrib.admin&#39;,
    &#39;django.contrib.auth&#39;,
    &#39;django.contrib.contenttypes&#39;,
    &#39;django.contrib.sessions&#39;,
    &#39;django.contrib.messages&#39;,
    &#39;django.contrib.staticfiles&#39;,
    &#39;app_name&#39;,
)
</code></pre>
<p>3）生成迁移文件</p>
<pre><code>python manage.py makemigrations
</code></pre>
<p>4）执行迁移生成表</p>
<pre><code>python manage.py migrate
</code></pre>
<p>5）使用模型类进行crud操作</p>
<p><strong>注：</strong><br>使用数据库生成模型类<br>python manage.py inspectdb &gt; app_name/models.py</p>
]]></content>
      <categories>
        <category>python</category>
        <category>框架</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django | Django模型查询</title>
    <url>/2021/07/26/Django%E6%A8%A1%E5%9E%8B%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h1 id="Django模型查询"><a href="#Django模型查询" class="headerlink" title="Django模型查询"></a>Django模型查询</h1><h2 id="查询集的两个特性："><a href="#查询集的两个特性：" class="headerlink" title="查询集的两个特性："></a>查询集的两个特性：</h2><p>1.<strong>惰性执行</strong><br>创建查询集不会带来任何数据库的访问，直到调用数据时，才会访问数据库<br>2.<strong>缓存</strong><br>case1:构成了两个查询集，无法重用缓存，每次查询都会与数据库进行一次交互</p>
<pre><code>print([e.attr for e in Entry.objects.all()])
print([e.attr for e in Entry.objects.all()])
</code></pre>
<p>case2:两次循环使用同一个查询集，第二次使用缓存中的数据</p>
<pre><code>querylist=ExampleModel.objects.all()
print([e.attr for e in querylist])
print([e.attr for e in querylist])
</code></pre>
<p>case3:何时查询集不会被缓存<br>对整个查询集的子集进行求值时不会缓存</p>
<pre><code>query=ExampleModel.objects.all()
for ... in query[0:10]
for ... in query[11:20]
</code></pre>
<h2 id="字段查询"><a href="#字段查询" class="headerlink" title="字段查询"></a>字段查询</h2><p>实现where子名，作为方法filter()、exclude()、get()的参数<br>语法：属性名称__比较运算符=值<br>举例：查询模型类中属性attr1包含1的对象<br>query_list = ExampleModel.objects.filter(attr1__contains=’1’)  </p>
<p><strong>比较运算符：</strong><br>exact、contains、startswith、endswith、isnull、isnotnull、gt、gte、lt、lte、year、<br>month、day、week_day、hour、minute、second<br>注：跨关联查询（语法：模型类名__属性名__比较运算符）</p>
<p><strong>聚合函数：</strong><br>aggregate(Avg()/Count/Max/Min/Sum)</p>
<h2 id="F对象和Q对象"><a href="#F对象和Q对象" class="headerlink" title="F对象和Q对象"></a>F对象和Q对象</h2><p>1.通过构造F对象来比较模型中的两个列<br>举例：query_list = ExampleModel.objects.filter(attr1=F(‘attr2’))<br>2.通过构造Q对象来实现or查询<br>举例：query_list = ExampleModel.objects.filter(Q(pk__lt=6) | Q(attr__gt=1))</p>
]]></content>
      <categories>
        <category>python</category>
        <category>框架</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>EEG | EEG Pathology Detection Based on Deep Learning</title>
    <url>/2020/11/05/EEG-Pathology-Detection-Based-on-Deep-Learning/</url>
    <content><![CDATA[<p>EEG Pathology Detection Based on Deep Learning</p>
<h1 id="Target-EEG-Pathology-Detection"><a href="#Target-EEG-Pathology-Detection" class="headerlink" title="Target: EEG Pathology Detection"></a>Target: EEG Pathology Detection</h1><h1 id="Proposed-Methonds"><a href="#Proposed-Methonds" class="headerlink" title="Proposed Methonds:"></a>Proposed Methonds:</h1><p>Method One:Shallow CNN Model<br>Method Two:Deep CNN Model(AlexNet)<br>Method Three:Fusion stategy based on a multiplayer perception<br>Fusion of CNN features of several distinct temporal segments of the EEG signal</p>
<p><b style="color:red">In future study:investigate different fusion strategies</b></p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
      </categories>
      <tags>
        <tag>CNN</tag>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title>脑电基础知识 | 简单了解EEG</title>
    <url>/2020/10/11/EEG-introduction/</url>
    <content><![CDATA[<h1 id="简单了解EEG"><a href="#简单了解EEG" class="headerlink" title="简单了解EEG"></a>简单了解EEG</h1><h2 id="What"><a href="#What" class="headerlink" title="What?"></a>What?</h2><p>EEG is the electrical response of brain cells in the cerebral cortex.</p>
<h2 id="How-to-record"><a href="#How-to-record" class="headerlink" title="How to record?"></a>How to record?</h2><p>typically collected by an electrode collection system(10/20 system)placed on the head of the brain. </p>
<span id="more"></span>
<h2 id="characteristic"><a href="#characteristic" class="headerlink" title="characteristic"></a>characteristic</h2><ul>
<li>a highly random <b>nonlinear non-stationary signal</b></li>
<li>contains very <b>complex components</b></li>
<li>the signal amplitude is microvolts,and the <b>intensity is very weak</b>.</li>
<li>it is very <b>susceptible</b> to other <b>physiological signals</b> of the human body(<b>EOG/ECG/EMG</b>) or interference from non-physiological signals such as spatial electromagnetic noise.</li>
</ul>
<h2 id="Existed-problem"><a href="#Existed-problem" class="headerlink" title="Existed problem"></a>Existed problem</h2><p><b>Artifacts often mask the waveform characteristics of EEG</b>,which makes the reading of EEG signals more difficult<br>and bring great difficulties to the subsequent research and application of EEG signal.</p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>脑电基础知识</category>
      </categories>
      <tags>
        <tag>EEG</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer Vision | DogsVSCats</title>
    <url>/2021/11/16/DogsVSCats/</url>
    <content><![CDATA[<h1 id="Dogs-VS-Cats"><a href="#Dogs-VS-Cats" class="headerlink" title="Dogs VS Cats"></a>Dogs VS Cats</h1><h2 id="猫狗大战任务"><a href="#猫狗大战任务" class="headerlink" title="猫狗大战任务"></a>猫狗大战任务</h2><p>猫狗大战是来源于Kaggle的一个比赛项目，任务为给定一个有猫狗照片数据集，设计一种算法对测试集中的猫狗图片进行分类。<br><strong>比赛项目网址：</strong><br><a href="https://www.kaggle.com/">https://www.kaggle.com/</a><br><strong>网络</strong></p>
<pre><code>layer1: Conv2d(3, 16, 3, padding=1)
layer2: relu():
layer3: max_pool2d(2)
layer4: Conv2d(16, 16, 3, padding=1)
layer5: relu()
layer6: max_pool2d(2)
layer7: Linear(50*50*16, 128)
layer8: relu()
layer9: Linear(128, 64)
layer10: relu()
layer11: Linear(64, 2)
</code></pre>
]]></content>
      <categories>
        <category>项目经历</category>
        <category>Deep Learning</category>
        <category>Computer Vision</category>
        <category>Dogs VS Cats</category>
      </categories>
      <tags>
        <tag>Dogs VS Cats</tag>
      </tags>
  </entry>
  <entry>
    <title>EmotionalTendencyPredictionUsingLSTM</title>
    <url>/2021/11/29/EmotionalTendencyPredictionUsingLSTM/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>并发 | Exchanger</title>
    <url>/2022/06/07/Exchanger/</url>
    <content><![CDATA[<h1 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h1><p>Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程<br>通过exchange方法交换数据，如果第一个线程先执行exchange方法，它会一直等待第二个线程也执行exchange方法，当<br>两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。<br><strong>应用场景</strong><br>（1）遗传算法<br>遗传算法里需要选出两个人作为交配对象，这时候会交换两个人的数据，并使用交叉规则得出2个交配结果。<br>（2）校对工作<br>例如，我们需要将纸制银行流水通过人工的方式录入成电子银行流水，为了避免错误，采用AB岗两个人进行录入，录入到<br>Excel后，系统需要加载这两个Excel，并对两个Excel数据进行校对，看看是否录入一致。<br><strong>示例代码：</strong></p>
<pre><code>package concurrency.exchanger;

import java.util.concurrent.Exchanger;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ExchangerTest &#123;
    private static final Exchanger&lt;String&gt; exgr = new Exchanger&lt;String&gt;();
    
    private static ExecutorService threadPool = Executors.newFixedThreadPool(2);
    
    public static void main(String[] args) &#123;
        threadPool.execute(new Runnable()&#123;
            @Override
            public void run() &#123;
                try&#123;
                    String A = &quot;银行流水A&quot;;//A录入银行流水数据
                    exgr.exchange(A);
                &#125;catch(InterruptedException e)&#123;
                    e.printStackTrace();
                &#125;
            &#125;
            
        &#125;);
        
        threadPool.execute(new Runnable()&#123;
            @Override
            public void run() &#123;
                try&#123;
                    String B = &quot;银行流水B&quot;;//B录入银行流水数据
                    String A = exgr.exchange(B);
                    System.out.println(&quot;A和B数据是否一致：&quot;+A.equals(B)+&quot;,A录入的是：&quot;+A+&quot;,B录入的是：&quot;+B);
                &#125;catch(InterruptedException e)&#123;
                    e.printStackTrace();
                &#125;
            &#125;
            
        &#125;);
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>并发</category>
        <category>Exchanger</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>Exchanger</tag>
      </tags>
  </entry>
  <entry>
    <title>spring | FactoryBean</title>
    <url>/2022/03/05/FactoryBean/</url>
    <content><![CDATA[<h1 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h1><p>Spring中有两种类型的bean，一种是普通bean，另一种是工厂bean，即FactoryBean。工厂bean跟普通bean不同，其返回的对象不是指定类的一个实例，其返回的是该工厂bean的getObject方法所返回的对象。<br><strong>示例：</strong><br>1.项目目录<br><img src="/2022/03/05/FactoryBean/1.PNG"></p>
<p>2.Car.java</p>
<pre><code>package com.atguigu.spring.factorybean;

public class Car &#123;
    private String brand;
    private Double price;
    public String getBrand() &#123;
        return brand;
    &#125;
    public void setBrand(String brand) &#123;
        this.brand = brand;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Car [brand=&quot; + brand + &quot;, price=&quot; + price + &quot;]&quot;;
    &#125;
    public Double getPrice() &#123;
        return price;
    &#125;
    public void setPrice(Double price) &#123;
        this.price = price;
    &#125;
    
&#125;
</code></pre>
<p>3.MyFactory.java</p>
<pre><code>package com.atguigu.spring.factorybean;

import org.springframework.beans.factory.FactoryBean;

public class MyFactory implements FactoryBean&lt;Car&gt;&#123;
    @Override
    public Car getObject() throws Exception &#123;
        Car car = new Car();
        car.setBrand(&quot;奥迪&quot;);
        car.setPrice(200000.0);
        return car;
    &#125;

    @Override
    public Class&lt;?&gt; getObjectType() &#123;
        return Car.class;
    &#125;

    @Override
    public boolean isSingleton() &#123;
        return false;
    &#125;
&#125;
</code></pre>
<p>4.factory-bean.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    
    &lt;!-- 工厂bean --&gt;
    &lt;bean id=&quot;factory&quot; class=&quot;com.atguigu.spring.factorybean.MyFactory&quot;&gt;&lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>5.Test.java</p>
<pre><code>package com.atguigu.spring.factorybean;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test &#123;

    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;factory-bean.xml&quot;);
        Object bean = ac.getBean(&quot;factory&quot;);
        System.out.println(bean);
    &#125;
&#125;
</code></pre>
<p>6.运行结果<br>Car [brand=奥迪, price=200000.0]</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>spring</category>
        <category>FactoryBean</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>urllib.request | GET请求</title>
    <url>/2021/08/05/GET%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<h1 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h1><p>使用urllib.request模块可以在python中访问互联网资源，以下是发送GET请求的示例代码。</p>
<pre><code># coding=utf-8

import urllib.request

# url中？后的内容是请求参数，多个参数之间以&amp;分割
url = &#39;http://localhost:8080/NoteWebService/note.do?action=query&amp;ID=10&#39;

# 创建Request对象，默认是GET请求
req = urllib.request.Request(url)

with urllib.request.urlopen(req) as response:
    data = response.read()  # 读取数据，为字节序列数据
    json_data = data.decode()  # 将字节序列数据转换为字符串
    print(json_data)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>内置模块</category>
        <category>urllib</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>urllib</tag>
      </tags>
  </entry>
  <entry>
    <title>GPU | GPU利用率低？</title>
    <url>/2021/10/09/GPU%E5%88%A9%E7%94%A8%E7%8E%87%E4%BD%8E%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="GPU利用率低？"><a href="#GPU利用率低？" class="headerlink" title="GPU利用率低？"></a>GPU利用率低？</h1><p><a href="https://blog.csdn.net/qq_32998593/article/details/92849585">GPU利用率低？</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>GPU</category>
      </categories>
      <tags>
        <tag>GPU</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP | HTTP请求方法</title>
    <url>/2020/11/09/HTTP%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h1><h2 id="常见的几种请求方式"><a href="#常见的几种请求方式" class="headerlink" title="常见的几种请求方式"></a>常见的几种请求方式</h2><table>
<thead>
<tr>
<th>Methods</th>
<th>Descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>获取数据 例如：获取指定的页面</td>
</tr>
<tr>
<td>POST</td>
<td>修改数据 例如：提交表单、上传文件</td>
</tr>
<tr>
<td>PUT</td>
<td>保存数据</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除 例如：删除指定页面</td>
</tr>
<tr>
<td>OPTION</td>
<td>询问服务器的某种支持特性</td>
</tr>
<tr>
<td>HEAD</td>
<td>用于获取报头</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>Java | HashMap的七种遍历方式</title>
    <url>/2022/04/23/HashMap%E7%9A%84%E4%B8%83%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="HashMap的七种遍历方式"><a href="#HashMap的七种遍历方式" class="headerlink" title="HashMap的七种遍历方式"></a>HashMap的七种遍历方式</h1><p><a href="https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw">参考资料</a></p>
<pre><code>import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;

public class HashMapTraversalMethodsTest &#123;
    public static void main(String[] args) &#123;
        
        Map&lt;Integer, String&gt; map = new HashMap();
        map.put(1, &quot;Java&quot;);
        map.put(2, &quot;Python&quot;);
        map.put(3, &quot;C&quot;);
        map.put(4, &quot;C++&quot;);
        map.put(5, &quot;JavaScript&quot;);
        
        //迭代器EntrySet（推荐使用）
//        Iterator&lt;Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();
//        while(iterator.hasNext())&#123;
//            Entry&lt;Integer, String&gt; entry = iterator.next();
//            System.out.println(entry.getKey());
//            System.out.println(entry.getValue());
//        &#125;
        
        //迭代器KeySet
//        Iterator&lt;Integer&gt; iterator = map.keySet().iterator();
//        while(iterator.hasNext())&#123;
//            Integer key = iterator.next();
//            System.out.println(key);
//            System.out.println(map.get(key));
//        &#125;
        
        //ForEach EntrySet
//        for(Entry&lt;Integer, String&gt; entry:map.entrySet())&#123;
//            System.out.println(entry.getKey());
//            System.out.println(entry.getValue());
//        &#125;
        
        //ForEach KeySet
//        for(Integer key:map.keySet())&#123;
//            System.out.println(key);
//            System.out.println(map.get(key));
//        &#125;
        
        //Lambda
//        map.forEach((key, value) -&gt; &#123;
//            System.out.println(key);
//            System.out.println(value);
//        &#125;);
        
        //Streams API单线程
//        map.entrySet().stream().forEach((entry) -&gt; &#123;
//            System.out.println(entry.getKey());
//            System.out.println(entry.getValue());
//        &#125;);
        
        //Streams API多线程
        map.entrySet().parallelStream().forEach((entry) -&gt;&#123;
            System.out.println(entry.getKey());
            System.out.println(entry.getValue());
        &#125;);
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
        <category>HashMap的七种遍历方式</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
        <tag>遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程 | I/O密集型和计算密集型</title>
    <url>/2020/11/02/IO%E5%AF%86%E9%9B%86%E5%9E%8B%E5%92%8C%E8%AE%A1%E7%AE%97%E5%AF%86%E9%9B%86%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="I-O密集型和计算密集型"><a href="#I-O密集型和计算密集型" class="headerlink" title="I/O密集型和计算密集型"></a>I/O密集型和计算密集型</h1><p><strong>I/O密集型</strong>—&gt;需要网络功能，大量的时间都在等待网络数据的到来—&gt;通常使用多线程/协程</p>
<p><strong>计算密集型</strong>—&gt;需要占用大量的cpu资源—&gt;通常使用多进程</p>
]]></content>
      <categories>
        <category>python</category>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>参考文献 | Identifying Users and Activities with Cognitive Signal Processing from a Wearable Headband</title>
    <url>/2021/11/13/IdentifyingUsersAndActivitiesWithCognitiveSignalProcessingFromAWearableHeadband/</url>
    <content><![CDATA[<h1 id="Identifying-Users-and-Activities-with-Cognitive-Signal-Processing-from-a-Wearable-Headband"><a href="#Identifying-Users-and-Activities-with-Cognitive-Signal-Processing-from-a-Wearable-Headband" class="headerlink" title="Identifying Users and Activities with Cognitive Signal Processing from a Wearable Headband"></a>Identifying Users and Activities with Cognitive Signal Processing from a Wearable Headband</h1><h2 id="Predictions"><a href="#Predictions" class="headerlink" title="Predictions"></a>Predictions</h2><p>1.Predicting a person<br>2.Predicting an activity<br>3.Predicting a person as well as the activity</p>
<h2 id="Contributions-propose-a-method-of-data-representation-histograms-representation"><a href="#Contributions-propose-a-method-of-data-representation-histograms-representation" class="headerlink" title="Contributions: propose a method of data representation-histograms representation"></a>Contributions: propose a method of data representation-histograms representation</h2><p>This paper shows that <strong>histograms of brain signals</strong> can be a very useful representation for data mining<br>activities. One of the primary advantages of the histograms is that they <strong>reduce the variable length<br>of signals to fixed length representations</strong>.</p>
<h2 id="ideas-from-reading-this-paper"><a href="#ideas-from-reading-this-paper" class="headerlink" title="ideas from reading this paper"></a>ideas from reading this paper</h2><p>combining activities predicting/emotion recognition to a system.</p>
<h2 id="Cite-this-paper"><a href="#Cite-this-paper" class="headerlink" title="Cite this paper"></a>Cite this paper</h2><p>Wiechert, Glavin &amp; Triff, Matt &amp; Liu, Zhixing &amp; Yin, Zhicheng &amp; Zhao, Shuai &amp; Zhong, Ziyun &amp; Zhaou, Runxing &amp; Lingras, Pawan. (2016). Identifying users and activities with cognitive signal processing from a wearable headband. 129-136. 10.1109/ICCI-CC.2016.7862025. </p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>脑电分类</category>
        <category>参考文献</category>
      </categories>
      <tags>
        <tag>脑电分类</tag>
        <tag>EEG</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM | JDK监控和故障处理常用工具总结</title>
    <url>/2022/06/22/JDK%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="JDK监控和故障处理常用工具总结"><a href="#JDK监控和故障处理常用工具总结" class="headerlink" title="JDK监控和故障处理常用工具总结"></a>JDK监控和故障处理常用工具总结</h1><ol>
<li>jps<br>JVM Process Status Tool,用于查看所有Java进程的启动类、传入参数和Java虚拟机参数等信息。</li>
<li>jstat<br>JVM Statistics Monitoring Tool,用于收集HotSpot虚拟机各方面的运行数据。</li>
<li>jinfo<br>Configuration Info for Java,显示虚拟机配置信息。</li>
<li>jmap<br>Memory Map for Java,生成虚拟机的内存转储快照（heapdump文件）、</li>
<li>jhat<br>JVM Heap Analysis Tool,用于分析堆转储快照，它会建立一个HTTP/Web服务器，让用户可以在浏览器上查看分析结果。</li>
<li>jstack<br>Stack Trace for Java,生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。<br><a href="https://javaguide.cn/java/jvm/jdk-monitoring-and-troubleshooting-tools.html#jdk-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7">参考链接</a></li>
</ol>
]]></content>
      <categories>
        <category>JVM</category>
        <category>JDK监控和故障处理常用工具总结</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>并发 | Java中的12个原子操作类</title>
    <url>/2022/06/07/Java%E4%B8%AD%E7%9A%8413%E4%B8%AA%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="Java中的13个原子操作类"><a href="#Java中的13个原子操作类" class="headerlink" title="Java中的13个原子操作类"></a>Java中的13个原子操作类</h1><p>在java.util.concurrent.atomic包中包含了12个原子类，属于四种类型的原子更新方式，分别是：<br>（1）原子更新基本类型<br>    AtomicInteger:原子更新整型；<br>    AtomicBoolean:原子更新布尔类型；<br>    AtomicLong:源自更新长整型。<br>（2）原子更新数组<br>    AtomicIntegerArray:原子更新整型数组里的元素；<br>    AtomicLongArray:原子更新长整型数组里的元素；<br>    AtomicReferenceArray:原子更新引用类型数组里的元素<br>（3）原子更新引用<br>    AtomicReference:原子更新引用类型；<br>    AtomicReferenceFieldUpdater:原子更新引用类型里的字段；<br>    AtomicMarkableReference:原子更新带有标记位的引用类型（可以原子更新一个布尔类型的标记位和引用类型）。<br>（4）原子更新属性（字段）<br>    AtomicIntegerFieldUpdater:原子更新整型的字段的更新器；<br>    AtomicLongFieldUpdater:原子更新长整型的字段的更新器；<br>    AtomicStampedReference:原子更新带有版本号的引用类型，能够解决使用CAS进行原子更新时可能出现的ABA问题。<br>以下给出每个类型的原子更新的一个示例代码：</p>
<span id="more"></span>
<p><strong>示例代码1-原子更新基本类型</strong></p>
<pre><code>package concurrency.atomic;

import java.util.concurrent.atomic.AtomicInteger;

public class AtomicIntegerTest1 &#123;
    static AtomicInteger ai = new AtomicInteger(1);
    
    public static void main(String[] args)&#123;
        int addAndGet = ai.addAndGet(2);
        System.out.println(addAndGet);
    
        boolean compareAndSet = ai.compareAndSet(1, 2);
        System.out.println(compareAndSet);
        System.out.println(ai.get());
        
        System.out.println(ai.getAndIncrement());
        System.out.println(ai.get());
        
        ai.lazySet(3);
        System.out.println(ai.get());
        
        int andSet = ai.getAndSet(2);
        System.out.println(andSet);
        System.out.println(ai.get());
    &#125;
&#125;
</code></pre>
<p><strong>示例代码2-原子更新数组</strong></p>
<pre><code>package concurrency.atomic;

import java.util.concurrent.atomic.AtomicIntegerArray;

public class AtomicIntegerArrayTest &#123;
    static int[] value = new int[]&#123;1,2&#125;;
    static AtomicIntegerArray ai = new AtomicIntegerArray(value);
    
    public static void main(String[] args)&#123;
        System.out.println(ai.getAndSet(0, 3));
        System.out.println(ai.get(0));
        System.out.println(value[0]);
        int addAndGet = ai.addAndGet(0, 3);
        System.out.println(addAndGet);
        System.out.println(ai.get(0));
        System.out.println(ai.compareAndSet(0, 3, 33));
        System.out.println(ai.compareAndSet(0, 6, 66));

    &#125;
&#125;
</code></pre>
<p><strong>示例代码3-原子更新引用</strong></p>
<pre><code>package concurrency.atomic;

import java.util.concurrent.atomic.AtomicReference;


public class AtomicReferenceTest &#123;
    public static AtomicReference&lt;User&gt; atomicUserRef = new AtomicReference&lt;User&gt;();
    
    public static void main(String[] args)&#123;
        User user = new User(&quot;conan&quot;, 15);
        atomicUserRef.set(user);
        User updateUser = new User(&quot;Shinichi&quot;, 17);
        atomicUserRef.compareAndSet(user, updateUser);
        System.out.println(atomicUserRef.get().getName());
        System.out.println(atomicUserRef.get().getOld());
    &#125;
    
    static class User&#123;
        private String name;
        private int old;
        
        public User(String name, int old)&#123;
            this.name = name;
            this.old = old;
        &#125;

        public String getName() &#123;
            return name;
        &#125;

        public void setName(String name) &#123;
            this.name = name;
        &#125;

        public int getOld() &#123;
            return old;
        &#125;

        public void setOld(int old) &#123;
            this.old = old;
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>示例代码4-原子更新属性</strong></p>
<pre><code>package concurrency.atomic;

import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;

public class AtomicIntegerFieldUpdaterTest &#123;
    //创建原子更新器，并设置需要更新的对象和对象的属性
    private static AtomicIntegerFieldUpdater&lt;User&gt; a = AtomicIntegerFieldUpdater.newUpdater(User.class, &quot;old&quot;);
    
    public static void main(String[] args)&#123;
        //设置柯南的年龄是10岁
        User conan = new User(&quot;conan&quot;, 10);
        //柯南长了一岁，但是仍然会输出旧的年龄
        System.out.println(a.getAndIncrement(conan));
        //输出柯南现在的年龄
        System.out.println(a.get(conan));
    &#125;
    
    public static class User&#123;
        private String name;
        public volatile int old;
        
        public User(String name, int old)&#123;
            this.name = name;
            this.old = old;
        &#125;

        public String getName() &#123;
            return name;
        &#125;

        public int getOld() &#123;
            return old;
        &#125;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>并发</category>
        <category>Java中的12个原子操作类</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>原子类</tag>
      </tags>
  </entry>
  <entry>
    <title>框架 | Java中的6大框架</title>
    <url>/2022/01/26/Java%E4%B8%AD%E7%9A%846%E5%A4%A7%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="Java中的6大框架"><a href="#Java中的6大框架" class="headerlink" title="Java中的6大框架"></a>Java中的6大框架</h1><p><strong>6大框架</strong><br>1)structs1<br>2)structs2<br>3)hibernate<br>4)spring<br>5)springMVC<br>6)mybatis<br><strong>SSM</strong><br><strong>SSM=spring+springMVC+mybatis</strong><br><strong>框架分类</strong><br>MVC框架：struts1(封装了servlet),struts2(封装了filter),springMVC<br>持久层框架：hibernate,mybatis<br>整合型框架，设计型框架：spring</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>Java中的6大框架</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Java | Java判断对象是否相等</title>
    <url>/2022/01/07/Java%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89/</url>
    <content><![CDATA[<h1 id="Java判断对象是否相等"><a href="#Java判断对象是否相等" class="headerlink" title="Java判断对象是否相等"></a>Java判断对象是否相等</h1><h2 id="1-类的创建"><a href="#1-类的创建" class="headerlink" title="1.类的创建"></a>1.类的创建</h2><p>要判断两个对象是否相等，我们首先得创建相应得类并由此类创建两个对象;此处我们定义一个Monkey类，该类<br>包含两个属性：name 和 age;同时我们为类中得实例变量添加了构造器、getter和setter方法。</p>
<span id="more"></span>

<pre><code>class Monkey&#123;
    private String name;
    private int age;
    
    public Monkey(String name, int age)&#123;
        this.setName(name);
        this.setAge(age);
    &#125;

    public String getName() &#123;
        return this.name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;
&#125;
</code></pre>
<h2 id="Java中如何判断两个对象是否相等"><a href="#Java中如何判断两个对象是否相等" class="headerlink" title="Java中如何判断两个对象是否相等"></a>Java中如何判断两个对象是否相等</h2><p>Java通过hashCode()和equals的结果共同决定两个对象是否相等</p>
<h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。<br>这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK<br>的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。</p>
<h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><p>equals它的作用也是判断两个对象是否相等，如果对象重写了equals()方法，<br>比较两个对象的内容是否相等；如果没有重写，比较两个对象的地址是否相同，<br>价于“==”。同样的，equals()定义在JDK的Object.java中，这就意味着Java<br>中的任何类都包含有equals()函数。<br><strong>注意：通常我们可以通过重写hashCode()和equals()来自定义两个对象相等的标准，且若重写，<br>必须同时对两个方法进行重写。</strong></p>
<h2 id="重写hashCode-和equals"><a href="#重写hashCode-和equals" class="headerlink" title="重写hashCode()和equals()"></a>重写hashCode()和equals()</h2><p>我们只需再上面定义的Monkey类中重写这两个方法即可；equals方法直接返回true,也就是说对<br>这个类产生的任意两个对象进行比较都会返回ture；hashCode()方法返回一个固定的值，这里取4。</p>
<pre><code>class Monkey&#123;
    ...
    
    public boolean equals(Object obj) &#123;
        return true;
    &#125;
    
    public int hashCode() &#123;
        return 4;
    &#125;
    
    ...
&#125;
</code></pre>
<h2 id="写测试类"><a href="#写测试类" class="headerlink" title="写测试类"></a>写测试类</h2><p>下面我们创建一个HashCodeAndEqualsTest测试类进行测试。</p>
<pre><code>public class HashCodeAndEqualsTest &#123;
    
    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        Monkey monkey1 = new Monkey(&quot;wu kong&quot;, 10);
        Monkey monkey2 = monkey1;
        Monkey monkey3 = new Monkey(&quot;liu er&quot;,  5);
        
        System.out.println(&quot;monkey1&#39;s name:&quot; + monkey1.getName() + &quot;,age:&quot; + monkey1.getAge());
        System.out.println(&quot;monkey2&#39;s name:&quot; + monkey2.getName() + &quot;,age:&quot; + monkey2.getAge());
        System.out.println(&quot;monkey3&#39;s name:&quot; + monkey3.getName() + &quot;,age:&quot; + monkey3.getAge());
        
        System.out.println(&quot;monkey1&#39;s hash code:&quot; + monkey1.hashCode());
        System.out.println(&quot;monkey2&#39;s hash code:&quot; + monkey2.hashCode());
        System.out.println(&quot;monkey3&#39;s hash code:&quot; + monkey3.hashCode());
        
        System.out.println(&quot;Is monkey1 equal to monkey2:&quot; + monkey1.equals(monkey2));
        System.out.println(&quot;Is monkey1 equal to monkey3:&quot; + monkey1.equals(monkey3));
    &#125;

&#125;
</code></pre>
<h3 id="1-没有重写方法的程序执行结果"><a href="#1-没有重写方法的程序执行结果" class="headerlink" title="1.没有重写方法的程序执行结果"></a>1.没有重写方法的程序执行结果</h3><pre><code>monkey1&#39;s name:wu kong,age:10
monkey2&#39;s name:wu kong,age:10
monkey3&#39;s name:liu er,age:5
monkey1&#39;s hash code:366712642
monkey2&#39;s hash code:366712642
monkey3&#39;s hash code:1829164700
Is monkey1 equal to monkey2:true
Is monkey1 equal to monkey3:false
</code></pre>
<p>monkey1和monkey2指向堆上的同一个对象，故monkey1.equals(monkey2)的结果为true,monkey1和<br>monkey3指向堆上两个不同的对象，故equals()方法返回false。</p>
<h3 id="2-重写后的程序执行结果"><a href="#2-重写后的程序执行结果" class="headerlink" title="2.重写后的程序执行结果"></a>2.重写后的程序执行结果</h3><pre><code>monkey1&#39;s name:wu kong,age:10
monkey2&#39;s name:wu kong,age:10
monkey3&#39;s name:liu er,age:5
monkey1&#39;s hash code:4
monkey2&#39;s hash code:4
monkey3&#39;s hash code:4
Is monkey1 equal to monkey2:true
Is monkey1 equal to monkey3:true
</code></pre>
<p>由于我们对equals和hashCode方法进行了重写，重新确定了对象相等的标准，故monkey1和monkey3为<br>“同一对象”。</p>
<h3 id="3-只重写equals方法时，程序的执行结果"><a href="#3-只重写equals方法时，程序的执行结果" class="headerlink" title="3.只重写equals方法时，程序的执行结果"></a>3.只重写equals方法时，程序的执行结果</h3><pre><code>monkey1&#39;s name:wu kong,age:10
monkey2&#39;s name:wu kong,age:10
monkey3&#39;s name:liu er,age:5
monkey1&#39;s hash code:366712642
monkey2&#39;s hash code:366712642
monkey3&#39;s hash code:1829164700
Is monkey1 equal to monkey2:true
Is monkey1 equal to monkey3:true
</code></pre>
<p>重写了equals方法后，monkey1和monkey3两个对象被认为指向同一实例，但他们的hash code不同</p>
<h3 id="4-只重写hashCode方法时，程序的执行结果"><a href="#4-只重写hashCode方法时，程序的执行结果" class="headerlink" title="4.只重写hashCode方法时，程序的执行结果"></a>4.只重写hashCode方法时，程序的执行结果</h3><pre><code>monkey1&#39;s name:wu kong,age:10
monkey2&#39;s name:wu kong,age:10
monkey3&#39;s name:liu er,age:5
monkey1&#39;s hash code:4
monkey2&#39;s hash code:4
monkey3&#39;s hash code:4
Is monkey1 equal to monkey2:true
Is monkey1 equal to monkey3:false
</code></pre>
<p>虽然monkey1、monkey2的hash code相同，但equals方法返回false。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
        <category>判断两个对象是否相等</category>
      </categories>
      <tags>
        <tag>equals</tag>
        <tag>hashCode</tag>
      </tags>
  </entry>
  <entry>
    <title>spring | JdbcTemplate增删改查</title>
    <url>/2022/03/07/JdbcTemplate/</url>
    <content><![CDATA[<h1 id="JdbcTemplate增删改查"><a href="#JdbcTemplate增删改查" class="headerlink" title="JdbcTemplate增删改查"></a>JdbcTemplate增删改查</h1><p>1.项目目录<br><img src="/2022/03/07/JdbcTemplate/1.PNG"><br>2.Emp.java</p>
<pre><code>package com.atguigu.jdbctemplate;

public class Emp &#123;
    private Integer eid;
    private String ename;
    private Integer age;
    private String sex;
    public Integer getEid() &#123;
        return eid;
    &#125;
    public void setEid(Integer eid) &#123;
        this.eid = eid;
    &#125;
    public String getEname() &#123;
        return ename;
    &#125;
    public void setEname(String ename) &#123;
        this.ename = ename;
    &#125;
    public Integer getAge() &#123;
        return age;
    &#125;
    public void setAge(Integer age) &#123;
        this.age = age;
    &#125;
    public String getSex() &#123;
        return sex;
    &#125;
    public void setSex(String sex) &#123;
        this.sex = sex;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Emp [eid=&quot; + eid + &quot;, ename=&quot; + ename + &quot;, age=&quot; + age + &quot;, sex=&quot; + sex + &quot;]&quot;;
    &#125;
    
&#125;
</code></pre>
<p>3.ssm表<br><img src="/2022/03/07/JdbcTemplate/2.PNG"><br>4.db.properties</p>
<pre><code>jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/ssm
jdbc.username=root
jdbc.password=root
</code></pre>
<p>5.jdbc.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&gt;
    
    &lt;!-- 引入属性文件 --&gt;
    &lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;
        &lt;property name=&quot;location&quot; value=&quot;db.properties&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    
    &lt;!-- 引入属性文件 --&gt;
    &lt;context:property-placeholder location=&quot;db.properties&quot;/&gt;
    
    &lt;!-- 创建数据源 --&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    
    &lt;!-- 通过数据源配置JdbcTemplate --&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    
&lt;/beans&gt;
</code></pre>
<p>6.TestJdbcTemplate.java</p>
<pre><code>package com.atguigu.jdbctemplate;

import static org.junit.Assert.*;

import java.util.ArrayList;
import java.util.List;

import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;

public class TestJdbcTemplate &#123;
    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;jdbc.xml&quot;);
    JdbcTemplate jdbcTemplate = ac.getBean(&quot;jdbcTemplate&quot;, JdbcTemplate.class);
    
    @Test
    public void test() &#123;
        //单个增删改
        //System.out.println(jdbcTemplate);//org.springframework.jdbc.core.JdbcTemplate@6483f5ae
        //jdbcTemplate.update(&quot;insert into emp values(1,&#39;zhangsan&#39;,23,&#39;男&#39;)&quot;);
        
        //增加记录
        //String sql = &quot;insert into emp values(2, ?, ?, ?)&quot;;
        //jdbcTemplate.update(sql, &quot;lisi&quot;, 25, &quot;男&quot;);
        
        //删除记录
        //String sql = &quot;delete from emp where eid=?&quot;;
        //jdbcTemplate.update(sql,2);
        
        //修改记录
        //String sql = &quot;update emp set ename=? where eid=?&quot;; 
        //jdbcTemplate.update(sql, &quot;lisi&quot;, 1);
        
        //不能使用
        //String sql = &quot;delete from emp where eid in (?)&quot;;
        //String eids = &quot;3, 4, 5&quot;;
        //jdbcTemplate.update(sql,eids);
        
        //可以使用
        //String eids = &quot;3,4,5&quot;;
        //String sql = &quot;delete from emp where eid in (&quot;+eids+&quot;)&quot;;
        //jdbcTemplate.update(sql);
        
        //String sql = &quot;select * from emp where ename like &#39;%?%&#39;&quot;;//不能使用
        //String sql = &quot;select * from emp where ename like concat(&#39;%&#39;,?,&#39;%&#39;)&quot;;//可以使用
    &#125;
    
    @Test
    public void testBatchUpdate()&#123;
        //批量增删改
//        String sql = &quot;insert into emp values(?,?,?,?)&quot;;
//        List&lt;Object[]&gt; list = new ArrayList&lt;&gt;();
//        list.add(new Object[]&#123;3,&quot;a1&quot;,1,&quot;男&quot;&#125;);
//        list.add(new Object[]&#123;4,&quot;a2&quot;,2,&quot;男&quot;&#125;);
//        list.add(new Object[]&#123;5,&quot;a3&quot;,3,&quot;男&quot;&#125;);
//        jdbcTemplate.batchUpdate(sql, list);
    &#125;
    
    @Test
    public void testQueryForObject()&#123;
        //jdbcTemplate.queryForObject(sql, requiredType);//用来获取单个的值
        //jdbcTemplate.queryForObject(sql, rowMapper);//用来获取单条数据
        
//        String sql= &quot;select eid,ename,age,sex from emp where eid=?&quot;;
//        RowMapper&lt;Emp&gt; rowMapper = new BeanPropertyRowMapper&lt;&gt;(Emp.class);//将列名（字段名或字段名的别名）与属性名进行映射
//        Emp emp = jdbcTemplate.queryForObject(sql, new Object[]&#123;3&#125;, rowMapper);
//        System.out.println(emp);
        
        String sql = &quot;select count(*) from emp&quot;;
        Integer count = jdbcTemplate.queryForObject(sql, Integer.class);
        System.out.println(count);
    &#125;
    
    @Test
    public void testQuery()&#123;
        String sql = &quot;select eid,ename,age,sex from emp&quot;;
        RowMapper&lt;Emp&gt; rowMapper = new BeanPropertyRowMapper&lt;&gt;(Emp.class);
        List&lt;Emp&gt; list = jdbcTemplate.query(sql, rowMapper);
        for(Emp emp:list)&#123;
            System.out.println(emp);
        &#125;
    &#125;

&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>spring</category>
        <category>JdbcTemplate</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>JdbcTemplate</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis | Jedis实现手机号验证码</title>
    <url>/2022/05/06/Jedis%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%9C%BA%E5%8F%B7%E9%AA%8C%E8%AF%81%E7%A0%81/</url>
    <content><![CDATA[<h1 id="Jedis实现手机号验证码"><a href="#Jedis实现手机号验证码" class="headerlink" title="Jedis实现手机号验证码"></a>Jedis实现手机号验证码</h1><p><img src="/2022/05/06/Jedis%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%9C%BA%E5%8F%B7%E9%AA%8C%E8%AF%81%E7%A0%81/1.PNG"><br><strong>要求</strong><br>1.输入手机号，点击发送后随机生成6位数字码，2分钟有效<br>2.输入验证码，点击验证，返回成功或失败<br>3.每个手机号每天只能输入3次</p>
<span id="more"></span>
<p>1.index.jsp</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=ISO-8859-1&quot;&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;script  src=&quot;/Verify_code/static/jquery/jquery-3.1.0.js&quot; &gt;&lt;/script&gt;
&lt;link href=&quot;/Verify_code/static/bs/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot; /&gt;
&lt;script  src=&quot;/Verify_code/static/bs/js/bootstrap.min.js&quot;   &gt;&lt;/script&gt;

&lt;/head&gt;
&lt;body&gt;
   &lt;div class=&quot;container&quot;&gt;
        &lt;div class=&quot;row&quot;&gt;
            &lt;div id=&quot;alertdiv&quot; class=&quot;col-md-12&quot;&gt;
                  &lt;form class=&quot;navbar-form navbar-left&quot; role=&quot;search&quot; id=&quot;codeform&quot;&gt;
                  &lt;div class=&quot;form-group&quot;&gt;
                    &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;填写手机号&quot; name=&quot;phone_no&quot;&gt;
                    &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; id=&quot;sendCode&quot;&gt;发送验证码&lt;/button&gt;&lt;br&gt;
                    &lt;font id=&quot;countdown&quot; color=&quot;red&quot; &gt;&lt;/font&gt;
                    &lt;br&gt;
                    &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;填写验证码&quot; name=&quot;verify_code&quot;&gt;
                    &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; id=&quot;verifyCode&quot;&gt;确定&lt;/button&gt;
                    &lt;font id=&quot;result&quot; color=&quot;green&quot; &gt;&lt;/font&gt;&lt;font id=&quot;error&quot; color=&quot;red&quot; &gt;&lt;/font&gt;
                    &lt;/div&gt;
                    &lt;/form&gt;
    &lt;/div&gt;
   &lt;/div&gt;
  &lt;/div&gt;

&lt;/body&gt;
&lt;script type=&quot;text/javascript&quot;&gt; 
var t=120;//设定倒计时的时间 
var interval;
function refer()&#123;  
    $(&quot;#countdown&quot;).text(&quot;请于&quot;+t+&quot;秒内填写验证码 &quot;); // 显示倒计时 
    t--; // 计数器递减 
    if(t&lt;=0)&#123;
        clearInterval(interval);
        $(&quot;#countdown&quot;).text(&quot;验证码已失效，请重新发送！ &quot;);
    &#125;
&#125; 

$(function()&#123;
    $(&quot;#sendCode&quot;).click( function () &#123;
           
           $.post(&quot;/Verify_code/CodeSenderServlet&quot;,$(&quot;#codeform&quot;).serialize(),function(data)&#123;
             if(data==&quot;true&quot;)&#123;
                 t=120;
                 clearInterval(interval);
                 interval= setInterval(&quot;refer()&quot;,1000);//启动1秒定时  
             &#125;else if (data==&quot;limit&quot;)&#123;
                clearInterval(interval);
                $(&quot;#countdown&quot;).text(&quot;单日发送超过次数！ &quot;)
             &#125;
          &#125;);   
    &#125;);
    
    $(&quot;#verifyCode&quot;).click( function () &#123;
        
           $.post(&quot;/Verify_code/CodeVerifyServlet&quot;,$(&quot;#codeform&quot;).serialize(),function(data)&#123;
             if(data==&quot;true&quot;)&#123;
                 $(&quot;#result&quot;).attr(&quot;color&quot;,&quot;green&quot;);
                 $(&quot;#result&quot;).text(&quot;验证成功&quot;);
                 clearInterval(interval);
                 $(&quot;#countdown&quot;).text(&quot;&quot;);
             &#125;else&#123;
                 $(&quot;#result&quot;).attr(&quot;color&quot;,&quot;red&quot;);
                 $(&quot;#result&quot;).text(&quot;验证失败&quot;);
             &#125;
          &#125;);   
    &#125;);
    
    
&#125;);
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p>2.CodeSenderServlet.java(发送验证码)</p>
<pre><code>@WebServlet(&quot;/CodeSenderServlet&quot;)
public class CodeSenderServlet extends HttpServlet &#123;
    private static final long serialVersionUID = 1L;
       
    /**
     * @see HttpServlet#HttpServlet()
     */
    public CodeSenderServlet() &#123;
        super();
        // TODO Auto-generated constructor stub
    &#125;

    /**
     * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)
     */
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        
        //获取手机号
        String phone_no = request.getParameter(&quot;phone_no&quot;);
        //获取验证码
        String code = getCode(6);
        //拼接key
        String codeKey = &quot;Verify_code:&quot; + phone_no + &quot;:code&quot;;//Verify_code:12345:code
        String countKey = &quot;Verify_code:&quot; + phone_no + &quot;:count&quot;;
        
        Jedis jedis = new Jedis(&quot;192.168.44.132&quot;, 6379);
        //判断发送验证码的次数
        String count = jedis.get(countKey);
        if(count == null) &#123;
            //代表第一次
            jedis.setex(countKey, 24*60*60, &quot;1&quot;);
        &#125;else if(Integer.parseInt(count) &lt;= 2) &#123;
            jedis.incr(countKey);
        &#125;else if(Integer.parseInt(count) &gt; 2) &#123;
            response.getWriter().print(&quot;limit&quot;);
            jedis.close();
            return ;
        &#125;
        
        //向redis中进行存储，以手机号为键，以验证码为值
        jedis.setex(codeKey, 120, code);
        jedis.close();
        response.getWriter().print(true);
        
    &#125;
    
    
    private String getCode(int length) &#123;
        String code = &quot;&quot;;
        Random random = new Random();
        for(int i = 0; i &lt; length; i++) &#123;
            int rand = random.nextInt(10);
            code += rand;
        &#125;
        return code;
    &#125;

&#125;
</code></pre>
<p>3.验证</p>
<pre><code>@WebServlet(&quot;/CodeVerifyServlet&quot;)
public class CodeVerifyServlet extends HttpServlet &#123;
    private static final long serialVersionUID = 1L;
       
    /**
     * @see HttpServlet#HttpServlet()
     */
    public CodeVerifyServlet() &#123;
        super();
        // TODO Auto-generated constructor stub
    &#125;

    /**
     * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)
     */
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
    
        //获取验证码和手机号
        String phone_no = request.getParameter(&quot;phone_no&quot;);
        String verify_code = request.getParameter(&quot;verify_code&quot;);
        //拼接key
        String codeKey = &quot;Verify_code:&quot; + phone_no + &quot;:code&quot;;
        //从redis中获取手机号所对应的验证码
        Jedis jedis = new Jedis(&quot;192.168.44.132&quot;, 6379);
        String code = jedis.get(codeKey);
        if(code.equals(verify_code)) &#123;
            response.getWriter().print(true);
        &#125;
        jedis.close();
        
    &#125;

&#125;
</code></pre>
]]></content>
      <categories>
        <category>Redis</category>
        <category>Jedis实现手机号验证码</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Jedis</tag>
        <tag>手机号验证码</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习 | K近邻算法(KNN)</title>
    <url>/2021/02/21/K%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95-KNN/</url>
    <content><![CDATA[<h1 id="K近邻算法-KNN"><a href="#K近邻算法-KNN" class="headerlink" title="K近邻算法(KNN)"></a>K近邻算法(KNN)</h1><h2 id="KNN算法原理"><a href="#KNN算法原理" class="headerlink" title="KNN算法原理"></a>KNN算法原理</h2><p>k近邻法(k-nearest neighbor, k-NN)一种基本分类与回归方法。它的工作原理是：存在一个样本数据集合，也称作为训练样本集，并且样本集中每个数据都存在标签，即我们知道样本集中每一个数据与所属分类的对应关系。输入没有标签的新数据后，将新的数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本最相似数据(最近邻)的分类标签。一般来说，我们只选择样本数据集中前k个最相似的数据，这就是k-近邻算法中k的出处，通常k是不大于20的整数。最后，选择k个最相似数据中出现次数最多的分类，作为新数据的分类。</p>
<span id="more"></span>
<h2 id="距离度量"><a href="#距离度量" class="headerlink" title="距离度量"></a>距离度量</h2><p>我们已经知道k-近邻算法根据特征比较，然后提取样本集中特征最相似数据（最近邻）的分类标签，那么如何进行比较？KNN算法通过距离（欧式距离）度量进行判断。<br><b>Note:</b>距离度量方法还有切比雪夫距离、马氏距离、巴氏距离等；</p>
<h2 id="简单k-近邻算法步骤"><a href="#简单k-近邻算法步骤" class="headerlink" title="简单k-近邻算法步骤"></a>简单k-近邻算法步骤</h2><p>1.计算已知类别数据集中的点与当前点的距离<br>2.按照距离递增次序排序<br>3.选取与当前点距离最小的k个点<br>4.确定前k个点所在类别的出现频率<br>5.返回前k个点所出现频率最高的类别作为当前点的预测分类</p>
<h2 id="KNN的一般流程"><a href="#KNN的一般流程" class="headerlink" title="KNN的一般流程"></a>KNN的一般流程</h2><p>1.收集数据：爬虫/第三方提供的免费/收费数据。一般来讲，数据放在txt文本文件中，按照一定的格式进行存储，便于解析和处理。<br>2.准备数据：使用python解析、预处理数据<br>3.分析数据：可以使用很多方法对数据进行分析。例如使用Matplotlib将数据可视化<br>4.测试算法：计算错误率<br>5.使用算法：错误率在可接受范围内，就可以使用k-近邻算法进行分类</p>
<h2 id="KNN的优缺点"><a href="#KNN的优缺点" class="headerlink" title="KNN的优缺点"></a>KNN的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>1.简单好用，容易理解，精度高，理论成熟，既可以用来做<b>分类</b>也可以用来做<b>回归</b><br>2.可用于数值型数据和离散型数据<br>3.训练时间复杂度为O(n);无数据输入假定；<br>4.对异常值不敏感</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>1.<b>计算复杂性高</b>；空间复杂性高<br>2.样本不平衡问题（即有些类别的样本数量很多，而其他样本的数量很少）<br>3.<b>一般数值很大的时候不用这个，计算量太大。但是单个样本也不能太少，否则容易发生误分。</b><br>4.最大的缺点是无法给出数据的内在含义  </p>
<h2 id="实战代码地址"><a href="#实战代码地址" class="headerlink" title="实战代码地址"></a>实战代码地址</h2><p><a href="https://github.com/victory-liao/Machine-Learning">Click here to look up code</a></p>
<h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><p><a href="https://cuijiahua.com/blog/2017/11/ml_1_knn.html">KNN</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>KNN</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>KNN</tag>
      </tags>
  </entry>
  <entry>
    <title>RNN | LSTM</title>
    <url>/2021/11/13/LSTM/</url>
    <content><![CDATA[<h1 id="Understanding-LSTM-Networks"><a href="#Understanding-LSTM-Networks" class="headerlink" title="Understanding LSTM Networks"></a>Understanding LSTM Networks</h1><p><a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/">Understanding LSTM Networks</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
        <category>RNN</category>
        <category>LSTM</category>
      </categories>
      <tags>
        <tag>LSTM</tag>
        <tag>RNN</tag>
      </tags>
  </entry>
  <entry>
    <title>RNN | LSTM输入输出格式</title>
    <url>/2021/11/21/LSTM%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="LSTM模型结构的可视化"><a href="#LSTM模型结构的可视化" class="headerlink" title="LSTM模型结构的可视化"></a>LSTM模型结构的可视化</h1><p><a href="https://zhuanlan.zhihu.com/p/139617364?utm_source=wechat_session&utm_medium=social&utm_oi=1006101315038175232&utm_campaign=shareopn">非常到位的LSTM解读！</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
        <category>RNN</category>
        <category>LSTM</category>
      </categories>
      <tags>
        <tag>LSTM</tag>
        <tag>RNN</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux | vim | vim常用命令及三种命令模式</title>
    <url>/2020/10/08/Linux-vim/</url>
    <content><![CDATA[<h1>vim常用命令</h1> 
yy:复制 光标所在的这一行
numyy:复制 光标所在行开始向下的num行<br><br>

<p>p:paste<br><br></p>
<p>dd:剪切 光标所在的这一行<br><br>numdd:剪切 光标所在行向下num行<br><br>D:从当前的光标开始剪切，一直到行末<br><br>d0:从单签光标开始剪切，一直到行首<br><br>x：删除当前的光标，每次只会删除一个<br><br>X：删除当前光标前面那个，每次只会删除一个<br><br></p>
<span id="more"></span>
<p>h：left j：down k：up l：right<br><br></p>
<p>H:当前屏幕的最上方<br><br>M:当前屏幕的中间<br><br>L:当前屏幕的下方<br><br></p>
<p>ctrl+f 向下翻一页<br><br>ctrl+b 向上翻一页<br><br></p>
<p>ctrl+u 向上翻半页<br><br>ctrl+d 向下翻半页<br><br></p>
<p>numG:快速定位到第num行代码<br><br>G:快速回到整个代码的最后一行<br><br>gg:快速回到整个代码的第一行<br><br></p>
<p>w:向后跳一个单词的长度<br><br>b：向前跳一个单词的长度<br><br></p>
<p>u:撤销刚刚的操作<br><br>ctrl+r：反撤销<br><br></p>
<p>选中一片代码<br><br>v:<br><br>V:<br><br>‘&gt;&gt;:向右移动代码<br><br>&lt;&lt;:向左移动代码<br><br></p>
<p>.:重复执行上一次的命令<br><br></p>
<p>r:替换一个字符<br><br>R:替换光标以及后边的字符<br><br></p>
<p>/string:查找 n:下一个 N：上一个<br><br></p>
<p>shift+zz==wq<br><br></p>
<p>末行模式：<br><br>w:保存<br><br>q:退出<br><br>wq:保存并退出<br><br><br>x:退出</p>
<h1>vim三种命令模式</h1>
![vim三种命令模式](./Linux-vim/vim.jpg)  





]]></content>
      <categories>
        <category>Linux</category>
        <category>vim</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>可视化 | Logistic回归可视化主要代码</title>
    <url>/2021/03/11/Logistic%E5%9B%9E%E5%BD%92%E5%8F%AF%E8%A7%86%E5%8C%96%E4%B8%BB%E8%A6%81%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h1 id="Logistic回归可视化主要代码"><a href="#Logistic回归可视化主要代码" class="headerlink" title="Logistic回归可视化主要代码"></a>Logistic回归可视化主要代码</h1><pre><code>import matplotlib.pyplot as plt

fig = plt.figure()
ax = fig.add_subplot(111)
ax.scatter(xcord1,ycord1,s=20,c=&#39;red&#39;,marker=&#39;s&#39;,alpha=0.5)
ax.plot(x,y)
plt.title()
plt.xlabel()
plt.ylabel()
plt.show()
</code></pre>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>可视化(Visualization)</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>逻辑回归</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习 | Logistic回归</title>
    <url>/2021/03/06/Logistic%E5%9B%9E%E5%BD%92/</url>
    <content><![CDATA[<h1 id="Logistic回归"><a href="#Logistic回归" class="headerlink" title="Logistic回归"></a>Logistic回归</h1><p>Logistic回归是一种<b>分类</b>算法，通常用于<b>二分类</b>问题(例如：明天是否会下雨)，但也可以用于多分类问题。</p>
<span id="more"></span>
<h2 id="Logistic回归与梯度上升算法"><a href="#Logistic回归与梯度上升算法" class="headerlink" title="Logistic回归与梯度上升算法"></a>Logistic回归与梯度上升算法</h2><h3 id="Logistic回归-1"><a href="#Logistic回归-1" class="headerlink" title="Logistic回归"></a>Logistic回归</h3><p><b>回归：</b>利用一条直线对一些数据点进行拟合的过程。</p>
<p>Logistic回归是分类方法，它利用的是Sigmoid函数阈值在[0,1]这个特性。</p>
<p><b>Logistic回归进行分类的主要思想：</b>根据现有数据对分类边界线建立回归公式，以此进行分类</p>
<p>其实，Logistic回归本质上是一个基于条件概率的判别模型(Discriminative Model)。</p>
<p><b>Sigmoid函数(Logistic函数)：</b><br><img src="/2021/03/06/Logistic%E5%9B%9E%E5%BD%92/1.png"><br><img src="/2021/03/06/Logistic%E5%9B%9E%E5%BD%92/2.jpg"><br><img src="/2021/03/06/Logistic%E5%9B%9E%E5%BD%92/3.png"><br>整合成一个公式：<br><img src="/2021/03/06/Logistic%E5%9B%9E%E5%BD%92/5.jpg"></p>
<p><b>Sigmoid函数的图像：</b><br><img src="/2021/03/06/Logistic%E5%9B%9E%E5%BD%92/6.png"><br>z是一个矩阵，θ是参数列向量(要求解的)，x是样本列向量(给定的数据集)。θ^T表示θ的转置。g(z)函数实现了任意实数到[0,1]的映射，这样我们的数据集([x0,x1,…,xn])，不管是大于1或者小于0，都可以映射到[0,1]区间进行分类。hθ(x)给出了输出为1的概率。比如当hθ(x)=0.7，那么说明有70%的概率输出为1。输出为0的概率是输出为1的补集，也就是30%。</p>
<p>如果我们有合适的参数列向量θ([θ0,θ1,…θn]^T)，以及样本列向量x([x0,x1,…,xn])，那么我们对样本x分类就可以通过上述公式计算出一个概率，如果这个概率大于0.5，我们就可以说样本是正样本，否则样本是负样本。</p>
<p><b>如何得到合适的参数向量θ？</b><br>根据sigmoid函数的特性，我们可以做出如下的假设：<br><img src="/2021/03/06/Logistic%E5%9B%9E%E5%BD%92/7.jpg"><br>两个概率公式合而为一：(损失函数-Loss Function)<br><img src="/2021/03/06/Logistic%E5%9B%9E%E5%BD%92/8.jpg"><br>取对数：<br><img src="/2021/03/06/Logistic%E5%9B%9E%E5%BD%92/9.jpg"><br>这个损失函数，是对于一个样本而言的。给定一个样本，我们就可以通过这个损失函数求出，样本所属类别的概率，而这个概率越大越好，所以也就是求解这个损失函数的最大值。既然概率出来了，那么最大似然估计也该出场了。假定样本与样本之间相互独立，那么整个样本集生成的概率即为所有样本生成概率的乘积，再将公式对数化，便可得到如下公式：<br><img src="/2021/03/06/Logistic%E5%9B%9E%E5%BD%92/10.png"><br>其中，m为样本的总数，y(i)表示第i个样本的类别，x(i)表示第i个样本，需要注意的是θ是多维向量，x(i)也是多维向量。</p>
<p>综上所述，满足J(θ)的最大的θ值即是我们需要求解的模型。</p>
<p>怎么求解使J(θ)最大的θ值呢？因为是<b>求最大值</b>，所以我们需要使用<b>梯度上升算法</b>。如果面对的问题是求解使J(θ)<b>最小</b>的θ值，那么我们就需要使用<b>梯度下降算法</b>。面对我们这个问题，如果使<b>J(θ) := -J(θ)</b>，那么问题就从求极大值转换成求极小值了，使用的算法就从梯度上升算法变成了梯度下降算法，它们的思想都是相同的，学会其一，就也会了另一个。</p>
<h3 id="梯度上升算法"><a href="#梯度上升算法" class="headerlink" title="梯度上升算法"></a>梯度上升算法</h3><p>爬坡这个动作用数学公式表达即为：<br><img src="/2021/03/06/Logistic%E5%9B%9E%E5%BD%92/11.png"><br>其中，α为步长，也就是学习速率，控制更新的幅度。<br>梯度上升迭代公式：<br><img src="/2021/03/06/Logistic%E5%9B%9E%E5%BD%92/12.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><b>Logistic回归的一般过程：</b><br>1.收集数据：采用任意方法收集数据。<br>2.准备数据：由于需要进行距离计算，因此要求数据类型为数值型。另外，结构化数据格式则最佳。<br>3.分析数据：采用任意方法对数据进行分析。<br>4.训练算法：大部分时间将用于训练，训练的目的是为了找到最佳的分类回归系数。<br>5.测试算法：一旦训练步骤完成，分类将会很快。<br>6.使用算法：首先，我们需要输入一些数据，并将其转换成对应的结构化数值；接着，基于训练好的回归系数，就可以对这些数值进行简单的回归计算，判定它们属于哪个类别；在这之后，我们就可以在输出的类别上做一些其他分析工作。</p>
<p><b>Logistic回归的优缺点</b><br>优点：实现简单，易于理解和实现；计算代价不高，速度很快，存储资源低。<br>缺点：容易欠拟合，分类精度可能不高。</p>
<p><b>其他</b><br>1.Logistic回归的目的是寻找一个非线性函数Sigmoid的最佳拟合参数，求解过程可以由最优化算法完成。<br><br>2.改进的一些最优化算法，比如sag。它可以在新数据到来时就完成参数更新，而不需要重新读取整个数据集来进行批量处理。<br><br>机器学习的一个重要问题就是如何处理缺失数据。这个问题没有标准答案，取决于实际应用中的需求。现有一些解决方案，每种方案都各有优缺点。<br><br>3.我们需要根据数据的情况，这是Sklearn的参数，以期达到更好的分类效果。</p>
<p><a href="https://cuijiahua.com/blog/2017/11/ml_6_logistic_1.html">参考资料1</a><br><a href="https://cuijiahua.com/blog/2017/11/ml_7_logistic_2.html">参考资料2</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>Logistic Regression</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>逻辑回归</tag>
      </tags>
  </entry>
  <entry>
    <title>参考文献 | Multimodal Emotion Recognition Method based on Facial expressions and EEG</title>
    <url>/2022/01/04/MultimodalEmotionRecognition/</url>
    <content><![CDATA[<h1 id="Multimodal-Emotion-Recognition-Method-based-on-Facial-expressions-and-EEG"><a href="#Multimodal-Emotion-Recognition-Method-based-on-Facial-expressions-and-EEG" class="headerlink" title="Multimodal Emotion Recognition Method based on Facial expressions and EEG"></a>Multimodal Emotion Recognition Method based on Facial expressions and EEG</h1><h2 id="Contributions"><a href="#Contributions" class="headerlink" title="Contributions"></a>Contributions</h2><p>To solve the <strong>multimodal emtoion recognition</strong> problem, the emotion recognition results<br>were calculated using the <strong>Monte Carlo method</strong> to combine the recognition results of<br><strong>facical expressions</strong> and <strong>EEG</strong> in the multimodal emotion recognition.</p>
<span id="more"></span>
<h2 id="Unimodal-experiment"><a href="#Unimodal-experiment" class="headerlink" title="Unimodal experiment"></a>Unimodal experiment</h2><ol>
<li>They trained a <strong>CNN</strong> model using the FER2013 public dataset as a facial expressions classifier.</li>
<li>A <strong>SVM</strong> was used to classify the EEG data.</li>
</ol>
<p><img src="/2022/01/04/MultimodalEmotionRecognition/unimodal.jpg"></p>
<h2 id="Multimodal-experiment"><a href="#Multimodal-experiment" class="headerlink" title="Multimodal experiment"></a>Multimodal experiment</h2><p>Combine the recognition results of facical expressions and EEG in the multimodal emotion recognition using the Monte Carlo method<br><img src="/2022/01/04/MultimodalEmotionRecognition/multimodal.jpg"></p>
<h2 id="Cite-this-paper"><a href="#Cite-this-paper" class="headerlink" title="Cite this paper"></a>Cite this paper</h2><p><a href="https://doi.org/10.1016/j.bspc.2021.103029">https://doi.org/10.1016/j.bspc.2021.103029</a></p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>脑电分类</category>
        <category>参考文献</category>
      </categories>
      <tags>
        <tag>脑电分类</tag>
        <tag>EEG</tag>
      </tags>
  </entry>
  <entry>
    <title>python | MapReduce</title>
    <url>/2021/11/07/MapReduce/</url>
    <content><![CDATA[<h1 id="map-and-reduce"><a href="#map-and-reduce" class="headerlink" title="map and reduce"></a>map and reduce</h1><p>1.map()<br>map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。</p>
<span id="more"></span>
<p><strong>例1：</strong></p>
<pre><code>ls = [1,2,3,4,5,6,7,8,9]
fx = lambda x:x**2
rst = map(fx, ls)
print(list(rst))
</code></pre>
<p><strong>例2：</strong>   </p>
<pre><code>int2str = lambda x : str(x)
rst = map(int2str, ls)
list(rst)
</code></pre>
<p>2.reduce()<br>reduce: 用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，依此类推，最后得到一个结果。<br><strong>例1：</strong></p>
<pre><code>from functools import reduce
# 从python3开始，reduce函数移动到了functools这个包，每次使用前要先import
mul_xy = lambda x, y: x*y
reduce(mul_xy, [1, 3, 5, 7, 9])
</code></pre>
<p><strong>例2：</strong>  </p>
<pre><code># 求n的阶乘
from functools import reduce
n = int(input(&quot;请输入一个数：&quot;))
jiecheng = lambda x, y: x * y
reduce(jiecheng, [i for i in range(1, n+1)])
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
        <category>map reduce</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>map</tag>
        <tag>reduce</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis | 三种查询方式</title>
    <url>/2022/04/02/MyBatis%E4%B8%89%E7%A7%8D%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="MyBatis三种查询方式"><a href="#MyBatis三种查询方式" class="headerlink" title="MyBatis三种查询方式"></a>MyBatis三种查询方式</h1><p>1.项目目录<br><img src="/2022/04/02/MyBatis%E4%B8%89%E7%A7%8D%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F/1.PNG"><br>2.EmpSelectMapper.java</p>
<pre><code>package com.atguigu.mapper;

import java.util.Map;

import org.apache.ibatis.annotations.MapKey;

import com.atguigu.bean.Emp;

public interface EmpSelectMapper &#123;
    //根据eid查询一个员工信息
    Emp getEmpByEid(String eid);
    
    //获取所有的员工数量
    Integer getCount();
    
    //以map集合获取一个员工信息
    Map&lt;String, Object&gt; getEmpMapByEid(String eid);
    
    //以map集合获取所有员工信息
    
    @MapKey(&quot;eid&quot;)//设置map的建，因为在查询时传出所有的员工信息，可以把员工信息作为值，但是必须设置键
    Map&lt;String, Object&gt; getAllEmpMap();
&#125;
</code></pre>
<p>3.EmpSelectMapper.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
 PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
 &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
 
&lt;mapper namespace=&quot;com.atguigu.mapper.EmpSelectMapper&quot;&gt;
    
    
    &lt;!-- //根据eid查询一个员工信息
    Emp getEmpByEid(String eid); --&gt;
    &lt;select id=&quot;getEmpByEid&quot; resultType=&quot;Emp&quot;&gt;
        select eid,ename,age,sex from emp where eid=#&#123;eid&#125;
    &lt;/select&gt;
    
    &lt;!-- //获取所有的员工数量
    Integer getCount(); --&gt;
    &lt;select id=&quot;getCount&quot; resultType=&quot;Integer&quot;&gt;
        select count(eid) from emp
    &lt;/select&gt;
    
    &lt;!-- //以map集合获取一个员工信息
    Map&lt;String, Object&gt; getEmpMapByEid(String eid); --&gt;
    &lt;select id=&quot;getEmpMapByEid&quot; resultType=&quot;java.util.HashMap&quot;&gt;
        select eid,ename,age,sex from emp where eid=#&#123;eid&#125;
    &lt;/select&gt;
    
    &lt;!-- //以map集合获取所有员工信息
    @MapKey(&quot;eid&quot;)//设置map的建，因为在查询时传出所有的员工信息，可以把员工信息作为值，但是必须设置键
    Map&lt;String, Object&gt; getAllEmpMap(); --&gt;
    &lt;select id=&quot;getAllEmpMap&quot; resultType=&quot;Emp&quot;&gt;
    select eid,ename,age,sex from emp
    &lt;/select&gt;
    
&lt;/mapper&gt;
</code></pre>
<p>4.TestSelect.java</p>
<pre><code>package com.atguigu.test;

import java.io.IOException;
import java.io.InputStream;
import java.util.Map;

import javax.annotation.Resource;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.Test;

import com.atguigu.bean.Emp;
import com.atguigu.mapper.EmpSelectMapper;

public class TestSelect &#123;
    @Test
    public void testSelect() throws IOException&#123;
        InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
        SqlSession sqlSession = sqlSessionFactory.openSession(true);
        EmpSelectMapper mapper = sqlSession.getMapper(EmpSelectMapper.class);
        //若查询出的数据有多条，则绝不能将接口中方法的返回值设置为Javabean
//        Emp emp = mapper.getEmpByEid(&quot;3&quot;);
//        System.out.println(emp);
        
        //获取员工总记录数
//        Integer i = mapper.getCount();
//        System.out.println(i);
        
        //以map获取单个emp
//        Map&lt;String, Object&gt; map = mapper.getEmpMapByEid(&quot;6&quot;);
//        System.out.println(map);
        
        //以map获取所有emp
        Map&lt;String, Object&gt; map = mapper.getAllEmpMap();
        System.out.println(map);
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>MyBatis</category>
        <category>MyBatis三种查询方式</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis | 增删改查</title>
    <url>/2022/04/02/MyBatis%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</url>
    <content><![CDATA[<h1 id="MyBatis-CRUD"><a href="#MyBatis-CRUD" class="headerlink" title="MyBatis CRUD"></a>MyBatis CRUD</h1><p>按照<a href="https://victory-liao.github.io/2022/04/01/MyBatis%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/">MyBatis搭建过程</a>进行项目搭建，<br>并在mybatis-config.xml中将按如下方式引入映射文件：</p>
<pre><code>&lt;!-- 引入映射文件 --&gt;
&lt;mappers&gt;
    &lt;!-- &lt;mapper resource=&quot;EmpMapper.xml&quot; /&gt;
    &lt;mapper resource=&quot;DeptMapper.xml&quot;&gt;&lt;/mapper&gt; --&gt;
    
    &lt;!-- 此种写法要求mapper接口和mapper映射文件在同一个包下 --&gt;
    &lt;package name=&quot;com.atguigu.mapper&quot;/&gt;
    
&lt;/mappers&gt;
</code></pre>
<h2 id="CRUD-案例"><a href="#CRUD-案例" class="headerlink" title="CRUD 案例"></a>CRUD 案例</h2><p>1.项目目录<br><img src="/2022/04/02/MyBatis%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/1.PNG"><br>2.Emp.java</p>
<pre><code>package com.atguigu.bean;

public class Emp &#123;
    private Integer eid;
    private String ename;
    private Integer age;
    private String sex;
    public Integer getEid() &#123;
        return eid;
    &#125;
    public void setEid(Integer eid) &#123;
        this.eid = eid;
    &#125;
    public String getEname() &#123;
        return ename;
    &#125;
    public void setEname(String ename) &#123;
        this.ename = ename;
    &#125;
    public Integer getAge() &#123;
        return age;
    &#125;
    public void setAge(Integer age) &#123;
        this.age = age;
    &#125;
    public String getSex() &#123;
        return sex;
    &#125;
    public void setSex(String sex) &#123;
        this.sex = sex;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Emp [eid=&quot; + eid + &quot;, ename=&quot; + ename + &quot;, age=&quot; + age + &quot;, sex=&quot; + sex + &quot;]&quot;;
    &#125;
    public Emp(Integer eid, String ename, Integer age, String sex) &#123;
        super();
        this.eid = eid;
        this.ename = ename;
        this.age = age;
        this.sex = sex;
    &#125;
    public Emp() &#123;
        super();
        // TODO Auto-generated constructor stub
    &#125;
    
    
    
&#125;
</code></pre>
<p>3.EmpMapper.java</p>
<pre><code>package com.atguigu.mapper;

import java.util.List;

import com.atguigu.bean.Emp;

public interface EmpMapper &#123;
    //根据eid查询员工信息
    Emp getEmpByEid(String eid);
    
    //获取所有的员工信息
    List&lt;Emp&gt; getAllEmp();
    
    //添加员工信息
    void addEmp(Emp emp);
    
    //修改员工信息
    void updateEmp(Emp emp);
    
    //删除员工信息
    Integer deleteEmp(String id);
&#125;
</code></pre>
<p>4.EmpMapper.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
 PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
 &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
 
&lt;mapper namespace=&quot;com.atguigu.mapper.EmpMapper&quot;&gt;
    &lt;!-- Emp getEmpByEid(String eid); --&gt;
    &lt;select id=&quot;getEmpByEid&quot; resultType=&quot;Emp&quot;&gt;
        select eid,ename,age,sex from emp where eid=#&#123;eid&#125;
    &lt;/select&gt;
    
    &lt;!-- List&lt;Emp&gt; getAllEmp(); --&gt;
    &lt;select id=&quot;getAllEmp&quot; resultType=&quot;Emp&quot;&gt;
        select eid,ename,age,sex from emp
    &lt;/select&gt;
    
    &lt;!-- void addEmp(Emp emp); --&gt;
    &lt;insert id=&quot;addEmp&quot;&gt;
        insert into emp values(null, #&#123;ename&#125;, #&#123;age&#125;, #&#123;sex&#125;)
    &lt;/insert&gt;
    
    &lt;!-- void updateEmp(Emp emp); --&gt;
    &lt;update id=&quot;updateEmp&quot; parameterType=&quot;Emp&quot;&gt;
        update emp set ename=#&#123;ename&#125;,age=#&#123;age&#125;,sex=#&#123;sex&#125; where eid=#&#123;eid&#125;
    &lt;/update&gt;
    
    &lt;!-- void deleteEmp(String id);  --&gt;
    &lt;delete id=&quot;deleteEmp&quot;&gt;
        delete from emp where eid=#&#123;eid&#125;
    &lt;/delete&gt;
&lt;/mapper&gt;
</code></pre>
<p>5.TestCRUD.java</p>
<pre><code>package com.atguigu.test;

import java.io.IOException;
import java.io.InputStream;
import java.util.List;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.Test;

import com.atguigu.bean.Emp;
import com.atguigu.mapper.EmpMapper;

public class TestCRUD &#123;
    @Test
    public void testCRUD() throws IOException&#123;
        InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
//        SqlSession sqlSession = sqlSessionFactory.openSession();//需要手动处理事务
        SqlSession sqlSession = sqlSessionFactory.openSession(true);//自动处理事务
        EmpMapper empMapper = sqlSession.getMapper(EmpMapper.class);
        //测试：根据eid获取员工信息
//        Emp emp = empMapper.getEmpByEid(&quot;3&quot;);
//        System.out.println(emp);
        
        //测试：获取所有的员工信息
//        List&lt;Emp&gt; list = empMapper.getAllEmp();
//        System.out.println(list);
        
        //测试：添加员工信息
//        empMapper.addEmp(new Emp(null,&quot;admin&quot;,23,&quot;女&quot;));
//        sqlSession.commit();//提交事务
        
        //测试：修改员工信息
        empMapper.updateEmp(new Emp(2, &quot;张二&quot;, 33, &quot;女&quot;));
        
        //测试：删除员工信息
//        Integer rowNum = empMapper.deleteEmp(&quot;5&quot;);
//        System.out.println(rowNum);//返回值类型为Integer:返回受影响的行数 Boolean:·
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>MyBatis</category>
        <category>CRUD</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>CRUD</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis | 获取参数值的两种方式</title>
    <url>/2022/04/02/MyBatis%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0%E5%80%BC%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="MyBatis获取参数值的两种方式"><a href="#MyBatis获取参数值的两种方式" class="headerlink" title="MyBatis获取参数值的两种方式"></a>MyBatis获取参数值的两种方式</h1><p>1.${}:insert into emp values(null,admin,23,男)<br>Statement:<br>    必须使用字符串拼接的方式操作SQL，一定要注意单引号问题<br>    不能防止SQL注入<br>2.#{}:insert into emp values(null,?,?,?)<br>PreparedStatement：<br>    可以使用通配符操作SQL，因为在为String赋值时可以自动加单引号，因此不需要注意单引号问题<br>    <strong>可以防止SQL注入</strong><br>使用建议：**建议使用#{}**，在特殊情况下，需要使用${}，例如模糊查询和批量删除</p>
<h2 id="不同的参数类型，-和-的不同取值方式："><a href="#不同的参数类型，-和-的不同取值方式：" class="headerlink" title="不同的参数类型，${}和#{}的不同取值方式："></a>不同的参数类型，${}和#{}的不同取值方式：</h2><p>1、当传输参数为单个String或基本数据类型和其包装类型<br>#{}：可以以任意的名字获取参数值<br>${}：只能以${value}或${_parameter}获取<br>2、当传输参数为JavaBean时<br>#{}和${}都可以通过属性名直接获取属性值，但是要注意${}的单引号问题<br>3、当传输多个参数时，mybatis会默认将这些参数放在map集合中<br>两种方式：<br>（1）键为0，1，2，3…N-1,以参数为值<br>（2）键为param1,param2,param3…paramN，以参数为值<br>#{}:#{0}、#{1}；#{param1}、#{param2}<br>${}:#{param1}、{param2}，但是要注意${}的单引号问题<br>4、当传输Map参数时<br>#{}和${}都可以通过键的名字直接获取值，但是要注意${}的单引号问题<br>5、命名参数<br>可以通过@Param(“key”)为map集合指定键的名字<br>Emp getEmpByEidAndEnameByParam(@Param(“eid”)String eid, @Param(“ename”)String ename);<br>6、当传输参数为List或Array,mybatis会将List或Array放在map中<br>List以list为键，Array以array为键</p>
<h2 id="Statement与PreparedStatement"><a href="#Statement与PreparedStatement" class="headerlink" title="Statement与PreparedStatement"></a>Statement与PreparedStatement</h2><pre><code>package com.atguigu.test;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;

import com.atguigu.bean.Emp;

public class TestJDBC &#123;
    public static void main(String[] args) throws Exception &#123;
        Class.forName(&quot;&quot;);
        Connection conn = DriverManager.getConnection(&quot;&quot;,&quot;&quot;,&quot;&quot;);
        //可以使用通配符赋值
        PreparedStatement ps = conn.prepareStatement(&quot;insert into emp values(null, ?, ?,?&quot;);
        ps.setString(1, &quot;root&quot;);
        ps.setString(2, &quot;23&quot;);
        ps.setString(3, &quot;男&quot;);
        ps.executeUpdate();
        
        Statement statement = conn.createStatement();
        Emp emp = new Emp(null, &quot;a&quot;, 1, &quot;b&quot;);
        //不可以使用通配符赋值
        statement.executeUpdate(&quot;insert into emp values(null, &#39;&quot;+emp.getEname()+&quot;&#39;, &quot;+emp.getAge()+&quot;, &#39;&quot;+emp.getSex()+&quot;&#39;)&quot;);
    &#125;
&#125;
</code></pre>
<span id="more"></span>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>1.项目目录<br><img src="/2022/04/02/MyBatis%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0%E5%80%BC%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/1.PNG"><br>2.ParamMapper.java</p>
<pre><code>package com.atguigu.mapper;

import java.util.List;
import java.util.Map;

import org.apache.ibatis.annotations.Param;

import com.atguigu.bean.Emp;

public interface ParamMapper &#123;
    //添加员工信息
    void insertEmp(Emp emp);
    
    //获取名字中包含以name开头且后面多一个任意字符的员工信息
    List&lt;Emp&gt; getAllEmp(String name);
        
    //删除名字中包含name的员工信息
    void deleteEmp(String name);
    
    //根据eid获取员工信息
    Emp getEmpByEid(String eid);
    
    //根据eid和ename获取员工信息
    Emp getEmpByEidAndEname(String eid, String ename);
    
    //根据map查询员工信息
    Emp getEmpByMap(Map&lt;String, Object&gt; map);
    
    //根据eid和ename获取员工信息
    Emp getEmpByEidAndEnameByParam(@Param(&quot;eid&quot;)String eid, @Param(&quot;ename&quot;)String ename);
&#125;
</code></pre>
<p>3.ParamMapper.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
 PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
 &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
 
&lt;mapper namespace=&quot;com.atguigu.mapper.ParamMapper&quot;&gt;
    &lt;!--
        useGeneratedKeys:可以使用自动生成的主键 
        keyProperty:将自动生成的主键赋值给传递过来的参数的哪一个属性
     --&gt;
    &lt;insert id=&quot;insertEmp&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;eid&quot;&gt;
        &lt;!-- insert into emp values(null, #&#123;ename&#125;, #&#123;age&#125;, #&#123;sex&#125;) --&gt;
        
        insert into emp values(null, &#39;$&#123;ename&#125;&#39;, $&#123;age&#125;, &#39;$&#123;sex&#125;&#39;)
    &lt;/insert&gt;
    
    &lt;select id=&quot;getAllEmp&quot; resultType=&quot;Emp&quot;&gt;
        &lt;!-- 模糊查询 --&gt;
        select eid,ename,age,sex from emp where ename like &#39;$&#123;value&#125;_&#39;
    &lt;/select&gt;
    
    &lt;delete id=&quot;deleteEmp&quot;&gt;
        &lt;!-- 批量删除 --&gt;
        delete from emp where ename like &#39;%$&#123;value&#125;%&#39;
    &lt;/delete&gt;
    
    &lt;!-- Emp getEmpByEid(String eid); --&gt;
    &lt;select id=&quot;getEmpByEid&quot; resultType=&quot;Emp&quot;&gt;
        &lt;!-- select eid,ename,age,sex from emp where eid=#&#123;eid&#125; --&gt;
        
        &lt;!-- 参数与接口中的参数不一致也可以 --&gt;
        &lt;!-- select eid,ename,age,sex from emp where eid=#&#123;eids&#125; --&gt;
        

        &lt;!-- 
            报错：
            org.apache.ibatis.reflection.ReflectionException: 
            There is no getter for property named &#39;eid&#39; in 
            &#39;class java.lang.String&#39; 
        --&gt;
        &lt;!-- select eid,ename,age,sex from emp where eid = $&#123;eid&#125; --&gt;
        
        &lt;!-- 成功 --&gt;
        &lt;!-- select eid,ename,age,sex from emp where eid = $&#123;value&#125; --&gt;
        
        select eid,ename,age,sex from emp where eid = $&#123;_parameter&#125;
    &lt;/select&gt;
    
    &lt;!-- Emp getEmpByEidAndEname(String eid, String ename); --&gt;
    &lt;select id=&quot;getEmpByEidAndEname&quot; resultType=&quot;Emp&quot;&gt;
        &lt;!-- select eid,ename,age,sex from emp where eid=#&#123;0&#125; and ename=#&#123;1&#125; --&gt;
        &lt;!-- select eid,ename,age,sex from emp where eid=#&#123;param1&#125; and ename=#&#123;param2&#125; --&gt;
        
        select eid,ename,age,sex from emp where eid=$&#123;param1&#125; and ename=&#39;$&#123;param2&#125;&#39;
        &lt;!-- select eid,ename,age,sex from emp where eid=$&#123;0&#125; and ename=$&#123;1&#125; --&gt;&lt;!-- 不可行 --&gt;
    &lt;/select&gt;
    
    &lt;!-- Emp getEmpByMap(Map&lt;String, Object&gt; map); --&gt;
    &lt;select id=&quot;getEmpByMap&quot; resultType=&quot;Emp&quot;&gt;
        select eid,ename,age,sex from emp where eid=$&#123;eid&#125; and ename=&#39;$&#123;ename&#125;&#39;
    &lt;/select&gt;
    
    &lt;!-- Emp getEmpByEidAndEnameByParam(@Param(&quot;eid&quot;)String eid, @Param(&quot;ename&quot;)String ename); --&gt;
    &lt;select id=&quot;getEmpByEidAndEnameByParam&quot; resultType=&quot;Emp&quot;&gt;
        select eid,ename,age,sex from emp where eid=#&#123;eid&#125; and ename=#&#123;ename&#125;
    &lt;/select&gt;

    
&lt;/mapper&gt;
</code></pre>
<p>4.TestParam.java</p>
<pre><code>package com.atguigu.test;

import java.io.IOException;

import java.io.InputStream;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.Test;

import com.atguigu.bean.Emp;
import com.atguigu.mapper.ParamMapper;


public class TestParam &#123;
    @Test
    public void testCRUD() throws IOException&#123;
        InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
//        SqlSession sqlSession = sqlSessionFactory.openSession();//需要手动处理事务
        SqlSession sqlSession = sqlSessionFactory.openSession(true);//自动处理事务
        ParamMapper mapper = sqlSession.getMapper(ParamMapper.class);
        
        //获取名字中包含admin的所有员工信息(模糊查询)
//        List&lt;Emp&gt; allEmp = mapper.getAllEmp(&quot;admin&quot;);
//        System.out.println(allEmp);
        
        //删除名字中包含admin的所有员工信息(批量删除)
//        mapper.deleteEmp(&quot;admin&quot;);
        
        
//        Emp emp = new Emp(null, &quot;admin&quot;, 23, &quot;男&quot;);
//        mapper.insertEmp(emp);
//        System.out.println(emp.getEid());
        
//        Emp emp = mapper.getEmpByEid(&quot;1&quot;);
//        System.out.println(emp);
        
//        Emp emp = mapper.getEmpByEidAndEname(&quot;1&quot;, &quot;张三&quot;);
//        System.out.println(emp);
        
//        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
//        map.put(&quot;eid&quot;, &quot;1&quot;);
//        map.put(&quot;ename&quot;, &quot;张三&quot;);
//        Emp emp = mapper.getEmpByMap(map);
//        System.out.println(emp);
        
        Emp emp = mapper.getEmpByEidAndEnameByParam(&quot;1&quot;, &quot;张三&quot;);
        System.out.println(emp);
    &#125;
&#125; 
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>MyBatis</category>
        <category>MyBatis获取参数值的两种方式</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis | MyBatis搭建过程</title>
    <url>/2022/04/01/MyBatis%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="MyBatis搭建过程"><a href="#MyBatis搭建过程" class="headerlink" title="MyBatis搭建过程"></a>MyBatis搭建过程</h1><p>1.导入MyBatis框架的jar包、Mysql驱动包、log4j的jar包</p>
<pre><code>myBatis-3.4.1.jar
mysql-connector-java-5.1.37-bin.jar
log4j.jar
</code></pre>
<p>2.创建MyBatis的核心（全局）配置文件mybatis-config.xml并配置（如何连接数据库）<br>3.创建映射文件XxxMapper.xml并配置（如何操作数据库）<br>4.创建mapper接口，实现两个绑定:<br>4.1接口全限定名要和映射文件的namespace保持一致<br>4.2接口中方法名和SQL语句的id保持一致<br>5.获取MyBatis操作数据库的会话对象SqlSession，通过getMapper()获取接口的动态代理实现类</p>
<pre><code>InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
SqlSession sqlSession = sqlSessionFactory.openSession();
UserMapper mapper = sqlSession.getMapper(UserMapper.class);
</code></pre>
<p>6、测试</p>
<span id="more"></span>
<h2 id="搭建过程案例"><a href="#搭建过程案例" class="headerlink" title="搭建过程案例"></a>搭建过程案例</h2><p>1.项目目录<br><img src="/2022/04/01/MyBatis%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/1.PNG"></p>
<p><strong>user表</strong><br><img src="/2022/04/01/MyBatis%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/2.PNG"></p>
<p><strong>log4j.xml</strong></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE log4j:configuration SYSTEM &quot;log4j.dtd&quot;&gt;
 
&lt;log4j:configuration xmlns:log4j=&quot;http://jakarta.apache.org/log4j/&quot;&gt;
 
 &lt;appender name=&quot;STDOUT&quot; class=&quot;org.apache.log4j.ConsoleAppender&quot;&gt;
   &lt;param name=&quot;Encoding&quot; value=&quot;UTF-8&quot; /&gt;
   &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt;
    &lt;param name=&quot;ConversionPattern&quot; value=&quot;%-5p %d&#123;MM-dd HH:mm:ss,SSS&#125; %m  (%F:%L) \n&quot; /&gt;
   &lt;/layout&gt;
 &lt;/appender&gt;
 &lt;logger name=&quot;java.sql&quot;&gt;
   &lt;level value=&quot;debug&quot; /&gt;
 &lt;/logger&gt;
 &lt;logger name=&quot;org.apache.ibatis&quot;&gt;
   &lt;level value=&quot;info&quot; /&gt;
 &lt;/logger&gt;
 &lt;root&gt;
   &lt;level value=&quot;debug&quot; /&gt;
   &lt;appender-ref ref=&quot;STDOUT&quot; /&gt;
 &lt;/root&gt;
&lt;/log4j:configuration&gt;
</code></pre>
<p>2.导入上图中所示的jar包<br>3.jdbc.properties</p>
<pre><code>jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/ssm
jdbc.username=root
jdbc.password=root
</code></pre>
<p>4.mybatis-config.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
 PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
 &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;!-- &lt;properties&gt;
        &lt;property name=&quot;jdbc.driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
    &lt;/properties&gt; --&gt;
    
    &lt;!-- 
        &lt;properties&gt;:设置或引入资源文件
        resource:在类路径下访问资源文件
        url:在网络路径或磁盘路径下访问资源文件
     --&gt;
    &lt;properties resource=&quot;jdbc.properties&quot;&gt;&lt;/properties&gt;
    
    &lt;settings&gt;
        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;&gt;&lt;/setting&gt;
    &lt;/settings&gt;
    
    &lt;typeAliases&gt;
        &lt;!-- 
            为类型设置类型别名
            type:Java类型，若只设置type，默认的别名就是类型，且不区分大小写
         --&gt;
         &lt;!-- &lt;typeAlias type=&quot;com.atguigu.bean.User&quot; alias=&quot;User&quot;/&gt; --&gt;
         
         &lt;package name=&quot;com.atguigu.bean&quot;/&gt;
    &lt;/typeAliases&gt;

    &lt;!--
        &lt;environments&gt;:设置连接数据库的环境
        default:设置默认使用的数据库环境
     --&gt;
    &lt;environments default=&quot;development&quot;&gt;
        &lt;!-- 
            &lt;environment&gt;:设置某个具体的数据库环境
            id:数据库环境的唯一标识
         --&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;!--
                type=&quot;JDBC|MANAGED&quot; 
             --&gt;
            &lt;transactionManager type=&quot;JDBC&quot; /&gt;
            &lt;!--
                type=&quot;POOLED|UNPOOLED|JNDI&quot; 
             --&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt;
                &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;
                &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt;
                &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    
    &lt;!-- 引入映射文件 --&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;UserMapper.xml&quot; /&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<p>5.User.java</p>
<pre><code>package com.atguigu.bean;

public class User &#123;
    private Integer uid;
    private String userName;
    private String password;
    private Integer age;
    private String sex;
    public Integer getUid() &#123;
        return uid;
    &#125;
    public void setUid(Integer uid) &#123;
        this.uid = uid;
    &#125;
    public String getUserName() &#123;
        return userName;
    &#125;
    public void setUserName(String userName) &#123;
        this.userName = userName;
    &#125;
    public String getPassword() &#123;
        return password;
    &#125;
    public void setPassword(String password) &#123;
        this.password = password;
    &#125;
    public Integer getAge() &#123;
        return age;
    &#125;
    public void setAge(Integer age) &#123;
        this.age = age;
    &#125;
    public String getSex() &#123;
        return sex;
    &#125;
    public void setSex(String sex) &#123;
        this.sex = sex;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;User [uid=&quot; + uid + &quot;, userName=&quot; + userName + &quot;, password=&quot; + password + &quot;, age=&quot; + age + &quot;, sex=&quot;
                + sex + &quot;]&quot;;
    &#125;
    
&#125;
</code></pre>
<p>6.UserMapper.xml(举例：操作数据库中的user表)</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
 PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
 &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
 
&lt;mapper namespace=&quot;com.atguigu.mapper.UserMapper&quot;&gt;
    &lt;!-- 
        &lt;select&gt;:定义查询语句 
        id:设置SQL语句的唯一标识
        resultType:结果类型，即实体类的全限定名
    --&gt;
    &lt;select id=&quot;getUserByUid&quot; resultType=&quot;User&quot;&gt;
        &lt;!-- 
        当数据库表中的字段与类中的属性名不一样时，可以在查询时指定别名
        select uid,user_name userName,password,age,sex from user where uid = #&#123;id&#125; 
        --&gt;
        
        &lt;!--
         当数据库表中的字段与类中的属性名不一样时，如果不指定别名，需要在核心配置文件mybatis-config.xml中做以下配置：
         &lt;settings&gt;
            &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;&gt;&lt;/setting&gt;
         &lt;/settings&gt;
         
         注：此配置通常不使用，即在开发时将数据库的字段名与类的属性名保持一致
         --&gt;
        select uid,user_name,password,age,sex from user where uid = #&#123;id&#125;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p>7.UserMapper.java(mapper接口)</p>
<pre><code>package com.atguigu.mapper;

import com.atguigu.bean.User;

public interface UserMapper &#123;
    User getUserByUid(String uid);
&#125;
</code></pre>
<p>8.TestMybatis.java(测试类)</p>
<pre><code>package com.atguigu.mapper;

import java.io.IOException;
import java.io.InputStream;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.Test;

import com.atguigu.bean.User;

public class TestMybatis &#123;

    @Test
    public void test() throws IOException&#123;
        InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
        SqlSession sqlSession = sqlSessionFactory.openSession();
        //getMapper():会通过动态代理动态生成UserMapper的代理实现类
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);
        //System.out.println(mapper.getClass().getName());
        User user = mapper.getUserByUid(&quot;1&quot;);
        System.out.println(user);  
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>MyBatis</category>
        <category>MyBatis搭建过程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL | 内连接和外连接的区别</title>
    <url>/2022/01/19/MySQL%E5%86%85%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%A4%96%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="内连接和外连接的区别"><a href="#内连接和外连接的区别" class="headerlink" title="内连接和外连接的区别"></a>内连接和外连接的区别</h1><p><strong>区别：</strong><br>内连接（inner join）：取出两张表中匹配到的数据，匹配不到的不保留<br>外连接（outer join）：取出连接表中匹配到的数据，匹配不到的也会保留，其值为NULL</p>
<p><a href="https://blog.csdn.net/johnhan9/article/details/88686288">参考资料</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>内连接和外连接的区别</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>内连接</tag>
        <tag>外连接</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL | MySQL常见的表操作语句</title>
    <url>/2021/10/14/MySQL%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A1%A8%E6%93%8D%E4%BD%9C%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h1 id="MySQL常见的表操作语句"><a href="#MySQL常见的表操作语句" class="headerlink" title="MySQL常见的表操作语句"></a>MySQL常见的表操作语句</h1><p>1.表的创建</p>
<pre><code>create table table_name(
id int auto_increment primary key not null,
name varchar(11) not null
);
</code></pre>
<p>2.增加记录</p>
<pre><code>insert into table_name values()
insert into table_name values(),(),()
insert into table_name() values()
insert into table_name() values(),(),()
</code></pre>
<p>3.修改记录</p>
<pre><code>update table_name set attr=val where...
</code></pre>
<p>4.删除记录</p>
<pre><code>delete from table_name where...
</code></pre>
<p>5.表查询</p>
<pre><code>条件：select * from table_name where...
聚合：select count(*)|min()|max()|avg() from table_name
分组：select gender,count(*) from table_name group by gender having....
排序：select * from table_name order by...
分页：select * from table_name limit start,count
</code></pre>
<p>连接查询：<a href="https://blog.csdn.net/zjt980452483/article/details/82945663">点击此处，查看更多关于连接查询！！！</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>GPU | NVIDIAGeForceGTX1650驱动安装</title>
    <url>/2021/10/09/NVIDIAGeForceGTX1650%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="NVIDIAGeForceGTX1650驱动安装"><a href="#NVIDIAGeForceGTX1650驱动安装" class="headerlink" title="NVIDIAGeForceGTX1650驱动安装"></a>NVIDIAGeForceGTX1650驱动安装</h1><p>当我们想使用GPU（可以用来加速）来跑深度学习代码前，需要进行显卡驱动安装，我的显卡是NVIDIA GeForce GTX 1650。</p>
<p><strong>需要安装：</strong><br>1.Cuda<br>2.CuDNN<br><strong>下载地址：</strong><br><a href="https://developer.nvidia.com/cuda-toolkit">Cuda</a><br><a href=" https://developer.nvidia.com/cudnn">CuDNN</a><br><strong>我的显卡使用的Cuda、CuDNN版本：</strong><br>1.Cuda-10.1<br>2.CuDNN-7.6<br>3.Tensorflow-gpu-1.15.0(可选，在这里我是想用来加速Tensorflow代码的训练)</p>
<p><strong>注意：深度学习框架、python、Cuda、CuDNN版本的对应以及Cuda与自己显卡的兼容性</strong><br><a href="https://blog.csdn.net/s_hikki/article/details/106107778">NVIDIA GeForce GTX 1650驱动安装</a><br><a href="https://tensorflow.google.cn/install/source_windows#configuration_options">版本对应参考资料</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>GPU</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>GPU</tag>
      </tags>
  </entry>
  <entry>
    <title>PIL | PIL.Image.crop()</title>
    <url>/2021/11/22/PILImageCrop/</url>
    <content><![CDATA[<h1 id="PIL-Image-crop"><a href="#PIL-Image-crop" class="headerlink" title="PIL.Image.crop()"></a>PIL.Image.crop()</h1><p>程序使用PIL.Image.crop()将一张图片切割成9张小图片。</p>
<span id="more"></span>
<p><strong>show you the code:</strong></p>
<pre><code># -*- coding: utf-8 -*-

from PIL import Image

filename = r&#39;path of picture you want to crop&#39;
img = Image.open(filename)
size = img.size
print(size)

# 准备将图片切割成9张小图片
weight = int(size[0] // 3)
height = int(size[1] // 3)
# 切割后的小图的宽度和高度
print(weight, height)

for j in range(3):
    for i in range(3):
        box = (weight * i, height * j, weight * (i + 1), height * (j + 1))
        region = img.crop(box)
        region.save(&#39;&#123;&#125;&#123;&#125;.png&#39;.format(j, i))
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>PIL</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>PIL</tag>
      </tags>
  </entry>
  <entry>
    <title>urllib.request | POST请求</title>
    <url>/2021/08/05/POST%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<h1 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h1><p>使用urllib.request模块可以在python中访问互联网资源，以下是发送POST请求的示例代码。</p>
<pre><code># coding=utf-8

import urllib.request

url = &#39;http://localhost:8080/NoteWebService/note.do&#39;

# 准备HTTP参数
params_dict = &#123;&#39;action&#39;: &#39;query&#39;, &#39;ID&#39;: &#39;10&#39;&#125;  # 准备将参数放到字典中
params_str = urllib.parse.urlencode(params_dict)  # 将字典参数转换为字符串，形式为action=query&amp;ID=10

# 字符串转换为字节序列对象
params_bytes = params_str.encode()  # 发送POST请求时的参数要以字节序列形式发送

req = urllib.request.Request(url, data=params_bytes)  # 发送POST请求
with urllib.request.urlopen(req) as response:
    data = response.read()
    json_data = data.decode()
    print(json_data)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>内置模块</category>
        <category>urllib</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>urllib</tag>
      </tags>
  </entry>
  <entry>
    <title>Anaconda | ProxyError</title>
    <url>/2021/07/08/ProxyError/</url>
    <content><![CDATA[<p>在使用Anaconda创建虚拟环境时出错： ProxyError: Conda cannot proceed due to an error in your proxy configuration</p>
<p><a href="https://blog.csdn.net/littlehaes/article/details/103518285">解决办法！！！</a></p>
]]></content>
      <categories>
        <category>Anaconda</category>
      </categories>
      <tags>
        <tag>Anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title>python | Python变量单前下划线与双前下划线的区别</title>
    <url>/2020/11/29/Python%E5%8F%98%E9%87%8F%E5%8D%95%E5%89%8D%E4%B8%8B%E5%88%92%E7%BA%BF%E4%B8%8E%E5%8F%8C%E5%89%8D%E4%B8%8B%E5%88%92%E7%BA%BF%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="Python变量单前下划线与双前下划线的区别"><a href="#Python变量单前下划线与双前下划线的区别" class="headerlink" title="Python变量单前下划线与双前下划线的区别"></a>Python变量单前下划线与双前下划线的区别</h1><h2 id="variable"><a href="#variable" class="headerlink" title="_variable"></a>_variable</h2><p>表面上为私有，实际在外部可以访问</p>
<h2 id="variable-1"><a href="#variable-1" class="headerlink" title="__variable"></a>__variable</h2><p>实际上的私有，只能在内部访问，不能在外部访问（报错）</p>
<h2 id="variable-2"><a href="#variable-2" class="headerlink" title="_ variable _"></a>_ <em>variable</em> _</h2><p>魔法方法（magic method）/ 特殊方法</p>
<h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><pre><code>class TestPrivacy(object):
    _name = &#39;hello&#39; 
    __name = &#39;world&#39;
    
print(TestPrivacy._name) # Output:&#39;hello&#39;
print(TestPrivacy.__name) # Output: AttributeError: type object &#39;TestPrivacy&#39; has no attribute &#39;__name&#39;
</code></pre>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python-docx | Python检查word文件中的特殊标记词是否与文件名中的一致</title>
    <url>/2021/10/29/Python%E6%A3%80%E6%9F%A5word%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E6%A0%87%E8%AE%B0%E8%AF%8D%E6%98%AF%E5%90%A6%E4%B8%8E%E6%96%87%E4%BB%B6%E5%90%8D%E4%B8%AD%E7%9A%84%E4%B8%80%E8%87%B4/</url>
    <content><![CDATA[<h1 id="Python检查word文件中的特殊标记词是否与文件名中的一致"><a href="#Python检查word文件中的特殊标记词是否与文件名中的一致" class="headerlink" title="Python检查word文件中的特殊标记词是否与文件名中的一致"></a>Python检查word文件中的特殊标记词是否与文件名中的一致</h1><p>公司的部分文件分为“内部”和“外部”。正常情况下，这个标识在文件名及文件首页左上角都有标注。然鹅，有时候操作一下，忘记改了，或者忘记标注了。就需要回头去一个一个地整理，非常麻烦。这种重复的，繁杂的操作，尽快冲Python来，人类还是应该多做做其它更有意思的事。</p>
<p>代码：</p>
<pre><code>import os
from win32com import client as wc  # 导入模块
import docx
from docx.shared import Pt  # 用于设定字体大小（磅值）
from docx.oxml.ns import qn  # 用于应用中文字体

# 将文件夹内的所有doc转存为docx文件
path = os.getcwd() + &quot;\\文件\\&quot;  # 文件夹绝对路径
files = []
for file in os.listdir(path):
    if file.endswith(&quot;.doc&quot;):  # 排除文件夹内的其他干扰文件，只获取&quot;.doc&quot;后缀的word文件
        files.append(path+file)

word = wc.Dispatch(&quot;Word.Application&quot;)  # 打开word应用程序
for file in files:
    doc = word.Document(file)  # 打开word文件
    doc.SaveAs(&quot;&#123;&#125;x&quot;.format(file), 12)  # 另存为后缀为&quot;.docx&quot;的文件，其中参数12指docx文件
    doc.Close()  # 关闭原来word文件
word.Quit()

for file in files:  # 删除doc文件
    os.remove(file)

# 获取所有docx文件路径
docx_files = []
for file in os.listdir(path):  # 排除文件夹内的其它干扰文件，只获取&quot;.doc&quot;后缀的word文件
    if file.endswith(&quot;.docx&quot;):
        docx_files.append(path+file)

counter = 0  # 计数器，用于记录有多少文件没被处理

for file in docx_files:
    file_head = file.split(&#39;.&#39;)[0].rstrip()  # 文件名头，类似这样的“C:\\Users\\文件\\测试”
    file_tail = file.split(&#39;\\&#39;)[-1]  # 文件名尾，类似这样“测试.docx”
    mark_words = [&quot;公开&quot;, &quot;内部&quot;]
    mark_fileName = file_head[-3:-1]  # 文件名中倒数第2,3个文字

    doc = docx.Document(file)
    mark_doc = doc.paragraphs[0].text  # 文件中首段文字
    # 比对标记词
    if mark_doc in mark_words:  # 判断文件中有无标记
        if mark_fileName in mark_words:  # 判断文件名中有无标记
            if mark_doc == mark_fileName:  # 如果二者标记相同
                counter += 1
                pass
            else:  # 二者标记不同
                os.rename(file, file.replace(mark_fileName, mark_doc))  # 重命名文件
                print(f&quot;【&#123;file_tail&#125;】文件名重命名标识为【&#123;mark_doc&#125;】&quot;)
        else:
            os.rename(file, f&quot;&#123;file_head&#125;（&#123;mark_doc&#125;）.docx&quot;)  # 文件名中无标记，则加标记
            print(f&quot;【&#123;file_tail&#125;】文件名增加标识为【&#123;mark_doc&#125;】&quot;)
    else:
        # 文中无标记，则在首段前插入一段，写入标记
        p = doc.paragraphs[0]
        pNew = p.insert_paragraph_before()
        run = pNew.add_run(mark_words[0])  # 写为“公开”
        # 字体设置
        run.font.size = Pt(16)
        run.font.name = &quot;黑体&quot;
        r = run._element.rPr.rFonts
        r.set(qn(&quot;w:eastAsia&quot;), &quot;黑体&quot;)

        doc.save(file)
        print(f&quot;【&#123;file_tail&#125;】内容增加标识为【&#123;mark_words[0]&#125;】&quot;)

        if mark_fileName in mark_words:  # 查看文件名中是否有标记
            if mark_fileName == mark_words[0]:  # 标记是否为“公开”
                pass
            else:  # 标记不是“公开”则替换
                os.rename(file, file.replace(mark_fileName, mark_words[0]))  # 重命名文件
                print(f&quot;【&#123;file_tail&#125;】文件名重命名标识为【&#123;mark_words[0]&#125;】&quot;)
        else:
            os.rename(file, f&quot;&#123;file_head&#125;（&#123;mark_words[0]&#125;）.docx&quot;)  # 文件名中无标记，则加标记
            print(f&quot;【&#123;file_tail&#125;】文件名增加标识为【&#123;mark_words[0]&#125;】&quot;)

print(f&quot;完成！共检查&#123;len(docx_files)&#125;个文件,处理了 &#123;len(docx_files) - counter&#125; 个文件。&quot;)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>python-docx</category>
      </categories>
      <tags>
        <tag>os</tag>
        <tag>win32com</tag>
        <tag>python-docx</tag>
      </tags>
  </entry>
  <entry>
    <title>requests | Python爬取博客的所有文章并存为带目录的word文档</title>
    <url>/2021/10/31/Python%E7%88%AC%E5%8F%96%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E7%AB%A0%E5%B9%B6%E5%AD%98%E4%B8%BA%E5%B8%A6%E7%9B%AE%E5%BD%95%E7%9A%84word%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h1 id="Python爬取博客的所有文章并存为带目录的word文档"><a href="#Python爬取博客的所有文章并存为带目录的word文档" class="headerlink" title="Python爬取博客的所有文章并存为带目录的word文档"></a>Python爬取博客的所有文章并存为带目录的word文档</h1><p>Python爬取博客的所有文章并存为带目录的word文档,结果非常美丽！从此阅读博客文章轻松多了！！！</p>
<span id="more"></span>
<p>实现代码：</p>
<pre><code>import requests
from bs4 import BeautifulSoup

url = f&#39;http://blog.sina.com.cn/s/articlelist_5119330124_0_1.html&#39;
wb_data = requests.get(url)

soup = BeautifulSoup(wb_data.content)

# 获取当页所有文章的标题和链接
# print(soup.select(&#39;.atc_title&#39;))

# 获取当页所有文章的发表时间
# print(soup.select(&#39;.atc_tm&#39;))

# print(soup.select(&#39;.atc_title&#39;)[0].select(&#39;a&#39;))
# [&lt;a href=&quot;http://blog.sina.com.cn/s/blog_13122c74c0102zdsy.html&quot; target=&quot;_blank&quot; title=&quot;&quot;&gt;投资难在慢成毁于速成&lt;/a&gt;]
# print(soup.select(&#39;.atc_title&#39;)[0].select(&#39;a&#39;)[0].get(&quot;href&quot;))
# http://blog.sina.com.cn/s/blog_13122c74c0102zdsy.html
# print(soup.select(&#39;.atc_title&#39;)[0].select(&#39;a&#39;)[0].text)

# print(soup.select(&#39;.atc_tm&#39;)[0].text)

# 获取所有博客文章的链接
import requests
from bs4 import BeautifulSoup

all_links = &#123;&#125;
for i in range(1, 6):
    url = f&#39;http://blog.sina.com.cn/s/articlelist_5119330124_0_&#123;i&#125;.html&#39;
    wb_data = requests.get(url)
    soup = BeautifulSoup(wb_data.content)
    links = soup.select(&#39;.atc_title&#39;)
    times = soup.select(&#39;.atc_tm&#39;)
    for i in range(len(links)):
        http_link = links[i].select(&#39;a&#39;)[0].get(&#39;href&#39;)
        title = links[i].text.strip()
        time = times[i].text
        all_links[title] = [http_link, time]

# print(len(all_links))

# 获取单篇文章中的文字
url = &#39;http://blog.sina.com.cn/s/blog_13122c74c0102zbt3.html&#39;
wb_data = requests.get(url)
soup = BeautifulSoup(wb_data.content)
article = soup.select(&quot;.articalContent.newfont_family&quot;)
# print(article)
# print(article[0].text)
# print(article[0].text.replace(&quot;\xa0&quot;, &quot;&quot;))

# 获取单篇文章中的图片链接
url = &#39;http://blog.sina.com.cn/s/blog_13122c74c0102zbud.html&#39;
wb_data = requests.get(url)
soup = BeautifulSoup(wb_data.content)
img_link = soup.select(&quot;.articalContent.newfont_family&quot;)[0].find_all(&quot;img&quot;)[0].get(&quot;real_src&quot;)


# 图片下载函数
def downloadImg(img_url, file_path):
    req = requests.get(url=img_url)
    with open(file_path, &#39;wb&#39;) as f:
        f.write(req.content)


downloadImg(r&#39;http://s8.sinaimg.cn/middle/005AsbCIzy7vEfdM1M599&#39;,
            r&#39;..\实例67_Python爬取博客的所有文章并存为带目录的word文档\1.jpg&#39;)

# 写入标题，内容到word文件
import docx
from docx.oxml.ns import qn  # 用于应用中文字体


def to_word(all_links):
    header = &#123;
        &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) &quot;
                      &quot;Chrome/49.0.2623.221 Safari/537.36 SE 2.X MetaSr 1.0&quot;&#125;
    doc = docx.Document()  # 新建word文档
    doc.styles[&#39;Normal&#39;].font.name = u&#39;宋体&#39;
    doc.styles[&#39;Normal&#39;]._element.rPr.rFonts.set(qn(&#39;w:eastAsia&#39;), u&#39;宋体&#39;)

    counter = 0  # 计数器，用于记录写入word的文章数
    for title in all_links.keys():
        doc.add_heading(title, 1)
        date = all_links[title][1][:10]  # 只取日期，不要时间
        doc.add_paragraph(date)
        wb_data = requests.get(all_links[title][0], headers=header)
        soup = BeautifulSoup(wb_data.content)
        article = soup.select(&quot;.articalContent.newfont_family&quot;)
        # 有些文章被加密，获取不到内容，此时article为空，所以加个if语句判断
        if article:
            text = article[0].text.replace(&quot;\xa0&quot;, &quot;&quot;)
            doc.add_paragraph(text)
            print(f&quot;写入文章 &#123;title&#125; 。&quot;)
            counter += 1
    print(f&quot;共写入 &#123;counter&#125; 篇文章。&quot;)
    doc.save(&quot;新浪微博文章.docx&quot;)


to_word(all_links)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>requests</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>requests</tag>
        <tag>BeautifulSoup</tag>
      </tags>
  </entry>
  <entry>
    <title>xlrd | Python汇总各单位Excel档领料记录并加总每日领用次数</title>
    <url>/2021/10/29/Python%E6%B1%87%E6%80%BB%E5%90%84%E5%8D%95%E4%BD%8DExcel%E6%A1%A3%E9%A2%86%E6%96%99%E8%AE%B0%E5%BD%95%E5%B9%B6%E5%8A%A0%E6%80%BB%E6%AF%8F%E6%97%A5%E9%A2%86%E7%94%A8%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h1 id="Python汇总各单位Excel档领料记录并加总每日领用次数"><a href="#Python汇总各单位Excel档领料记录并加总每日领用次数" class="headerlink" title="Python汇总各单位Excel档领料记录并加总每日领用次数"></a>Python汇总各单位Excel档领料记录并加总每日领用次数</h1><p><a href="https://www.cnblogs.com/insane-Mr-Li/p/9092619.html">xlrd详解</a><br>代码：</p>
<pre><code>import time
import xlrd
import datetime


# 读取xls文件中的数据
def Get_data(file):
    wb = xlrd.open_workbook(file)  # 读取工作簿
    ws = wb.sheets()[0]  # 选第一个工作表
    data = &#123;&#125;

    for row in range(7, ws.nrows - 2):
        dept = ws.cell(2, 16).value  # 部门
        dept_id = ws.cell(3, 16).value  # 部门编号
        dt = ws.cell(row, 0).value  # 时间
        if type(dt) is float:
            date_time = xlrd.xldate.xldate_as_datetime(dt, 0)
        else:
            date_time = datetime.datetime.strptime(dt, &#39;%Y-%m-%d %H:%M:%S&#39;)
        business = ws.cell(row, 2).value  # 业务类型
        model = ws.cell(row, 3).value  # 品种
        qty = ws.cell(row, 4).value  # 数量
        unit_price = ws.cell(row, 6).value  # 单价
        price = ws.cell(row, 8).value  # 总价
        reward = ws.cell(row, 9).value  # 额外值
        discount = ws.cell(row, 11).value  # 调整
        balance = ws.cell(row, 13).value  # 剩余
        location = str(ws.cell(row, 15).value).strip()  # 库位
        operator = ws.cell(row, 17).value  # 操作员
        date = date_time.date()  # 日期
        time = date_time.time()  # 时间
        info_list = [dept, dept_id, date_time, business, model, qty, unit_price, price, reward, discount,
                     balance, location, operator, date, time]
        data.setdefault(date, [])  # 以日期为键
        if info_list[3] != &quot;备注&quot;:  # 不要业务类型为“备注”的数据
            data[date].append(info_list)

    # 增加当日领取次数
    for key in data.keys():
        for i in data[key]:
            i.append(len(data[key]))

    return data


import os  # 用于获取目标文件所在路径

path = os.getcwd() + &quot;\\记录\\&quot;  # 文件夹绝对路径
files = []
for file in os.listdir(path):
    if file.endswith(&quot;.xls&quot;):  # 只获取&quot;.xls&quot;后缀的文件
        files.append(path + file)
# print(files)

# Get_data(files[0])


def Get_current_time():
    time_stamp = time.time()  # 当前时间的时间戳
    local_time = time.localtime(time_stamp)  #
    str_time = time.strftime(&#39;%Y-%m-%d %H.%M.%S&#39;, local_time)
    return str_time


# print(Get_current_time())

# 汇总数据到主文件
from openpyxl import Workbook
from openpyxl.styles import Border, Side, PatternFill, Font, GradientFill, Alignment  # 设置单元格格式

thin = Side(border_style=&quot;thin&quot;, color=&quot;000000&quot;)  # 定义边框粗细及颜色
title = [&#39;部门&#39;, &#39;部门编号&#39;, &#39;时间&#39;, &#39;业务类型&#39;, &#39;品种&#39;, &#39;数量&#39;, &#39;单价&#39;, &#39;金额&#39;, &#39;额外值&#39;,
         &#39;调整&#39;, &#39;剩余&#39;, &#39;库位&#39;, &#39;操作员&#39;, &#39;领取日期&#39;, &#39;领取时间&#39;, &#39;领取次数&#39;]

wb = Workbook()
ws = wb.active
ws.merge_cells(&quot;A1:P1&quot;)  # 合并首行单元格
ws.cell(1, 1).value = &quot;领料明细汇总表&quot;
ws.cell(1, 1).font = Font(name=u&#39;黑体&#39;, bold=True, size=18)
ws.row_dimensions[1].height = 22.2  # 设置首行行高
ws.cell(1, 1).alignment = Alignment(horizontal=&quot;center&quot;, vertical=&quot;center&quot;)  # 设置对齐
ws.append(title)  # 写入字段行

# 写入各部门领料的数据
for file in files:
    data = Get_data(file)
    for key in data.keys():
        for i in data[key]:
            ws.append(i)

# 设置字号，对齐，缩小字体填充，加边框
# Font(bold=True)可加粗字体
for row_number in range(2, ws.max_row + 1):
    for col_number in range(1, 17):
        c = ws.cell(row=row_number, column=col_number)
        c.font = Font(size=9)
        c.border = Border(top=thin, left=thin, right=thin, bottom=thin)
        c.alignment = Alignment(horizontal=&quot;left&quot;, vertical=&quot;center&quot;)

# 设置列宽
col_name = list(&quot;ABCDEFGHIJKLMNOP&quot;)
col_width = [8, 8, 16, 8, 16, 8, 8, 9.8, 8, 8, 8, 11, 8.3, 9, 8, 8]
for i in range(len(col_name)):
    ws.column_dimensions[col_name[i]].width = col_width[i]

# 分组隐藏列
ws.column_dimensions.group(&#39;I&#39;, &#39;K&#39;, hidden=True)
ws.column_dimensions.group(&#39;N&#39;, &#39;O&#39;, hidden=True)

wb.save(f&quot;领料明细汇总表&#123;Get_current_time()&#125;.xlsx&quot;)
</code></pre>
<p>记录：<br><a href="工程部领料明细.xls">工程部领料明细.xls</a><br><a href="生产部领料明细.xls">生产部领料明细.xls</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>xlrd</category>
      </categories>
      <tags>
        <tag>openpyxl</tag>
        <tag>xlrd</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb项目开发 | QueryRunner和数据库增删改查操作</title>
    <url>/2022/01/26/QueryRunner%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="QueryRunner和数据库增删改查操"><a href="#QueryRunner和数据库增删改查操" class="headerlink" title="QueryRunner和数据库增删改查操"></a>QueryRunner和数据库增删改查操</h1><p>基于<a href="https://victory-liao.github.io/2022/01/25/jdbc/">JavaWeb项目开发 | jdbc</a>中的配置编写以下代码实现数据库的增删改查（CRUD）。<br><strong>在test1数据库中建表dept</strong></p>
<pre><code>create table dept(
int id primary key auto_increment not null,
varchar(20) name
)
</code></pre>
<p><strong>Dept.java（JavaBean）</strong></p>
<pre><code>package com.oracle.bean;

public class Dept &#123;
    private int id;
    private String name;
    public Dept() &#123;
        super();
        // TODO Auto-generated constructor stub
    &#125;
    public Dept(int id, String name) &#123;
        super();
        this.id = id;
        this.name = name;
    &#125;
    public int getId() &#123;
        return id;
    &#125;
    public void setId(int id) &#123;
        this.id = id;
    &#125;
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    
    
&#125;
</code></pre>
<p><strong>新建一个Test类实现数据库增删改查操作</strong></p>
<pre><code>package com.oracle.test;

import java.sql.SQLException;
import java.util.List;

import org.apache.commons.dbutils.QueryRunner;
import org.apache.commons.dbutils.handlers.BeanHandler;
import org.apache.commons.dbutils.handlers.BeanListHandler;
import org.apache.commons.dbutils.handlers.ScalarHandler;

import com.oracle.bean.Dept;
import com.oracle.utils.DataSourceUtils;

public class Test &#123;
    
    public static void main(String[] args) throws SQLException &#123;
        //创建QueryRunner对象
        QueryRunner qr = new QueryRunner(DataSourceUtils.getDataSource());
        
        //增加数据
        //String sql = &quot;insert into dept(name) values(?)&quot;;
        //qr.update(sql, &quot;需求部&quot;);
        
        //修改数据
        //String sql = &quot;update dept set name=? where id=?&quot;;
        //qr.update(sql, &quot;需求组&quot;, 4);
        
        //删除数据
        //String sql = &quot;delete from dept where id=?&quot;;
        //qr.update(sql, 4);
        
        //查询数据
        //（1）查询结果为一行
        //String sql = &quot;select * from dept where id=?&quot;;
        //Dept d = qr.query(sql, new BeanHandler&lt;&gt;(Dept.class), 1);
        //System.out.println(d.getId());
        //System.out.println(d.getName());
        
        //（2）查询结果为多行
//        String sql = &quot;select * from dept&quot;;
//        List&lt;Dept&gt; list = qr.query(sql, new BeanListHandler&lt;&gt;(Dept.class));
//        for(Dept d:list) &#123;
//            System.out.println(d.getId());
//            System.out.println(d.getName());
//        &#125;
        
        //（2）查询结果为聚合函数
        String sql = &quot;select count(*) from dept&quot;;
        
        int i = ((Long) qr.query(sql, new ScalarHandler())).intValue();
        
        System.out.println(i);
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb项目开发</category>
        <category>QueryRunner和数据库增删改查操作</category>
      </categories>
  </entry>
  <entry>
    <title>SpringMVC | REST风格GetPostPutDelete请求</title>
    <url>/2022/03/09/REST%E9%A3%8E%E6%A0%BCGetPostPutDelete%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<h1 id="REST风格-GET-POST-PUT-DELETE请求"><a href="#REST风格-GET-POST-PUT-DELETE请求" class="headerlink" title="REST风格 GET/POST/PUT/DELETE请求"></a>REST风格 GET/POST/PUT/DELETE请求</h1><p>*<em>REST</em>：即 Representational State Transfer。（资源）表现层状态转化。是目前最流行的一种互联网软件架构。</p>
<p>浏览器 form 表单只支持 GET 与 POST 请求，而DELETE、PUT 等 method 并不<br>支持，Spring3.0 添加了一个过滤器(HiddenHttpMethodFilter)，可以<strong>将这些<br>请求转换为标准的 http 方法</strong>，使得支持 GET、POST、PUT 与 DELETE 请求。</p>
<p>HiddenHttpMethodFilter支持REST风格的过滤器：可以将POST请求转换为PUT或DELETE请求</p>
<p><img src="/2022/03/09/REST%E9%A3%8E%E6%A0%BCGetPostPutDelete%E8%AF%B7%E6%B1%82/2.PNG"></p>
<span id="more"></span>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>1.项目目录<br><img src="/2022/03/09/REST%E9%A3%8E%E6%A0%BCGetPostPutDelete%E8%AF%B7%E6%B1%82/1.PNG"><br>2.web.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&gt;
  &lt;display-name&gt;SpringMVC02&lt;/display-name&gt;
  &lt;welcome-file-list&gt;
    &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;
  &lt;/welcome-file-list&gt;
  
  &lt;!-- The front controller of this Spring Web application, responsible for handling all application requests --&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;

    &lt;!-- Map all requests to the DispatcherServlet for handling --&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    
    &lt;!-- 支持REST风格的过滤器：可以将POST请求转换为PUT或DELETE请求 --&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
    
&lt;/web-app&gt;
</code></pre>
<p>3.springMVC-servlet.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&gt;
    
    &lt;!-- 扫描组件 --&gt;
    &lt;context:component-scan base-package=&quot;com.atguigu.controller&quot;&gt;&lt;/context:component-scan&gt;
    
    &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/view/&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>4.rest.jsp</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;a href=&quot;testREST/1001&quot;&gt;测试GET请求&lt;/a&gt;
    &lt;br&gt;
    &lt;form action=&quot;testREST&quot; method=&quot;POST&quot;&gt;
        &lt;input type=&quot;submit&quot; value=&quot;测试POST&quot;/&gt;
    &lt;/form&gt;
    &lt;br&gt;
    &lt;form action=&quot;testREST&quot; method=&quot;POST&quot;&gt;
        &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot;/&gt;
        &lt;input type=&quot;submit&quot; value=&quot;测试PUT&quot;/&gt;
    &lt;/form&gt;
    &lt;br&gt;
    &lt;form action=&quot;testREST/1001&quot; method=&quot;POST&quot;&gt;
        &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;DELETE&quot;/&gt;
        &lt;input type=&quot;submit&quot; value=&quot;测试DELETE&quot;/&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>5.success.jsp</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;成功&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>6.RESTController.java</p>
<pre><code>package com.atguigu.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

@Controller
public class RESTController &#123;
    @RequestMapping(value=&quot;/testREST/&#123;id&#125;&quot;, method=RequestMethod.GET)
    public String getUserById(@PathVariable(&quot;id&quot;)Integer id)&#123;
        System.out.println(&quot;GET,id=&quot;+id);
        return &quot;success&quot;;
    &#125;
    
    @RequestMapping(value=&quot;/testREST&quot;,method=RequestMethod.POST)
    public String insertUser()&#123;
        System.out.println(&quot;POST&quot;);
        return &quot;success&quot;;
    &#125;
    
    @RequestMapping(value=&quot;/testREST&quot;,method=RequestMethod.PUT)
    public String updateUser()&#123;
        System.out.println(&quot;PUT&quot;);
        return &quot;success&quot;;
    &#125;
    
    @RequestMapping(value=&quot;/testREST/&#123;id&#125;&quot;,method=RequestMethod.DELETE)
    public String deleteUser(@PathVariable(&quot;id&quot;)Integer id)&#123;
        System.out.println(&quot;DELETE,id=&quot;+id);
        return &quot;success&quot;;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>SpringMVC</category>
        <category>REST风格 GET/POST/PUT/DELETE请求</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
        <tag>HiddenHttpMethodFilter</tag>
        <tag>REST</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis | 主从复制</title>
    <url>/2022/05/13/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><ol>
<li>主从复制<br>主机数据更新后根据配置和策略，自动同步到备机的master/slaver机制，master以写为主，slave以读为主<br><img src="/2022/05/13/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/1.PNG"></li>
<li>复制原理<br>（1）每次从机联通后，都会给主机发送sync指令<br>（2）主机立刻进行存盘操作并发送RDB文给从机<br>（3）从机收到RDB文件后，进行全盘加载<br>（4）之后每次主机的写操作，都会立刻发送给从机，从机执行相同的命令<br><img src="/2022/05/13/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/2.PNG"></li>
<li>哨兵模式<br>能够后台监控主机是否故障，如果故障了根据投票数自动将从机转换为主机<br><img src="/2022/05/13/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/3.PNG"></li>
<li>故障恢复<br>（1）如果发生故障，从下线的主服务的所有从服务里挑选一个从服务，将其转成主服务<br>选择条件：<br>1）选择优先级靠前的（优先级可以在redis.conf中设置slave-priority）<br>2）选择偏移量最大的(偏移量最大指获得原主服务数据最多的服务)<br>3）选择runid最小的从服务（每个Redis实例启动后都会随机生成一个40为的runid）</li>
<li>优点<br>（1）读写分离<br>（2）容灾快速恢复</li>
</ol>
]]></content>
      <categories>
        <category>Redis</category>
        <category>主从复制</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>主从复制</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis | 关闭服务报错</title>
    <url>/2022/05/15/Redis%E5%85%B3%E9%97%AD%E6%9C%8D%E5%8A%A1%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<h1 id="Redis关闭服务报错"><a href="#Redis关闭服务报错" class="headerlink" title="Redis关闭服务报错"></a>Redis关闭服务报错</h1><p>在linux中执行redis-cli shutdown命令来关闭redis服务时报错：</p>
<pre><code>(error) ERR Errors trying to SHUTDOWN. Check logs.
</code></pre>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>1)执行vim命令打开redis.conf文件</p>
<pre><code>vim redis.conf
</code></pre>
<p>2)在配置文件中找到logfile “”，并修改为 logfile “/opt/myRedis/redis_log.log”<br>3)修改日志文件redis_log.log的文件权限</p>
<pre><code>sudo chmod 777 /opt/myRedis/redis_log.log
</code></pre>
<p>4)强制关闭redis服务</p>
<pre><code>kill -9 当前redis服务的进程号
</code></pre>
<p>5)重启redis服务(案例将redis的配置文件做了备份，放在/opt/myRedis/目录下)</p>
<pre><code>redis-server redis.conf
</code></pre>
]]></content>
      <categories>
        <category>Redis</category>
        <category>关闭服务报错</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>关闭服务报错</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis | 持久化方式</title>
    <url>/2022/05/09/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="Redis持久化方式"><a href="#Redis持久化方式" class="headerlink" title="Redis持久化方式"></a>Redis持久化方式</h1><ol>
<li>两个不同形式得持久化方式<br>RDB(Redis DataBase)<br>AOF(Append Of File)</li>
<li>RDB</li>
<li>1 RDB<br>在指定的时间间隔内将内存中的数据集快照(Snapshot)写入磁盘,恢复时将快照文件直接读到内存中。</li>
<li>2 备份<br>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能；</li>
<li>3 适用<br>大规模数据的恢复且对于数据恢复的完整性不是非常敏感</li>
<li>4 优点<br>1）节省磁盘空间<br>2）恢复速度快</li>
<li>5 缺点<br>1）虽然Redis在fork时使用了写时拷贝技术,但是如果数据庞大时还是比较消耗性能。<br>2）在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。</li>
<li>AOF</li>
<li>1 AOF<br>以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)，只许追加文件但不可以改写文件，Redis启动之初会读取该文件重新构建数据，换言之，Redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</li>
<li>2 AOF同步频率设置：<br>1）始终同步<br>2）每秒同步<br>3）不主动进行同步</li>
<li>3 Rewrite:<br>AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制,当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof。</li>
</ol>
<p><strong>如何实现重写？</strong><br>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，遍历新进程的内存中数据，每条记录有一条的Set语句。重写aof文件的操作，并没有读取旧的aof文件，而是<strong>将整个内存中的数据库内容用命令的方式重写了一个新的aof文件</strong>，这点和快照有点类似。<br><strong>何时重写</strong><br>系统载入时或者上次重写完毕时，Redis会记录此时AOF大小，设为base_size,如果Redis的AOF当前大小&gt;= base_size +base_size*100% (默认)或当前大小&gt;=64mb(默认)的情况下，Redis会对AOF进行重写。<br>3.4 AOF的优点：<br>1）备份机制更稳健，丢失数据概率更低。<br>2）可读的日志文本，通过操作AOF文件，可以处理误操作。<br>3.5 AOF的缺点：<br>1）比起RDB占用更多的磁盘空间。<br>2）恢复备份速度要慢。<br>3）每次读写都同步的话，有一定的性能压力。<br>4）存在个别Bug，造成不能恢复。<br><strong>注意：</strong><br>1）AOF和RDB同时开启，系统默认取AOF的数据<br>2）推荐AOF和RDB都使用<br>3）如果对数据不敏感，可以选单独用RDB<br>4）不建议单独用 AOF，因为可能会出现Bug<br>5）如果只是做纯内存缓存，可以都不用</p>
]]></content>
      <categories>
        <category>Redis</category>
        <category>持久化方式</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>持久化方式</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis | 集群</title>
    <url>/2022/05/13/Redis%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h1 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h1><ol>
<li>问题<br>1）服务器内存容量不够，redis如何进行扩容？<br>2）大量并发写操作， redis如何分摊？</li>
<li>集群<br>Redis 集群实现了对Redis的水平扩容，即<strong>启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1/N</strong>。<br>注：Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</li>
<li>slots<br>一个 Redis 集群包含 16384 个插槽（hash slot）， 数据库中的每个键都属于这 16384 个插槽的其中一个， 集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。<br>集群中的每个节点负责处理一部分插槽。举个例子， 如果一个集群可以有主节点，其中：节点A负责处理0号至5500号插槽，节点B负责处理5501号至11000号插槽，节点C负责处理11001号至16383号插槽。</li>
<li>集群的优点<br>1）实现扩容<br>2）分摊压力<br>3）无中心配置相对简单</li>
<li>集群的缺点<br>1）多键操作是不被支持的（这些键有可能存在不同的服务器上，可以通过{}来定义组的概念，从而使key中{}内相同内容的键值对放到一个slot中去。）<br>2）多键的Redis事务是不被支持的。lua脚本不被支持。<br>3）由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大。</li>
</ol>
]]></content>
      <categories>
        <category>Redis</category>
        <category>集群</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis | 集群搭建</title>
    <url>/2022/05/20/Redis%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="Redis集群搭建"><a href="#Redis集群搭建" class="headerlink" title="Redis集群搭建"></a>Redis集群搭建</h1><p>1.下载Redis并将redis放到linux目录/opt下<br>2.在opt下创建myRedis文件夹,并备份redis.conf到此处<br>3.安装ruby环境<br>（1）yum install ruby<br>（2）yum install rubygems<br>4.创建6个实例（此处使用相同主机的不同端口来模拟多个节点）<br>通过include引入备份文件redis.conf（redis.conf中需要修改配置：protected-mode no   daemonize yes   appendonly no）的内容并修改每个节点不同的信息<br>(1)redis6379.conf</p>
<pre><code>include /opt/myRedis/redis.conf
pidfile &quot;/var/run/redis6379.pid&quot;
port 6379
dbfilename &quot;dump6379.rdb&quot;
cluster-enabled yes
cluster-config-file nodes-6379.conf
cluster-node-timeout 15000
</code></pre>
<p>(2)redis6380.conf</p>
<pre><code>include /opt/myRedis/redis.conf
pidfile &quot;/var/run/redis6380.pid&quot;
port 6380
dbfilename &quot;dump6380.rdb&quot;
cluster-enabled yes
cluster-config-file nodes-6380.conf
cluster-node-timeout 15000
</code></pre>
<p>(3)redis6381.conf</p>
<pre><code>include /opt/myRedis/redis.conf
pidfile &quot;/var/run/redis6381.pid&quot;
port 6381
dbfilename &quot;dump6381.rdb&quot;
cluster-enabled yes
cluster-config-file nodes-6381.conf
cluster-node-timeout 15000
</code></pre>
<p>(4)redis6389.conf</p>
<pre><code>include /opt/myRedis/redis.conf
pidfile &quot;/var/run/redis6389.pid&quot;
port 6389
dbfilename &quot;dump6389.rdb&quot;
cluster-enabled yes
cluster-config-file nodes-6389.conf
cluster-node-timeout 15000
</code></pre>
<p>(5)redis6390.conf</p>
<pre><code>include /opt/myRedis/redis.conf
pidfile &quot;/var/run/redis6390.pid&quot;
port 6390
dbfilename &quot;dump6390.rdb&quot;
cluster-enabled yes
cluster-config-file nodes-6390.conf
cluster-node-timeout 15000
</code></pre>
<p>(6)redis6391.conf</p>
<pre><code>include /opt/myRedis/redis.conf
pidfile &quot;/var/run/redis6391.pid&quot;
port 6391
dbfilename &quot;dump6391.rdb&quot;
cluster-enabled yes
cluster-config-file nodes-6391.conf
cluster-node-timeout 15000
</code></pre>
<p>5.启动所有redis实例，nodes-xxxx.conf文件都生成正常。<br><img src="/2022/05/20/Redis%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/1.PNG"><br>6.将六个实例组合到一个集群当中</p>
<pre><code>redis-cli --cluster create 192.168.1.108:6379 192.168.1.108:6380 192.168.1.108:6381 192.168.1.108:6389 192.168.1.108:6390 192.168.1.108:6391 --cluster-replicas 1
</code></pre>
<p>7.启动客户端并查看集群<br><img src="/2022/05/20/Redis%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/2.PNG"></p>
]]></content>
      <categories>
        <category>Redis</category>
        <category>集群搭建</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis | 面试题目</title>
    <url>/2022/05/22/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="Redis面试题目"><a href="#Redis面试题目" class="headerlink" title="Redis面试题目"></a>Redis面试题目</h1><p><a href="https://mp.weixin.qq.com/s/3ln9VAB_heYTI7yvxnp2bw">参考资料</a></p>
]]></content>
      <categories>
        <category>Redis</category>
        <category>面试题目</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC | RequestMapping注解的几个属性和作用位置</title>
    <url>/2022/03/08/RequestMapping%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%87%A0%E4%B8%AA%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BD%9C%E7%94%A8%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="RequestMapping注解的几个属性和作用位置"><a href="#RequestMapping注解的几个属性和作用位置" class="headerlink" title="RequestMapping注解的几个属性和作用位置"></a>RequestMapping注解的几个属性和作用位置</h1><p>1.项目目录<br><img src="/2022/03/08/RequestMapping%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%87%A0%E4%B8%AA%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BD%9C%E7%94%A8%E4%BD%8D%E7%BD%AE/1.PNG"></p>
<span id="more"></span>
<p>2.web.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&gt;
  &lt;display-name&gt;SpringMVC02&lt;/display-name&gt;
  &lt;welcome-file-list&gt;
    &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;
  &lt;/welcome-file-list&gt;
  
  &lt;!-- The front controller of this Spring Web application, responsible for handling all application requests --&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;

    &lt;!-- Map all requests to the DispatcherServlet for handling --&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<p>3.springMVC-servlet.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&gt;
    
    &lt;!-- 扫描组件 --&gt;
    &lt;context:component-scan base-package=&quot;com.atguigu.controller&quot;&gt;&lt;/context:component-scan&gt;
    
    &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/view/&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>4.index.jsp</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;a href=&quot;test&quot;&gt;测试springMVC&lt;/a&gt;
    
    &lt;br&gt;
    
    &lt;form action=&quot;test&quot; method=&quot;post&quot;&gt;
        &lt;input type=&quot;submit&quot; value=&quot;测试POST&quot;&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>5.success.jsp</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;成功&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>6.TestController.java</p>
<pre><code>package com.atguigu.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

@Controller
//@RequestMapping(&quot;/mvc&quot;)
public class TestController &#123;
    /**
     * @RequestMapping:设置请求映射，把请求和控制层中的方法设置映射关系
     * 当请求路径和@RequestMapping的value属性一致时，则该注解所标注的方法即为处理请求的方法
     * 
     * @RequestMapping可以加在类上，也可以加在方法上
     * 若类和方法上都加有，应该一层一层的访问，西安访问类，再访问类中的方法
     * 
     * method:用来设置请求方式，只有客户端发送请求的方式和method的值一致，才能处理请求
     * 请求方式：GET查询    POST添加    PUT修改    DELETE删除
     * params:用来设置客户端传到服务器的数据，支持表达式
     * username !username username=admin username!=admin
     * headers:用来设置请求头信息，所发送的请求的请求头信息一定要个headers属性中所设置的一致
     */
//    @RequestMapping(value=&quot;/test&quot;, method=RequestMethod.POST)
//    public String testPOST()&#123;
//        System.out.println(&quot;SUCCESS:POST&quot;);
//        return &quot;success&quot;;
//    &#125;
    
//    @RequestMapping(value=&quot;/test&quot;, method=RequestMethod.GET)
//    public String testGET()&#123;
//        System.out.println(&quot;SUCCESS:GET&quot;);
//        return &quot;success&quot;;
//    &#125;
    
//    @RequestMapping(value=&quot;/test&quot;, params=&#123;&quot;username&quot;, &quot;!age&quot;, &quot;sex!=1&quot;&#125;)
//    public String testParams()&#123;
//        System.out.println(&quot;SUCCESS&quot;);
//        return &quot;success&quot;;
//    &#125;
    
    @RequestMapping(value=&quot;/test&quot;, 
            headers=&#123;&quot;Accept-Encoding=gzip, deflate&quot;&#125;)
    public String testHeaders()&#123;
        System.out.println(&quot;SUCCESS&quot;);
        return &quot;success&quot;;
    &#125;
    
    /**
    * springMVC支持Ant方式的请求路径
    * 在Ant中，有3个匹配符
    * *:任意字符
    * ?:任意一个字符
    * **:任意多层目录
    */
    //访问路径举例：localhost:8080/SpringMVC02/abc/ant11/a/b/testAnt
    @RequestMapping(value=&quot;/*/ant??/**/testAnt&quot;)
    public String testAnt()&#123;
        System.out.println(&quot;SUCCESS:testAnt&quot;);
        return &quot;success&quot;;
    &#125;
    
    /**
     * 以前：localhost:8080/SpringMVC02/testREST?id=1001&amp;username=admin
     * 现在：localhost:8080/SpringMVC02/testREST/1001/admin
     */
    @RequestMapping(&quot;/testREST/&#123;id&#125;/&#123;username&#125;&quot;)//占位符方式的路径
    public String testREST(@PathVariable(&quot;id&quot;)Integer id, @PathVariable(&quot;username&quot;)String username)&#123;
        System.out.println(&quot;id:&quot;+id+&quot;,username=&quot;+username);
        return &quot;success&quot;;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>SpringMVC</category>
        <category>RequestMapping注解的几个属性和作用位置</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
        <tag>RequestMapping Ant风格路径</tag>
        <tag>PathVariable注解</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL | SQL语句实例大全</title>
    <url>/2022/01/20/SQL%E8%AF%AD%E5%8F%A5%E5%AE%9E%E4%BE%8B%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<h1 id="SQL语句实例大全"><a href="#SQL语句实例大全" class="headerlink" title="SQL语句实例大全"></a>SQL语句实例大全</h1><p><strong>SQL语句分类</strong></p>
<ol>
<li>DDL(Data Definition Language)数据定义语言<br>用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter等<br><a href="https://cloud.tencent.com/developer/article/1393524">DDL参考</a></li>
<li><strong>DML</strong>(Data Manipulation Language)数据操作语言<br>用来对数据库中表的数据进行增删改。关键字：insert, delete, update等 </li>
<li><strong>DQL</strong>(Data Query Language)数据查询语言<br>用来查询数据库中表的记录(数据)。关键字：select, where等 </li>
<li>DCL(Data Control Language)数据控制语言(了解)<br>用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE等<br>注：重点关注DML、DQL；实际开发中我们可以使用数据库软件来创建数据库、表、列等（DDL了解即可）；DCL为DBA关注的事情。<span id="more"></span></li>
</ol>
<p><strong>DML Test</strong></p>
<pre><code>CREATE TABLE student1(
id INT,
NAME VARCHAR(20),
birthday DATE
)

INSERT INTO student1 (id,NAME,birthday) VALUES(1,&#39;zhangsan&#39;, &#39;2022-1-20&#39;)

INSERT INTO student1 VALUES(2,&#39;lisi&#39;,&#39;2022-1-2&#39;)

INSERT INTO student1 VALUES(3,&#39;wangmazi&#39;,&#39;2022-1-3&#39;),(4,&#39;zhaoliu&#39;,&#39;2012-1-2&#39;)

INSERT INTO student1 (id,NAME) VALUES(5, &#39;sunqi&#39;)

UPDATE student1 SET NAME=&#39;lisi&#39;

UPDATE student1 SET birthday=&#39;1998-1-1&#39; WHERE id=5

UPDATE student1 SET id=1,NAME=&#39;zhangsan&#39; WHERE id=1

DELETE FROM student1

DELETE FROM student1 WHERE id=5

SELECT * FROM student1

SELECT id,NAME,birthday FROM student1

SELECT NAME FROM student1
</code></pre>
<p><strong>DQL Test</strong></p>
<pre><code>CREATE TABLE student3 ( 
id INT, NAME VARCHAR(20),
age INT, sex VARCHAR(5), 
address VARCHAR(100), 
math INT, 
english INT 
)

INSERT INTO student3(id,NAME,age,sex,address,math,english) 
VALUES (1,&#39;马云&#39;,55,&#39;男&#39;,&#39;杭 州&#39;,66,78),
(2,&#39;马化腾&#39;,45,&#39;女&#39;,&#39;深圳&#39;,98,87),
(3,&#39;马景涛&#39;,55,&#39;男&#39;,&#39;香港&#39;,56,77),
(4,&#39;柳 岩&#39;,20,&#39;女&#39;,&#39;湖南&#39;,76,65),
(5,&#39;柳青&#39;,20,&#39;男&#39;,&#39;湖南&#39;,86,NULL),
(6,&#39;刘德华&#39;,57,&#39;男&#39;,&#39;香 港&#39;,99,99),
(7,&#39;马德&#39;,22,&#39;女&#39;,&#39;香港&#39;,99,99),
(8,&#39;德玛西亚&#39;,18,&#39;男&#39;,&#39;南京&#39;,56,65)

SELECT * FROM student3 WHERE math&gt;80

SELECT * FROM student3 WHERE english&lt;=80

SELECT * FROM student3 WHERE age=20

SELECT * FROM student3 WHERE age!=20
SELECT * FROM student3 WHERE age&lt;&gt;20

SELECT * FROM student3 WHERE age&gt;35 AND sex=&#39;男&#39;
SELECT * FROM student3 WHERE age&gt;35 &amp;&amp; sex=&#39;男&#39;

SELECT * FROM student3 WHERE age&gt;35 OR sex=&#39;男&#39;
SELECT * FROM student3 WHERE age&gt;35 || sex=&#39;男&#39;

SELECT * FROM student3 WHERE id=1 OR id=3 OR id=5

SELECT * FROM student3 WHERE NAME LIKE &#39;马%&#39;

SELECT * FROM student3 WHERE NAME LIKE &#39;%德%&#39;

SELECT * FROM student3 WHERE NAME LIKE &#39;马__&#39;

SELECT COUNT(*) FROM student3

SELECT COUNT(*) FROM student3 WHERE age&gt;40

SELECT SUM(math) FROM student3 

SELECT AVG(math) FROM student3

SELECT MAX(math) FROM student3

SELECT MIN(math) FROM student3

INSERT INTO student3(id,NAME,age,sex,address,math,english) 
VALUES (9,&#39;唐僧&#39;,25,&#39;男&#39;,&#39;长安&#39;,87,78), 
(10,&#39;孙悟空&#39;,18,&#39;男&#39;,&#39;花果山&#39;,100,66), 
(11,&#39;猪八戒&#39;,22,&#39;男&#39;,&#39;高老庄&#39;,58,78), 
(12,&#39;沙僧&#39;,50,&#39;男&#39;,&#39;流沙河&#39;,77,88), 
(13,&#39;白骨精&#39;,22,&#39;女&#39;,&#39;白虎岭&#39;,66,66), 
(14,&#39;蜘蛛精&#39;,23,&#39;女&#39;,&#39;盘丝洞&#39;,88,88)

SELECT * FROM student3 LIMIT 2,6

SELECT * FROM student3 LIMIT 0,5

SELECT * FROM student3 LIMIT 5
</code></pre>
<p><strong>主键</strong></p>
<pre><code>CREATE TABLE st5(
id INT PRIMARY KEY,
NAME VARCHAR(20),
age INT
)

INSERT INTO st5 (id, NAME) VALUES (1, &#39;唐伯虎&#39;),(2, &#39;周文宾&#39;),(3, &#39;祝枝山&#39;),(4, &#39;文征明&#39;)
INSERT INTO st5 (id, NAME) VALUES (1, &#39;文征明2&#39;)
INSERT INTO st5 (id, NAME) VALUES (NULL, &#39;文征明3&#39;)

ALTER TABLE st5 DROP PRIMARY KEY
</code></pre>
<p><strong>主键自增</strong></p>
<pre><code>CREATE TABLE st6(
id INT PRIMARY KEY AUTO_INCREMENT,
NAME VARCHAR(20),
age INT
)

INSERT INTO st6(NAME,age) VALUES(&#39;唐僧&#39;,22)
INSERT INTO st6(NAME,age) VALUES(&#39;孙悟空&#39;,26)
INSERT INTO st6 (NAME, age) VALUES (&#39;猪八戒&#39;, 25)
INSERT INTO st6 (NAME, age) VALUES (&#39;沙僧&#39;, 20)
</code></pre>
<p><strong>外键和级联</strong></p>
<pre><code>CREATE TABLE department ( 
id INT PRIMARY KEY AUTO_INCREMENT, 
dep_name VARCHAR(20), 
dep_location VARCHAR(20) 
)

CREATE TABLE employee(
id INT PRIMARY KEY AUTO_INCREMENT,
NAME VARCHAR(30),
age INT,
dep_id INT,
CONSTRAINT employee_depid_ref_department_id_fk FOREIGN KEY(dep_id) REFERENCES
 department(id) ON UPDATE CASCADE ON DELETE CASCADE
 )

INSERT INTO department (dep_name, dep_location) 
VALUES (&#39;研发部&#39;, &#39;广州&#39;), (&#39;销售部&#39;, &#39;深圳&#39;)

INSERT INTO employee (NAME, age, dep_id) 
VALUES (&#39;张三&#39;, 20, 1), (&#39;李四&#39;, 21, 1), 
(&#39;王五&#39;, 20, 1), (&#39;老王&#39;, 20, 2), 
(&#39;大王&#39;, 22, 2), (&#39;小王&#39;, 18, 2)

INSERT INTO employee (NAME, age, dep_id) VALUES (&#39;二王&#39;, 20, 5)
INSERT INTO employee (NAME, age, dep_id) VALUES (&#39;二王&#39;, 20, 1)

INSERT INTO employee (NAME, age, dep_id) VALUES (&#39;张三&#39;, 20, 1),
(&#39;李四&#39;, 21, 1),(&#39;王五&#39;, 20, 1),(&#39;老王&#39;, 20, 2),(&#39;大王&#39;, 22, 2),(&#39;小王&#39;, 18, 2)

UPDATE department SET id=10 WHERE id=1

DELETE FROM department WHERE id=2
</code></pre>
<p><strong>多表查询：内外连接</strong></p>
<pre><code>CREATE TABLE dept(
id INT PRIMARY KEY AUTO_INCREMENT NOT NULL,
NAME VARCHAR(20)
)

CREATE TABLE emp(
id INT PRIMARY KEY AUTO_INCREMENT NOT NULL,
NAME VARCHAR(20),
gender CHAR(1),
salary DOUBLE,
join_date DATE,
dept_id INT,
CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept(id) ON DELETE CASCADE ON UPDATE CASCADE
)

SELECT * FROM emp, dept WHERE emp.`dept_id`=dept.`id`

SELECT * FROM emp INNER JOIN dept ON emp.`dept_id`=dept.`id`

SELECT * FROM emp LEFT OUTER JOIN dept ON emp.`dept_id`=dept.`id` AND emp.`gender`=&#39;男&#39;

SELECT * FROM dept RIGHT OUTER JOIN emp ON emp.`dept_id`=dept.`id` AND emp.`gender`=&#39;男&#39;
</code></pre>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>SQL语句实例大全</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>SQL语句</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM | 修改</title>
    <url>/2022/04/18/SSM-%E4%BF%AE%E6%94%B9/</url>
    <content><![CDATA[<h1 id="修改员工信息"><a href="#修改员工信息" class="headerlink" title="修改员工信息"></a>修改员工信息</h1><p>1.list.jsp</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
&lt;title&gt;展示员工信息&lt;/title&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;$&#123;pageContext.servletContext.contextPath&#125;/css/index_work.css&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;th&gt;EID&lt;/th&gt;
            &lt;th&gt;ENAME&lt;/th&gt;
            &lt;th&gt;AGE&lt;/th&gt;
            &lt;th&gt;SEX&lt;/th&gt;
            &lt;th&gt;DEPARTMENTNAME&lt;/th&gt;
            &lt;th&gt;OPTIONS&lt;/th&gt;
        &lt;/tr&gt;
        &lt;c:forEach items=&quot;$&#123;empList&#125;&quot; var=&quot;emp&quot;&gt;
            &lt;tr&gt;
                &lt;td&gt;$&#123;emp.eid&#125;&lt;/td&gt;
                &lt;td&gt;$&#123;emp.ename&#125;&lt;/td&gt;
                &lt;td&gt;$&#123;emp.age&#125;&lt;/td&gt;
                &lt;td&gt;$&#123;emp.sex == 0 ? &#39;女&#39;:&#39;男&#39;&#125;&lt;/td&gt;
                &lt;td&gt;$&#123;emp.dept.dname&#125;&lt;/td&gt;
                &lt;td&gt;
                    &lt;a href=&quot;emp&quot;&gt;删除&lt;/a&gt;
                    &lt;a href=&quot;$&#123;pageContext.servletContext.contextPath&#125;/emp/$&#123;emp.eid&#125;&quot;&gt;修改&lt;/a&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
        &lt;/c:forEach&gt;
        &lt;tr&gt;
            &lt;td colspan=&quot;10&quot;&gt;
                $&#123;page&#125;
            &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>2.update.jsp</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%@taglib uri=&quot;http://www.springframework.org/tags/form&quot; prefix=&quot;form&quot;%&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
&lt;title&gt;修改员工信息&lt;/title&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;$&#123;pageContext.servletContext.contextPath&#125;/css/index_work.css&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form:form action=&quot;$&#123;pageContext.servletContext.contextPath&#125;/emp&quot; method=&quot;post&quot; modelAttribute=&quot;emp&quot;&gt;
        &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot;/&gt;
        &lt;form:hidden path=&quot;eid&quot;/&gt;
        &lt;table&gt;
            &lt;tr&gt;
                &lt;th colspan=&quot;2&quot;&gt;UPDATE EMP INFO&lt;/th&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;ENAME&lt;/td&gt;
                &lt;td&gt;
                    &lt;form:input path=&quot;ename&quot;/&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;AGE&lt;/td&gt;
                &lt;td&gt;
                    &lt;form:input path=&quot;age&quot;/&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;sex&lt;/td&gt;
                &lt;td&gt;
                    &lt;form:radiobuttons path=&quot;sex&quot; items=&quot;$&#123;sex&#125;&quot;/&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;DEPARTMENT&lt;/td&gt;
                &lt;td&gt;
                    &lt;form:select path=&quot;dept.did&quot; items=&quot;$&#123;deptList&#125;&quot; itemLabel=&quot;dname&quot; itemValue=&quot;did&quot;&gt;&lt;/form:select&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td colspan=&quot;2&quot;&gt;
                    &lt;input type=&quot;submit&quot; value=&quot;修改&quot; /&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
        &lt;/table&gt;
    &lt;/form:form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>3.EmpController.java</p>
<pre><code>@Controller
public class EmpController &#123;

    @Autowired
    private EmpService service;
    
    @RequestMapping(value=&quot;/emp/&#123;eid&#125;&quot;, method=RequestMethod.GET)
    public String toUpdate(@PathVariable(&quot;eid&quot;)String eid, Map&lt;String, Object&gt; map)&#123;
        //要修改的员工信息
        Emp emp = service.getEmpByEid(eid);
        
        //所有的部门信息
        List&lt;Dept&gt; deptList = service.getAllDept();
        
        //获取存储性别的map集合
        Map&lt;String, String&gt; sex = new HashMap&lt;&gt;();
        sex.put(&quot;0&quot;, &quot;女&quot;);
        sex.put(&quot;1&quot;, &quot;男&quot;);
        
        map.put(&quot;emp&quot;, emp);
        map.put(&quot;deptList&quot;, deptList);
        map.put(&quot;sex&quot;, sex);
        
        return &quot;update&quot;;
    &#125;
    
    @RequestMapping(value=&quot;/emp&quot;, method=RequestMethod.PUT)
    public String updateEmp(Emp emp)&#123;
        service.updateEmp(emp);
        return &quot;redirect:/emps/1&quot;;
    &#125;
&#125;
</code></pre>
<p>4.EmpService.java</p>
<pre><code>public interface EmpService &#123;
    ......
    
    List&lt;Dept&gt; getAllDept();
&#125;
</code></pre>
<p>5.EmpServiceImpl.java</p>
<pre><code>@Service
public class EmpServiceImpl implements EmpService&#123;
    @Autowired
    private EmpMapper empMapper;
    
    @Autowired
    private DeptMapper deptMapper;
    
    ......
    
    @Override
    public List&lt;Dept&gt; getAllDept() &#123;
        // TODO Auto-generated method stub
        return deptMapper.getAllDept();
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>SSM</category>
        <category>修改</category>
      </categories>
      <tags>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM | 列表及分页</title>
    <url>/2022/04/18/SSM-%E5%88%97%E8%A1%A8%E5%8F%8A%E5%88%86%E9%A1%B5/</url>
    <content><![CDATA[<h1 id="列表及分页"><a href="#列表及分页" class="headerlink" title="列表及分页"></a>列表及分页</h1><p>1.index.jsp(请求)</p>
<pre><code>......
&lt;a href=&quot;emps/1&quot;&gt;展示员工信息&lt;/a&gt;
......
</code></pre>
<span id="more"></span>
<p>2.PageUtil.java</p>
<pre><code>package com.atguigu.ssm.util;

import javax.servlet.http.HttpServlet;

import javax.servlet.http.HttpServletRequest;

import com.atguigu.ssm.bean.Emp;
import com.github.pagehelper.PageInfo;

/**
 * 首页 上一页 1 2 3 4 5 下一页 末页
 */
public class PageUtil &#123;
    public static String getPageInfo(PageInfo&lt;?&gt; pageInfo, HttpServletRequest request)&#123;
        String path = request.getContextPath() + &quot;/&quot;;
        
        StringBuilder builder = new StringBuilder();
        
        //拼接首页
        builder.append(&quot;&lt;a href=&#39;&quot;+path+&quot;emps/1&#39;&gt;首页&lt;/a&gt;&quot;);
        builder.append(&quot;&amp;nbsp;&quot;);
        
        //拼接上一页
        if(pageInfo.isHasPreviousPage())&#123;
            builder.append(&quot;&lt;a href=&#39;&quot;+path+&quot;emps/&quot;+pageInfo.getPrePage()+&quot;&#39;&gt;上一页 &lt;/a&gt;&quot;);
            builder.append(&quot;&amp;nbsp;&quot;);
        &#125;else&#123;
            builder.append(&quot;上一页&quot;);
            builder.append(&quot;&amp;nbsp;&quot;);
        &#125;
        
        //拼接页码
        int[] nums = pageInfo.getNavigatepageNums();
        for(int i : nums)&#123;
            if(i == pageInfo.getPageNum())&#123;
                builder.append(&quot;&lt;a style=&#39;color:red;&#39; href=&#39;&quot;+path+&quot;emps/&quot;+i+&quot;&#39;&gt;&quot;+i+&quot;&lt;/a&gt;&quot;);
                builder.append(&quot;&amp;nbsp;&quot;);
            &#125;else&#123;
                builder.append(&quot;&lt;a href=&#39;&quot;+path+&quot;emps/&quot;+i+&quot;&#39;&gt;&quot;+i+&quot;&lt;/a&gt;&quot;);
                builder.append(&quot;&amp;nbsp;&quot;);
            &#125;
        &#125;
        
        //拼接下一页
        if(pageInfo.isHasNextPage())&#123;
            builder.append(&quot;&lt;a href=&#39;&quot;+path+&quot;emps/&quot;+pageInfo.getNextPage()+&quot;&#39;&gt;下一页&lt;/a&gt;&quot;);
            builder.append(&quot;&amp;nbsp;&quot;);
        &#125;else&#123;
            builder.append(&quot;下一页&quot;);
            builder.append(&quot;&amp;nbsp;&quot;);
        &#125;
        
        //拼接尾页
        builder.append(&quot;&lt;a href=&#39;&quot;+path+&quot;emps/&quot;+pageInfo.getPages()+&quot;&#39;&gt;尾页&lt;/a&gt;&quot;);
        builder.append(&quot;&amp;nbsp;&quot;);
        
        return builder.toString();
    &#125;
&#125;
</code></pre>
<p>3.EmpController.java</p>
<pre><code>package com.atguigu.ssm.controller;

import java.util.List;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

import com.atguigu.ssm.bean.Emp;
import com.atguigu.ssm.service.EmpService;
import com.atguigu.ssm.util.PageUtil;
import com.github.pagehelper.PageHelper;
import com.github.pagehelper.PageInfo;

@Controller
public class EmpController &#123;

    @Autowired
    private EmpService service;
    
    @RequestMapping(value=&quot;/emps/&#123;pageNum&#125;&quot;, method=RequestMethod.GET)
    public String getAllEmp(Map&lt;String, Object&gt; map, @PathVariable(&quot;pageNum&quot;)Integer pageNum, HttpServletRequest request)&#123;
        PageHelper.startPage(pageNum, 1);
        List&lt;Emp&gt; empList = service.getAllEmp();
        PageInfo&lt;Emp&gt; pageInfo = new PageInfo&lt;&gt;(empList, 5);
        String page = PageUtil.getPageInfo(pageInfo, request);
        map.put(&quot;empList&quot;, empList);
        map.put(&quot;page&quot;, page);
        return &quot;list&quot;;
    &#125;
&#125;
</code></pre>
<p>4.EmpService(Service接口)</p>
<pre><code>package com.atguigu.ssm.service;

import java.util.List;

import com.atguigu.ssm.bean.Emp;

public interface EmpService &#123;
    List&lt;Emp&gt; getAllEmp();
    
    Emp getEmpByEid(String eid);
    
    void updateEmp(Emp emp);
&#125;
</code></pre>
<p>5.EmpServiceImpl.java(Service实现类)</p>
<pre><code>package com.atguigu.ssm.service.impl;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.atguigu.ssm.bean.Emp;
import com.atguigu.ssm.mapper.EmpMapper;
import com.atguigu.ssm.service.EmpService;

@Service
public class EmpServiceImpl implements EmpService&#123;
    @Autowired
    private EmpMapper mapper;

    @Override
    public List&lt;Emp&gt; getAllEmp() &#123;
        // TODO Auto-generated method stub
        return mapper.getAllEmp();
    &#125;

    @Override
    public Emp getEmpByEid(String eid) &#123;
        // TODO Auto-generated method stub
        return mapper.getEmpByEid(eid);
    &#125;

    @Override
    public void updateEmp(Emp emp) &#123;
        // TODO Auto-generated method stub
        mapper.updateEmp(emp);
    &#125;
&#125;
</code></pre>
<p>6.Emp.java(Emp Bean)</p>
<pre><code>package com.atguigu.ssm.bean;

public class Dept &#123;
    private Integer did;
    private String dname;
    public Integer getDid() &#123;
        return did;
    &#125;
    public void setDid(Integer did) &#123;
        this.did = did;
    &#125;
    public String getDname() &#123;
        return dname;
    &#125;
    public void setDname(String dname) &#123;
        this.dname = dname;
    &#125;
&#125;
</code></pre>
<p>7.Dept.java(Dept Bean)</p>
<pre><code>package com.atguigu.ssm.bean;

public class Emp &#123;
    private Integer eid;
    private String ename;
    private Integer age;
    private String sex;
    private Dept dept;
    public Integer getEid() &#123;
        return eid;
    &#125;
    public void setEid(Integer eid) &#123;
        this.eid = eid;
    &#125;
    public String getEname() &#123;
        return ename;
    &#125;
    public void setEname(String ename) &#123;
        this.ename = ename;
    &#125;
    public Integer getAge() &#123;
        return age;
    &#125;
    public void setAge(Integer age) &#123;
        this.age = age;
    &#125;
    public String getSex() &#123;
        return sex;
    &#125;
    public void setSex(String sex) &#123;
        this.sex = sex;
    &#125;
    public Dept getDept() &#123;
        return dept;
    &#125;
    public void setDept(Dept dept) &#123;
        this.dept = dept;
    &#125;
&#125;
</code></pre>
<p>8.EmpMapper.java(Emp Mapper接口)</p>
<pre><code>package com.atguigu.ssm.mapper;

import java.util.List;

import com.atguigu.ssm.bean.Emp;

public interface EmpMapper &#123;
    //获取所有的员工信息
    List&lt;Emp&gt; getAllEmp();
    
    //根据eid获取员工信息
    Emp getEmpByEid(String eid);
    
    //修改员工信息
    void updateEmp(Emp emp);
&#125;
</code></pre>
<p>9.DeptMapper.java(Dept Mapper接口)</p>
<pre><code>package com.atguigu.ssm.mapper;

import java.util.List;

import com.atguigu.ssm.bean.Dept;

public interface DeptMapper &#123;
    //获取所有的部门信息
    List&lt;Dept&gt; getAllDept();
&#125;
</code></pre>
<p>10.EmpMapper.xml(Emp映射文件)</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
 PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
 &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
 
&lt;mapper namespace=&quot;com.atguigu.ssm.mapper.EmpMapper&quot;&gt;
    &lt;!-- 
        //获取所有的员工信息
        List&lt;Emp&gt; getAllEmp(); 
    --&gt;
    &lt;resultMap type=&quot;Emp&quot; id=&quot;empMap&quot;&gt;
        &lt;id column=&quot;eid&quot; property=&quot;eid&quot; /&gt;
        &lt;result column=&quot;ename&quot; property=&quot;ename&quot;/&gt;
        &lt;result column=&quot;age&quot; property=&quot;age&quot;/&gt;
        &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;
        &lt;association property=&quot;dept&quot; javaType=&quot;Dept&quot;&gt;
            &lt;id column=&quot;did&quot; property=&quot;did&quot;/&gt;
            &lt;result column=&quot;dname&quot; property=&quot;dname&quot;/&gt;
        &lt;/association&gt;
    &lt;/resultMap&gt;
    &lt;select id=&quot;getAllEmp&quot; resultMap=&quot;empMap&quot;&gt;
        select 
        e.eid,e.ename,e.age,e.sex,d.did,d.dname
        from emp e 
        left join 
        dept d
        on 
        e.did = d.did
    &lt;/select&gt;
    
    &lt;!-- 
        //根据eid获取员工信息
        Emp getEmpByEid(String eid); 
    --&gt;
    &lt;select id=&quot;getEmpByEid&quot; resultMap=&quot;empMap&quot;&gt;
        select 
        e.eid,e.ename,e.age,e.sex,d.did,d.dname
        from emp e 
        left join 
        dept d
        on 
        e.did = d.did
        where e.eid = #&#123;eid&#125;
    &lt;/select&gt;
    
    &lt;!-- 
        //修改员工信息
        void updateEmp(Emp emp); 
    --&gt;
    &lt;update id=&quot;updateEmp&quot;&gt;
        update emp set
        ename = #&#123;ename&#125;,
        age = #&#123;age&#125;,
        sex = #&#123;sex&#125;,
        did = #&#123;dept.did&#125;
        where eid = #&#123;eid&#125;
    &lt;/update&gt;
&lt;/mapper&gt;
</code></pre>
<p>11.DeptMapper.xml(Dept映射文件)</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
 PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
 &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
 
&lt;mapper namespace=&quot;com.atguigu.ssm.mapper.DeptMapper&quot;&gt;
    &lt;!-- 
        //获取所有的部门信息
        List&lt;Dept&gt; getAllDept(); 
    --&gt;
    &lt;select id=&quot;getAllDept&quot; resultType=&quot;Dept&quot;&gt;
        select did,dname from dept
    &lt;/select&gt;
     
&lt;/mapper&gt;
</code></pre>
<p><strong>结果展示</strong><br><img src="/2022/04/18/SSM-%E5%88%97%E8%A1%A8%E5%8F%8A%E5%88%86%E9%A1%B5/1.PNG"></p>
<p><img src="/2022/04/18/SSM-%E5%88%97%E8%A1%A8%E5%8F%8A%E5%88%86%E9%A1%B5/2.PNG"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>SSM</category>
        <category>列表及分页</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>分页</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM | 批量删除</title>
    <url>/2022/04/18/SSM-%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4/</url>
    <content><![CDATA[<h1 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h1><p>1.list.jsp</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
&lt;title&gt;展示员工信息&lt;/title&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;$&#123;pageContext.servletContext.contextPath&#125;/css/index_work.css&quot;/&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;$&#123;pageContext.servletContext.contextPath&#125;/js/jquery-1.8.2.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    $(function()&#123;
        $(&quot;#selectAll&quot;).click(function()&#123;
            $(&quot;[name=&#39;eid&#39;]&quot;).prop(&quot;checked&quot;, $(this).prop(&quot;checked&quot;));
        &#125;);
        
        $(&quot;#deleteMore&quot;).click(function()&#123;
            $(&quot;form&quot;).attr(&quot;action&quot;, $(this).attr(&quot;href&quot;)).submit();
            return false;//关闭默认跳转
        &#125;);
    &#125;);
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form method=&quot;post&quot;&gt;
        &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;DELETE&quot;/&gt;
        &lt;table&gt;
            &lt;tr&gt;
                &lt;th&gt;
                    &lt;input type=&quot;checkbox&quot; id=&quot;selectAll&quot;&gt;
                &lt;/th&gt;
                &lt;th&gt;EID&lt;/th&gt;
                &lt;th&gt;ENAME&lt;/th&gt;
                &lt;th&gt;AGE&lt;/th&gt;
                &lt;th&gt;SEX&lt;/th&gt;
                &lt;th&gt;DEPARTMENTNAME&lt;/th&gt;
                &lt;th&gt;OPTIONS&lt;/th&gt;
            &lt;/tr&gt;
            &lt;c:forEach items=&quot;$&#123;empList&#125;&quot; var=&quot;emp&quot;&gt;
                &lt;tr&gt;
                    &lt;td&gt;
                        &lt;input type=&quot;checkbox&quot; name=&quot;eid&quot; value=&quot;$&#123;emp.eid&#125;&quot;/&gt;
                    &lt;/td&gt;
                    &lt;td&gt;$&#123;emp.eid&#125;&lt;/td&gt;
                    &lt;td&gt;$&#123;emp.ename&#125;&lt;/td&gt;
                    &lt;td&gt;$&#123;emp.age&#125;&lt;/td&gt;
                    &lt;td&gt;$&#123;emp.sex == 0 ? &#39;女&#39;:&#39;男&#39;&#125;&lt;/td&gt;
                    &lt;td&gt;$&#123;emp.dept.dname&#125;&lt;/td&gt;
                    &lt;td&gt;
                        &lt;a href=&quot;emp&quot;&gt;删除&lt;/a&gt;
                        &lt;a href=&quot;$&#123;pageContext.servletContext.contextPath&#125;/emp/$&#123;emp.eid&#125;&quot;&gt;修改&lt;/a&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/c:forEach&gt;
            &lt;tr&gt;
                &lt;td colspan=&quot;10&quot;&gt;
                    &lt;a id=&quot;deleteMore&quot; href=&quot;$&#123;pageContext.servletContext.contextPath&#125;/emps&quot;&gt;批量删除&lt;/a&gt;&amp;nbsp;
                    $&#123;page&#125;
                &lt;/td&gt;
            &lt;/tr&gt;
        &lt;/table&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>2.EmpMapper.java</p>
<pre><code>public interface EmpMapper &#123;
    //获取所有的员工信息
    List&lt;Emp&gt; getAllEmp();
    
    ......
    
    void deleteMore(String eids);
&#125;
</code></pre>
<p>3.EmpMapper.xml</p>
<pre><code>&lt;!-- void deleteMore(String eids); --&gt;
&lt;delete id=&quot;deleteMore&quot;&gt;
    delete from emp where eid in ($&#123;value&#125;)
&lt;/delete&gt;
</code></pre>
<p>4.EmpService.java</p>
<pre><code>public interface EmpService &#123;
    ......
    
    void deleteMore(String eids);
&#125;
</code></pre>
<p>5.EmpServiceImpl.java</p>
<pre><code>@Service
public class EmpServiceImpl implements EmpService&#123;
    @Autowired
    private EmpMapper empMapper;
    
    ......

    @Override
    public void deleteMore(String eids) &#123;
        // TODO Auto-generated method stub
        empMapper.deleteMore(eids);
    &#125;
&#125;
</code></pre>
<p>6.EmpController.java</p>
<pre><code>@Controller
public class EmpController &#123;

    @Autowired
    private EmpService service;
    
    ......
    
    @RequestMapping(value=&quot;/emps&quot;, method=RequestMethod.DELETE)
    public String deleteMore(String eid)&#123;
        //获取客户端name属性相同的多个元素的值，可以通过字符串直接获取，每个值以逗号分隔，也可以以数组直接获取
        System.out.println(eid);
        service.deleteMore(eid);
        return &quot;redirect:/emps/1&quot;;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>SSM</category>
        <category>批量删除</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM</tag>
        <tag>批量删除</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM | SSM项目搭建</title>
    <url>/2022/04/18/SSM%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="SSM整合步骤："><a href="#SSM整合步骤：" class="headerlink" title="SSM整合步骤："></a>SSM整合步骤：</h2><p>1.导入jar包<br>    spring:<br>    springMVC:<br>    mybatis:<br>    第三方支持:log4j,pageHelper,AspectJ,jackson,jstl<br><img src="/2022/04/18/SSM%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/1.PNG"><br>2.搭建springMVC<br>    (1)web.xml<br>        CharacterEncodingFilter:filter<br>        HiddenHttpMethodFilter:filter<br>        DispatcherServlet:servlet<br>    (2)springMVC.xml<br>        扫描控制层组件：<a href="context:component-scan">context:component-scan</a><br>        视图解析器:InternalResourceViewResolver<br>        Default Servlet:<a href="mvc:default-servlet-handler/">mvc:default-servlet-handler/</a><br>        MVC驱动:&lt;mvc:annotation-driven /&gt;<br>        可选：MultipartResolver,拦截器</p>
<span id="more"></span>
<p>3.整合springMVC和spring<br>    (1)web.xml<br>        ContextLoaderListener:listener<br>        context-param<br>    (2)spring.xml<br>        扫描组件（排除控制层）<br>4.搭建mybatis<br>    核心配置文件mybatis-config.xml<br>    mapper接口和mapper映射文件<br>5.spring整合mybatis<br>    spring.xml:<br>        properties文件的引入<br>        DataSource数据源的配置：xxxDataSource<br>        事务管理器：DataSourceTransactionManager<br>        开启事务驱动:<a href="tx:annotation-driven">tx:annotation-driven</a><br>        SqlSessionFactoryBean:管理SqlSession<br>        MypperScannerConfigurer:自动生成Mapper接口的代理实现类<br>6.REST CRUD<br>    查询+分页<br>    修改（form）<br><strong>项目目录</strong><br><img src="/2022/04/18/SSM%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/2.PNG"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>SSM</category>
        <category>SSM项目搭建</category>
      </categories>
      <tags>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title>并发 | Semaphore</title>
    <url>/2022/06/07/Semaphore/</url>
    <content><![CDATA[<h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><p>Semaphore（信号量）是用来控制同时访问特定资源的数量，它通过协调各个线程，以保证合理的使用公共资源。<br><strong>应用场景：</strong><br>Semaphore可以用于做<strong>流量控制</strong>，特别是公共资源优先的应用场景，比如<strong>数据库连接</strong>。<br><strong>示例代码：</strong></p>
<pre><code>package concurrency.semaphore;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Semaphore;

public class SemaphoreTest &#123;
    private static final int THREAD_COUNT = 30;
    
    private static ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);
    
    private static Semaphore s = new Semaphore(10);
    
    public static void main(String[] args) &#123;
        for(int i = 0; i &lt; THREAD_COUNT; i++)&#123;//虽然有30个线程在执行，但是只允许10个并发执行
            threadPool.execute(new Runnable()&#123;
                @Override
                public void run()&#123;
                    try&#123;
                        s.acquire();
                        System.out.println(&quot;save data&quot;);
                        s.release();
                    &#125;catch(InterruptedException e)&#123;
                        e.printStackTrace();
                    &#125;
                &#125;
            &#125;);
        &#125;
        threadPool.shutdown();
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>并发</category>
        <category>Semaphore</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>Semaphore</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC | SpringMVC之HelloWorld</title>
    <url>/2022/03/08/SpringMVC%E4%B9%8BHelloWorld/</url>
    <content><![CDATA[<h1 id="SpringMVC之HelloWorld"><a href="#SpringMVC之HelloWorld" class="headerlink" title="SpringMVC之HelloWorld"></a>SpringMVC之HelloWorld</h1><h2 id="springMVC的搭建过程："><a href="#springMVC的搭建过程：" class="headerlink" title="springMVC的搭建过程："></a>springMVC的搭建过程：</h2><p>1.导入jar</p>
<p>2.在web.xml配置springMVC的核心（前端）控制器DispatcherServlet<br>作用：加载springMVC的配置文件，在下方的配置方式下，DispatcherServlet<br>自动加载配置文件，此时的配置文件有默认的位置和名称<br>    默认位置：WEB-INF下，默认名称：<servlet-name>-servlet.xml,<br>    例如以下配置方式的文件名：springMVC-servlet.xml<br>    当加载了配置文件，springMVC就会根据扫描组件找到控制层</servlet-name></p>
<pre><code>&lt;servlet&gt;
&lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;
&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
&lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;
&lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<p>3.创建一个POJO,在此类上加上@Controller注解，springMVC就会将此类作为控制层加载，让其处理请求响应<br>4.在控制层中，需要在方法上设置@RequestMapping(value=”hello”),<br>springMVC就是通过此注解将请求路径与控制层中的方法进行匹配，此时请求路径为localhost:8080/projectName/xxx<br>5.处理请求的方法会返回一个字符串，即视图名称，最终会通过配置文件中配置的视图解析器实现页面跳转<br>方式：prefix + 视图名称 + suffix，此为最终跳转的页面路径</p>
<span id="more"></span>
<h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><p>1.项目目录<br><img src="/2022/03/08/SpringMVC%E4%B9%8BHelloWorld/1.PNG"><br>2.web.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&gt;
  &lt;display-name&gt;SpringMVC01&lt;/display-name&gt;
  &lt;welcome-file-list&gt;
    &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;
  &lt;/welcome-file-list&gt;
  
  &lt;servlet&gt;
    &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
  
&lt;/web-app&gt;
</code></pre>
<p>3.springMVC-servlet.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&gt;
    
    &lt;!-- 扫描组件，将加上@Controller注解的类作为springMVC的控制层 --&gt;
    &lt;context:component-scan base-package=&quot;com.atguigu.test&quot;&gt;&lt;/context:component-scan&gt;
    
    &lt;!-- 
        配置视图解析器
        作用：将prefix + 视图名称 + suffix 确定最终要跳转的页面
        /WEB-INF/view/success.jsp
     --&gt;
    &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/view/&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    

&lt;/beans&gt;
</code></pre>
<p>4.index.jsp</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;a href=&quot;hello&quot;&gt;测试springMVC&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>5.success.jsp</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;success&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>6.TestController.java</p>
<pre><code>package com.atguigu.test;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class TestController &#123;
    /**
     * 假设：localhost:8080/SpringMVC01/hello
     */
    
    @RequestMapping(&quot;hello&quot;)
    public String hello()&#123;
        System.out.println(&quot;SUCCESS&quot;);
        return &quot;success&quot;;//视图名称
    &#125;
&#125;
</code></pre>
<p>7.运行结果<br><img src="/2022/03/08/SpringMVC%E4%B9%8BHelloWorld/2.PNG"></p>
<p><img src="/2022/03/08/SpringMVC%E4%B9%8BHelloWorld/3.PNG"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>SpringMVC</category>
        <category>SpringMVC之HelloWorld</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC | 处理请求数据</title>
    <url>/2022/03/09/SpringMVC%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="处理请求数据"><a href="#处理请求数据" class="headerlink" title="处理请求数据"></a>处理请求数据</h1><p>1.项目目录<br><img src="/2022/03/09/SpringMVC%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE/1.PNG"></p>
<span id="more"></span>
<p>2.web.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&gt;
  &lt;display-name&gt;SpringMVC02&lt;/display-name&gt;
  &lt;welcome-file-list&gt;
    &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;
  &lt;/welcome-file-list&gt;
  
  &lt;!-- The front controller of this Spring Web application, responsible for handling all application requests --&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;

    &lt;!-- Map all requests to the DispatcherServlet for handling --&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    
    &lt;filter&gt;
        &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
    
&lt;/web-app&gt;
</code></pre>
<p>3.springMVC-servlet.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&gt;
    
    &lt;!-- 扫描组件 --&gt;
    &lt;context:component-scan base-package=&quot;com.atguigu.controller&quot;&gt;&lt;/context:component-scan&gt;
    
    &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/view/&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>4.param.jsp</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form action=&quot;param&quot; method=&quot;post&quot;&gt;
        username:&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br&gt; 
        password:&lt;input type=&quot;text&quot; name=&quot;password&quot; /&gt;&lt;br&gt;
        age:&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;br&gt;
        
        &lt;!-- 测试RequestParam取消这段代码的注释 --&gt;
        &lt;!-- province:&lt;input type=&quot;text&quot; name=&quot;province&quot; /&gt;&lt;br&gt;
        city:&lt;input type=&quot;text&quot; name=&quot;city&quot; /&gt;&lt;br&gt;
        country:&lt;input type=&quot;text&quot; name=&quot;country&quot; /&gt; --&gt;
        
        &lt;!-- 使用POJO获取客户端数据 --&gt;
        province:&lt;input type=&quot;text&quot; name=&quot;address.province&quot; /&gt;&lt;br&gt;
        city:&lt;input type=&quot;text&quot; name=&quot;address.city&quot; /&gt;&lt;br&gt;
        country:&lt;input type=&quot;text&quot; name=&quot;address.country&quot; /&gt;
        &lt;input type=&quot;submit&quot; value=&quot;添加&quot;/&gt;
        
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>5.success.jsp</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;成功&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>6.User.java</p>
<pre><code>package com.atguigu.bean;

public class User &#123;
    private Integer id;
    private String username;
    private String password;
    private Address address;
    public Integer getId() &#123;
        return id;
    &#125;
    public void setId(Integer id) &#123;
        this.id = id;
    &#125;
    public String getUsername() &#123;
        return username;
    &#125;
    public void setUsername(String username) &#123;
        this.username = username;
    &#125;
    public String getPassword() &#123;
        return password;
    &#125;
    public void setPassword(String password) &#123;
        this.password = password;
    &#125;
    public Address getAddress() &#123;
        return address;
    &#125;
    public void setAddress(Address address) &#123;
        this.address = address;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;User [id=&quot; + id + &quot;, username=&quot; + username + &quot;, password=&quot; + password + &quot;, address=&quot; + address + &quot;]&quot;;
    &#125;
    
&#125;
</code></pre>
<p>7.Address.java</p>
<pre><code>package com.atguigu.bean;

public class Address &#123;
    private String province;
    private String city;
    private String country;
    public String getProvince() &#123;
        return province;
    &#125;
    public void setProvince(String province) &#123;
        this.province = province;
    &#125;
    public String getCity() &#123;
        return city;
    &#125;
    public void setCity(String city) &#123;
        this.city = city;
    &#125;
    public String getCountry() &#123;
        return country;
    &#125;
    public void setCountry(String country) &#123;
        this.country = country;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Address [province=&quot; + province + &quot;, city=&quot; + city + &quot;, country=&quot; + country + &quot;]&quot;;
    &#125;
    
&#125;
</code></pre>
<p>8.ParamController.java</p>
<pre><code>package com.atguigu.controller;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.CookieValue;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;

import com.atguigu.bean.User;

@Controller
public class ParamController &#123;
    /**
     * 在springMVC获取客户端传递的数据的方式
     * 1、在处理请求的方法中，加入相对应的形参，保证形参参数名和传递的数据的参数名保持一致，就可以自动赋值
     * @RequestParam：可以把请求参数传递给请求方法
     * 当不满足赋值条件时，可以使用value属性，指定映射关系
     * required：设置形参是否必须被赋值，默认为ture，必须赋值，若设置为false，则不必须赋值，
     * 因此形参的值为null
     * defaultValue:若形参所获得的值为null，则设置一个默认值，用在分页和模糊查询中
     */
//    @RequestMapping(value=&quot;/param&quot;, method=RequestMethod.POST)
//    public String testRequestParam(@RequestParam(value=&quot;name&quot;, required=false, defaultValue=&quot;admin&quot;)String username, String password, String age)&#123;
//        System.out.println(&quot;username=&quot;+username+&quot;,password=&quot;+password+&quot;,age=&quot;+age);
//        return &quot;success&quot;;
//    &#125;
    
    /**
     * @RequestHeader:在处理请求的方法上，获取请求头信息，用户和@RequestParam一致
     */
//    @RequestMapping(value=&quot;/testRequestHeader&quot;)
//    public String testRequestHeader(@RequestHeader(value=&quot;Accept-Language&quot;)String al)&#123;
//        System.out.println(al);
//        return &quot;success&quot;;
//    &#125;
    
    /**
     * @CookieValue:在处理请求的方法上，获取cookie信息，用法和RequestParam一致
     */
//    @RequestMapping(&quot;/testCookieValue&quot;)
//    public String testCookieValue(@CookieValue(&quot;JSESSIONID&quot;)String sessionId)&#123;
//        System.out.println(&quot;testCookieValue:sessionId:&quot;+sessionId);
//        return &quot;success&quot;;
//    &#125;
    
    /**
     * 可以使用POJO获取客户端数据，要求实体类对象中的属性名一定要和页面中表单元素的name属性值一致，且支持级联关系
     */
//    @RequestMapping(value=&quot;/param&quot;, method=RequestMethod.POST)
//    public String testPojo(User user)&#123;
//        System.out.println(user);
//        return &quot;success&quot;;
//    &#125;
    
    /**
     * 可以通过设置形参的方式，获取servletAPI
     */
    @RequestMapping(&quot;/param&quot;)
    public String testServletAPI(HttpServletRequest request, HttpServletResponse response)&#123;
        System.out.println(&quot;testServletAPI,&quot;+request+&quot;,&quot;+response);
        
        String username = request.getParameter(&quot;username&quot;);
        System.out.println(username);
        return &quot;success&quot;;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>SpringMVC</category>
        <category>处理请求数据</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
        <tag>RequestParam注解</tag>
        <tag>RequestHeader注解</tag>
        <tag>CookieValue注解</tag>
        <tag>使用POJO获取客户端数据</tag>
        <tag>获取servletAPI</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC | 处理请求过程中往作用域中放值的三种方式</title>
    <url>/2022/03/09/SpringMVC%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%BE%80%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%E6%94%BE%E5%80%BC%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="处理响应数据-ModelAndView"><a href="#处理响应数据-ModelAndView" class="headerlink" title="处理响应数据 ModelAndView"></a>处理响应数据 ModelAndView</h1><p>在<a href="https://victory-liao.github.io/2022/03/09/SpringMVC%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE/">处理请求数据</a><br>项目的ParamController.java的类中加入以下代码：</p>
<pre><code>/**
 * SpringMVC处理请求过程中，往作用域中放值有以下三种方式
 * 总结：根据ModelAndView源码调试，不管使用以下那种方式，最终都会把model数据和view数据封装到一个ModelAndView中
 */
//往作用域中放值方式1
//    @RequestMapping(value=&quot;/param&quot;, method=RequestMethod.POST)
//    public ModelAndView param()&#123;
//        ModelAndView mav = new ModelAndView();
//        //javaWEB： request.setAttribute(xxx) 
//        mav.addObject(&quot;username&quot;, &quot;root&quot;);//往request作用域中放值
//        mav.setViewName(&quot;success&quot;);//设置视图名称，实现页面跳转
//        return mav;
//    &#125;
    
    //往作用域中放值方式2
//    @RequestMapping(value=&quot;/param&quot;, method=RequestMethod.POST)
//    public String param(Map&lt;String, Object&gt; map)&#123;
//        map.put(&quot;username&quot;, &quot;admin&quot;);//向作用域中放值
//        return &quot;success&quot;;//返回视图名称
//    &#125;

//往作用域中放值方式3
@RequestMapping(value=&quot;/param&quot;, method=RequestMethod.POST)
public String param(Model model)&#123;
    model.addAttribute(&quot;usernaem&quot;, &quot;zhangsan&quot;);//向作用域中放值
    return &quot;success&quot;;//返回视图名称
&#125;
</code></pre>
<p>并在param.jsp页面获取request作用域中的值</p>
<pre><code>&lt;!-- $&#123;requestScope.username &#125; --&gt;
    $&#123;username&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>SpringMVC</category>
        <category>处理请求过程中往作用域中放值的三种方式</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
        <tag>ModelAndView</tag>
      </tags>
  </entry>
  <entry>
    <title>Java | ThreadLocal</title>
    <url>/2022/04/23/ThreadLocal/</url>
    <content><![CDATA[<h1 id="ThreadLocal示例"><a href="#ThreadLocal示例" class="headerlink" title="ThreadLocal示例"></a>ThreadLocal示例</h1><p>ThreadLocal:<br>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。如果想实现每一个线程都有自己的专属本地变量该如何解决呢？ JDK 中提供的ThreadLocal类正是为了解决这样的问题。<br>ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。<br>如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是ThreadLocal变量名的由来。他们可以使用 get（） 和 set（） 方法来获取默认值或将修改其值，从而避免了线程安全问题。</p>
<p><strong>代码：</strong></p>
<pre><code>import java.text.SimpleDateFormat;
import java.util.Random;

public class ThreadLocalTest implements Runnable&#123;

    //private static final ThreadLocal&lt;SimpleDateFormat&gt; formatter = ThreadLocal.withInitial(()-&gt;new SimpleDateFormat(&quot;yyyyMMdd HHmm&quot;));
    private static final ThreadLocal&lt;SimpleDateFormat&gt; formatter = new ThreadLocal&lt;SimpleDateFormat&gt;()&#123;
        @Override
        protected SimpleDateFormat initialValue()&#123;
            return new SimpleDateFormat(&quot;yyyyMMdd HHmm&quot;);
        &#125;
    &#125;;
    
    @Override
    public void run() &#123;
        System.out.println(&quot;Thread Name=&quot;+Thread.currentThread().getName()+&quot; default formatter=&quot;+formatter.get().toPattern());
        try &#123;
            Thread.sleep(new Random().nextInt(1000));
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        formatter.set(new SimpleDateFormat());
        System.out.println(&quot;Thread Name=&quot;+Thread.currentThread().getName()+&quot; current formatter=&quot;+formatter.get().toPattern());
        
    &#125;
    
    public static void main(String[] args) throws InterruptedException&#123;
        ThreadLocalTest obj = new ThreadLocalTest();
        for(int i=0;i&lt;10;i++)&#123;
            Thread t = new Thread(obj, &quot;&quot;+i);
            Thread.sleep(new Random().nextInt(1000));
            t.start();
        &#125;
    &#125;
    
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
        <category>ThreadLocal</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ThreadLocal</tag>
      </tags>
  </entry>
  <entry>
    <title>tkinter | Tkinter制作python程序的图形化界面</title>
    <url>/2021/10/30/Tkinter%E5%88%B6%E4%BD%9Cpython%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2/</url>
    <content><![CDATA[<h1 id="Tkinter制作python程序的图形化界面"><a href="#Tkinter制作python程序的图形化界面" class="headerlink" title="Tkinter制作python程序的图形化界面"></a>Tkinter制作python程序的图形化界面</h1><p>代码：</p>
<pre><code>from os import listdir, getcwd
from xlrd import open_workbook, xldate
from datetime import datetime
from time import time, localtime, strftime
from openpyxl import Workbook
from openpyxl.styles import Border, Side, PatternFill, Font, GradientFill, Alignment
from tkinter import Tk, Entry, Button, Listbox, X, Y, END, Scrollbar, RIGHT, BOTTOM, HORIZONTAL
from tkinter.filedialog import askdirectory


class MainGUI():
    def __init__(self):
        myWindow = Tk()
        myWindow.title(&quot;领料记录汇总&quot;)
        # 设置窗口大小
        myWindow.geometry(&#39;590x400&#39;)
        myWindow.iconbitmap(getcwd() + &quot;\\PO.ico&quot;)
        # 增加文本框
        self.input_entry = Entry(myWindow, highlightcolor=&#39;red&#39;, highlightthickness=1)
        self.input_entry.place(x=10, y=10, width=480, height=30)
        self.btn_in = Button(myWindow, text=&#39;输入文件目录&#39;, command=self.select_dir1, width=10, height=1)
        self.btn_in.place(x=500, y=10)

        self.output_entry = Entry(myWindow, highlightcolor=&#39;blue&#39;, highlightthickness=1)
        self.output_entry.place(x=10, y=50, width=480, height=30)
        self.btn_out = Button(myWindow, text=&#39;输出文件目录&#39;, command=self.select_dir2, width=10, height=1)
        self.btn_out.place(x=500, y=50)

        self.btn_run = Button(myWindow, text=&#39;执行汇总&#39;, width=10, height=1, command=self.Summary_data)
        self.btn_run.place(x=500, y=90)
        # 增加列表框
        self.result_show = Listbox(myWindow, bg=&#39;DarkSeaGreen&#39;)  # yscrollcommand = scroll_bar,
        self.result_show.place(x=10, y=130, width=570, height=260)
        self.sbY = Scrollbar(self.result_show, command=self.result_show.yview)  # 在列表框中增加Y轴滚动条
        self.sbY.pack(side=RIGHT, fill=Y)
        self.result_show.config(yscrollcommand=self.sbY.set)
        self.sbX = Scrollbar(self.result_show, command=self.result_show.xview, orient=HORIZONTAL)  # 在列表框中增加X轴滚动条
        self.sbX.pack(side=BOTTOM, fill=X)
        self.result_show.config(xscrollcommand=self.sbX.set)

        myWindow.mainloop()

    def select_dir1(self):
        self.input_entry.delete(0, END)
        self.input_entry.insert(0, askdirectory(initialdir=&quot;D:\\&quot;))

    def select_dir2(self):
        self.output_entry.delete(0, END)
        self.output_entry.insert(0, askdirectory(initialdir=&quot;D:\\&quot;))

    # 读取xls文件中的数据
    def Get_data(self, file):
        wb = open_workbook(file)  # 读取工作簿
        ws = wb.sheets()[0]  # 选第一个工作表
        data = &#123;&#125;
        for row in range(7, ws.nrows - 2):
            dept = ws.cell(2, 16).value  # 部门
            dept_id = ws.cell(3, 16).value  # 部门编号
            dt = ws.cell(row, 0).value  # 时间
            if type(dt) is float:
                date_time = xldate.xldate_as_datetime(dt, 0)
            else:
                date_time = datetime.strptime(dt, &#39;%Y-%m-%d %H:%M:%S&#39;)
            business = ws.cell(row, 2).value  # 业务类型
            model = ws.cell(row, 3).value  # 品种
            qty = ws.cell(row, 4).value  # 数量
            unit_price = ws.cell(row, 6).value  # 单价
            price = ws.cell(row, 8).value  # 总价
            reward = ws.cell(row, 9).value  # 额外值
            discount = ws.cell(row, 11).value  # 调整
            balance = ws.cell(row, 13).value  # 剩余
            location = str(ws.cell(row, 15).value).strip()  # 库位
            operator = ws.cell(row, 17).value  # 操作员
            date = date_time.date()  # 日期
            time = date_time.time()  # 时间
            info_list = [dept, dept_id, date_time, business, model, qty, unit_price, price, reward, discount,
                         balance, location, operator, date, time]
            data.setdefault(date, [])  # 以日期为键
            if info_list[3] != &quot;备注&quot;:  # 不要业务类型为“备注”的数据
                data[date].append(info_list)
        # 增加当日领取次数
        for key in data.keys():
            for i in data[key]:
                i.append(len(data[key]))

        return data

    def Get_file_path(self, path):
        files = []
        for file in listdir(path):
            if file.endswith(&quot;.xls&quot;):  # 排除文件夹内的其它干扰文件
                files.append(path + &quot;\\&quot; + file)
        return files

    def Get_current_time(self):
        time_stamp = time()  # 当前时间的时间戳
        local_time = localtime(time_stamp)  #
        str_time = strftime(&#39;%Y-%m-%d %H.%M.%S&#39;, local_time)
        return str_time

    def Summary_data(self):
        thin = Side(border_style=&quot;thin&quot;, color=&quot;000000&quot;)  # 定义边框粗细及颜色
        title = [&#39;部门&#39;, &#39;部门编号&#39;, &#39;时间&#39;, &#39;业务类型&#39;, &#39;品种&#39;, &#39;数量&#39;, &#39;单价&#39;, &#39;金额&#39;, &#39;额外值&#39;,
                 &#39;调整&#39;, &#39;剩余&#39;, &#39;库位&#39;, &#39;操作员&#39;, &#39;领取日期&#39;, &#39;领取时间&#39;, &#39;领取次数&#39;]

        wb = Workbook()
        ws = wb.active

        ws.merge_cells(&quot;A1:P1&quot;)
        ws.cell(1, 1).value = &quot;领料明细汇总表&quot;
        ws.cell(1, 1).font = Font(name=u&#39;黑体&#39;, bold=True, size=18)
        ws.row_dimensions[1].height = 22.2
        ws.cell(1, 1).alignment = Alignment(horizontal=&quot;center&quot;, vertical=&quot;center&quot;)
        ws.append(title)

        # 插入数据
        files = self.Get_file_path(self.input_entry.get())  # get()获取文本编辑框中的输入文件目录，并获取目录下的xls文件
        for file in files:
            data = self.Get_data(file)
            for key in data.keys():
                for i in data[key]:
                    ws.append(i)
            f = f&quot;&#123;file&#125; 的内容已加入总表.&quot;  # 创建一个显示项
            self.result_show.insert(&quot;end&quot;, f)  # 将结果添加到列表框中

        # 设置字号，对齐，缩小字体填充，加边框
        # Font(bold=True)可加粗字体
        for row_number in range(2, ws.max_row + 1):
            for col_number in range(1, 17):
                c = ws.cell(row=row_number, column=col_number)
                c.font = Font(size=9)
                c.border = Border(top=thin, left=thin, right=thin, bottom=thin)
                c.alignment = Alignment(horizontal=&quot;left&quot;, vertical=&quot;center&quot;)

        col_name = list(&quot;ABCDEFGHIJKLMNOP&quot;)
        col_width = [8, 8, 16, 8, 16, 8, 8, 9.8, 8, 8, 8, 11, 8.3, 9, 8, 8]
        for i in range(len(col_name)):
            ws.column_dimensions[col_name[i]].width = col_width[i]

        ws.column_dimensions.group(&#39;I&#39;, &#39;K&#39;, hidden=True)
        ws.column_dimensions.group(&#39;N&#39;, &#39;O&#39;, hidden=True)

        wb.save(f&quot;&#123;self.output_entry.get()&#125;\\领料明细汇总表&#123;self.Get_current_time()&#125;.xlsx&quot;)
        f = &quot;-&quot; * 100  # 创建分割线
        self.result_show.insert(&quot;end&quot;, f)  # 将分割线添加到列表框
        f = f&quot;领料明细汇总表&#123;self.Get_current_time()&#125;.xlsx 已生成，请去输出文件夹查看.&quot;  # 创建一个显示项
        self.result_show.insert(&quot;end&quot;, f)  # 将结果添加到列表框
        f = &quot; &quot; * 100
        self.result_show.insert(&quot;end&quot;, f)  # 将以上空格添加到列表框


if __name__ == &quot;__main__&quot;:
    MainGUI()
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>tkinter</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>tkinter</tag>
      </tags>
  </entry>
  <entry>
    <title>UML | UML中的事物分类</title>
    <url>/2021/05/23/UML%E4%B8%AD%E7%9A%84%E4%BA%8B%E7%89%A9%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="UML中的事物分类"><a href="#UML中的事物分类" class="headerlink" title="UML中的事物分类"></a>UML中的事物分类</h1><p>1.结构事物<br>模型的<strong>静态部分</strong>，是UML模型中的名词，描述概念或物理元素。<br><strong>包括</strong>：类(class),(接口)interface,协作(collaboration),用例(use case),主动类(active class),构件(component),节点(node)</p>
<p>2.行为事物<br>模型的<strong>动态部分</strong>，描述了跨越时间和空间的行为。<br><strong>包括</strong>：交互(interaction)，状态机(state machine)</p>
<p><strong>交互</strong>：由在特定语境中共同完成一定任务的一组对象之间交换的<strong>消息</strong>组成，描述一个对象群体的行为或单个操作的行为</p>
<p><strong>状态机</strong>：描述了一个对象或一个交互在<strong>生命期内响应事件</strong>所经历的<strong>状态序列</strong></p>
<p>3.分组事物<br>分组事物是一些由<strong>模型分解成的组织部分</strong>，最主要的是<strong>包</strong></p>
<p>4.注释事物<br>用来描述、说明和标注模型的任何元素，主要是<strong>注解</strong></p>
]]></content>
      <categories>
        <category>UML</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>VGG | 使用3x3卷积核的优点</title>
    <url>/2021/11/15/VGG3x3%E5%8D%B7%E7%A7%AF%E6%A0%B8%E7%9A%84%E4%BC%98%E7%82%B9/</url>
    <content><![CDATA[<h1 id="VGG使用3x3卷积核的优点"><a href="#VGG使用3x3卷积核的优点" class="headerlink" title="VGG使用3x3卷积核的优点"></a>VGG使用3x3卷积核的优点</h1><p>2个3x3的卷积核串联和一个5x5的卷积核拥有相同的感受野，但是，2个3x3的卷积核拥有更少的参数，<br>对于通道为1的5x5特征图得到通道为1的输出特征图，前者有3x3x2=18个参数，后者5x5=25个参数，<br>其次，多个3x3的卷积核比一个较大的尺寸的卷积核加入了更多的非线性函数，增强了模型的非线性表达能力。<br><strong>1x1卷积核的作用：</strong> 改变通道数目，保持尺度不变情况下增强非线性表达能力，可以实现跨通道的信息交互。</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
        <category>CNN</category>
        <category>VGG</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>CNN</tag>
        <tag>VGG</tag>
      </tags>
  </entry>
  <entry>
    <title>Web服务器</title>
    <url>/2020/11/09/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h1 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h1><p><strong>Web服务器是可以向发出请求的浏览器提供文档的程序。</strong></p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><pre><code># coding:utf-8
import socket
import re

from multiprocessing import Process

# 设置静态文件根目录
HTML_ROOT_DIR = &quot;./html&quot;


def handle_client(client_socket):
    &quot;&quot;&quot;处理客户端请求&quot;&quot;&quot;
    # 获取客户端请求数据
    request_data = client_socket.recv(1024)
    print(&quot;request data:&quot;,request_data)
    request_lines = request_data.splitlines()
    for line in request_lines:
        print(line)

    # 解析请求报文
    # &#39;GET / HTTP/1.1&#39;
    request_start_line = request_lines[0]
    #提取用户请求的文件名
    file_name = re.match(r&quot;\w+ +(/[^ ]*) &quot;,request_start_line.decode(&quot;utf-8&quot;)).group(1)

    if &quot;/&quot; == file_name:
        file_name = &quot;/index.html&quot;
    # 打开文件，读取内容
    try:
        file = open(HTML_ROOT_DIR + file_name,&quot;rb&quot;)
    except IOError:
        response_start_line = &quot;HTTP/1.1 404 Not Found\r\n&quot;
        response_headers = &quot;Server: My server\r\n&quot;
        response_body = &quot;the file is not found&quot;
    else:
        file_data = file.read()
        file.close()

        # 构造响应数据
        response_start_line = &quot;HTTP/1.1 200 OK\r\n&quot;
        response_headers = &quot;Server: My server\r\n&quot;
        response_body = file_data.decode(&quot;utf-8&quot;)

    response = response_start_line + response_headers + &quot;\r\n&quot; + response_body
    print(&quot;response:&quot;,response)

    # 向客户端返回响应数据
    client_socket.send(bytes(response,&quot;utf-8&quot;))

    #关闭客户端链接
    client_socket.close()

def main():
    server_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
    #SOL_SOCKET:设置选项级别为SOCKET
    #SO_REUSEADDR:1
    server_socket.bind((&quot;&quot;,7788))
    server_socket.listen(128)

    while True:
        client_socket,client_address= server_socket.accept()
        print(&quot;[%s,%s]用户连接上了&quot;%(client_address))
        handle_client_process = Process(target=handle_client,args=(client_socket,))
        handle_client_process.start()
        client_socket.close()

if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
<h2 id="访问Web服务器"><a href="#访问Web服务器" class="headerlink" title="访问Web服务器"></a>访问Web服务器</h2><p>在浏览器地址栏输入 127.0.0.1:7788或127.0.0.1:7788/index.html</p>
<h2 id="项目文件结构"><a href="#项目文件结构" class="headerlink" title="项目文件结构"></a>项目文件结构</h2><p><img src="/2020/11/09/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.JPG" alt="文件结构"></p>
]]></content>
      <tags>
        <tag>Web服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础 | 递归与分治</title>
    <url>/2020/10/16/algorithms-2/</url>
    <content><![CDATA[<h1 id="递归与分治策略"><a href="#递归与分治策略" class="headerlink" title="递归与分治策略"></a>递归与分治策略</h1><p><b style="color:red">分治与递归经常同时应用在算法设计中</b></p>
<h2 id="递归（Recursion）"><a href="#递归（Recursion）" class="headerlink" title="递归（Recursion）"></a>递归（Recursion）</h2><p>递归算法—<b>直接或间接地调用自身</b>的较小模式的算法<br>递归函数—用函数自身的较小模式给出其定义的函数</p>
<span id="more"></span>
<h3 id="example1-Fibonacci-Series"><a href="#example1-Fibonacci-Series" class="headerlink" title="example1:Fibonacci Series"></a>example1:Fibonacci Series</h3><p>Code1:</p>
<pre><code>fibonacci(int n)
&#123;
    if(n&lt;=1) return 1;//递归边界
    else return fibonacci(n-1)+fibonacci(n-2);//递归方程
&#125;
</code></pre>
<p>时间复杂度:T(n)=sqrt(2)^n<br>时间复杂度过高的原因：存在很多重复的计算</p>
<p>Code2:</p>
<pre><code>fibonacci(int n)
&#123;
    int f[3]=&#123;1,1&#125;;
    
    for(i=0;i&lt;=n;i++)
    &#123;
        f[2]=f[0]+f[1]; f[0]=f[1]; f[1]=f[2];
    &#125;
    
    return f[2];
&#125;
</code></pre>
<p>时间复杂度：O(n)</p>
<p><b style="color:red">设计更快的算法！！！</b></p>
<h3 id="example2-Hanoi塔"><a href="#example2-Hanoi塔" class="headerlink" title="example2:Hanoi塔"></a>example2:Hanoi塔</h3><p>Code:</p>
<pre><code>hanoi(int n,char a,char b,char c)//T(n)=O(2^n)
&#123;//将塔座a上的盘子移到塔座b上，塔座c为辅助塔座
    if(n&gt;0)
    &#123;
        hanoi(n-1,a,c,b);
        move(a,b);
        hanoi(n-1,c,b,a);
    &#125;
&#125;
</code></pre>
<h3 id="递归小结"><a href="#递归小结" class="headerlink" title="递归小结"></a>递归小结</h3><p>优点：结构清晰、可读性强—&gt;设计算法、调试程序比较方便<br>缺点：程序运行效率低</p>
<h2 id="分治-Divide-and-Conquer"><a href="#分治-Divide-and-Conquer" class="headerlink" title="分治(Divide and Conquer)"></a>分治(Divide and Conquer)</h2><h3 id="适用条件："><a href="#适用条件：" class="headerlink" title="适用条件："></a>适用条件：</h3><ol>
<li>该问题的规模缩小到一定程度就可以容易地解决</li>
<li>该问题<b>可以分解为若干个规模较小的相同问题</b>，即该问题具有最优子结构性质</li>
<li>该问题分解出的子问题的解可以<b>合并</b>为该问题的解</li>
<li>该问题分解出的各个子问题是相互独立的（<b>子问题之间不包含公共的子问题</b>）</li>
</ol>

<h3 id="基本步骤："><a href="#基本步骤：" class="headerlink" title="基本步骤："></a>基本步骤：</h3><pre><code>divide-and-conquer(p)
&#123;
    if(|p|&lt;=n0) naive(p);//解决朴素问题
    divide p into smaller p1,p2...pa//分解问题
    for(i=1;i&lt;=a;i++)
    &#123;
        yi=divide-and-conquer(pi);//递归的解各子问题
    &#125;
    return merge(y1,y2...ya);将子问题的解合并为原问题解
&#125;
</code></pre>
<p><b style="color:yellow">Note:</b><br>在用分治法设计算法时，最好使子问题的规模大致相同(将一个问题分为大小相等的a个子问题的处理方法是行之有效的)。<br>这种做法出自<strong>平衡子问题</strong>的思想</p>
<h3 id="example1-Binary-Search-Algorithm"><a href="#example1-Binary-Search-Algorithm" class="headerlink" title="example1:Binary Search Algorithm"></a>example1:Binary Search Algorithm</h3><p>Code:</p>
<pre><code>binarySearch(int a[],int x)//T(n) = O(logn)
&#123;
    int n = sizeof(a),left = 0,right = n-1;
    
    while (left&lt;=right)
    &#123;
        int middle = (left+right)/2;
        if(x == a[middle]) return middle;
        if(x&gt;a[middle]) left = middle + 1;
        else right = middle-1;
    &#125;
    
    return -1;//x not found
&#125;
</code></pre>
<h3 id="example2-Powering-a-number"><a href="#example2-Powering-a-number" class="headerlink" title="example2:Powering a number"></a>example2:Powering a number</h3><p><b>Problem:</b>Compute a^n,where n is subjected to N.<br><b>Naive algorithm:</b>O(n)<br><b>Divide-and-conquer algorithm:</b><br>Code:</p>
<pre><code>power(int a,int n)//T(n)=O(logn)
&#123;
    if(n==1) return a;
    else if(n%2==0) return power(a,n/2)*power(a,n/2);
    else return power(a,(n-1)/2*power(a,(n-1)/2*a);
&#125;
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
        <category>算法基础</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>requests | 批量下载公众号文章</title>
    <url>/2021/11/05/batch-download-gzh-article/</url>
    <content><![CDATA[<h1 id="批量下载公众号文章"><a href="#批量下载公众号文章" class="headerlink" title="批量下载公众号文章"></a>批量下载公众号文章</h1><p>程序实现从公众号批量下载文章并保存为pdf.</p>
<span id="more"></span>
<p>代码：</p>
<pre><code># import requests
# import json
#
# url = &quot;https://mp.weixin.qq.com/mp/profile_ext&quot;  # 公号的链接
# headers = &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) &quot;
#                          &quot;Chrome/83.0.4103.116 Safari/537.36 &quot;&#125;
# proxies = &#123;
#     &#39;https&#39;: None,
#     &#39;http&#39;: None,
# &#125;
# uin = &#39;MjU1Mjg4NjAzNQ==&#39;
# # Key会随时间变化，需要获取最新的key，不然抓取不到数据
# key = &#39;3390dbef8687839b29dd8a2499d96e7ee28002a981da4f1d962e56d4c93430eef1b27ae1dc2e2304590ee88091fcb33e6f59df16f55cf9fa4516fa6ab77f5db7055f877e3b48007fc57fc07a522d0b0d1d15c3ee0ca047f22cd49301079a0e10b01df3fe4069bbdb4dd2cbe38cfa1dcb3ac01a93dd04c8e01504896fcab7d8be&#39;
# # 重要参数
# params = &#123;
#     &#39;action&#39;: &#39;getmsg&#39;,
#     &#39;__biz&#39;: &#39;MzU4ODg3MzAwNw==&#39;,  # 每个公众号的不一样，从Fiddler复制过来
#     &#39;f&#39;: &#39;json&#39;,
#     &#39;offset&#39;: 0,  # 控制翻页
#     &#39;count&#39;: &#39;10&#39;,
#     &#39;is_ok&#39;: &#39;1&#39;,
#     &#39;scene&#39;: &#39;124&#39;,
#     &#39;uin&#39;: uin,  # 每个公众号的不一样，从Fiddler复制过来
#     &#39;key&#39;: key,  # 每个公众号的不一样，从Fiddler复制过来
#     &#39;wxtoken&#39;: &#39;&#39;,
#     &#39;x5&#39;: &#39;0&#39;,
# &#125;
#
# # 获取公众号页面信息
# response = requests.get(url, headers=headers, params=params, proxies=proxies)
# # print(response.text)
# # print(type(response.text))
# response_dict = json.loads(response.text)  # 将字符串转换成python能识别的格式
# # print(response_dict)
#
# general_msg_list = response_dict[&#39;general_msg_list&#39;]  # 此时是字符串
# # print(general_msg_list)
# data_list = json.loads(general_msg_list)[&#39;list&#39;]  # 转换成python能够识别的格式，并取出文章链接的信息
# print(data_list)

# print(data_list[0])

import requests
import json
import time


def article_links(index):
    &quot;&quot;&quot;用于获取单个页面的文章链接，index用于控制页数&quot;&quot;&quot;
    links = []
    url = &#39;https://mp.weixin.qq.com/mp/profile_ext&#39;
    headers = &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) &quot;
                             &quot;Chrome/83.0.4103.116 Safari/537.36 &quot;&#125;
    proxies = &#123;
        &#39;https&#39;: None,
        &#39;http&#39;: None,
    &#125;
    uin = &#39;MjU1Mjg4NjAzNQ==&#39;
    # # Key会随时间变化，需要获取最新的key，不然抓取不到数据
    key = &#39;3390dbef8687839b29dd8a2499d96e7ee28002a981da4f1d962e56d4c93430eef1b27ae1dc2e2304590ee88091fcb33e6f59df16f55cf9fa4516fa6ab77f5db7055f877e3b48007fc57fc07a522d0b0d1d15c3ee0ca047f22cd49301079a0e10b01df3fe4069bbdb4dd2cbe38cfa1dcb3ac01a93dd04c8e01504896fcab7d8be&#39;
    # 重要参数
    params = &#123;
        &#39;action&#39;: &#39;getmsg&#39;,
        &#39;__biz&#39;: &#39;MzU4ODg3MzAwNw==&#39;,  # 每个公众号的不一样，从Fiddler复制过来
        &#39;f&#39;: &#39;json&#39;,
        &#39;offset&#39;: 0,  # 控制翻页
        &#39;count&#39;: &#39;10&#39;,
        &#39;is_ok&#39;: &#39;1&#39;,
        &#39;scene&#39;: &#39;124&#39;,
        &#39;uin&#39;: uin,  # 每个公众号的不一样，从Fiddler复制过来
        &#39;key&#39;: key,  # 每个公众号的不一样，从Fiddler复制过来
        &#39;wxtoken&#39;: &#39;&#39;,
        &#39;x5&#39;: &#39;0&#39;,
    &#125;
    response = requests.get(url, headers=headers, params=params, proxies=proxies)
    response_dict = json.loads(response.text)
    can_msg_continue = response_dict.get(&#39;can_msg_continue&#39;)  # 用于判断是否是最后一页，若为0，则表示最后一页
    general_msg_list = response_dict.get(&#39;general_msg_list&#39;)
    data_list = json.loads(general_msg_list)[&#39;list&#39;]
    for data in data_list:
        # 部分公众号文章是“消息”，因此data里的数据缺少我们需要的字段，需要跳过
        try:
            title = data[&#39;app_msg_ext_info&#39;][&#39;title&#39;]  # 文章标题
            datetime = data[&#39;comm_msg_info&#39;][&#39;datetime&#39;]  # 获取时间戳
            date = time.strftime(&#39;%Y-%m-%d&#39;, time.localtime(datetime))  # 将时间戳转换为本地时间
            url = data[&#39;app_msg_ext_info&#39;][&#39;content_url&#39;]  # 文章链接
            info = &#123;
                &quot;url&quot;: url,
                &quot;title&quot;: title,
                &quot;date&quot;: date,
            &#125;
            links.append(info)
        except:
            pass
    return links, can_msg_continue


all_links = []
for i in range(100):  # 根据实际而定，因为每页10篇文章，100页对应1000篇文章
    all_links.extend(article_links(i)[0])
    if article_links(i)[1] == 0:
        break
print(all_links[:])

print(len(all_links))


import pdfkit
import wechatsogou


def link_to_pdf(url, title, date):
    ws_api = wechatsogou.WechatSogouAPI(captcha_break_time=3)  # 调用接口
    content_info = ws_api.get_article_content(url)  # 请求链接
    content = content_info[&#39;content_html&#39;]  # 转换为html格式
    # 将标题和文章内容放入如下html中处理以下
    html = f&#39;&#39;&#39;
            &lt;!DOCTYPE html&gt;
            &lt;html lang=&quot;en&quot;&gt;
            &lt;head&gt;
                &lt;meta charset=&quot;UTF-8&quot;&gt;
                &lt;title&gt;&#123;title&#125;&lt;/title&gt;
            &lt;/head&gt;
            &lt;body&gt;
            &lt;h2 style=&quot;text-align: center;font-weight: 400;&quot;&gt;&#123;title&#125;&lt;/h2&gt;
            &#123;content&#125;
            &lt;/body&gt;
            &lt;/html&gt;&#39;&#39;&#39;
    path_wkthmltopdf = r&quot;E:\my\python_project\70个python实战项目\实例70_Python批量将公号文章保留原格式下载为PDF\wkhtmltox\bin\wkhtmltopdf.exe&quot;  # wkhtmltopdf可执行程序路径
    config = pdfkit.configuration(wkhtmltopdf=path_wkthmltopdf)  # 配置pdfkit
    pdfkit.from_string(html, f&quot;&#123;title&#125; &#123;date&#125;.pdf&quot;, configuration=config)  # 转PDF，并按设定好的命名文件
    print(f&quot;&#123;title&#125;.pdf 已下载&quot;)


for link in all_links:
    url = link[&#39;url&#39;]
    title = link[&#39;title&#39;]
    date = link[&#39;date&#39;]
    link_to_pdf(url, title, date)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>requests</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>requests</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>spring | bean的作用域</title>
    <url>/2022/03/05/bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<h1 id="bean的作用域"><a href="#bean的作用域" class="headerlink" title="bean的作用域"></a>bean的作用域</h1><p>1.项目目录<br><img src="/2022/03/05/bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/1.PNG"></p>
<p>2.Student.java</p>
<pre><code>package com.atguigu.ioc.scope;

public class Student &#123;
    private Integer sid;
    private String sname;
    public Student() &#123;
        System.out.println(&quot;Student 无参构造方法&quot;);
    &#125;
    public Integer getSid() &#123;
        return sid;
    &#125;
    public void setSid(Integer sid) &#123;
        this.sid = sid;
    &#125;
    public String getSname() &#123;
        return sname;
    &#125;
    public void setSname(String sname) &#123;
        this.sname = sname;
    &#125;
//    @Override
//    public String toString() &#123;
//        return &quot;Student [sid=&quot; + sid + &quot;, sname=&quot; + sname + &quot;]&quot;;
//    &#125;
&#125;
</code></pre>
<p>3.scope.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    
    &lt;bean id=&quot;student&quot; class=&quot;com.atguigu.ioc.scope.Student&quot; scope=&quot;singleton&quot;&gt;
        &lt;property name=&quot;sid&quot; value=&quot;1001&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;sname&quot; value=&quot;张三&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>4.Test.java</p>
<pre><code>package com.atguigu.ioc.scope;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test &#123;
    public static void main(String[] args)&#123;
        /**
         * 若spring中有单例模式（singleton）的bean，在初始化容器时就会创建此对象
         * 而多例即原型(prototype)的bean，会在使用时创建
         */
        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;scope.xml&quot;);
        
//        Student student1 = ac.getBean(&quot;student&quot;,Student.class);
//        Student student2 = ac.getBean(&quot;student&quot;,Student.class);
//        
//        System.out.println(student1);
//        System.out.println(student2);
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>spring</category>
        <category>bean的作用域</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring | bean的生命周期</title>
    <url>/2022/03/05/bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="bean的生命周期、bean的后置处理器"><a href="#bean的生命周期、bean的后置处理器" class="headerlink" title="bean的生命周期、bean的后置处理器"></a>bean的生命周期、bean的后置处理器</h1><p>1.项目目录<br><img src="/2022/03/05/bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/1.PNG"></p>
<p>2.bean的生命周期（******）<br>① 通过构造器或工厂方法创建bean实例<br>② 为bean的属性设置值和对其他bean的引用<br>③ 调用bean的初始化方法<br>④  bean可以使用了<br>⑤ 当容器关闭时，调用bean的销毁方法</p>
<p>3.Person.java</p>
<pre><code>package com.atguigu.ioc.life;

public class Person &#123;
    private Integer id;
    private String sex;
    private String name;
    
    public Integer getId() &#123;
        return id;
    &#125;
    
    public void setId(Integer id) &#123;
        System.out.println(&quot;Two:依赖注入&quot;);
        this.id = id;
    &#125;
    
    public String getSex() &#123;
        return sex;
    &#125;
    
    public void setSex(String sex) &#123;
        this.sex = sex;
    &#125;
    
    public String getName() &#123;
        return name;
    &#125;
    
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    
    public Person() &#123;
        System.out.println(&quot;One:创建对象&quot;);
    &#125;
    
    public void init()&#123;
        System.out.println(&quot;Three:初始化&quot;);
    &#125;
    
    

    @Override
    public String toString() &#123;
        return &quot;Four: Person [id=&quot; + id + &quot;, sex=&quot; + sex + &quot;, name=&quot; + name + &quot;]&quot;;
    &#125;

    public void destroy()&#123;
        System.out.println(&quot;Five:销毁&quot;);
    &#125;
&#125;
</code></pre>
<p>4.AfterHandler.java(后置处理器)</p>
<pre><code>package com.atguigu.ioc.life;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;

public class AfterHandler implements BeanPostProcessor&#123;

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;
        // TODO Auto-generated method stub
        return bean;
    &#125;

    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;
        Person person = (Person)bean;
        if(person.getSex().equals(&quot;男&quot;))&#123;
            person.setName(&quot;张无忌&quot;);
        &#125;else&#123;
            person.setName(&quot;赵敏&quot;);
        &#125;
        return person;
    &#125;
 
&#125;
</code></pre>
<p>5.life.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    
    &lt;!-- 测试bean的生命周期 --&gt;
    &lt;bean id=&quot;person&quot; class=&quot;com.atguigu.ioc.life.Person&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;&gt;
        &lt;property name=&quot;id&quot; value=&quot;1001&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;sex&quot; value=&quot;男&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    
    &lt;!-- 测试后置处理器 --&gt;
    &lt;bean class=&quot;com.atguigu.ioc.life.AfterHandler&quot;&gt;&lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>6.Test.java</p>
<pre><code>package com.atguigu.ioc.life;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test &#123;
    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;life.xml&quot;);
        
        Person person = ac.getBean(&quot;person&quot;, Person.class);
        System.out.println(person);
        
        ac.close();
    &#125;
&#125;
</code></pre>
<p>7.运行结果</p>
<pre><code>One:创建对象
Two:依赖注入
Three:初始化
Four: Person [id=1001, sex=男, name=张无忌]
二月 15, 2022 4:34:28 下午 org.springframework.context.support.ClassPathXmlApplicationContext doClose
信息: Closing org.springframework.context.support.ClassPathXmlApplicationContext@2dda6444: startup date [Tue Feb 15 16:34:27 CST 2022]; root of context hierarchy
Five:销毁
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>spring</category>
        <category>bean的生命周期、bean的后置处理器</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>伪迹移除 | comparison of methods of artifacts removal</title>
    <url>/2021/02/09/comparison-of-methods-of-artifacts-removal/</url>
    <content><![CDATA[<h1 id="Comparison-of-Methods-of-Artifacts-Removal"><a href="#Comparison-of-Methods-of-Artifacts-Removal" class="headerlink" title="Comparison of Methods of Artifacts Removal"></a>Comparison of Methods of Artifacts Removal</h1><div style>
    <h1 style="color: red">Regression Methods</h1>
    <p>
        Regression methods often assume that the scal potential is a <em>linear combination</em> of brain and other potentials(EOG、ECG、EMG).By subtracting propagated EOG/ECG/EMG from EEG recordings,EEG signals can be recovered.
    </p>
    <p>
        Regression can also be done in frequency domain based on the concept that <em>subtraction in the frequency domain is equivalent to filtering in the time domain</em>.By eliminating spectral estimates of EOG/EMG/ECG from EEG recordings,it is possible to recover the non-contaminated EEG.
    </p>
    <p style>
        <b>Disadvantages:</b>
        Both types of regression methods are <em>off-line and rely on EOG/ECG/EMG recordings</em>,which are however,not always available.
    </p>
</div>
<hr>
<span id="more"></span>

<div style>
    <h1 style="color: red">PCA(Principle Component Analysis)</h1>
    <p>
        This method assumes that each <em>EEG channel recording is simultaneously generated by multiple sources</em> across the scalp. By decomposing multiple channel EEG data into principle components using PCA,the artifactual sources can be identified and removed.
    </p>
    <p style>
        <b>Disadvantages:</b>
        PCA methods usually <em>failed to completely separate artifacts</em> from cerebral activities,and the <em>orthogonal assumption</em> fro data components,which is always required while using PCA,is <em>hardly satisfied</em>.
    </p>
</div>
<hr>

<div style>
    <h1 style="color:red">ICA(Independent Component Analysis)</h1>
    <p>
        ICA was originally developed fro blind source separation(<em>BSS</em>)
    </p>
    <p style>
        <b>Disadvantages:</b>
        ICA usually requires a large amount of data and visual inspection to eliminate noisy independent components,making the method <em>time-consuming and not suitable for real-time applications</em>.        
    </p>
</div>
<hr>

<div style>
    <h1 style="color:red">Wavelet Analysis</h1>
    <p>
        It is effective to mesure and manipulate <em>non-stationary signals</em>.In wavelet-based methods,the wavelet thresholding techniques have received significant attention.For this class of methods,wavelet coefficitents at low-frequency sub-bands are corrected by some thresholding functions before signal reconstruction.
    </p>
    <p style>
        <b>Advantages:</b>
        As an online artifact removal method,the most important advantage of using this method for EEG correction is that <em>it does not rely on either the reference signal or visual inspection.
    </em></p>
    <p style>
        <b>Disadvantages:</b>
        It performance is not consistent because the method is sensitive to the selections of wavelet basis and thresholding functions.
    </p>
</div>






]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>伪迹移除</category>
      </categories>
      <tags>
        <tag>ICA</tag>
        <tag>PCA</tag>
        <tag>小波变换</tag>
      </tags>
  </entry>
  <entry>
    <title>cookie | cookie</title>
    <url>/2021/07/29/cookie/</url>
    <content><![CDATA[<p>在基于HTTP的请求当中，客户端发送请求到服务器端，服务器端响应请求返回一些信息（包含cookie）。<br>1.cookie是什么？<br>cookie:存储在浏览器当中的文本信息，存储格式：键值对，一旦你访问某个网站，存储了这个键值对，后面再次请求这个服务器时，cookie会自动加到请求报文的头里面发送到服务器。<br><img src="/2021/07/29/cookie/cookie1.png"><br>2.cookie是怎么来的？<br>我们在服务器端设置（set_cookie()）的，通过response返回到浏览器，浏览器将cookie存储下来<br><strong>注：cookie是区别于域名的，跨域名不能共享cookie信息</strong><br>3.一种常见的场景<br>假设我们在淘宝网站浏览了运动鞋商品，在我们浏览其他网站时会看到与我们之前浏览的运动鞋类似的商品推荐，<br>“cookie是区别于域名的”，这句话似乎错了？？<br>答：此时的现象并不是其他网站读取了淘宝网站的cookie，而是在其他网站内嵌了淘宝网站，即此时的运动鞋商品<br>推荐的信息是从淘宝网站本身读取到的，原理如下图所示：<br><img src="/2021/07/29/cookie/cookie.png"></p>
]]></content>
      <categories>
        <category>cookie</category>
      </categories>
      <tags>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title>Django | django中两种模板目录设置</title>
    <url>/2021/07/30/django%E4%B8%AD%E4%B8%A4%E7%A7%8D%E6%A8%A1%E6%9D%BF%E7%9B%AE%E5%BD%95%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="django中两种模板目录设置"><a href="#django中两种模板目录设置" class="headerlink" title="django中两种模板目录设置"></a>django中两种模板目录设置</h1><p>在进行django项目开发中，我们需要创建一个用于存放模板的文件夹，模板文件夹通常放在以下两个位置之一。<br>第一种的项目目录为蓝色框所框选的目录，第二种的项目目录为红色框所框选的目录。<br><img src="/2021/07/30/django%E4%B8%AD%E4%B8%A4%E7%A7%8D%E6%A8%A1%E6%9D%BF%E7%9B%AE%E5%BD%95%E8%AE%BE%E7%BD%AE/content.png"></p>
<h2 id="位置（1）的优缺点："><a href="#位置（1）的优缺点：" class="headerlink" title="位置（1）的优缺点："></a>位置（1）的优缺点：</h2><p><strong>优点：</strong> 便于移植（首次开发完application应用，可将application应用移植到其他项目）<br><strong>缺点：</strong> 项目下的每个应用都有一个templates文件夹，不便于管理</p>
<h2 id="位置（2）的优缺点："><a href="#位置（2）的优缺点：" class="headerlink" title="位置（2）的优缺点："></a>位置（2）的优缺点：</h2><p><strong>优点：</strong> 便于管理模板文件<br><strong>缺点：</strong> 不方便移植到其他项目中</p>
]]></content>
      <categories>
        <category>python</category>
        <category>框架</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django | django中模板文件中的链接地址怎么写</title>
    <url>/2021/07/28/django%E4%B8%AD%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80%E6%80%8E%E4%B9%88%E5%86%99/</url>
    <content><![CDATA[<h1 id="django中模板文件中的链接地址怎么写"><a href="#django中模板文件中的链接地址怎么写" class="headerlink" title="django中模板文件中的链接地址怎么写?"></a>django中模板文件中的链接地址怎么写?</h1><p>在进行django项目开发中，通常会遇到一个场景：我们在当前页面点击一个链接，跳转到其他的页面，<br>那么在当前页面中的这个标签中的地址我们应该如何去写？</p>
<span id="more"></span>

<p><img src="/2021/07/28/django%E4%B8%AD%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80%E6%80%8E%E4%B9%88%E5%86%99/1.png"><br>假定我们当前处于 <a href="http://www.xxx.com/doc/a.html">www.xxx.com/doc/a.html</a> ,我们需要跳转到 b.html，那么我们可以这样写标签中的url,<br><a href="/b.html">,在这里url中的第一个斜杠代表的是根目录（www.xxx.com），之后浏览器将会把这个url<br>解析为 www.xxx.com/b.html。</a></p>
<p>另一种情况：<br>假设我们将标签中的url写为 <a href="b.html"></a>,浏览器将会把此url地址解析为 <a href="http://www.xxx.com/doc/b.html">www.xxx.com/doc/b.html</a> ,<br>前面没有斜杠即从为当前目录。</p>
]]></content>
      <categories>
        <category>python</category>
        <category>框架</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django | django开发流程</title>
    <url>/2021/04/15/django%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="django开发流程"><a href="#django开发流程" class="headerlink" title="django开发流程"></a>django开发流程</h1><p>1.安装虚拟环境<br>conda create -n python27 python==2.7<br>2..安装django<br>pip install django==1.8.2<br>3.创建项目<br>django-adming startproject project_name<br>4.创建应用<br>python manage.py startapp app_name<br>5.将app应用加入到installed_apps中<br>6.app_name/models.py中定义模型类<br>6.数据库配置(settings.py-DATABASES)<br>7.生成迁移文件<br>python manage.py makemigrations<br>8.执行迁移<br>python manage.py migrate<br>9.开启服务器<br>python manage.py runserver ip:port<br>10.创建管理员用户<br>python manage.py createsuperuser，按提示输入用户名、邮箱、密码<br>11.向admin注册app_name的模型<br>app_name/admin.py<br>admin.site.register(BookInfo)</p>
<p>注：<br>python shell—python manage.py shell</p>
]]></content>
      <categories>
        <category>python</category>
        <category>框架</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb项目开发 | el表达式</title>
    <url>/2022/01/11/el%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="el表达式"><a href="#el表达式" class="headerlink" title="el表达式"></a>el表达式</h1><ol>
<li>el表达式<br><img src="/2022/01/11/el%E8%A1%A8%E8%BE%BE%E5%BC%8F/1.PNG"></li>
<li>测试el表达式</li>
</ol>
<pre><code>&lt;%@page import=&quot;com.oracle.bean.Product&quot;%&gt;
&lt;%@page import=&quot;java.util.HashMap&quot;%&gt;
&lt;%@page import=&quot;java.util.ArrayList&quot;%&gt;
&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;%
        //在request域中设置简单数据
        request.setAttribute(&quot;a&quot;, 1);
        request.setAttribute(&quot;b&quot;, 1);
        
        //在request域中设置复杂数据(ArrayList)
        ArrayList&lt;String&gt; arr = new ArrayList&lt;String&gt;();
        arr.add(&quot;zhangsan&quot;);
        arr.add(&quot;lisi&quot;);
        arr.add(&quot;wangwu&quot;);
        request.setAttribute(&quot;list&quot;, arr);
        
        //在request域中设置复杂数据(HashMap)
        HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
        map.put(&quot;a&quot;, &quot;A&quot;);
        map.put(&quot;b&quot;, &quot;B&quot;);
        map.put(&quot;c&quot;, &quot;C&quot;);
        request.setAttribute(&quot;map&quot;, map);
        
        //在request域中设置复杂数据(JavaBean)
        Product p = new Product();
        p.setId(1);
        p.setPname(&quot;黄瓜&quot;);
        p.setPrice(15.2);
        p.setPdesc(&quot;黄瓜好吃，香&quot;);
        request.setAttribute(&quot;p&quot;, p);
    %&gt;
    
    &lt;%=request.getAttribute(&quot;a&quot;) %&gt;
    
    $&#123;a+b&#125;&lt;br&gt;
    
    $&#123;list[0]&#125;&lt;br&gt;
    
    $&#123;map.a&#125;&lt;br&gt;
    
    $&#123;p.pname&#125;&lt;br&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="3">
<li>效果<br><img src="/2022/01/11/el%E8%A1%A8%E8%BE%BE%E5%BC%8F/2.PNG"></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb项目开发</category>
        <category>el表达式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>el表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>Django | django自定义错误页面</title>
    <url>/2021/07/28/django%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[<h1 id="django自定义错误页面"><a href="#django自定义错误页面" class="headerlink" title="django自定义错误页面"></a>django自定义错误页面</h1><p>在进行django项目开发时，如果用户请求一个不存在的页面，将会显示以下界面：<br><img src="/2021/07/28/django%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2/1.png"><br>我们可以自定义一个错误页面来展示提示信息。</p>
<p>django版本：1.8.2</p>
<p><strong>步骤：</strong><br>1.修改settings.py</p>
<pre><code>DEBUG = False
ALLOWED_HOSTS = [&#39;*&#39;]
</code></pre>
<p>2.在templates文件夹下创建404.html页面</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
找不到了
&lt;hr/&gt;
&#123;&#123; request_path &#125;&#125;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>3.运行服务器，访问一个不存在的页面，将显示自定义的错误页面<br><img src="/2021/07/28/django%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2/2.png"></p>
]]></content>
      <categories>
        <category>python</category>
        <category>框架</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb项目开发 | filter</title>
    <url>/2022/01/11/filter/</url>
    <content><![CDATA[<h1 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h1><h2 id="filter-1"><a href="#filter-1" class="headerlink" title="filter"></a>filter</h2><ol>
<li>filter是什么？<br>servlet2.3后增加的新功能,运行在服务器端的程序，先于与之相关的servlet或者jsp页面之前运行</li>
<li>作用<br>过滤请求和相应</li>
<li>应用场景<br>(1)自动登录<br>(2)统一编码<br>(3)过滤特殊符号或敏感词<h2 id="filter程序编写"><a href="#filter程序编写" class="headerlink" title="filter程序编写"></a>filter程序编写</h2></li>
<li>编写一个类</li>
<li>1 实现一个Filter接口</li>
<li>2 重写接口所有的方法</li>
<li>编写配置文件</li>
<li>1 注册filter</li>
<li>2 绑定路径</li>
<li>2.1 完全匹配 例如：/demo1</li>
<li>2.2 目录匹配 例如: /* 过滤所有请求<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2></li>
<li>项目目录<br><img src="/2022/01/11/filter/1.PNG"></li>
<li>代码</li>
</ol>
<p><strong>Demo1Filter</strong></p>
<pre><code>package com.oracle.filter;

import java.io.IOException;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;

public class Demo1Filter implements Filter&#123;

    @Override
    public void destroy() &#123;
        // TODO Auto-generated method stub
        
    &#125;

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException &#123;
        // TODO Auto-generated method stub
        System.out.println(&quot;Demo1Filter过滤到请求.../demo1&quot;);
        
        //放行
        chain.doFilter(request, response);
    &#125;

    @Override
    public void init(FilterConfig arg0) throws ServletException &#123;
        // TODO Auto-generated method stub
        
    &#125;

&#125;
</code></pre>
<p><strong>web.xml</strong><br><img src="/2022/01/11/filter/2.PNG"><br><strong>Demo1Servlet</strong></p>
<pre><code>package com.oracle.servlet;

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

public class Demo1Servlet extends HttpServlet &#123;
    private static final long serialVersionUID = 1L;

    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        System.out.println(&quot;Demo1Servlet接收到请求.../demo1&quot;);
    &#125;

    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        doGet(request, response);
    &#125;
&#125;
</code></pre>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="/2022/01/11/filter/3.PNG"></p>
<p><img src="/2022/01/11/filter/4.PNG"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb项目开发</category>
        <category>filter</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>filter</tag>
      </tags>
  </entry>
  <entry>
    <title>脑电基础知识 | five major brain waves</title>
    <url>/2020/12/07/five-major-brain-waves/</url>
    <content><![CDATA[<h1 id="Five-Major-Brain-Waves"><a href="#Five-Major-Brain-Waves" class="headerlink" title="Five Major Brain Waves"></a>Five Major Brain Waves</h1><p>Five major brain waves can be distinguished by their frequency ranges:</p>
<p>|frequency band|frequency range|<br>|—–|—-|—-|<br>|delta|0.5-4Hz|appears for continuous-attention tasks|<br>|theta|4-8Hz|spikes when repressing(抑制) a response or action|<br>|alpha|8-13Hz|measures relax or closing eyes|<br>|beta|13-30Hz|reflects active thinking,focus,high alert or anxiety|<br>|gamma|30-50Hz|displays during cross-modal sensory processing|</p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>脑电基础知识</category>
      </categories>
      <tags>
        <tag>EEG</tag>
      </tags>
  </entry>
  <entry>
    <title>论文框架与写作技巧 | 论文框架</title>
    <url>/2021/02/10/framework-of-paper/</url>
    <content><![CDATA[<h1 id="Framework-of-Paper"><a href="#Framework-of-Paper" class="headerlink" title="Framework of Paper"></a>Framework of Paper</h1><div id="div1" style>
    <em>How to write a paper?</em><br>
    In fact,we need to write as follows:<br>
    Problem X is important<br>
    Previous works A, B, and C have been done<br>
    A, B, and C have their weakness<br>
    Your work D<br>
    Theoretical analysis<br>
    Experimental comparison against A, B, and C<br>
    Why D is better<br>
    Strength and weakness of D<br>
    Future work on D<br>
    So there is a framework of paper as folllows! 
    <span id="more"></span>
</div>


<div style>
    <h1 style="color: red">Title</h1>
    <h2 style="color: red">Abstract---Summarize your contributions</h2>
    What is the problem<br>
    What is your work<br>  
    Features of your work<br>  
    Advantages of your work<br>  
    Results<br>  
    <h2 style="color: red">Introduction---Background and organization of the paper</h2>
    Problem X is important<br>  
    A, B, and C have been done<br>  
    A, B, and C have their weakness<br>
    Our work D<br>
    Features and advantages of D<br>
    Results<br>
    Organization of the paper<br>
    <h2 style="color: red">Previous work---Why your work,the differences</h2>
    Categorization of previous works<br>
    One or two sentences for a work(Strength,Weakness)<br>
    <h2 style="color: red">Your contribution---Introduce your work</h2>
    Motivation<br>
    Definition,notation<br>
    Algorithm(Pseudocode,Diagram,Explanations)<br>
    <h2 style="color: red">Theoretical analysis---Theoretical support to your work</h2>
    Definition,notation<br>
    Lemma<br>
    Theorem<br>
    Proof<br>
    <h2 style="color: red">Experiments---Experimental to your work</h2>
    Experimental design<br>
    Comparison<br>
    Discussion<br>
    <h2 style="color: red">Discussion---The relationship between your work and some very related works</h2>
    Work A:<br>
    Why it is very related<br>
    Difference to your work<br>
    Work B:<br>
    Why it is very related<br>
    Difference to your work<br>
    <h2 style="color: red">Conclusion---summary and future work</h2>
    Summary<br>
    Future work<br>
    <h2 style="color: red">Acknowledgement</h2>
    <h2 style="color: red">Reference</h2>
    <h2 style="color: red">Appendix</h2>
</div>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>论文框架与写作技巧</category>
      </categories>
      <tags>
        <tag>论文</tag>
        <tag>论文框架</tag>
      </tags>
  </entry>
  <entry>
    <title>python | getattr()函数</title>
    <url>/2021/05/20/getattr-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="python-getattr-函数"><a href="#python-getattr-函数" class="headerlink" title="python getattr()函数"></a>python getattr()函数</h1><p>描述：getattr()函数用于返回一个对象属性值</p>
<p>参数：<br>object – 对象<br>name – 对象属性(字符串)<br>default – 默认返回值(如果不提供该参数，在没有对应属性时，将触发AttributeError)</p>
<p>实例：<br>class A(object):<br>    bar = 1</p>
<p>a = A()<br>print(getattr(a, ‘bar’))  # 获取属性bar值 result:1<br>print(getattr(a, ‘bar2’))  # 属性bar2不存在，触发异常<br>print(getattr(a, ‘bar2’, 3)  # result:3</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo | hexo博客上传PDF、PPT、EXCEL等资源</title>
    <url>/2021/10/18/hexo%E5%8D%9A%E5%AE%A2%E4%B8%8A%E4%BC%A0PdfPptExcel%E7%AD%89%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<h1 id="hexo博客上传PDF、PPT、EXCEL等资源"><a href="#hexo博客上传PDF、PPT、EXCEL等资源" class="headerlink" title="hexo博客上传PDF、PPT、EXCEL等资源"></a>hexo博客上传PDF、PPT、EXCEL等资源</h1><p><a href="https://benpaodewoniu.github.io/2020/04/28/hexo27/">hexo博客上传PDF、PPT、EXCEL等资源</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo | hexo博客换电脑了怎么办</title>
    <url>/2021/08/30/hexo%E5%8D%9A%E5%AE%A2%E6%8D%A2%E7%94%B5%E8%84%91%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E/</url>
    <content><![CDATA[<h1 id="hexo博客换电脑了怎么办"><a href="#hexo博客换电脑了怎么办" class="headerlink" title="hexo博客换电脑了怎么办"></a>hexo博客换电脑了怎么办</h1><p>我们搭建的hexo博客在更换电脑之后，如果重新搭建博客比较费时费力，可以按照以下资料快速在新的电脑上使用hexo博客发布内容。</p>
<p><a href="https://www.cnblogs.com/study-everyday/p/8902136.html">参考资料1</a><br><a href="https://www.cnblogs.com/study-everyday/p/8902136.html">参考资料2</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Java | java引用</title>
    <url>/2022/03/24/java%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h1 id="强软弱虚四大引用"><a href="#强软弱虚四大引用" class="headerlink" title="强软弱虚四大引用"></a>强软弱虚四大引用</h1><pre><code>import java.lang.ref.PhantomReference;
import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
import java.lang.ref.SoftReference;
import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

class StudentClass&#123;
    @Override
    protected void finalize() throws Throwable&#123;
        System.out.println(&quot;student对象被回收了&quot;);
    &#125;
&#125;

public class ReferencesTest &#123;
    public static void main(String[] args) &#123;
        
        /**
         * 强引用
         * 只要某个对象有强引用与之关联，这个对象永远不会被回收，即使内存不足，JVM宁愿抛出OOM，也不会去回收。
         */
        //StudentClass student = new StudentClass();
        //student = null;//断开强引用与对象之间的关联
        //System.gc();
        
        
        /**
         * 软引用
         * 内存不足时，JVM会回收软引用关联的对象
         * 
         * 比较适合用作缓存，当内存足够，可以正常的拿到缓存，当内存不够，就会先干掉缓存，不至于马上抛出OOM。
         */
//        SoftReference&lt;byte[]&gt; softReference = new SoftReference&lt;byte[]&gt;(new byte[1024*1024*10]);
//        System.out.println(softReference.get());
//        System.gc();
//        System.out.println(softReference.get());
//        byte[] bytes = new byte[1024 * 1024 * 10];
//        System.out.println(softReference.get());
        
        /**
         * 弱引用
         * 不管内存是否足够，只要发生GC，都会被回收
         */
//        WeakReference&lt;byte[]&gt; weakReference = new WeakReference&lt;byte[]&gt;(new byte[1]);
//        System.out.println(weakReference.get());
//        System.gc();
//        System.out.println(weakReference.get());
        
//        [B@15db9742
//         null
        
        /**
         * 虚引用
         * 特点一：无法通过虚引用来获取对一个对象的真实引用
         * 特点二：虚引用必须与ReferenceQueue一起使用，当GC准备回收一个对象，如果发现它还有虚引用，就会在回收之前，把这个虚引用加入到与之关联的ReferenceQueue中。
         * 
         * 
         * Unlike soft and weak references, phantom references are not
 automatically cleared by the garbage collector as they are enqueued.  An
object that is reachable via phantom references will remain so until all
such references are cleared or themselves become unreachable.
         */
        ReferenceQueue&lt;Object&gt; referenceQueue = new ReferenceQueue&lt;&gt;();
        List&lt;byte[]&gt; bytes = new ArrayList&lt;&gt;();
        PhantomReference&lt;StudentClass&gt; reference = new PhantomReference&lt;StudentClass&gt;(new StudentClass(),referenceQueue);
        
        new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 100;i++ ) &#123;
                bytes.add(new byte[1024 * 1024]);
            &#125;
        &#125;).start();
 
        new Thread(() -&gt; &#123;
            while (true) &#123;
                Reference poll = referenceQueue.poll();
                if (poll != null) &#123;
                    System.out.println(&quot;虚引用被回收了：&quot; + poll);
                &#125;
            &#125;
        &#125;).start();
        Scanner scanner = new Scanner(System.in);
        scanner.hasNext();
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
        <category>强软弱虚四大引用</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>引用</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb项目开发 | jdbc</title>
    <url>/2022/01/25/jdbc/</url>
    <content><![CDATA[<h1 id="jdbc"><a href="#jdbc" class="headerlink" title="jdbc"></a>jdbc</h1><p>在使用Java语言进行开发时，我们可以使用jdbc操作数据库；实际开发中我们通常直接导入数据库连接池（c3p0-0.9.1.2.jar）、<br>数据库驱动（mysql-connector-java-5.0.4-bin.jar）和简化jdbc操作的类库（commons-dbutils-1.4.jar）；并在c3p0-config.xml中配置数据库。<br><img src="/2022/01/25/jdbc/1.PNG"><br><strong>数据库配置（c3p0-config.xml）</strong><br>配置数据库的用户名、密码、驱动以及要连接的数据库<br>（本例连接用户名为root、密码为root、数据库驱动为mysql数据库驱动、连接的数据库为本地的test1数据库）</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;c3p0-config&gt;
    &lt;default-config&gt;
        &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt;
        &lt;property name=&quot;password&quot;&gt;root&lt;/property&gt;
        &lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt;
        &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql://127.0.0.1:3306/test1&lt;/property&gt;
    &lt;/default-config&gt; 
&lt;/c3p0-config&gt; 
</code></pre>
<p>注：以上三个jar包可在网上通过名称搜索自行下载。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb项目开发</category>
        <category>jdbc封装类和数据库连接池</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>jdbc</tag>
      </tags>
  </entry>
  <entry>
    <title>json</title>
    <url>/2022/03/13/json/</url>
    <content><![CDATA[<h1 id="json"><a href="#json" class="headerlink" title="json"></a>json</h1><p>1.json有两种对象<br>（1）json对象：{key1:value1,key2:value2,…}<br>（2）json数组：[value1,value2,…]<br>2.解析方式<br>（1）Json对象解析方式：对象.key<br>（2）json数组解析方式：for循环遍历<br>3.java对象转换json<br>（1）Bean和map—&gt;json对象<br>（2）List—&gt;json数组</p>
<p><strong>示例：</strong><br>数据：<br>    user：id=1,username=admin,age=23,sex=男</p>
<p>Xml方式:</p>
<pre><code>&lt;userinfo&gt;
    &lt;user&gt;
        &lt;id&gt;1&lt;/id&gt;
        &lt;username&gt;admin&lt;/username&gt;
        &lt;age&gt;23&lt;/age&gt;
        &lt;sex&gt;男&lt;/sex&gt;
    &lt;/user&gt;
&lt;/userinfo&gt;
</code></pre>
<p>Json方式:</p>
<pre><code>&#123;id:1,username:admin,age:23,sex:男&#125;
</code></pre>
]]></content>
      <categories>
        <category>json</category>
      </categories>
      <tags>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb项目开发 | jsp</title>
    <url>/2022/01/11/jsp/</url>
    <content><![CDATA[<h1 id="jsp"><a href="#jsp" class="headerlink" title="jsp"></a>jsp</h1><ol>
<li>什么是jsp?<br>java server pages(java服务器页面)，本质上就是一个servlet,运行在服务器端.</li>
<li>作用<br>可以在jsp嵌入java代码，动态展示数据</li>
<li>jsp的特定内容</li>
<li>1 jsp的脚本<br>&lt;%…%&gt;:写java程序片段<br>&lt;%=…%&gt;:输出表达式（输出表达式不能以分号结尾）</li>
<li>2 jsp的指令<br>（1）包含在.jsp文件的头部，声明当前页面的一些属性和行为</li>
</ol>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
        pageEncoding=&quot;UTF-8&quot;%&gt;
</code></pre>
<p>（2）taglib:导入标签库<br>s<br>    &lt;%@taglib prefix=”c” uri=”<a href="http://java.sun.com/jsp/jstl/core&quot;">http://java.sun.com/jsp/jstl/core&quot;</a> %&gt;<br>导入标签库后就可以使用jstl标签替换jsp中的if、for表达式。更多见<a href="https://victory-liao.github.io/2022/01/11/jstl%E6%A0%87%E7%AD%BE/">jstl标签</a><br>3.3 jsp中的域对象<br>request:当前请求<br>session:当前会话<br>3.4 jsp的动作标签<br>语法：&lt;jsp:动作标签 属性=”值”&gt;<br>例如： 将其他页面包含到当前页面 </p>
<pre><code>&lt;jsp:include page=&quot;/..&quot;&gt;&lt;/jsp:inclue&gt;
</code></pre>
<span id="more"></span>
<p>3.5 jsp测试</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!--定义两个变量--&gt;
    &lt;%
        int a = 1;
        int b = 2;
    %&gt;
    &lt;!--输出a+b的值--&gt;
    &lt;%=a+b %&gt;
    &lt;!--写if表达式--&gt;
    &lt;%
        if(a&gt;b)&#123;
        %&gt;
        &lt;font color=&quot;red&quot;&gt;a is 大于 b&lt;/font&gt;
        &lt;%
        &#125;else&#123;
            %&gt;
            &lt;font color=&quot;red&quot;&gt;a 小于 b&lt;/font&gt;
        &lt;%
        &#125;
    %&gt;
    &lt;!--写for语句--&gt;
    &lt;%
        for(int i=1;i&lt;11;i++)&#123;
            %&gt;
            &lt;%=i %&gt;
            &lt;% 
        &#125;
    %&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><img src="/2022/01/11/jsp/1.PNG"><br>3.5 jsp中的域对象测试</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;%
        request.setAttribute(&quot;username&quot;, &quot;zhangsan&quot;);
    %&gt;
    &lt;%=request.getAttribute(&quot;username&quot;) %&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><img src="/2022/01/11/jsp/2.PNG"><br>3.6 jsp动作标签测试<br>以下代码可以是开发中引入前端页面的共同部分<br><strong>a.jsp</strong></p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
11111111111111111
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>b.jsp</strong></p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;jsp:include page=&quot;/a.jsp&quot;&gt;&lt;/jsp:include&gt;
    &lt;/br&gt;
    22222222222222222
    33333333333333333
    &lt;/br&gt;
    &lt;jsp:include page=&quot;/c.jsp&quot;&gt;&lt;/jsp:include&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>c.jsp</strong></p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
33333333333333333
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>效果：</p>
<pre><code>11111111111111111
22222222222222222
33333333333333333
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb项目开发</category>
        <category>jsp</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>jsp</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb项目开发 | jstl标签</title>
    <url>/2022/01/11/jstl%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<h1 id="jstl标签"><a href="#jstl标签" class="headerlink" title="jstl标签"></a>jstl标签</h1><ol>
<li>jstl标签(替换jsp页面中的if、forjava代码)<br><img src="/2022/01/11/jstl%E6%A0%87%E7%AD%BE/1.PNG"></li>
<li>jstl标签测试</li>
</ol>
<pre><code>&lt;%@page import=&quot;java.util.HashMap&quot;%&gt;
&lt;%@page import=&quot;java.util.ArrayList&quot;%&gt;
&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;%
        request.setAttribute(&quot;a&quot;, 1);
        request.setAttribute(&quot;b&quot;, 4);
        
        //在request域中设置复杂数据(ArrayList)
        ArrayList&lt;String&gt; arr = new ArrayList&lt;String&gt;();
        arr.add(&quot;zhangsan&quot;);
        arr.add(&quot;lisi&quot;);
        arr.add(&quot;wangwu&quot;);
        request.setAttribute(&quot;list&quot;, arr);
        
        //在request域中设置复杂数据(HashMap)
        HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
        map.put(&quot;a&quot;, &quot;A&quot;);
        map.put(&quot;b&quot;, &quot;B&quot;);
        map.put(&quot;c&quot;, &quot;C&quot;);
        request.setAttribute(&quot;map&quot;, map);
    %&gt;
    &lt;c:if test=&quot;$&#123;a&gt;b&#125;&quot;&gt;
        &lt;font color=&quot;red&quot;&gt;a大于b&lt;/font&gt;&lt;br&gt;
    &lt;/c:if&gt;
    
    &lt;c:if test=&quot;$&#123;a&lt;b&#125;&quot;&gt;
        &lt;font color=&quot;green&quot;&gt;a大于b&lt;/font&gt;&lt;br&gt;
    &lt;/c:if&gt;
    
    &lt;c:forEach begin=&quot;1&quot; end=&quot;10&quot; step=&quot;1&quot; var=&quot;n&quot;&gt;
        $&#123;n&#125;
    &lt;/c:forEach&gt;&lt;br&gt;
    
    &lt;c:forEach items=&quot;$&#123;list&#125;&quot; var=&quot;s&quot;&gt;
        $&#123;s&#125;
    &lt;/c:forEach&gt;&lt;br&gt;
    
    &lt;c:forEach items=&quot;$&#123;map&#125;&quot; var=&quot;en&quot;&gt;
        $&#123;en.key&#125;
        $&#123;en.value&#125;&lt;br&gt;
    &lt;/c:forEach&gt;
&lt;/body&gt;
&lt;/html&gt;s
</code></pre>
<ol start="3">
<li>效果<br><img src="/2022/01/11/jstl%E6%A0%87%E7%AD%BE/2.PNG"></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb项目开发</category>
        <category>jstl标签</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>jstl标签</tag>
      </tags>
  </entry>
  <entry>
    <title>os | os.listdir()和os.walk()</title>
    <url>/2021/10/29/listdir%E5%92%8Cwalk/</url>
    <content><![CDATA[<h1 id="os-listdir-和os-walk"><a href="#os-listdir-和os-walk" class="headerlink" title="os.listdir()和os.walk()"></a>os.listdir()和os.walk()</h1><p><a href="https://www.jianshu.com/p/5c3b45d672d5">os.listdir()和os.walk()</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>内置模块</category>
        <category>os</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>matplotlib | 绘制双柱状图</title>
    <url>/2021/10/24/matplotlib%E7%BB%98%E5%88%B6%E5%8F%8C%E6%9F%B1%E7%8A%B6%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="使用matplotlib绘制双柱状图"><a href="#使用matplotlib绘制双柱状图" class="headerlink" title="使用matplotlib绘制双柱状图"></a>使用matplotlib绘制双柱状图</h1><p>实现代码：</p>
<pre><code>import matplotlib.pyplot as plt


# 定义函数来显示柱状上的数值
def autolabel(rects):
    for rect in rects:
        height = rect.get_height()
        plt.text(rect.get_x() + rect.get_width() / 2. - 0.2, 1.03 * height, &#39;%s&#39; % float(height))


if __name__ == &#39;__main__&#39;:
    l1 = [75, 57, 59, 60, 60]
    l2 = [68.39, 58, 54, 58, 55]

    # l1 = [68.50, 53.13, 53.04, 52.64, 56.32]
    # l2 = [66.31, 53.57, 50.54, 55.54, 47.72]
    name = [&#39;CNN-LSTM&#39;, &#39;CNN3Conv&#39;, &#39;CNN5Conv&#39;, &#39;LeNet&#39;, &#39;EEGNet&#39;]
    total_width, n = 0.8, 2
    width = total_width / n
    x = [0, 1, 2, 3, 4]
    plt.rc(&#39;font&#39;, family=&#39;SimHei&#39;, size=12)  # 设置中文显示，否则出现乱码！
    a = plt.bar(x, l1, width=width, label=&#39;Valence&#39;, fc=&#39;y&#39;)
    for i in range(len(x)):
        x[i] = x[i] + width
    b = plt.bar(x, l2, width=width, label=&#39;Arousal&#39;, tick_label=name, fc=&#39;r&#39;)
    autolabel(a)
    autolabel(b)
    plt.xlabel(&#39;Models&#39;)
    plt.ylabel(&#39;Accuracy&#39;)
    plt.title(&#39;Valence Accuracy and Arousal Accuracy&#39;)
    plt.legend()
    plt.show()
    plt.savefig(&#39;accuracy.png&#39;)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>matplotlib</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>matplotlib</tag>
        <tag>双柱状图</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis | 缓存</title>
    <url>/2022/04/14/mybatis%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><p>mybatis中的一级缓存默认开启，是SqlSession级别的，即同一个SqlSession对于一个SQL语句执行之后就会存储在缓存中，<br>下次执行相同的sql，直接从缓存中取。<br><strong>一级缓存失效的几种情况：</strong><br>（1）不同的SqlSession对应不同的一级缓存<br>（2）同一个SqlSession但是查询条件不同<br>（3）同一个SqlSession两次查询期间执行了任何一次增删改操作，会自动将缓存清空<br>（4）同一个SqlSession两次查询期间手动清空了缓存</p>
<h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p>mybatis的二级缓存默认不开启，需要设置：<br>1）全局配置文件中开启二级缓存<setting name="cacheEnabled" value="true"><br>2）需要使用二级缓存的映射文件处使用cache配置缓存<cache><br>3）POJO需要实现Serializable接口<br>注意：二级缓存在 SqlSession 关闭或提交之后才会生效<br>1)全局setting的cacheEnable：<br>配置二级缓存的开关，一级缓存一直是打开的。<br>2)select标签的useCache属性：<br>配置这个select是否使用二级缓存。一级缓存一直是使用的<br>3)sql标签的flushCache属性：<br>增删改默认flushCache=true。sql执行以后，会同时清空一级和二级缓存。<br>查询默认 flushCache=false。<br>4)sqlSession.clearCache()：只是用来清除一级缓存。</cache></setting></p>
<span id="more"></span>

<p>1.项目目录<br><img src="/2022/04/14/mybatis%E7%BC%93%E5%AD%98/1.PNG"><br>2.EmpMapper.java</p>
<pre><code>public interface EmpMapper &#123;
    .....
    
    //添加员工信息，将0|1--&gt;女|男
    void insertEmp(Emp emp);
    
    //根据eid所组成的字符串进行批量删除
    void deleteMoreEmp(String eids);
 
    //test cache
    //根据eid查询员工信息
    Emp getEmpByEid(String eid);
&#125;
</code></pre>
<p>3.EmpMapper.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
 PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
 &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
 
&lt;mapper namespace=&quot;com.atguigu.mapper.EmpMapper&quot;&gt;
    &lt;!-- 第三方缓存 --&gt;
    &lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt;
    
     &lt;!-- Emp getEmpByEid(String eid); --&gt;
     &lt;!--
        useCache:配置这个select是否使用二级缓存 
      --&gt;
     &lt;select id=&quot;getEmpByEid&quot; resultType=&quot;Emp&quot; useCache=&quot;true&quot;&gt;
        &lt;include refid=&quot;empColumns&quot;&gt;&lt;/include&gt; where eid=#&#123;eid&#125;
     &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p>4.TestCache.java</p>
<pre><code>package com.atguigu.test;

import java.io.InputStream;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.Test;

import com.atguigu.bean.Emp;
import com.atguigu.mapper.EmpMapper;

public class TestCache &#123;
    @Test
    public void testFirstCache() throws Exception&#123;
        //测试一级缓存
        //同一个SqlSession
//        SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
//        SqlSession sqlSession = sqlSessionFactory.openSession(true);
//        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
//        Emp emp1 = mapper.getEmpByEid(&quot;8&quot;);
//        System.out.println(emp1);
//        System.out.println(&quot;===================&quot;);
//        Emp emp2 = mapper.getEmpByEid(&quot;8&quot;);
//        System.out.println(emp2);
        
//        DEBUG 04-14 16:23:56,710 ==&gt;  Preparing: select eid,ename,age,sex,did from emp where eid=?   (BaseJdbcLogger.java:145) 
//        DEBUG 04-14 16:23:56,726 ==&gt; Parameters: 8(String)  (BaseJdbcLogger.java:145) 
//        DEBUG 04-14 16:23:56,738 &lt;==      Total: 1  (BaseJdbcLogger.java:145) 
//        Emp [eid=8, ename=小红, age=11, sex=0, dept=null]
//        ===================
//        Emp [eid=8, ename=小红, age=11, sex=0, dept=null]
        
        
        //不同SqlSession
//        SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
//        SqlSession sqlSession1 = sqlSessionFactory.openSession(true);
//        EmpMapper mapper1 = sqlSession1.getMapper(EmpMapper.class);
//        Emp emp1 = mapper1.getEmpByEid(&quot;8&quot;);
//        System.out.println(emp1);
//        
//        System.out.println(&quot;===================&quot;);
//        
//        SqlSession sqlSession2 = sqlSessionFactory.openSession(true);
//        EmpMapper mapper2 = sqlSession2.getMapper(EmpMapper.class);
//        Emp emp2 = mapper2.getEmpByEid(&quot;8&quot;);
//        System.out.println(emp2);
        
//        DEBUG 04-14 16:26:44,934 ==&gt;  Preparing: select eid,ename,age,sex,did from emp where eid=?   (BaseJdbcLogger.java:145) 
//        DEBUG 04-14 16:26:44,950 ==&gt; Parameters: 8(String)  (BaseJdbcLogger.java:145) 
//        DEBUG 04-14 16:26:44,961 &lt;==      Total: 1  (BaseJdbcLogger.java:145) 
//        Emp [eid=8, ename=小红, age=11, sex=0, dept=null]
//        ===================
//        DEBUG 04-14 16:26:44,966 ==&gt;  Preparing: select eid,ename,age,sex,did from emp where eid=?   (BaseJdbcLogger.java:145) 
//        DEBUG 04-14 16:26:44,966 ==&gt; Parameters: 8(String)  (BaseJdbcLogger.java:145) 
//        DEBUG 04-14 16:26:44,967 &lt;==      Total: 1  (BaseJdbcLogger.java:145) 
//        Emp [eid=8, ename=小红, age=11, sex=0, dept=null]
        
        //同一个SqlSession两次查询期间执行了任何一次增删改操作
        SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
        SqlSession sqlSession1 = sqlSessionFactory.openSession(true);
        EmpMapper mapper1 = sqlSession1.getMapper(EmpMapper.class);
        Emp emp1 = mapper1.getEmpByEid(&quot;8&quot;);
        System.out.println(emp1);
        
        sqlSession1.clearCache();
        System.out.println(&quot;===================&quot;);
//        Emp emp = new Emp();
//        emp.setEid(null);
//        emp.setAge(25);
//        emp.setEname(&quot;lisi&quot;);
//        mapper1.insertEmp(emp);
        
        EmpMapper mapper2 = sqlSession1.getMapper(EmpMapper.class);
        Emp emp2 = mapper2.getEmpByEid(&quot;8&quot;);
        System.out.println(emp2);
//        DEBUG 04-14 16:39:56,334 ==&gt;  Preparing: select eid,ename,age,sex,did from emp where eid=?   (BaseJdbcLogger.java:145) 
//        DEBUG 04-14 16:39:56,350 ==&gt; Parameters: 8(String)  (BaseJdbcLogger.java:145) 
//        DEBUG 04-14 16:39:56,361 &lt;==      Total: 1  (BaseJdbcLogger.java:145) 
//        Emp [eid=8, ename=小红, age=11, sex=0, dept=null]
//        ===================
//        DEBUG 04-14 16:39:56,362 ==&gt;  Preparing: select eid,ename,age,sex,did from emp where eid=?   (BaseJdbcLogger.java:145) 
//        DEBUG 04-14 16:39:56,363 ==&gt; Parameters: 8(String)  (BaseJdbcLogger.java:145) 
//        DEBUG 04-14 16:39:56,364 &lt;==      Total: 1  (BaseJdbcLogger.java:145) 
//        Emp [eid=8, ename=小红, age=11, sex=0, dept=null]
    &#125;
    
    @Test
    public void testSecondCache() throws Exception&#123;
        
        SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
        SqlSession sqlSession = sqlSessionFactory.openSession(true);
        EmpMapper mapper1 = sqlSession.getMapper(EmpMapper.class);
        Emp emp1 = mapper1.getEmpByEid(&quot;8&quot;);
        System.out.println(emp1);
        sqlSession.commit();//二级缓存在 SqlSession 关闭或提交之后才会生效
        System.out.println(&quot;====================&quot;);
        EmpMapper mapper2 = sqlSession.getMapper(EmpMapper.class);
        Emp emp2 = mapper2.getEmpByEid(&quot;8&quot;);
        System.out.println(emp2);

    &#125;
    
    public SqlSessionFactory getSqlSessionFactory() throws Exception&#123;
        InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
        return sqlSessionFactory;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>MyBatis</category>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>pandas | pandas提取指定数据并保存在原Excel工作簿中</title>
    <url>/2021/10/29/pandas%E6%8F%90%E5%8F%96%E6%8C%87%E5%AE%9A%E6%95%B0%E6%8D%AE%E5%B9%B6%E4%BF%9D%E5%AD%98%E5%9C%A8%E5%8E%9FExcel%E5%B7%A5%E4%BD%9C%E7%B0%BF%E4%B8%AD/</url>
    <content><![CDATA[<h1 id="pandas提取指定数据并保存在原Excel工作簿中"><a href="#pandas提取指定数据并保存在原Excel工作簿中" class="headerlink" title="pandas提取指定数据并保存在原Excel工作簿中"></a>pandas提取指定数据并保存在原Excel工作簿中</h1><p>实现代码：</p>
<pre><code>import pandas as pd

df = pd.read_excel(&quot;物料表.xlsx&quot;, header=2)
# print(df)

df500 = df[df[&quot;数量&quot;] &gt; 500]
# print(df500)

with pd.ExcelWriter(&#39;物料表.xlsx&#39;, mode=&#39;a&#39;, engine=&#39;openpyxl&#39;,
                    datetime_format=&#39;YYYY-MM-DD&#39;) as writer:
    df500.to_excel(writer, sheet_name=&#39;数量大于500&#39;, index=False)

from openpyxl import load_workbook
from openpyxl.styles import Border, Side, PatternFill, Font, GradientFill, Alignment

thin = Side(border_style=&quot;thin&quot;, color=&quot;000000&quot;)  # 定义边框粗细及颜色

wb = load_workbook(&quot;物料表.xlsx&quot;)
ws = wb[&quot;数量大于500&quot;]

# 调整列宽
ws.column_dimensions[&#39;A&#39;].width = 12
ws.column_dimensions[&#39;C&#39;].width = 15.5
ws.column_dimensions[&#39;G&#39;].width = 10

# 设置字号，对齐，缩小字体填充，加边框
for row_number in range(2, ws.max_row + 1):
    for col_number in range(1, ws.max_column + 1):
        c = ws.cell(row=row_number, column=col_number)
        c.font = Font(size=10)
        c.border = Border(top=thin, left=thin, right=thin, bottom=thin)
        c.alignment = Alignment(horizontal=&quot;left&quot;, vertical=&quot;center&quot;)
wb.save(&quot;物料表.xlsx&quot;)
</code></pre>
<p><a href="物料表.xlsx">物料表.xlsx</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>pandas</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>openpyxl</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>pandas | 文本数据处理</title>
    <url>/2021/11/06/pandas%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="pandas文本数据处理"><a href="#pandas文本数据处理" class="headerlink" title="pandas文本数据处理"></a>pandas文本数据处理</h1><p><a href="https://mp.weixin.qq.com/s/xmG8QizkbXJIBcqdT3nN-g">参考资料</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>pandas</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>python | pip安装出现Cannot fetch index base URL http://pypi.python.org/simple/解决方法</title>
    <url>/2021/01/28/pip%E5%AE%89%E8%A3%85%E5%87%BA%E7%8E%B0Cannot-fetch-index-base-URL-http-pypi-python-org-simple-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="pip安装出现Cannot-fetch-index-base-URL-http-pypi-python-org-simple-解决方法"><a href="#pip安装出现Cannot-fetch-index-base-URL-http-pypi-python-org-simple-解决方法" class="headerlink" title="pip安装出现Cannot fetch index base URL http://pypi.python.org/simple/解决方法"></a>pip安装出现Cannot fetch index base URL <a href="http://pypi.python.org/simple/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95">http://pypi.python.org/simple/解决方法</a></h1><p>1.sudo vi .pip/pip.conf<br>2.添加以下内容<br>[global]<br>index-url=<a href="http://pypi.doubanio.com/simple/">http://pypi.doubanio.com/simple/</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>itertools | product</title>
    <url>/2021/09/04/product/</url>
    <content><![CDATA[<h1 id="itertools-product"><a href="#itertools-product" class="headerlink" title="itertools.product()"></a>itertools.product()</h1><p>使用product()前需要导入itertools库<br><strong>用法1：</strong></p>
<pre><code>print(list(itertools.product(‘a&#39;, repeat=4)))   # 等价于 print(list(itertools.product(&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;)))

a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
print(list(itertools.product(a, repeat=2)))  # s等价于 print(list(itertools.product(a, a)))
</code></pre>
<p><strong>用法2：</strong></p>
<pre><code>print(list(itertools.product(a, b)))  # 等价于 print(list((x, y) for x in a for y in b))
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>内置模块</category>
        <category>itertools</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>itertools</tag>
      </tags>
  </entry>
  <entry>
    <title>python | property和property装饰器</title>
    <url>/2022/03/25/property%E5%92%8Cproperty%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<h1 id="property和property装饰器"><a href="#property和property装饰器" class="headerlink" title="property和property装饰器"></a>property和property装饰器</h1><pre><code>class Student:
    def __init__(self, name):
        self.__name = name

    def get_name(self):
        return self.__name

    def set_name(self, new_name):
        self.__name = new_name

    name = property(get_name, set_name)

s = Student(&quot;张三&quot;)
s.name = &quot;李四&quot;
print(s.name)

class Student:
    def __init__(self, name):
        self.__name = name

    @property
    def name(self):
        return self.__name
    @name.setter
    def name(self, new_name):
        self.__name = new_name

s = Student(&quot;张三&quot;)
s.name = &quot;李四&quot;
print(s.name)
</code></pre>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>property</tag>
        <tag>property装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title>pycharm同步代码到远程服务器</title>
    <url>/2021/04/18/pycharm%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%88%B0%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h1 id="pycharm同步代码到远程服务器"><a href="#pycharm同步代码到远程服务器" class="headerlink" title="pycharm同步代码到远程服务器"></a>pycharm同步代码到远程服务器</h1><p>1.在pycharm菜单栏点Tools–&gt;Deployment–&gt;Configuration<br>如果显示Please add a web server to configure,点+增加一个要配置的web服务器，传输协议选择SFTP，并输入新服务器的名称。<br>2.在connection选项中选择或输入对应信息<br>Type:SFTP<br>Host:服务器ip地址 Port:22(默认为22)<br>Username:<br>Authentication:Password<br>Password:<br>3.点Test Connection测试是否成功连接服务器<br>4.在Mappings选项中选择 Deployment path(将项目/文件部署到服务器的哪个路径下)<br>5.Tools–&gt;start SSH session<br>6.Tools–&gt;Deployment–&gt;upload to 刚刚输入的新服务器名称</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>pygame最小开发框架</title>
    <url>/2021/05/21/pygame%E6%9C%80%E5%B0%8F%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="pygame最小开发框架"><a href="#pygame最小开发框架" class="headerlink" title="pygame最小开发框架"></a>pygame最小开发框架</h1><pre><code>import pygame, sys

pygame.init()
screen = pygame.display.set_mode((1206, 780))
pygame.display.set_caption(&quot;Pygame&quot;)

while True:
        for event in pygame.event.get():
                if event.type == pygame.QUIT:
                        sys.exit()

        pygame.display.update()
</code></pre>
<p><img src="/2021/05/21/pygame%E6%9C%80%E5%B0%8F%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/pygame.jpg" alt="pygame最小开发框架"></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>pygame</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pygame</tag>
      </tags>
  </entry>
  <entry>
    <title>python | python @property</title>
    <url>/2021/05/20/python-property/</url>
    <content><![CDATA[<h1 id="python-property"><a href="#python-property" class="headerlink" title="python property"></a>python property</h1><pre><code>class Test(object):
        def __init__(self):
            self.__num = 100

           # def getNum(self):
           #     return self.__num
            #
        # def setNum(self,newNum):
            #     self.__num = newNum

        @property
        def num(self):
                return self.__num

        @num.setter
        def num(self,newNum):
                self.__num = newNum


t = Test()
t.num = 50
print(t.num)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python | python str 对象</title>
    <url>/2021/05/15/python-str-%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="python中的str对象"><a href="#python中的str对象" class="headerlink" title="python中的str对象"></a>python中的str对象</h1><p>python中的str对象是不可变对象，因此不存在修改字符串这一说法。<br>即：在s = ‘test’后写 s = ‘test1’</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python | python zip()函数</title>
    <url>/2021/05/20/python-zip-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="python-zip-函数"><a href="#python-zip-函数" class="headerlink" title="python zip()函数"></a>python zip()函数</h1><p>example:<br>1.zip() 压缩(zip)<br>case 1:<br>list1 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]<br>print([row for row in zip(list1)]) # ([1, 2, 3],), ([4, 5, 6],), ([7, 8, 9],)</p>
<p>case 2:<br>list1 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]<br>list2 = [[7, 8, 9], [4, 5, 6], [1, 2, 3]]<br>print([row for row in zip(list1, list2)])  # [([1, 2, 3], [7, 8, 9]), ([4, 5, 6], [4, 5, 6]), ([7, 8, 9], [1, 2, 3])]</p>
<p>2.zip(*) 解压(unzip)<br>list1 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]<br>print([row for row in zip(*list1)])  # [(1, 4, 7), (2, 5, 8), (3, 6, 9)]</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python | python 广播</title>
    <url>/2021/06/21/python-%E5%B9%BF%E6%92%AD/</url>
    <content><![CDATA[<h1 id="python-广播"><a href="#python-广播" class="headerlink" title="python 广播"></a>python 广播</h1><pre><code>&quot;&quot;&quot;
Calories from Carbs,Proteins,Fats in 100g of different foods:

           Apples        Beef        Eggs        Potatoes
   
Carb    [94.91525424  0.          2.83140283 88.42652796]
Protein [ 2.03389831 43.51464435 33.46203346 10.40312094]
Fat     [ 3.05084746 56.48535565 63.70656371  1.17035111]
 
Q:Calculate % of calories from Carbs,Proteins,Fats.Can you do this without
explicit for-loop?
&quot;&quot;&quot;

import numpy as np

A = np.array([[56.0,0.0,4.4,68.0],
             [1.2,104.0,52.0,8.0],
             [1.8,135.0,99.0,0.9]])
print(A)
cal = A.sum(axis=0)
print(cal)
percentage = 100*A/cal.reshape(1,4)
print(percentage)
</code></pre>
<p><a href="https://www.bilibili.com/video/BV1FT4y1E74V?p=21">参考吴恩达深度学习视频</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python | python 翻转列表</title>
    <url>/2021/05/20/python-%E7%BF%BB%E8%BD%AC%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="python-翻转列表"><a href="#python-翻转列表" class="headerlink" title="python 翻转列表"></a>python 翻转列表</h1><p>list1 = [1, 2, 3]<br>print(list1[::-1])  # [3, 2, 1]</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python | python中如何实现函数重载的效果</title>
    <url>/2021/08/02/python%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%9A%84%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<h1 id="python中如何实现函数重载的效果"><a href="#python中如何实现函数重载的效果" class="headerlink" title="python中如何实现函数重载的效果"></a>python中如何实现函数重载的效果</h1><h2 id="什么是函数重载？"><a href="#什么是函数重载？" class="headerlink" title="什么是函数重载？"></a>什么是函数重载？</h2><p>函数重载，即可以定义多个同名函数，但是参数列表不同，这样在调用时可以传递不同的实参。</p>
<h2 id="python中没有函数重载的概念"><a href="#python中没有函数重载的概念" class="headerlink" title="python中没有函数重载的概念"></a>python中没有函数重载的概念</h2><p>函数重载会增加代码量，所以在python中没有函数重载的概念，而是<strong>为函数的参数提供默认值</strong>实现的。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><pre><code># coding=utf-8

def make_coffee(name=&#39;卡布奇诺&#39;)：
    return &quot;制作一杯&#123;&#125;&quot;.format(name)
    
coffee1 = make_coffee(&#39;拿铁&#39;)  # 提供参数
coffee2 = make_coffee()  # 没有提供参数，使用默认值
print(coffee1)
print(coffee2)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python | python中的iter()与next()</title>
    <url>/2021/02/26/python%E4%B8%AD%E7%9A%84iter-%E4%B8%8Enext/</url>
    <content><![CDATA[<h1 id="python中的iter-与next"><a href="#python中的iter-与next" class="headerlink" title="python中的iter()与next()"></a>python中的iter()与next()</h1><p>可迭代对象(Iterable)：可以直接作用于for循环的对象</p>
<p>分类：<br>1.集合数据类型 list、tuple、dict、set、str<br>2.generator(包括生成器和带yield的generator function)<br>Note:生成器不但可以作用于 for 循环，还可以被 next() 函数不断调用并返回下一个值</p>
<p>生成器都是Iterator,但list、tuple、dict、str、set虽然是Iterable,却不是Iterator，可以使用iter()函数把list…Iterable编程Iterator</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python | python中的filter函数和map函数</title>
    <url>/2021/08/02/python%E4%B8%AD%E7%9A%84filter%E5%87%BD%E6%95%B0%E5%92%8Cmap%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="python中的filter函数和map函数"><a href="#python中的filter函数和map函数" class="headerlink" title="python中的filter函数和map函数"></a>python中的filter函数和map函数</h1><h2 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h2><p>filter()用于对容器中的元素进行过滤处理</p>
<pre><code># coding=utf-8
# 提供过滤条件函数
def f1(x):
    return x &gt; 50
    
data1 = [66, 15, 91, 28, 98, 50, 7, 90, 99]
filtered = filter(f1, data1)
data2 = list(filtered)
print(data2)


# lambda实现
data1 = [66, 15, 91, 28, 98, 50, 7, 90, 99]
filtered = filter(lambda x : (x &gt; 50), data1)
data2 = list(filtered)
print(data2)
</code></pre>
<h2 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h2><p>map()用于对容器中的元素进行映射或变换</p>
<pre><code># coding=utf-8
# 提供变换规则的函数
def f1(x):
    return x * 2

data1 = [66, 15, 91, 28, 98, 50, 7, 90, 99]
mapped = map(f1, data1)
data2 = list(mapped)
print(data2)


# lambda实现
data1 = [66, 15, 91, 28, 98, 50, 7, 90, 99]
mapped = map(lambda x : (x * 2), data1)
data2 = list(mapped)
print(data2)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>random | python为每个学生出不一样的题</title>
    <url>/2021/10/29/python%E4%B8%BA%E6%AF%8F%E4%B8%AA%E5%AD%A6%E7%94%9F%E5%87%BA%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E9%A2%98/</url>
    <content><![CDATA[<h1 id="python为每个学生出不一样的题"><a href="#python为每个学生出不一样的题" class="headerlink" title="python为每个学生出不一样的题"></a>python为每个学生出不一样的题</h1><p>实现代码：</p>
<pre><code>import random


# 不重复随机整数生成函数
def Random_num(num_max, num_qty):
    &#39;&#39;&#39;
    num_max:最大数
    num_qty:生成随机数的个数
    &#39;&#39;&#39;
    num_list = []  # 储存生成的随机数
    while len(num_list) &lt; num_qty:  # 控制随机数的个数
        num = random.randint(2, num_max)  # 设定在此范围内取数
        if num in num_list:  # 判断随机数是否重复
            continue  # 若重复，则重新生成
        else:
            num_list.append(num)  # 将不重复的随机数放入列表
    return num_list  # 生成完成后返回随机数列表


# 定义函数，按随机数在题库中抽取对应编号的题目
from openpyxl import load_workbook


def Question(que_type, numbers):
    &#39;&#39;&#39;
    que_type:试题类型（&quot;单选题&quot;,&quot;多选题&quot;,&quot;判断题&quot;,&quot;填空题&quot;）
    numbers:需要抽取的试题编号
    &#39;&#39;&#39;
    questions = []  # 储存抽取的题目
    wb = load_workbook(&quot;题库.xlsx&quot;)  # 载入题库
    if que_type == &quot;单选题&quot;:
        ws = wb[que_type]
        for i in numbers:  # 按随机生成的编号抽题
            question = ws[&quot;B&quot; + str(i)].value  # 问题在B列
            answerA = &quot;A：\t&quot; + str(ws[&quot;C&quot; + str(i)].value)  # 选项A在C列，&quot;\t&quot;相当于按一下tab键，在字符间产生间隔
            answerB = &quot;B：\t&quot; + str(ws[&quot;D&quot; + str(i)].value)  # 选项B在D列
            answerC = &quot;C：\t&quot; + str(ws[&quot;E&quot; + str(i)].value)  # 选项C在E列
            answerD = &quot;D：\t&quot; + str(ws[&quot;F&quot; + str(i)].value)  # 选项D在F列
            right_answer = ws[&quot;G&quot; + str(i)].value  # 正确答案在G列
            single_question = [question, answerA, answerB, answerC, answerD, right_answer]  # 每行的数据存入列表
            questions.append(single_question)  # 每个题目的数据存入总列表
    elif que_type == &quot;多选题&quot;:
        ws = wb[que_type]
        for i in numbers:
            question = ws[&quot;B&quot; + str(i)].value
            answerA = &quot;A：\t&quot; + str(ws[&quot;C&quot; + str(i)].value)
            answerB = &quot;B：\t&quot; + str(ws[&quot;D&quot; + str(i)].value)
            answerC = &quot;C：\t&quot; + str(ws[&quot;E&quot; + str(i)].value)
            answerD = &quot;D：\t&quot; + str(ws[&quot;F&quot; + str(i)].value)
            right_answer = ws[&quot;H&quot; + str(i)].value
            single_question = [question, answerA, answerB, answerC, answerD, right_answer]
            if ws[&quot;G&quot; + str(i)].value:  # 有些题有E选项，有些没有，因此需要判断一下是否有E选项
                answerE = &quot;E：\t&quot; + str(ws[&quot;G&quot; + str(i)].value)
                single_question.insert(-1, answerE)  # 将E选项插入到答案前面，保持答案是最后一个元素
            questions.append(single_question)
    else:  # 判断题和填空题，内容只取题干和答案
        ws = wb[que_type]
        for i in numbers:
            question = ws[&quot;B&quot; + str(i)].value
            right_answer = ws[&quot;C&quot; + str(i)].value
            single_question = [question, right_answer]
            questions.append(single_question)

    return questions


# 写入考试题到word文件
from docx import Document
from docx.shared import Pt  # 用于设定字体大小（磅值）
from docx.oxml.ns import qn  # 用于应用中文字体


def To_word(number, questions_data):
    doc = Document(&quot;试题-模板.docx&quot;)

    # 写入单选题
    title1 = &quot;一、单项选择题（共40题，每题1分）&quot;
    p = doc.add_paragraph()  # 插入段落
    r = p.add_run(title1)  # 插入文字块
    r.bold = True  # 字体加粗
    r.font.size = Pt(12)  # 字号设为12磅
    for index, i in enumerate(questions_data[&quot;单选题&quot;], start=1):  # 给题目从1开始编号
        doc.add_paragraph(f&quot;&#123;index&#125;. &#123;i[0]&#125;&quot;)  # 题干部分在单独一段
        doc.add_paragraph(f&quot;\t&#123;i[1]&#125;\t\t&#123;i[2]&#125;&quot;)  # 选项A和选项B在同一段落
        doc.add_paragraph(f&quot;\t&#123;i[3]&#125;\t\t&#123;i[4]&#125;&quot;)  # 选项C和选项D在同一段落

    # 写入多选题
    title2 = &quot;二、多项选择题（共20题，每题2分）&quot;
    p = doc.add_paragraph()
    r = p.add_run(title2)
    r.bold = True
    r.font.size = Pt(12)
    for index, i in enumerate(questions_data[&quot;多选题&quot;], start=1):
        doc.add_paragraph(f&quot;&#123;index&#125;. &#123;i[0]&#125;&quot;)
        doc.add_paragraph(f&quot;\t&#123;i[1]&#125;\t\t&#123;i[2]&#125;&quot;)
        doc.add_paragraph(f&quot;\t&#123;i[3]&#125;\t\t&#123;i[4]&#125;&quot;)
        if len(i) == 7:  # 判断是否有E选项，若有，则新建一段落写入
            doc.add_paragraph(f&quot;\t&#123;i[5]&#125;&quot;)

    # 写入判断题
    title3 = &quot;三、判断题（共10题，每题1分）&quot;
    p = doc.add_paragraph()
    r = p.add_run(title3)
    r.bold = True
    r.font.size = Pt(12)
    for index, i in enumerate(questions_data[&quot;判断题&quot;], start=1):
        doc.add_paragraph(f&quot;\t&#123;index&#125;. &#123;i[0]&#125;&quot;)

    # 写入填空题
    title4 = &quot;四、填空题（共10题，每题1分）&quot;
    p = doc.add_paragraph()
    r = p.add_run(title4)
    r.bold = True
    r.font.size = Pt(12)
    for index, i in enumerate(questions_data[&quot;填空题&quot;], start=1):
        doc.add_paragraph(f&quot;\t&#123;index&#125;. &#123;i[0]&#125;&quot;)

    doc.save(f&quot;试卷及答案\\考试题&#123;number&#125;.docx&quot;)


# 写入答案
from docx import Document
from docx.shared import Pt  # 用于设定字体大小（磅值）
from docx.oxml.ns import qn  # 用于应用中文字体


def Answer(number, questions_data):
    doc = Document()
    # 全局字体设为“宋体”
    doc.styles[&#39;Normal&#39;].font.name = u&#39;宋体&#39;
    doc.styles[&#39;Normal&#39;]._element.rPr.rFonts.set(qn(&#39;w:eastAsia&#39;), u&#39;宋体&#39;)

    title = &quot;计算机系2020第二学期期末考试题(答案)&quot;
    p = doc.add_paragraph()
    r = p.add_run(title)
    r.bold = True
    r.font.size = Pt(20)
    # 写入单选题答案
    title1 = &quot;一、单项选择题答案（共40题，每题1分）&quot;
    p = doc.add_paragraph()
    r = p.add_run(title1)
    r.bold = True
    r.font.size = Pt(12)

    p = doc.add_paragraph()
    for index, i in enumerate(questions_data[&quot;单选题&quot;], start=1):
        p.add_run(f&quot;&#123;index&#125;. &#123;i[-1]&#125;\t&quot;)
        if index % 10 == 0:  # 每段只显示10个答案
            p = doc.add_paragraph()  # 满10个，则新建段落

    # 写入多选题答案
    title2 = &quot;二、多项选择题答案（共20题，每题2分）&quot;
    p = doc.add_paragraph()
    r = p.add_run(title2)
    r.bold = True
    r.font.size = Pt(12)
    p = doc.add_paragraph()
    for index, i in enumerate(questions_data[&quot;多选题&quot;], start=1):
        p.add_run(f&quot;&#123;index&#125;. &#123;i[-1]&#125;\t&quot;)
        if index % 3 == 0:
            p = doc.add_paragraph()

            # 写入判断题答案
    title3 = &quot;三、判断题答案（共10题，每题1分）&quot;
    p = doc.add_paragraph()
    r = p.add_run(title3)
    r.bold = True
    r.font.size = Pt(12)
    p = doc.add_paragraph()
    for index, i in enumerate(questions_data[&quot;判断题&quot;], start=1):
        p.add_run(f&quot;&#123;index&#125;. &#123;i[-1]&#125;\t&quot;)
        if index % 5 == 0:  # 每段只显示5个答案
            p = doc.add_paragraph()  # 满5个，则新建段落

    # 写入填空题
    title4 = &quot;四、填空题答案（共10题，每题1分）&quot;
    p = doc.add_paragraph()
    r = p.add_run(title4)
    r.bold = True
    r.font.size = Pt(12)
    p = doc.add_paragraph()
    for index, i in enumerate(questions_data[&quot;填空题&quot;], start=1):
        p.add_run(f&quot;&#123;index&#125;. &#123;i[-1]&#125;\t\t&quot;)
        if index % 2 == 0:  # 每段只显示2个答案
            p = doc.add_paragraph()  # 满2个，则新建段落

    doc.save(f&quot;试卷及答案\\考试题&#123;number&#125;答案.docx&quot;)


# 主函数
for number in range(1, 21):  # 不同的试卷数量，此处为20套
    # 生成随机题目编号
    num_single_choice = Random_num(566, 40)
    num_mult_choice = Random_num(196, 20)
    num_judgment = Random_num(418, 10)
    num_completion = Random_num(190, 10)
    # 将生成的编号存入字典`question_num`
    question_num = &#123;&quot;单选题号&quot;: num_single_choice,
                    &quot;多选题号&quot;: num_mult_choice,
                    &quot;判断题号&quot;: num_judgment,
                    &quot;填空题号&quot;: num_completion
                    &#125;
    # 根据随机生成的题目编号去题库选题，并存入`questions_data`
    questions_data = &#123;
        &quot;单选题&quot;: Question(&quot;单选题&quot;, question_num[&quot;单选题号&quot;]),
        &quot;多选题&quot;: Question(&quot;多选题&quot;, question_num[&quot;多选题号&quot;]),
        &quot;判断题&quot;: Question(&quot;判断题&quot;, question_num[&quot;判断题号&quot;]),
        &quot;填空题&quot;: Question(&quot;填空题&quot;, question_num[&quot;填空题号&quot;])
    &#125;
    # 将试题写入word文档，并保存
    To_word(number, questions_data)
    # 将试题答案写入word文档，并保存
    Answer(number, questions_data)
    print(f&quot;试卷&#123;number&#125;及答案完成！&quot;)
</code></pre>
<p><a href="试题-模板.docx">试题-模板.docx</a><br><a href="题库.xlsx">题库.xlsx</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>内置模块</category>
        <category>random</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python-docx</tag>
        <tag>openpyxl</tag>
        <tag>random</tag>
      </tags>
  </entry>
  <entry>
    <title>random | python出数学练习题</title>
    <url>/2021/10/29/python%E5%87%BA%E6%95%B0%E5%AD%A6%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<h1 id="python出数学练习题"><a href="#python出数学练习题" class="headerlink" title="python出数学练习题"></a>python出数学练习题</h1><p>实现代码：</p>
<pre><code># import random
#
# for i in range(5):
#     num1 = random.randint(1, 9)
#     num2 = random.randint(1, 9)
#     print(f&quot;&#123;num1&#125; + &#123;num2&#125; = &quot;)


# 加法、乘法题
import random
data = []  # 储存题目的列表
group = []  # 中转列表
while len(data) &lt; 20:  # 题目个数，20行x4列共80个题，刚好放入word文档中的1页
    num1 = random.randint(0, 9)  # 随机整数1，从0-9中选取
    num2 = random.randint(0, 9)  # 随机整数2，从0-9中选取
    group.append(f&quot;&#123;num1&#125; + &#123;num2&#125; = &quot;)  # 数据放入中转列表
    if len(group) == 4:  # 按四道题分一组
        data.append(group)  # 数据放入总列表
        group = []  # 清空中转列表
print(data)

# # 减法题
# import random
#
# data = []
# group = []
# while len(data) &lt; 20:
#     num1 = random.randint(1, 9)
#     num2 = random.randint(1, 9)
#     if num1 &gt; num2:
#         group.append(f&quot;&#123;num1&#125; - &#123;num2&#125; = &quot;)
#         if len(group) == 4:
#             data.append(group)
#             group = []
#
# # print(data)

# # 除法题
# import random
#
# data = []  # 储存题目的列表
# group = []  # 中转列表
# while len(data) &lt; 20:
#     num1 = random.randint(1, 19)
#     num2 = random.randint(1, 19)
#     if num1 &gt;= num2 and num1 % num2 == 0:
#         group.append(f&quot;&#123;num1&#125; ÷ &#123;num2&#125; = &quot;)  # 数据放入中转列表
#         if len(group) == 4:  # 按四道题分一组
#             data.append(group)  # 数据放入总列表
#             group = []  # 清空中转列表
#
# print(data)

# 输出到word文件
def To_word(data, file_name):
    &quot;&quot;&quot;
    data:需要传入的列表
    file_name:word文件的文件名
    &quot;&quot;&quot;
    from docx import Document
    from docx.shared import Pt  # 用于设定字体大小（磅值）

    doc = Document()
    for i in data:
        # print(i)
        row = &quot;\t\t&quot;.join(i)
        # print(row)
        doc.add_paragraph(row)
    # 设置字号
    for para in doc.paragraphs:
        for run in para.runs:
            run.font.size = Pt(16)  # 文字大小磅值
    doc.save(f&quot;&#123;file_name&#125;.docx&quot;)

To_word(data, &quot;加法题&quot;)
# To_word(data, &quot;减法题&quot;)
# To_word(data, &quot;乘法题&quot;)
# To_word(data, &quot;除法题&quot;)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>内置模块</category>
        <category>random</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python-docx</tag>
        <tag>random</tag>
      </tags>
  </entry>
  <entry>
    <title>python | 分块拆分txt文件中的数据</title>
    <url>/2021/10/30/python%E5%88%86%E5%9D%97%E6%8B%86%E5%88%86txt%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="分块拆分txt文件中的数据"><a href="#分块拆分txt文件中的数据" class="headerlink" title="分块拆分txt文件中的数据"></a>分块拆分txt文件中的数据</h1><p>代码：</p>
<pre><code># -*- coding:utf-8 -*-
# 读取txt文件中的数据
file = open(&quot;数据.txt&quot;)
lines = file.readlines()
# print(lines[:5])

data = &#123;&#125;  # 储存分割的数据
line_list = []  # 中转列表
last_id = &quot;start&quot;  # 数据分块标识
for line in lines:
    row_data = line.split(&quot; &quot;)  # 将一行数据按空格分隔
    ID = row_data[0]  # 获得ID
    if last_id == &quot;start&quot;:  # 用于处理数据第一行
        line_list.append(line)  # 将第一行数据放入中转列表
    else:  # 不是第一行数据，则按如下执行
        if ID != last_id:  # 如果出现新的数据块
            if last_id in data:  # 新的数据块的ID已存在字典data中
                data[last_id].append(line_list)  # 将中转列表的数据添加到对应的ID中
            else:  # 新的数据快的ID不在字典data中
                data[last_id] = [line_list]  # 将上一个数据块加入对应的ID
            line_list = [line]  # 将中转列表清空，并放入新数据快的第一行数据
        else:  # 没出现新的数据块
            line_list.append(line)  # 将数据继续加入中转列表
    last_id = ID  # 每处理一行，将分块标识last_id更行为最新的ID

# 将最后一个文字块的数据放入字典
if last_id in data:
    data[last_id].append(line_list)
else:
    data[last_id] = [line_list]

# print(data[&#39;89031&#39;])

# for i in data.keys():
#     for block in data[i]:
#         print(block)
#         print(&quot;- -&quot;*50)


# 写入数据函数
def to_txt(filename, data_list):  # filename为写入文件的名字，data为要写入数据列表
    file = open(&quot;分块\\&quot; + filename + &#39;.txt&#39;, &#39;a&#39;)
    for i in range(len(data_list)):
        file.write(data_list[i])
    file.close()  # 保存数据并关闭


# 批量写入数据
for ID in data.keys():
    for i in range(len(data[ID])):
        to_txt(f&quot;&#123;ID&#125;_&#123;i+1&#125;&quot;, data[ID][i])
        
</code></pre>
<p><a href="数据.txt">数据.txt</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>PyQt5 | python制作图形用户界面让操作可视化</title>
    <url>/2021/10/29/python%E5%88%B6%E4%BD%9C%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E8%AE%A9%E6%93%8D%E4%BD%9C%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<h1 id="python制作图形用户界面让操作可视化"><a href="#python制作图形用户界面让操作可视化" class="headerlink" title="python制作图形用户界面让操作可视化"></a>python制作图形用户界面让操作可视化</h1><p>代码：</p>
<pre><code>import sys
import os
from PyQt5 import QtWidgets
from PyQt5.QtGui import QIcon
import xlrd
import datetime
import time
from openpyxl import Workbook
from openpyxl.styles import Border, Side, PatternFill, Font, GradientFill, Alignment


class MainGUI(QtWidgets.QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle(&quot;领料明细汇总&quot;)
        self.resize(800, 400)
        self.main_widget = QtWidgets.QWidget()
        self.main_widget_layout = QtWidgets.QGridLayout()
        self.main_widget.setLayout(self.main_widget_layout)

        self.input = QtWidgets.QLineEdit()
        self.input_btn = QtWidgets.QPushButton(&quot;选择输入文件夹&quot;)
        self.output = QtWidgets.QLineEdit()
        self.output_btn = QtWidgets.QPushButton(&quot;选择输出文件夹&quot;)
        self.show_result = QtWidgets.QListWidget()
        self.run = QtWidgets.QPushButton(&quot;执行汇总&quot;)

        self.main_widget_layout.addWidget(self.input, 0, 0, 1, 2)
        self.main_widget_layout.addWidget(self.input_btn, 0, 2, 1, 1)
        self.main_widget_layout.addWidget(self.output, 1, 0, 1, 2)
        self.main_widget_layout.addWidget(self.output_btn, 1, 2, 1, 1)
        self.main_widget_layout.addWidget(self.run, 2, 2, 1, 1)
        self.main_widget_layout.addWidget(self.show_result, 3, 0, 3, 3)

        self.setCentralWidget(self.main_widget)

        self.input_btn.clicked.connect(self.Choice_dir_input)  # 将&quot;选择输入文件夹&quot;按钮绑定Choice_dir_input函数
        self.output_btn.clicked.connect(self.Choice_dir_output)  # 将&quot;选择输出文件夹&quot;按钮绑定Choice_dir_output函数
        self.run.clicked.connect(self.Summary_data)  # “执行汇总”按钮绑定Summary_data函数

    def Choice_dir_input(self):
        # 选择目录操作
        dir_path = QtWidgets.QFileDialog.getExistingDirectory(self, &quot;请选择文件夹路径&quot;, &quot;D:\\&quot;)
        # 将选择的目录显示在文本编辑框中
        self.input.setText(dir_path)

    def Choice_dir_output(self):
        dir_path = QtWidgets.QFileDialog.getExistingDirectory(self, &quot;请选择文件夹路径&quot;, &quot;D:\\&quot;)
        self.output.setText(dir_path)

    def Get_data(self, file):
        &#39;&#39;&#39;获取单个Excel文件中的资料&#39;&#39;&#39;
        wb = xlrd.open_workbook(file)
        ws = wb.sheets()[0]
        data = &#123;&#125;
        for row in range(7, ws.nrows - 2):
            card_id = ws.cell(2, 16).value
            car = ws.cell(3, 16).value
            dt = ws.cell(row, 0).value
            if type(dt) is float:
                date_time = xlrd.xldate.xldate_as_datetime(dt, 0)
            else:
                date_time = datetime.datetime.strptime(dt, &#39;%Y-%m-%d %H:%M:%S&#39;)
            business = ws.cell(row, 2).value
            model = ws.cell(row, 3).value
            qty = ws.cell(row, 4).value
            unit_price = ws.cell(row, 6).value
            price = ws.cell(row, 8).value
            reward = ws.cell(row, 9).value
            discount = ws.cell(row, 11).value
            balance = ws.cell(row, 13).value
            location = str(ws.cell(row, 15).value).strip()
            operator = ws.cell(row, 17).value
            date = date_time.date()
            time = date_time.time()
            info_list = [card_id, car, date_time, business, model, qty, unit_price, price, reward, discount,
                         balance, location, operator, date, time]
            data.setdefault(date, [])
            if info_list[3] != &quot;备注&quot;:
                data[date].append(info_list)
        # 增加当日加油次数
        for key in data.keys():
            for i in data[key]:
                i.append(len(data[key]))
        return data

    def Get_file_path(self, path):
        files = []
        for file in os.listdir(path):
            if file.endswith(&quot;.xls&quot;):  # 排除文件夹内的其它干扰文件
                files.append(path + &quot;\\&quot; + file)
        return files

    def Get_current_time(self):
        time_stamp = time.time()  # 当前时间的时间戳
        local_time = time.localtime(time_stamp)  #
        str_time = time.strftime(&#39;%Y-%m-%d %H.%M.%S&#39;, local_time)
        return str_time

    def Summary_data(self, files):
        thin = Side(border_style=&quot;thin&quot;, color=&quot;000000&quot;)  # 定义边框粗细及颜色
        title = [&#39;部门&#39;, &#39;部门编号&#39;, &#39;时间&#39;, &#39;业务类型&#39;, &#39;品种&#39;, &#39;数量&#39;, &#39;单价&#39;, &#39;金额&#39;, &#39;额外值&#39;,
                 &#39;调整&#39;, &#39;剩余&#39;, &#39;库位&#39;, &#39;操作员&#39;, &#39;领取日期&#39;, &#39;领取时间&#39;, &#39;领取次数&#39;]

        wb = Workbook()
        ws = wb.active
        ws.merge_cells(&quot;A1:P1&quot;)
        ws.cell(1, 1).value = &quot;领料明细汇总表&quot;
        ws.cell(1, 1).font = Font(name=u&#39;黑体&#39;, bold=True, size=18)
        ws.row_dimensions[1].height = 22.2
        ws.cell(1, 1).alignment = Alignment(horizontal=&quot;center&quot;, vertical=&quot;center&quot;)
        ws.append(title)

        # 插入数据
        files = self.Get_file_path(self.input.text())  # 获取文本编辑框中的输入文件目录，并获取目录下的xls文件
        for file in files:
            data = self.Get_data(file)
            for key in data.keys():
                for i in data[key]:
                    ws.append(i)
            f = QtWidgets.QListWidgetItem(f&quot;&#123;file&#125; 的内容已加入总表.&quot;)  # 创建一个显示项
            self.show_result.addItem(f)  # 将结果添加到部件中

        # 设置字号，对齐，缩小字体填充，加边框
        # Font(bold=True)可加粗字体
        for row_number in range(2, ws.max_row + 1):
            for col_number in range(1, 17):
                c = ws.cell(row=row_number, column=col_number)
                c.font = Font(size=9)
                c.border = Border(top=thin, left=thin, right=thin, bottom=thin)
                c.alignment = Alignment(horizontal=&quot;left&quot;, vertical=&quot;center&quot;)

        col_name = list(&quot;ABCDEFGHIJKLMNOP&quot;)
        col_width = [8, 8, 16, 8, 16, 8, 8, 9.8, 8, 8, 8, 11, 8.3, 9, 8, 8]
        for i in range(len(col_name)):
            ws.column_dimensions[col_name[i]].width = col_width[i]

        ws.column_dimensions.group(&#39;I&#39;, &#39;K&#39;, hidden=True)
        ws.column_dimensions.group(&#39;N&#39;, &#39;O&#39;, hidden=True)

        wb.save(f&quot;&#123;self.output.text()&#125;\\领料明细汇总表&#123;self.Get_current_time()&#125;.xlsx&quot;)
        f = QtWidgets.QListWidgetItem(f&quot;\n领料明细汇总表&#123;self.Get_current_time()&#125;.xlsx 已生成，请去输出文件夹查看.&quot;)  # 创建一个显示项
        self.show_result.addItem(f)  # 将结果添加到部件中


def main():
    app = QtWidgets.QApplication(sys.argv)
    app.setWindowIcon(QIcon(&quot;PO.ico&quot;))  # 设置界面左上角图标
    gui = MainGUI()
    gui.show()
    sys.exit(app.exec_())


if __name__ == &#39;__main__&#39;:
    main()
    
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>PyQt5</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>openpyxl</tag>
        <tag>PyQt5</tag>
      </tags>
  </entry>
  <entry>
    <title>python | 去除字符串首尾空格</title>
    <url>/2021/11/13/python%E5%8E%BB%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A6%96%E5%B0%BE%E7%A9%BA%E6%A0%BC/</url>
    <content><![CDATA[<h1 id="去除字符串首尾空格"><a href="#去除字符串首尾空格" class="headerlink" title="去除字符串首尾空格"></a>去除字符串首尾空格</h1><p>程序使用两种方法去除字符串首尾的空格。</p>
<span id="more"></span>
<h2 id="1-strip-rstrip-lstrip"><a href="#1-strip-rstrip-lstrip" class="headerlink" title="1.strip() rstrip() lstrip()"></a>1.strip() rstrip() lstrip()</h2><pre><code>a = &#39;  welcome to my world  &#39;
print(len(a))
print(len(a.strip()))  # 去掉首尾字符串
print(len(a.lstrip()))  # 去掉首部空格
print(len(a.rstrip()))  # 去掉尾部空格
print(len(a.lstrip().rstrip()))  # 先去掉首部空格再去掉尾部空格
</code></pre>
<h1 id="2-递归实现"><a href="#2-递归实现" class="headerlink" title="2.递归实现"></a>2.递归实现</h1><pre><code>def trim(s):
    flag = 0
    if s[:1] == &#39; &#39;:
        s = s[1:]
        flag = 1
    if s[-1:] == &#39; &#39;:
        s = s[:-1]
        flag = 1
    if flag == 1:
        return trim(s)
    else:
        return s
print(len(&#39;  Hello World  &#39;))  # 15
print(len(trim(&#39;  Hello World  &#39;)))  # 11
</code></pre>
<h1 id="3-while循环实现"><a href="#3-while循环实现" class="headerlink" title="3.while循环实现"></a>3.while循环实现</h1><pre><code>def trim(s):
    while True:
        flag = 0
        if s[:1] == &#39; &#39;:
            s = s[1:]
            flag = 1
        if s[-1:] == &#39; &#39;:
            s = s[:-1]
            flag = 1
        if flag == 0:
            break
    return s
print(len(&#39;  Hello World  &#39;))  # 15
print(len(trim(&#39;  Hello World  &#39;)))  # 11
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>strip</tag>
      </tags>
  </entry>
  <entry>
    <title>python | python可变参数</title>
    <url>/2021/08/02/python%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h1 id="python可变参数"><a href="#python可变参数" class="headerlink" title="python可变参数"></a>python可变参数</h1><p>python中的函数可以定义<strong>接受不确定数量的参数</strong>，这种参数被称为<strong>可变参数</strong>。</p>
<p>可变参数有两种：1）参数前加*  2）参数前加**<br>*可变参数在函数中被组装成一个元组<br>**可变参数在函数中被组装成一个字典、</p>
<p>代码示例：</p>
<pre><code># *可变参数
def sum(*numbers):
    total = 0.0
    
    for number in numbers:
        total += number
        
    return total
    
print(sum(100.0, 20.0, 30.0))  # 150
print(sum(30.0, 80.0))  # 110

# **可变参数
# coding=utf-8

def show_info(**info):
    print(&#39;-----show_info-----&#39;)
    for key,value in info.items():
        print(&quot;&#123;0&#125; - &#123;1&#125;&quot;.format(key, value)
        
show_info(name=&#39;Tony&#39;, age=18, sex=True)
show_info(student_name=&#39;Tony&#39;, student_no=&#39;1000&#39;)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python | 垃圾回收机制</title>
    <url>/2021/11/14/python%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><h2 id="Pyhton垃圾回收机制"><a href="#Pyhton垃圾回收机制" class="headerlink" title="Pyhton垃圾回收机制"></a>Pyhton垃圾回收机制</h2><p>1.引用计数<br><strong>引用计数法的原理是：</strong> 每个对象维护一个ob_ref字段，用来记录该对象当前被引用的次数，每当新的引用指向该对象时，它的引用计数ob_ref加1，每当该对象的引用失效时计数ob_ref减1，一旦对象的引用计数为0，该对象立即被回收，对象占用的内存空间将被释放。<br><strong>缺点：</strong> 无法解决循环引用<br>2.标记清除<br>Python采用了“标记-清除”(Mark and Sweep)算法，解决容器对象可能产生的循环引用问题。<br><strong>标记阶段</strong> 遍历所有的对象，如果是可达的（reachable），也就是还有对象引用它，那么就标记该对象为可达；<br><strong>清除阶段</strong> 再次遍历对象，如果发现某个对象没有标记为可达，则就将其回收。<br><strong>优点：</strong> 解决了循环引用问题<br><strong>缺点：</strong> 标记清除算法在执行很多次数后，程序的堆空间会产生一些小的内存碎片。<br>3.分代回收(假设新生代、中生代和老生代的threshold分别为700、10、10.)<br>· 每新增 701 个需要 GC 的对象，触发一次新生代 GC<br>· 每执行 11 次新生代 GC ，触发一次中生代 GC<br>· 每执行 11 次中生代 GC ，触发一次老生代 GC (老生代 GC 还受其他策略影响，频率更低)<br>· 执行某个生代 GC 前，年轻生代对象链表也移入该代，一起 GC<br>· 一个对象创建后，随着时间推移将被逐步移入老生代，回收频率逐渐降低</p>
<p><a href="https://mp.weixin.qq.com/s/y_pqtoB-FcTxwBOHpi8hAg">参考资料</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
        <category>gc</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>垃圾回收机制</tag>
        <tag>gc</tag>
      </tags>
  </entry>
  <entry>
    <title>多进程 | python实现多任务进程</title>
    <url>/2021/11/06/python%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="python实现多任务进程"><a href="#python实现多任务进程" class="headerlink" title="python实现多任务进程"></a>python实现多任务进程</h1><p>以下内容主要阐述了python实现多进程的两种方式、进程间如何通信、进程池以及一个多进程案例：批量复制文件。</p>
<span id="more"></span>
<p><strong>Show You the Code:</strong></p>
<pre><code># 实现多进程
# 1.使用process类
import multiprocessing


def process(index):
    print(f&#39;Process:&#123;index&#125;&#39;)


if __name__ == &quot;__main__&quot;:
    for i in range(5):
        p = multiprocessing.Process(target=process, args=(i,))
        p.start()


# 2.继承process类
import time
from multiprocessing import Process


class MyProcess(Process):
    def __init__(self, loop):
        Process.__init__()
        self.loop = loop

    def run(self):
        for count in range(self.loop):
            time.sleep(1)
            print(f&#39;Pid:&#123;self.pid&#125; LoopCount:&#123;count&#125;&#39;)


if __name__ == &#39;__main__&#39;:
    for i in range(2, 5):
        p = MyProcess(i)
        p.start()


# 进程间的通信
# 1、Queue-队列 先进先出
from multiprocessing import Queue
import multiprocessing


def download(p):  # download the data
    lst = [11, 22, 33, 44]
    for item in lst:
        p.put(item)
    print(&quot;successfully downloaded data!&quot;)


def save_data(p):
    lst = []
    while True:
        data = p.get()
        lst.append(data)
        if p.empty():
            break
    print(lst)
    print(&quot;successfully saved data!&quot;)


def main():
    p1 = Queue()

    t1 = multiprocessing.Process(target=download, args=(p1,))
    t2 = multiprocessing.Process(target=save_data, args=(p1,))

    t1.start()
    t2.start()


if __name__ == &quot;__main__&quot;:
    main()


# 2、共享全局变量不适用于多进程编程
import multiprocessing

a = 1  # 全局变量


def demo1():
    global a
    a += 1


def demo2():
    print(a)


def main():
    t1 = multiprocessing.Process(target=demo1)
    t2 = multiprocessing.Process(target=demo2)

    t1.start()
    t2.start()


if __name__ == &quot;__main__&quot;:
    main()


# 进程池之间的通信
from multiprocessing import Pool
import os, time, random


def worker(a):
    t_start = time.time()
    print(&#39;%s开始执行，进程号为%d&#39; % (a, os.getpid()))

    time.sleep(random.random() * 2)
    t_stop = time.time()
    print(a, &#39;执行完成，耗时%0.2f&#39; % (t_stop - t_start))


if __name__ == &#39;__main__&#39;:
    po = Pool(3)  # 定义一个进程池
    for i in range(0, 10):
        po.apply_async(worker, (i,))  # 向进程池中添加worker任务

    print(&quot;--start--&quot;)
    po.close()

    po.join()
    print(&quot;--end--&quot;)


# 案例：文件批量复制
import os
import time
import multiprocessing


def copy_file(Q, oldfolderName, newfolderName, file_name):
    # 文件复制,不需要返回
    time.sleep(0.5)
    # print(&#39;\r从%s文件夹复制到%s文件夹的%s文件&#39;%(oldfolderName,newfolderName,file_name),end=&#39;&#39;)

    old_file = open(oldfolderName + &#39;/&#39; + file_name, &#39;rb&#39;)  # 待复制文件
    content = old_file.read()
    old_file.close()

    new_file = open(newfolderName + &#39;/&#39; + file_name, &#39;wb&#39;)  # 复制出的新文件
    new_file.write(content)
    new_file.close()

    Q.put(file_name)  # 向Q队列中添加文件


def main():
    oldfolderName = input(&#39;请输入要复制的文件夹名字:&#39;)  # 步骤1获取要复制文件夹的名字(可以手动创建,也可以通过代码创建,这里我们手动创建)
    newfolderName = oldfolderName + &#39;复件&#39;
    # 步骤二 创建一个新的文件夹
    if not os.path.exists(newfolderName):
        os.mkdir(newfolderName)

    filenames = os.listdir(oldfolderName)  # 3.获取文件夹里面所有待复制的文件名
    # print(filenames)

    pool = multiprocessing.Pool(5)  # 4.创建进程池

    Q = multiprocessing.Manager().Queue()  # 创建队列,进行通信
    for file_name in filenames:
        pool.apply_async(copy_file, args=(Q, oldfolderName, newfolderName, file_name))  # 5.向进程池添加任务
    pool.close()

    copy_file_num = 0
    file_count = len(filenames)
    # 不知道什么时候完成,所以定义一个死循环
    while True:
        file_name = Q.get()
        print(f&quot;&#123;file_name&#125;已经复制！&quot;)
        copy_file_num += 1
        time.sleep(0.2)
        print(&#39;\r拷贝进度%.2f %%&#39; % (copy_file_num * 100 / file_count), end=&#39;&#39;)  # 做一个拷贝进度条

        if copy_file_num &gt;= file_count:
            break


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>多进程</tag>
        <tag>multiprocessing</tag>
      </tags>
  </entry>
  <entry>
    <title>python | 对象转json</title>
    <url>/2021/11/08/python%E5%AF%B9%E8%B1%A1%E8%BD%ACjson/</url>
    <content><![CDATA[<h1 id="python对象转json"><a href="#python对象转json" class="headerlink" title="python对象转json"></a>python对象转json</h1><p>程序将python的对象转为json格式。</p>
<span id="more"></span>

<p><strong>train_data_cor.txt文件包含以下内容：</strong><br>james.txt 2-34,3:21,2,34,2.45,3.01,2:01,2:01,3:10,2-22<br>sarah.txt 2:58,2.58,2:39,2-25,2:55,2:54,2.18,2:55,2:55<br>julie.txt 2.59,2.11,2:11,2:23,3-10,2-23,3:10,3.21,3-21<br>mikey.txt 2:22,3.01,3:01,3.02,3:02,3.02,3:22,2.49,2:38</p>
<p><strong>code:</strong></p>
<pre><code>import json
class Athlete(json.JSONEncoder):
    def __init__(self,a_name,a_dob=None,a_times=[]):
        self.name = a_name
        self.dob = a_dob
        self.times = a_times
    def top3(self):
        return sorted(set([self.sanitize(t) for t in self.times]))[0:3]
    def sanitize(self,time_string):
        if &#39;-&#39; in time_string:
            splitter = &#39;-&#39;
        elif &#39;:&#39; in time_string:
            splitter = &#39;:&#39;
        else:
            return (time_string)
        (mins,secs) = time_string.split(splitter)
        return (mins+&#39;.&#39;+secs)


with open(&#39;train_data_cor.txt&#39;) as f:
    data = f.readline().strip().split(&#39;,&#39;)
    ath = Athlete(data.pop(0),data.pop(0),data)
    print(ath)

ath_json = json.dumps(ath.__dict__)

# 将json形式变量保存到文件中
with open(&#39;json.txt&#39;,&#39;w&#39;) as f:
    json.dump(ath_json,f)
    
# 读取json文件内容    
with open(&#39;json.txt&#39;) as f:
    ath = json.load(f)
    print(ath)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>itchat | python微信轰炸</title>
    <url>/2021/10/16/python%E5%BE%AE%E4%BF%A1%E8%BD%B0%E7%82%B8/</url>
    <content><![CDATA[<h1 id="python微信轰炸"><a href="#python微信轰炸" class="headerlink" title="python微信轰炸"></a>python微信轰炸</h1><p><a href="https://www.bilibili.com/read/cv11064085/">python微信轰炸</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>itchat</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>itchat</tag>
        <tag>微信轰炸</tag>
      </tags>
  </entry>
  <entry>
    <title>os | python批量重命名文件</title>
    <url>/2021/10/27/python%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="python批量重命名文件"><a href="#python批量重命名文件" class="headerlink" title="python批量重命名文件"></a>python批量重命名文件</h1><p>程序将’文件’文件夹下的所有文件重命名。</p>
<span id="more"></span>
<p>实现代码：</p>
<pre><code>import os


def Get_modify_time(file):
    return os.path.getmtime(file)  # 获取文件修改时间


path = &#39;文件&#39;  # 文件所在文件夹
files = [path + &quot;\\&quot; + i for i in os.listdir(path)]  # 获取文件夹下的文件名,并拼接完整路径
files.sort(key=Get_modify_time)  # 以文件修改时间为依据升序排序
seq = 1  # 计数器，从1开始
for file in files:
    os.rename(file, os.path.join(path, str(seq) + &quot;. &quot; + file.split(&quot;\\&quot;)[-1]))  # 重命名文件
    seq += 1
</code></pre>
<p>‘文件’文件夹包括以下文件：<br><a href="说明.docx">说明.docx</a><br><a href="文档.txt">文档.txt</a><br><a href="演示文稿 - v1.pptx">演示文稿 - v1.pptx</a><br><a href="演示文稿.pptx">演示文稿.pptx</a><br><a href="资料.xlsx">资料.xlsx</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>内置模块</category>
        <category>os</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>文档 | python文档</title>
    <url>/2021/10/27/python%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h1 id="python文档"><a href="#python文档" class="headerlink" title="python文档"></a>python文档</h1><p><a href="https://www.bookstack.cn/read/explore-python/SUMMARY.md">这是一个不错的python文档！！！</a><br><a href="https://github.com/ethan-funny/explore-python">github地址</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>文档</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python文档</tag>
      </tags>
  </entry>
  <entry>
    <title>python-docx | python替换word文档中的文字</title>
    <url>/2021/10/28/python%E6%9B%BF%E6%8D%A2word%E6%96%87%E6%A1%A3%E4%B8%AD%E7%9A%84%E6%96%87%E5%AD%97/</url>
    <content><![CDATA[<h1 id="python替换word文档中的文字"><a href="#python替换word文档中的文字" class="headerlink" title="python替换word文档中的文字"></a>python替换word文档中的文字</h1><p>实现代码：</p>
<pre><code># -*- coding:utf-8 -*-
import docx


# # 定义函数替换文字块中的字符
# def info_update(doc, old_info, new_info):
#     for para in doc.paragraphs:  # 遍历段落
#         for run in para.runs:  # 遍历文字块
#             # run.text = run.text.replace(old_info, new_info)  # 替换
#             print(run.text)
#
#
# doc = docx.Document(&#39;替换前.docx&#39;)
# info_update(doc, &#39;第四次&#39;, &#39;第五次&#39;)
# info_update(doc, &#39;2019&#39;, &#39;2020&#39;)
# info_update(doc, &#39;18&#39;, &#39;10&#39;)
# doc.save(&#39;替换后.docx&#39;)

# doc = docx.Document(&#39;替换前.docx&#39;)
# for para in doc.paragraphs:  # 遍历段落
#     for run in para.runs:  # 遍历文字块
#         # run.text = run.text.replace(old_info, new_info)  # 替换
#         print(run.text)

# # 按段落查看文字
# doc = docx.Document(&#39;替换前.docx&#39;)
# for para in doc.paragraphs:
#     print(para.text)

import docx
from docx.shared import Pt  # 用于设定字体大小(磅值)
from docx.oxml.ns import qn  # 用于应用中文字体


def info_update(doc, old_info, new_info):
    for para in doc.paragraphs:
        para.text = para.text.replace(old_info, new_info)

    # 设置第一段（标题）的文字格式
    for run in doc.paragraphs[0].runs:
        run.font.size = Pt(14)  # 文字大小磅值
        run.bold = True  # 加粗
        run.font.name = &quot;微软雅黑&quot;  # 字体选择
        # 中文字体应用，固定写法
        r = run._element.rPr.rFonts  # 字体，固定写法
        r.set(qn(&quot;w:eastAsia&quot;), &quot;微软雅黑&quot;)  # 字体

    # 设置第二及后续段落的文字格式
    for para in doc.paragraphs[1:]:
        for run in para.runs:
            run.font.size = Pt(12)  # 文字大小
            run.bold = False  # 不加粗
            run.font.name = &quot;微软雅黑&quot;  # 字体选择
            # 中文字体应用，固定写法
            r = run._element.rPr.rFonts
            r.set(qn(&quot;w:eastAsia&quot;), &quot;微软雅黑&quot;)


doc = docx.Document(&#39;替换前.docx&#39;)
info_update(doc, &quot;第四次&quot;, &quot;第五次&quot;)
info_update(doc, &quot;2019&quot;, &quot;2020&quot;)
info_update(doc, &quot;18&quot;, &quot;10&quot;)
doc.save(&#39;替换后_设置格式.docx&#39;)
</code></pre>
<p><a href="替换前.docx">替换前.docx</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>python-docx</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python-docx</tag>
      </tags>
  </entry>
  <entry>
    <title>requests | python爬虫爬取会计师网站的指定文章</title>
    <url>/2021/10/29/python%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96%E4%BC%9A%E8%AE%A1%E5%B8%88%E7%BD%91%E7%AB%99%E7%9A%84%E6%8C%87%E5%AE%9A%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="python爬虫爬取会计师网站的指定文章"><a href="#python爬虫爬取会计师网站的指定文章" class="headerlink" title="python爬虫爬取会计师网站的指定文章"></a>python爬虫爬取会计师网站的指定文章</h1><p>还没学习爬虫，没看懂！有缘再见！后会有期！</p>
<p>贴上代码：</p>
<pre><code>import requests
import os
import json


print(&quot;开始爬取文章......&quot;)
header = &#123;
    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.75 &#39;
                  &#39;Safari/537.36&#39;&#125;

form_data = &#123;&#39;_q&#39;: &#39;Article.list&#39;,
             &#39;siteId&#39;: &#39;7e0b3b27-2622-4aa7-b6f8-abfe5c5df922&#39;,
             &#39;catalogId&#39;: &#39;34f92da3-d6d0-4e96-899f-d7f581c18162&#39;,
             &#39;pub&#39;: &#39;true&#39;,
             &#39;limit&#39;: 5000,
             &#39;start&#39;: 1&#125;

# 这是异步加载，请求方法是POST
url = &quot;http://www.bicpa.org.cn/dtzj/zxgg/getArticles.action&quot;
res = requests.post(url, data=form_data, headers=header)

article_data0 = res.text.split(&quot;&#123;success:true,datas:&quot;)[1]  # 去掉字符串前面的无用信息“&#123;success:true,datas:”
article_data = article_data0.split(&quot;,total:&quot;)[0]  # 去掉字符串后面的无用信息“,total:4946&#125;”

obj = json.loads(article_data)
# 获取标题含有“委员会专家提示”的文章的标题，发布时间和链接
path = r&quot;http://www.bicpa.org.cn&quot;
articles = []
for info in obj:
    if &quot;委员会专家提示&quot; in info[&#39;title&#39;]:
        article = &#123;
            &quot;标题&quot;: info[&#39;title&#39;].strip(),  # strip()去除首尾空格
            &quot;发布时间&quot;: info[&#39;publishDate&#39;],
            &quot;链接&quot;: path + info[&#39;url&#39;] + info[&#39;primaryKey&#39;] + &quot;.html&quot;
        &#125;
        articles.append(article)


import requests
from bs4 import BeautifulSoup
import docx
from docx.shared import Pt  # 用于设定字体大小（磅值）
from docx.oxml.ns import qn  # 用于应用中文字体
import random
import time


# 获取想要的文章并批量写入word文件
def Get_article_to_word(url, date):
    user_agent_list = [
        &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36&quot;,
        &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&quot;,
        &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36&quot;,
        &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.62 Safari/537.36&quot;,
        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36&quot;,
        &quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)&quot;,
        &quot;Mozilla/5.0 (Macintosh; U; PPC Mac OS X 10.5; en-US; rv:1.9.2.15) Gecko/20110303 Firefox/3.6.15&quot;
    ]
    header = &#123;&#39;User-Agent&#39;: random.choice(user_agent_list)&#125;
    wb_data = requests.get(url, headers=header)
    soup = BeautifulSoup(wb_data.content)
    title = soup.select(&#39;.headword&#39;)[0].text.strip()  # 获得标题
    content1 = soup.select(&quot;.MsoNormal&quot;)  # 针对正文布局为 class = &quot;MsoNormal&quot;
    content2 = soup.select(&quot;#art_content&quot;)  # 针对正文布局为 id = &quot;art_content&quot;

    doc = docx.Document()  # 新建空白word文档
    # 设定全局字体
    doc.styles[&#39;Normal&#39;].font.name = u&#39;宋体&#39;
    doc.styles[&#39;Normal&#39;]._element.rPr.rFonts.set(qn(&#39;w:eastAsia&#39;), u&#39;宋体&#39;)

    # 写入标题行，并设置字体格式
    p = doc.add_paragraph()
    r = p.add_run(title)
    r.bold = True
    r.font.size = Pt(18)

    doc.add_paragraph(date)  # 写入日期
    doc.add_paragraph(url)  # 写入文章链接

    dirs = os.getcwd() + &quot;\\文章&quot;
    if not os.path.exists(dirs):
        os.makedirs(dirs)

    # 写入正文
    for i in content2:
        doc.add_paragraph(i.text)
    for i in content1:
        doc.add_paragraph(i.text)
    doc.save(f&quot;&#123;dirs&#125;\\&#123;title&#125;.docx&quot;)


# 遍历所有文章的链接，调用以上函数执行
for art in articles:
    Get_article_to_word(art[&quot;链接&quot;], art[&quot;发布时间&quot;])
    print(&quot;&#123;&#125; 下载完成。&quot;.format(art[&#39;标题&#39;]))
    if articles.index(art) % 30 == 29:  # 每获取30篇文章，暂停5秒，避免频繁请求被服务器切断连接
        time.sleep(5)

print(f&quot;共下载 &#123;len(articles)&#125; 篇文章。&quot;)
print(&quot;程序运行完成，关闭窗口退出.&quot;)
input()
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>requests</category>
      </categories>
      <tags>
        <tag>os</tag>
        <tag>python-docx</tag>
        <tag>requests</tag>
        <tag>json</tag>
        <tag>random</tag>
        <tag>BeautifulSoup4</tag>
        <tag>time</tag>
      </tags>
  </entry>
  <entry>
    <title>pyinstaller | python程序打包</title>
    <url>/2021/10/29/python%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<h1 id="python程序打包"><a href="#python程序打包" class="headerlink" title="python程序打包"></a>python程序打包</h1><p>通常情况我们在pycharm中写的python程序只能在安装了python的电脑上运行，那么如何移植到其他电脑上也能运行呢？<br>我们可以将py文件打包成可执行程序(exe文件).</p>
<h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><h3 id="1-pyinstaller库安装"><a href="#1-pyinstaller库安装" class="headerlink" title="1. pyinstaller库安装"></a>1. pyinstaller库安装</h3><pre><code>pip install pyinstaller -i https://pypi.doubanio.com/simple/
</code></pre>
<h3 id="2-打包"><a href="#2-打包" class="headerlink" title="2.打包"></a>2.打包</h3><pre><code>pyinstaller -D program.py ---&gt; 打包成一个文件夹（默认操作）
pyinstaller -F program.py ---&gt; 打包成单个可执行文件
</code></pre>
<p>程序运行后，会在目录生成一个文件：<br>1.program.spec(打包规则)<br>三个文件夹：<br>1.__pycache __(Python版本信息)<br>2.build(存储日志文件)<br>3.dist(储存可执行文件即相关的文件夹)<br><strong>注：打包完成后，除了dist文件夹，其它都可以删除，没什么用。</strong></p>
<h3 id="3-将打包好的文件制作成一个安装文件"><a href="#3-将打包好的文件制作成一个安装文件" class="headerlink" title="3.将打包好的文件制作成一个安装文件"></a>3.将打包好的文件制作成一个安装文件</h3><p>使用NSIS文件夹压缩器来制作安装文件。</p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>pyinstaller</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pyinstaller</tag>
        <tag>程序打包</tag>
      </tags>
  </entry>
  <entry>
    <title>jieba | python词频分析</title>
    <url>/2021/10/27/python%E8%AF%8D%E9%A2%91%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="python词频分析"><a href="#python词频分析" class="headerlink" title="python词频分析"></a>python词频分析</h1><p>程序分析了”主要业务”文件夹的所有文件中的文本信息的词频(分别存储在”词频”文件夹中)</p>
<span id="more"></span>

<p>实现代码：</p>
<pre><code>import os
import jieba
import pandas as pd

path = &#39;主要业务&#39;  # 文件所在文件夹
files = [path + &quot;\\&quot; + i for i in os.listdir(path)]  # 获取文件夹下的文件名,并拼接完整路径

for file in files:
    txt = open(file, &quot;r&quot;, encoding=&quot;utf-8&quot;).read()
    words = jieba.lcut(txt)
    wordsDict = &#123;&#125;  # 新建字典用于储存词及词频
    for word in words:
        if len(word) == 1:  # 单个的字符不作为词放入字典
            continue
        else:
            wordsDict.setdefault(word, 0)  # 设置词的初始出现次数为0
            wordsDict[word] += 1  # 对于重复出现的词，每出现一次，次数增加1

    stopWords = [&quot;2019&quot;, &quot;不断&quot;, &quot;持续&quot;, &quot;主要&quot;, &quot;企业&quot;, &quot;产品&quot;, &quot;业务&quot;, &quot;公司&quot;, &quot;行业&quot;, &quot;000&quot;, &quot;用于&quot;, &quot;情况&quot;, &quot;方面&quot;, &quot;一种&quot;, &quot;要求&quot;, &quot;对于&quot;,
                 &quot;进行&quot;, &quot;一般&quot;, &quot;212&quot;, &quot;实现&quot;, &quot;处理&quot;, &quot;通过&quot;, &quot;投入&quot;, &quot;随着&quot;]
    for word in stopWords:
        if word in wordsDict:
            del wordsDict[word]

    wordsDict_seq = sorted(wordsDict.items(), key=lambda x: x[1], reverse=True)  # 按字典的值降序排序

    df = pd.DataFrame(wordsDict_seq, columns=[&#39;词&#39;, &#39;次数&#39;])
    df.to_excel(&quot;词频//&#123;&#125;.xlsx&quot;.format(file.split(&quot;\\&quot;)[1][:-4]), index=False)  # 存为Excel时去掉index索引列
  
</code></pre>
<p>“主要业务”文件夹的所有文件:<br><a href="东旭蓝天：2019年年度报告.txt">东旭蓝天：2019年年度报告.txt</a><br><a href="保利地产：2018年年度报告.txt">保利地产：2018年年度报告.txt</a><br><a href="共达电声：2019年年度报告（更新后）.txt">共达电声：2019年年度报告（更新后）.txt</a><br><a href="华特气体：2019年年度报告（修订版）.txt">华特气体：2019年年度报告（修订版）.txt</a><br><a href="吉峰科技：2019年年度报告（更新后）.txt">吉峰科技：2019年年度报告（更新后）.txt</a><br><a href="引力传媒：2019年年度报告（修订版）.txt">引力传媒：2019年年度报告（修订版）.txt</a><br><a href="方正科技：2019年年度报告.txt">方正科技：2019年年度报告.txt</a><br><a href="湖北宜化：2019年年度报告（更新后）.txt">湖北宜化：2019年年度报告（更新后）.txt</a><br><a href="联创股份：2019年年度报告（更新后）.txt">联创股份：2019年年度报告（更新后）.txt</a><br><a href="高乐股份：2019年年度报告.txt">高乐股份：2019年年度报告.txt</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>jieba</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>os</tag>
        <tag>pandas</tag>
        <tag>jieba</tag>
      </tags>
  </entry>
  <entry>
    <title>baidu-aip | python调用人工智能识别表格</title>
    <url>/2021/10/27/python%E8%B0%83%E7%94%A8%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%AF%86%E5%88%AB%E8%A1%A8%E6%A0%BC/</url>
    <content><![CDATA[<h1 id="python调用人工智能识别表格"><a href="#python调用人工智能识别表格" class="headerlink" title="python调用人工智能识别表格"></a>python调用人工智能识别表格</h1><p>使用百度的OCR API识别表格中的文字。<br><a href="https://blog.csdn.net/weixin_39932611/article/details/112354147">参考资料1</a><br><a href="https://blog.csdn.net/weixin_44298740/article/details/117560495">参考资料2</a></p>
<span id="more"></span>

<pre><code># coding:utf-8
# 获取路径下所有图片文件，并存入列表
import os

work_path = &quot;图片\\&quot;
pictures = []  # 存储文件夹内所有文件的路径（包括子目录内的文件）
for root, dirs, files in os.walk(work_path):
    path = [os.path.join(root, name) for name in files]
    pictures.extend(path)

from aip import AipOcr  # 导入AipOcr模块，用于做文字识别
import time  # 时间模块
import requests  # 用于HTTP请求

APP_ID = &#39;25067363&#39;
API_KEY = &#39;0PRCHim4nzLcDNEYR1hcSGGG&#39;
SECRET_KEY = &#39;DFGtcTbhpD829q9GOUbjPYameEty7C6i&#39;
client = AipOcr(APP_ID, API_KEY, SECRET_KEY)

# 提交识别请求，并储存所有请求ID
for picture in pictures:
    pic = open(picture, &#39;rb&#39;)  # 以二进制方式打开图片
    img = pic.read()  # 读取
    table = client.tableRecognitionAsync(img)  # 调用表格识别模块
    print(table)
    # request_id = table[&#39;result&#39;][0][&#39;request_id&#39;]
    #
    # # 判断识别是否完成，直到完成才根据请求ID获取Excel下载路径
    # result = client.getTableRecognitionResult(request_id)  # 通过ID获取识别结果
    # while result[&#39;result&#39;][&#39;ret_msg&#39;] != &#39;已完成&#39;:  # 如果状态是“已完成”，才能获取下载地址
    #     time.sleep(2)  # 暂停2秒再刷新
    #     result = client.getTableRecognitionResult(request_id)  # 持续刷新，直到满足条件
    #
    # download_path = result[&#39;result&#39;][&#39;result_data&#39;]
    #
    # # 下载并将Excel文件名设为图片名
    # excel_name = picture.split(&quot;.&quot;)[0] + &quot;.xls&quot;  # 让excel文件的名字与图片相同
    # excel = requests.get(download_path)  # 抓取下载链接
    # file = open(excel_name, &#39;wb&#39;)  # 新建excel文件
    # file.write(excel.content)  # 写入excel文件并保存
    
</code></pre>
<p><a href="论文.jpg">论文.jpg</a><br><a href="收货表.jpg">收货表.jpg</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>baidu-aip</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>os</tag>
        <tag>requests</tag>
        <tag>time</tag>
        <tag>baidu-aip</tag>
      </tags>
  </entry>
  <entry>
    <title>python资源大全</title>
    <url>/2021/07/03/python%E8%B5%84%E6%BA%90%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<p>awesome-python 是 vinta 发起维护的 Python 资源列表，内容包括：Web 框架、网络爬虫、网络内容提取、模板引擎、数据库、数据可视化、图片处理、文本处理、自然语言处理、机器学习、日志、代码分析等。<br><a href="http://jobbole.github.io/awesome-python-cn/">python资源大全中文版</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python | re.match与re.search的区别</title>
    <url>/2020/11/08/re-match%E4%B8%8Ere-search%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="re-match与re-search的区别"><a href="#re-match与re-search的区别" class="headerlink" title="re.match与re.search的区别"></a>re.match与re.search的区别</h1><p>re.match从字符串的起始位置匹配一个模式，如果字符串开始不符合正则表达式，则匹配失败。<br>re.search匹配整个字符串，直到找到一个匹配</p>
<h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><pre><code>s = &quot;Cats are smarter than dogs&quot;
re.match(r&quot;dogs&quot;,s)#匹配失败
re.search(r&quot;dogs&quot;,s)#匹配成功
</code></pre>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python | re sub的使用方法</title>
    <url>/2021/08/27/re-sub%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="re-sub的使用方法"><a href="#re-sub的使用方法" class="headerlink" title="re.sub的使用方法"></a>re.sub的使用方法</h1><p>re.sub()实现相对复杂的替换</p>
<p><a href="https://www.jianshu.com/p/8c1d1a38f9b9">使用方法</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>内置模块</category>
        <category>re</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>re</tag>
      </tags>
  </entry>
  <entry>
    <title>matplotlib | recorded EEG visualization</title>
    <url>/2021/10/12/recorded-EEG-visualization/</url>
    <content><![CDATA[<h1 id="recorded-EEG-visualization"><a href="#recorded-EEG-visualization" class="headerlink" title="recorded EEG visualization"></a>recorded EEG visualization</h1><p>在做脑电（EEG）的相关研究时,通常我们需要使用公开的脑电数据集合，公开数据集包含了以及采集好的脑电数据。<br>我们可以使用python的第三方库matplotlib将数据集中的脑电数据进行可视化。</p>
<span id="more"></span>

<p>下面以绘制8个通道的脑电数据为例对脑电数据进行可视化：<br>注意：实例中使用公开数据集DEAP,详细信息可参考<a href="http://www.eecs.qmul.ac.uk/mmv/datasets/deap/">DEAP 官网</a></p>
<p><strong>示例代码：</strong></p>
<pre><code>import os
import glob
import pickle
import matplotlib.pyplot as plt

# 参数设置
window_size = 1
sampling_rate = 500


# 获取数据文件列表并划分(训练文件/测试文件)
data_dir = &quot;data_preprocessed_python/&quot;
file_list = glob.glob(os.path.join(data_dir, &quot;*&quot;))  # 整个数据集包含32个subject的样本数据
print(&quot;len(file_list):&quot;, len(file_list))


def get_data_and_label(file_list):
    &quot;&quot;&quot;
    获得固定窗口大小的数据和对应的标签

    Arrray name         Array shape         Array contents
    ---------------------------------------------------------------------------------------------
    data                40 x 40 x 8064      video/trial x channel x data
    labels              40 x 4              videl/trial x label(valence,arousal,dominance,liking)
    ---------------------------------------------------------------------------------------------
    &quot;&quot;&quot;
    data = []
    valence_labels = []
    arousal_labels = []

    for file in file_list:
        x = pickle.load(open(file, &#39;rb&#39;), encoding=&#39;latin1&#39;)  # type(x):dict &#123;&#39;labels&#39;:array(),&#39;data&#39;:array()&#125;

        labels = x[&#39;labels&#39;]
        valence_labels.extend(labels[:, 0])
        arousal_labels.extend(labels[:, 1])

        dat = x[&#39;data&#39;]
        data.extend(dat[:, :, :window_size * sampling_rate])

    return data

print(&quot;开始获取脑电波数据...&quot;)
data = get_data_and_label(file_list)
print(&quot;脑电波数据已获取，开始绘制脑电波...&quot;)
x = range(sampling_rate)
fig, ax = plt.subplots(3, 3)
ax[0][0].plot(x, list(data[0][0]))
ax[0][0].set_title(&#39;Fp1&#39;)
ax[0][1].plot(x, list(data[0][1]))
ax[0][1].set_title(&#39;AF3&#39;)
ax[0][2].plot(x, list(data[0][2]))
ax[0][2].set_title(&#39;F3&#39;)
ax[1][0].plot(x, list(data[0][3]))
ax[1][0].set_title(&#39;F7&#39;)
ax[1][1].plot(x, list(data[0][4]))
ax[1][1].set_title(&#39;FC5&#39;)
ax[1][2].plot(x, list(data[0][5]))
ax[1][2].set_title(&#39;FC1&#39;)
ax[2][0].plot(x, list(data[0][6]))
ax[2][0].set_title(&#39;C3&#39;)
ax[2][1].plot(x, list(data[0][7]))
ax[2][1].set_title(&#39;T7&#39;)
ax[2][2].plot(x, list(data[0][8]))
ax[2][2].set_title(&#39;CP5&#39;)
plt.show()
print(&quot;脑电波绘制完成！&quot;)
</code></pre>
<p><strong>绘制的脑电波：</strong></p>
<p><img src="/2021/10/12/recorded-EEG-visualization/500_brainwave.png"></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>matplotlib</category>
      </categories>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb项目开发 | request域对象</title>
    <url>/2022/01/10/request%E5%9F%9F%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="request域对象"><a href="#request域对象" class="headerlink" title="request域对象"></a>request域对象</h1><p><strong>场景</strong>：有时候我们发送一个请求然后由一个对应的servlet处理请求，接着我们需要将当前的request对象的一些信息传递到另一个servlet或者jsp页面。<br><strong>方法</strong>：</p>
<ol>
<li>请求转发<br>假设当前处理请求的是Demo2Servlet(/demo2)，需要传递信息到Demo3Servlet(/demo3)中。</li>
</ol>
<pre><code>request.getRequestDispatcher(&quot;/demo3&quot;).forward(request, response);
</code></pre>
<p>然后我们就可以在Demo3Servlet中获取request中的信息。</p>
<pre><code>package com.oracle;

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class Demo3Servlet extends HttpServlet &#123;
    private static final long serialVersionUID = 1L;
    
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        String username = request.getParameter(&quot;username&quot;);
        System.out.println(username);
    &#125;

    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        // TODO Auto-generated method stub
        doGet(request, response);
    &#125;

&#125;
</code></pre>
<ol start="2">
<li>使用request域对象（使用request的setAttribute()方法设置其他信息并传递到Demo3Servlet中）</li>
</ol>
<pre><code>package com.oracle;

import java.io.IOException;
import java.util.Map;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class Demo2Servlet extends HttpServlet &#123;
    private static final long serialVersionUID = 1L;
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        request.setAttribute(&quot;flag&quot;, 1);
        request.getRequestDispatcher(&quot;/demo3&quot;).forward(request, response);
    &#125;

    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        // TODO Auto-generated method stub
        doGet(request, response);
    &#125;
&#125;
</code></pre>
<ol start="3">
<li>在Demo3Servlet中获取请求中的信息或者在Demo2Servlet中设置的新信息）</li>
</ol>
<pre><code>package com.oracle;

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class Demo3Servlet extends HttpServlet &#123;
    private static final long serialVersionUID = 1L;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        String username = request.getParameter(&quot;username&quot;);
        System.out.println(username);
        
        //request.removeAttribute(&quot;flag&quot;);//如果在获取设置的属性前将其删除，后面将获取不到该属性
        Integer a = (Integer)request.getAttribute(&quot;flag&quot;);
        System.out.println(a);
    &#125;

    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        // TODO Auto-generated method stub
        doGet(request, response);
    &#125;

&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb项目开发</category>
        <category>request域对象</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>request域对象</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb项目开发 | request获取各种形式的数据、请求转发</title>
    <url>/2022/01/10/request%E8%8E%B7%E5%8F%96%E5%90%84%E7%A7%8D%E5%BD%A2%E5%BC%8F%E7%9A%84%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="request获取各种形式的数据"><a href="#request获取各种形式的数据" class="headerlink" title="request获取各种形式的数据"></a>request获取各种形式的数据</h1><ol>
<li>新建form.html<br><img src="/2022/01/10/request%E8%8E%B7%E5%8F%96%E5%90%84%E7%A7%8D%E5%BD%A2%E5%BC%8F%E7%9A%84%E6%95%B0%E6%8D%AE/1.PNG"></li>
<li>新建Demo2Servlet处理来自form表单的请求并通过request对象的集中常用方法获取各种形式的数据</li>
</ol>
<pre><code>package com.oracle;
import java.io.IOException;
import java.util.Map;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet implementation class Demo2Servlet
 */
public class Demo2Servlet extends HttpServlet &#123;
    private static final long serialVersionUID = 1L;

    /**
     * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)
     */
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        // TODO Auto-generated method stub
        //response.getWriter().append(&quot;Served at: &quot;).append(request.getContextPath());
//        //获取前台传递的参数
//        String username = request.getParameter(&quot;username&quot;);
//        String password = request.getParameter(&quot;pwd&quot;);
//        
//        //获取单值
//        System.out.println(username);
//        System.out.println(password);
//        
//        //获取多值
//        String[] vals = request.getParameterValues(&quot;hobby&quot;);
//        for(String val:vals) &#123;
//            System.out.println(val);
//        &#125;
        
        //获取表单中的所有数据
        Map&lt;String, String[]&gt; map = request.getParameterMap();
        for(String s:map.keySet()) &#123;
            String[] strs = map.get(s);
            
            for(String st:strs) &#123;
                System.out.println(st);
            &#125;
        &#125;
        
        
    &#125;

    /**
     * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)
     */
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        // TODO Auto-generated method stub
        doGet(request, response);
    &#125;

&#125;
</code></pre>
<ol start="3">
<li>请求转发<br>假设我们刚刚处理的表单就是一个网站的注册页面，提交登录成功后，我们需要跳转到登录页面（从一个页面跳转到另一个页面）</li>
</ol>
<p><strong>解决办法：</strong><br>我们只需要在doGet方法的最后增加下面一行代码（假设1.html为登录页面）：</p>
<pre><code>//请求转发到1.html页面
request.getRequestDispatcher(&quot;/1.html&quot;).forward(request, response);
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb项目开发</category>
        <category>request获取各种形式的数据、请求转发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>请求转发</tag>
        <tag>request</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL | Access denied for user &#39;root&#39;@&#39;localhost&#39;</title>
    <url>/2021/04/18/root-localhost/</url>
    <content><![CDATA[<h1 id="ERROR-Access-denied-for-user-‘root’-’localhost’"><a href="#ERROR-Access-denied-for-user-‘root’-’localhost’" class="headerlink" title="ERROR: Access denied for user ‘root’@’localhost’"></a>ERROR: Access denied for user ‘root’@’localhost’</h1><p>在安装mysql时，安装过程中没有提示输入密码，安装完成之后，在终端输入mysql报错Access denied for ‘root’@’localhost’,但是使用sudo mysql可以进入。</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h2><p>1.在终端输：sudo mysql 进入mysql<br>2.mysql&gt; use mysql<br>3.mysql&gt; alter user ‘root’@’localhost’ identified with mysql_native_password by ‘your password’</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Movies | sacrifice</title>
    <url>/2020/10/29/sacrifice/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="79e80760dd3d238a6e9a15b5be6ada3d11c39cf7b5591ebe4ef6d0374ab585ab">06cac7a4498bdc1ba84f9a7c2df89776a693a413eda0c1b32a74d9891b7b55a7901574726315dcdbc8314bb123e764c805202b86c9e30f9ce1445163b5696416a3bf9fda41bf13ed75c625bf6d79fbbbe96455d4c695063426ae736fb1ea1800bebd246813a28203ca22c1a7fe1305c347e97942718e0f945446f1363c99c5acca82179441369cf4493a004544c59043b24c113d8724aa6ceecbc5e1aedda601d321f50df2f2d0db5577cac7472095493d561a9bffa6b0448cf9cdc05d6447cf0e275a47a08ac48c0be83e0483b9c4a0ed3a5c7a7a22020d536f97a2a7903aa177d9d4d1d8bec07a9496b1d99fdfbe1aa89e08bd98e1b26fcf9a8efddd565e98688bc0af5133dd2b3261fbed6718c7f74b12064a0ce4270ea3523f42b3c93843946a1a9542a7796eb9b8af85fc6b23a26fc32d05b0f7e182d152c1e1410379d7fe2fe64c585e71bea30c4b37b35c322556c5a1034dbcf25bb987f524ff2610802740b1b797a7b9f9589fcabeb5650e98dc2807708ce8e9150c79e880ac3850d65677a0f0fe5920963a4a0af0a6921d2ec83a36ad47f861443a4fb718aa779b624d8fa2aab326c71a0fc6e1964a222fa6a4eac6e1d7db09c6e4858af318953ce0ad7a685ad5e9b454b2fde24126b5a03e88a28f4b490c6a0723fc6cee8b166c7200372465ff06793ce6f43f8a0a6734333e62a33b9fe5cc5fab81c188708bfdd9711f2a1ea07c8ac3bbc7124e4580d0518d1505c7843119484ed8c627324c6d6c270178efc5812df6fe6edfd521c83aaa54fa7a8cb7312435570206e91c1372684e0406d8c9e805702a1d4aec50cd7936c9e6b225f8cf5c5d672a4d09360c2cf2a7c61e20762521bc43b3b42cb1b1d4401efaf77060a368f90c05d89a932d3acb201d78bab5b05f7173ae28a5f888f13f37d5b6c3bc35fc4035c278f1dfecbf333bfb8067d48f07dea05cb0696f50e8e4008ba6f3ed72a475b95a06249c6a951689927c8a1e911906fecd41a47e5a51f3b5d68aa2f9184a590cd2306cce891770a161575ef050ca37761518ec408c7e3a14a76af47d1e78583a9ddd915c4524704afbeb4d0b26bb55df64d2a37a29755916adf48fd38f06e7c0615a98537e70397d5b94f99534b6cc71126c9ae55ab8bb49ff40f09a7eaf1946e323a0ed080e2e2aea3aacabbedaba2bebe989536d10480269727690f20dde3228e18c35ffdd7c848aa9907af197f8aca420bb6ba417dc3565140e6d31b081475d4c2d23b3551be1ef18fc654d21d227bd4a4e88c9db6e02773080ad3ca5ef83d995cebab3cd935e0faba541fb168190f23acbd6577cb3f858e57e366268bb4c6a9648f27b3073c1626707a0194eea8e3f6d181bc5b8069f472ecd256d80040e822c5689333db495b87c1be67ecbd591457d2b3e1ded7971a93c4dbce535e3128b8a7a77e29bfe3956a3f1802bb066bdae0bd1e2f8642d1eafdcce584e23e2eceffd4977a1f0eb5989bdd4ffc5132fa5b5cb5252b12a53f6b690e7aa28fe3926ab645671cf10452cab9a8c19f61c68a22bcaa3c9e92339f6ec3e9ecfe32f93d18058eb7ad76e59cfcbd69ff698b7ade19404ba67152bc5283191262e79804bb5637b4ba77773ffc3cd4cd618d9a094f288f15b8b9423664a503dc9d3d7528b73f6026a544617f9a0e2d0980f5ae6fbe6502535a3aa33cc4014e3decb8fe27fb3bf41053478846a731a02d6717d0effdde3e7d787de370f2bdd61ca46057e3bded549473f79f5b8563d3d940eae0f730ae31fbf75e52ecb10995fc1c7b51d93e3ce4f7b7d2a5b6252920816c48f97a720b16707fb33919da891fb3660ca999f168e272244004786f5f412b17c00950deec7c3e4970fc68f3cfce80218a5eae3c16c746fdd412b75fe4e767bcf63dd1933895cc249ab73456010f667a81411e0dfaf01fbb20ccee4f89ee8a30d2381e86daefa6f2a4eb43003fae18fa7663c1eec27929229a60c05da989796453d61dfb634d749e8084b9cbbb4e5a8ad388edf011464c87edad762ce5a821b4cc232d376c1b3e411b8dde670d787da6676777d4284cfb8f250e90f8745543cabdd62a8b95c687fa7bee4b99a7aed560f31d18f3cb2a93828ec8b923d6947aca01dd3ff9723d8e2896bd59324fe69cfc29714683ffcafb7a3b6fef802f931b3b6ecdcbd0ad4fa24fd2222ccd1e68018c0b5e22a9b37d94d7555bc5610c3a65bb92eb57dd53e0dc3fd3ee5abf738197958b86c11238a50d265ab71d6971e8c7fc5cb92ab9b4cecc89a621554d2b726b10a1c21078a044ad5246314e42c2225ab359d06710b5407a6ac2204fe87fb762493dd47237adcd67ad3350627fb4bda29b61743949b1f72113fea8a5df815ff5cde7de64e03c4ff88aeb22675</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Movies</category>
      </categories>
      <tags>
        <tag>金刚川</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb项目开发 | servlet</title>
    <url>/2022/01/10/servlet/</url>
    <content><![CDATA[<h1 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h1><h2 id="创建servlet"><a href="#创建servlet" class="headerlink" title="创建servlet"></a>创建servlet</h2><ol>
<li>在src下面新建一个包com.oracle(公司域名反写)</li>
<li>在com.oracle下新建一个servlet(New–&gt;Other–&gt;Web–&gt;Servlet)<br>输入servlet的名称：<br><img src="/2022/01/10/servlet/1.PNG"><br>修改URL mappings:<br><img src="/2022/01/10/servlet/2.PNG"><br>去掉Constructors form superclass的勾选：<br><img src="/2022/01/10/servlet/3.PNG"><br>创建好的servlet:<br><img src="/2022/01/10/servlet/4.PNG"><h2 id="测试Demo1Servlet"><a href="#测试Demo1Servlet" class="headerlink" title="测试Demo1Servlet"></a>测试Demo1Servlet</h2></li>
<li>创建demo1.html<br><img src="/2022/01/10/servlet/5.PNG"></li>
<li>在Demo1Servlet.java中编写处理来自demo1.html的请求的Java代码<br><img src="/2022/01/10/servlet/6.PNG"></li>
<li>在浏览器地址栏输入：localhost:8080/shop/demo1.html<br><img src="/2022/01/10/servlet/7.PNG"></li>
<li>点击上图中的超链接向服务器发出请求<br>servelet处理来自浏览器的请求，执行在Demo1Servlet.java中编写的Java代码<br><img src="/2022/01/10/servlet/8.PNG"></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb项目开发</category>
        <category>创建servlet接收并处理请求</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb项目开发 | session</title>
    <url>/2022/01/11/session/</url>
    <content><![CDATA[<h1 id="session"><a href="#session" class="headerlink" title="session"></a>session</h1><h2 id="session-1"><a href="#session-1" class="headerlink" title="session"></a>session</h2><ol>
<li>什么是session?<br>服务器端会话技术</li>
<li>api</li>
</ol>
<p><strong>(1)session的获取</strong></p>
<pre><code>HttpSession session=request.getSession()
</code></pre>
<p><strong>(2)session属性操作</strong></p>
<pre><code>session.setAttribute(&quot;attr_name&quot;, attr_value);//设置属性
session.getAttribute(attr_name);//获取属性
</code></pre>
<ol start="3">
<li>作用范围<br>一次会话中<h2 id="session-测试（其他的servlet可以共享一次请求中的数据）"><a href="#session-测试（其他的servlet可以共享一次请求中的数据）" class="headerlink" title="session 测试（其他的servlet可以共享一次请求中的数据）"></a>session 测试（其他的servlet可以共享一次请求中的数据）</h2></li>
<li>项目目录<br><img src="/2022/01/11/session/1.PNG"></li>
<li>代码</li>
</ol>
<p><strong>a.html</strong></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;a href=&quot;/sessiontest/demo1&quot;&gt;访问demo1&lt;/a&gt;
    &lt;a href=&quot;/sessiontest/demo2&quot;&gt;访问demo2&lt;/a&gt;
    &lt;a href=&quot;/sessiontest/demo3&quot;&gt;访问demo3&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>Demo1Servlet</strong></p>
<pre><code>package com.oracle;

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

public class Demo1Servlet extends HttpServlet &#123;
    private static final long serialVersionUID = 1L;

    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        //request.setAttribute(&quot;username&quot;, &quot;zhangsan&quot;);
        
        //请求转发
        //request.getRequestDispatcher(&quot;/demo2&quot;).forward(request, response);
        
        //创建session
        HttpSession session = request.getSession();
        System.out.println(&quot;Demo1Servlet增加username属性，值为lisi&quot;);
        session.setAttribute(&quot;username&quot;, &quot;lisi&quot;);
    &#125;

    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        doGet(request, response);
    &#125;
&#125;
</code></pre>
<p><strong>Demo2Servlet</strong></p>
<pre><code>package com.oracle;

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

public class Demo2Servlet extends HttpServlet &#123;
    private static final long serialVersionUID = 1L;

    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        //String username = (String)request.getAttribute(&quot;username&quot;);
        //System.out.println(username);//null 一次会话当中的第二次请求不能得到第一次请求的数据
        
        HttpSession session = request.getSession();
        String username = (String)session.getAttribute(&quot;username&quot;);
        System.out.println(&quot;Demo2Servlet:&quot; + username);
        
    &#125;

    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        doGet(request, response);
    &#125;
&#125;
</code></pre>
<p><strong>Demo3Servlet</strong></p>
<pre><code>package com.oracle;

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

public class Demo3Servlet extends HttpServlet &#123;
    private static final long serialVersionUID = 1L;

    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        HttpSession session = request.getSession();
        String username = (String)session.getAttribute(&quot;username&quot;);
        System.out.println(&quot;Demo2Servlet:&quot; + username);
    &#125;

    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        doGet(request, response);
    &#125;
&#125;
</code></pre>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="/2022/01/11/session/2.PNG"></p>
<p><img src="/2022/01/11/session/3.PNG"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb项目开发</category>
        <category>session</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>session</tag>
      </tags>
  </entry>
  <entry>
    <title>Django | session实现用户登录</title>
    <url>/2021/07/29/session%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<h1 id="session实现用户登录"><a href="#session实现用户登录" class="headerlink" title="session实现用户登录"></a>session实现用户登录</h1><p>下面将使用session实现用户登录，如下图所示效果：<br><img src="/2021/07/29/session%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95/login.gif"></p>
<h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><p>1.在views.py文件中创建视图(假定我们创建了一个名为booktest的应用)</p>
<pre><code>def index(request):
    uname = request.session.get(&#39;myname&#39;, default=&#39;未登录&#39;)
    context = &#123;&#39;uname&#39;: uname&#125;
    return render(request, &#39;booktest/index.html&#39;, context)


def login(request):
    return render(request, &#39;booktest/login.html&#39;)


def login_handle(request):
    uname = request.POST[&#39;uname&#39;]
    request.session[&#39;myname&#39;] = uname
    return redirect(&#39;/booktest/index/&#39;)


def logout(request):
    # del request.session[&#39;myname&#39;]  # 删除会话
    # request.session.clear()  # 清除所有会话
    request.session.flush()  # 删除当前的会话数据并删除会话的Cookie
    return redirect(&#39;/booktest/index/&#39;)
</code></pre>
<p>2.配置url</p>
<pre><code>主url:
from django.conf.urls import include, url
from django.contrib import admin

urlpatterns = [
    url(r&#39;^booktest/&#39;, include(&quot;booktest.urls&quot;, namespace=&#39;booktest&#39;)),
]
应用url:
from django.conf.urls import include, url
import views


urlpatterns = [
    url(r&#39;^index/$&#39;, views.index),
    url(r&#39;^login/$&#39;, views.login),
    url(r&#39;^login_handle/$&#39;, views.login_handle),
    url(r&#39;^logout/$&#39;, views.logout3),

]
</code></pre>
<p>3.创建模板</p>
<pre><code>index.html

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
你好：&#123;&#123; uname &#125;&#125;
&lt;br&gt;
&lt;a href=&quot;/booktest/session2/&quot;&gt;登录&lt;/a&gt;
&lt;br&gt;
&lt;a href=&quot;/booktest/session3/&quot;&gt;退出&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;

login.html

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form method=&quot;post&quot; action=&quot;/booktest/session2_handle/&quot;&gt;
    &lt;input type=&quot;text&quot; name=&quot;uname&quot;&gt;
    &lt;input type=&quot;submit&quot; name=&quot;登录&quot;&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>4.配置模板路径DIRS<br>注：templates为和应用同级的文件夹，本应用的模板存在templates/booktest/下</p>
<pre><code>TEMPLATES = [
    &#123;
        &#39;BACKEND&#39;: &#39;django.template.backends.django.DjangoTemplates&#39;,
        &#39;DIRS&#39;: [os.path.join(BASE_DIR, &#39;templates&#39;)],
        &#39;APP_DIRS&#39;: True,
        &#39;OPTIONS&#39;: &#123;
            &#39;context_processors&#39;: [
                &#39;django.template.context_processors.debug&#39;,
                &#39;django.template.context_processors.request&#39;,
                &#39;django.contrib.auth.context_processors.auth&#39;,
                &#39;django.contrib.messages.context_processors.messages&#39;,
            ],
        &#125;,
    &#125;,
]
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>框架</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy | shuffle数据</title>
    <url>/2021/11/15/shuffle%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="shuffle数据"><a href="#shuffle数据" class="headerlink" title="shuffle数据"></a>shuffle数据</h1><p>在使用大量的数据来训练深度学习模型时，我们有可能需要对训练数据和数据标签进行shuffle(打乱)操作。</p>
<span id="more"></span>
<p><strong>show you the example code:</strong></p>
<pre><code>data = np.array([[1, 1], [2, 2], [3, 3], [4, 4], [5, 5]])
y = np.array([1, 2, 3, 4, 5])

print(&#39;-------原数据：----------&#39;)
print(&#39;数据：&#39;, data)
print(&#39;标签：&#39;, y)
print(&#39;-------打乱数据：----------&#39;)
np.random.seed(116)
np.random.shuffle(data)
np.random.seed(116)
np.random.shuffle(y)
print(&#39;数据：&#39;, data)
print(&#39;标签：&#39;, y )
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>numpy</category>
      </categories>
      <tags>
        <tag>numpy</tag>
        <tag>shuffle</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | sigmoid or tanh</title>
    <url>/2021/06/24/sigmoid-or-tanh/</url>
    <content><![CDATA[<h1 id="sigmoid-or-tanh？"><a href="#sigmoid-or-tanh？" class="headerlink" title="sigmoid or tanh？"></a>sigmoid or tanh？</h1><p>Sigmoid outputs a value between 0 and 1 which makes it a very good choice for binary classification.<br>You can classify as 0 if the output is less than 0.5 and classify as 1 if the output is more than 0.5.<br>It can be done with tanh as well but it is less convenient as the output is between -1 and 1.(Sigmoid<br>输出的值介于 0 和 1 之间，这使其成为二元分类的一个非常好的选择。 如果输出小于 0.5，则可以将其归类为 0，如果输出<br>大于 0.5，则归类为 1。 它也可以用 tanh 来完成，但是它不太方便，因为输出在<br>-1 和 1 之间。)</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>激活函数</tag>
      </tags>
  </entry>
  <entry>
    <title>python | sorted</title>
    <url>/2021/11/07/sorted/</url>
    <content><![CDATA[<h1 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h1><p>sorted() 函数对所有可迭代的对象进行排序操作。<br><strong>sort 与 sorted 区别：</strong><br>sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。<br>list 的 sort 方法返回的是对已经存在的列表进行操作，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。</p>
<span id="more"></span>
<p><strong>sorted 语法：</strong><br>sorted(iterable, key=None, reverse=False)<br>参数说明：<br>    iterable – 可迭代对象。<br>    key – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。<br>    reverse – 排序规则，reverse = True 降序 ， reverse = False 升序（默认）。<br>返回值:返回重新排序的列表。<br><strong>示例：</strong><br>sorted([36, 5, -12, 9, -21])</p>
<p>sorted([36, 5, -12, 9, -21], reverse=True)</p>
<p>sorted([36, 5, -12, 9, -21], key=abs)   # 按绝对值排序key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序</p>
<p>list(map(abs, [36, 5, -12, 9, -21]))</p>
<p>points = [(5,2), (7,3), (3,4),(1,1),(2,6)]  # 按x坐标排序 y坐标排序 和0点距离排序</p>
<p>f_x = lambda x:x[0]<br>sorted(points, key=f_x)</p>
<p>f_y = lambda x:x[1]<br>sorted(points, key=f_y)</p>
<p>f_r = lambda x:x[0]**2+x[1]**2<br>sorted(points, key=f_r)</p>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
        <category>sorted</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>sorted</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC | spring和springMVC的整合</title>
    <url>/2022/03/18/spring%E5%92%8CspringMVC%E7%9A%84%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<h1 id="spring和springMVC的整合"><a href="#spring和springMVC的整合" class="headerlink" title="spring和springMVC的整合"></a>spring和springMVC的整合</h1><p>1、不整合：需要将spring所管理的内容都交给springMVC管理，这样会造成业务逻辑混乱<br>2、整合：spring的配置文件什么时候加载？怎么加载？<br>解决办法：监听器，可以在ServletContext加载时，通过监听器加载spring的配置文件，创建spring容器<br>spring提供的监听器：ContextLoaderListener<br>3、bean被创建两次的问题：在springMVC中只扫描控制层，在spring中，通过包含或排除对所扫描的包进行指定<br>4、spring和springMVC的关系<br>spring是父容器<br>springMVC是子容器<br>规定：子容器能够调用父容器的bean，而父容器不能够调用访问子容器中的bean</p>
<span id="more"></span>
<p>1.项目目录<br><img src="/2022/03/18/spring%E5%92%8CspringMVC%E7%9A%84%E6%95%B4%E5%90%88/1.PNG"><br>2.web.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&gt;
  &lt;display-name&gt;SpringMVC04&lt;/display-name&gt;
  &lt;welcome-file-list&gt;
    &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;
  &lt;/welcome-file-list&gt;
  
  &lt;filter&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
      &lt;param-name&gt;encoding&lt;/param-name&gt;
      &lt;param-value&gt;UTF-8&lt;/param-value&gt;
    &lt;/init-param&gt;
  &lt;/filter&gt;
  &lt;filter-mapping&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;
  
  &lt;servlet&gt;
    &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
      &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
  
  &lt;!-- 使用自定义监听器模拟spring、springMVC整合 --&gt;
  &lt;!-- &lt;listener&gt;
    &lt;listener-class&gt;com.atguigu.listener.SpringListener&lt;/listener-class&gt;
  &lt;/listener&gt; --&gt;
  
  &lt;!-- 使用spring提供的监听器模整合spring、springMVC --&gt;
  &lt;!-- needed for ContextLoaderListener --&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;classpath:spring.xml&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;!-- Bootstraps the root web application context before servlet initialization --&gt;
    &lt;listener&gt;
        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
    &lt;/listener&gt;
&lt;/web-app&gt;
</code></pre>
<p>3.spring.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&gt;

    &lt;!-- &lt;bean id=&quot;user&quot; class=&quot;com.atguigu.bean.User&quot;&gt;&lt;/bean&gt; --&gt;
    
    &lt;context:component-scan base-package=&quot;com.atguigu&quot;&gt;
        &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;
    &lt;/context:component-scan&gt;
    
    &lt;bean id=&quot;teacher&quot; class=&quot;com.atguigu.bean.Teacher&quot;&gt;&lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>4.springMVC.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&gt;
    
    &lt;context:component-scan base-package=&quot;com.atguigu.controller&quot;&gt;&lt;/context:component-scan&gt;
    
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/view/&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    
    &lt;mvc:default-servlet-handler/&gt;
    &lt;mvc:annotation-driven /&gt;
    
    &lt;!-- 
        处理文件，将客户端上传的File文件处理为MultipartFile
        注意：文件解析器bean中的id必须设置为multipartResolver 
    --&gt;
    &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
        &lt;!-- 设置文件解析的编码，注意一定要和页面的pageEncoding保持一致 --&gt;
        &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;&gt;&lt;/property&gt;
        &lt;!-- 设置最大上传文件大小 --&gt;
        &lt;property name=&quot;maxUploadSize&quot; value=&quot;88888888&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    
    &lt;!-- 异常处理 --&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt;
        &lt;property name=&quot;exceptionMappings&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;java.lang.NullPointerException&quot;&gt;error&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    
    &lt;!-- &lt;mvc:interceptors&gt;
        默认拦截所有请求
        第一种方式
        &lt;bean class=&quot;com.atguigu.interceptor.FirstInterceptor&quot;&gt;&lt;/bean&gt;
        &lt;bean class=&quot;com.atguigu.interceptor.SecondInterceptor&quot;&gt;&lt;/bean&gt;
        
            第二种方式
            此方式要求拦截器上必须加注解@Component
        
        &lt;ref bean=&quot;firstInterceptor&quot; /&gt;
        
        设置自定义拦截方式
        &lt;mvc:interceptor&gt;
            &lt;bean&gt;&lt;/bean&gt;
            &lt;mvc:mapping path=&quot;&quot;/&gt;
            &lt;mvc:exclude-mapping path=&quot;&quot;/&gt;
        &lt;/mvc:interceptor&gt;
    &lt;/mvc:interceptors&gt; --&gt;
&lt;/beans&gt;
</code></pre>
<p>5.index.jsp</p>
<pre><code>&lt;a href=&quot;testListener&quot;&gt;测试监听器&lt;/a&gt;
</code></pre>
<p>6.User.java</p>
<pre><code>package com.atguigu.bean;

import org.springframework.stereotype.Component;

@Component
public class User &#123;
    private Integer id;
    private String username;
    public Integer getId() &#123;
        return id;
    &#125;
    public void setId(Integer id) &#123;
        this.id = id;
    &#125;
    public String getUsername() &#123;
        return username;
    &#125;
    public void setUsername(String username) &#123;
        this.username = username;
    &#125;
    public User() &#123;
        System.out.println(&quot;User==&gt;构造方法&quot;);
    &#125;
&#125;
</code></pre>
<p>7.Teacher.java</p>
<pre><code>package com.atguigu.bean;

public class Teacher &#123;
    private Integer id;
    
    private String name;

    public Integer getId() &#123;
        return id;
    &#125;

    public void setId(Integer id) &#123;
        this.id = id;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public Teacher() &#123;
        System.out.println(&quot;Teacher==&gt;构造方法&quot;);
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Teacher [id=&quot; + id + &quot;, name=&quot; + name + &quot;]&quot;;
    &#125;
&#125;
</code></pre>
<p>8.SpringListener.java（自定义监听器）</p>
<pre><code>package com.atguigu.listener;

import javax.servlet.ServletContext;
import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

/**
 * Application Lifecycle Listener implementation class SpringListener
 *
 */
public class SpringListener implements ServletContextListener &#123;

    /**
     * Default constructor. 
     */
    public SpringListener() &#123;
        // TODO Auto-generated constructor stub
    &#125;

    /**
     * @see ServletContextListener#contextDestroyed(ServletContextEvent)
     */
    public void contextDestroyed(ServletContextEvent arg0)  &#123; 
         // TODO Auto-generated method stub
    &#125;

    /**
     * @see ServletContextListener#contextInitialized(ServletContextEvent)
     */
    public void contextInitialized(ServletContextEvent sce)  &#123; 
        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
        ServletContext servletContext = sce.getServletContext();
        servletContext.setAttribute(&quot;ac&quot;, ac);
    &#125;
&#125;
</code></pre>
<p>9.TestController.java</p>
<pre><code>package com.atguigu.controller;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpSession;

import org.springframework.context.ApplicationContext;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

import com.atguigu.bean.Teacher;

@Controller
public class TestController &#123;
    @RequestMapping(&quot;/testListener&quot;)
    public void testListener(HttpSession session)&#123;
        //获取spring所管理的teacher对象
        ServletContext servletContext = session.getServletContext();
        ApplicationContext ac = (ApplicationContext)servletContext.getAttribute(&quot;ac&quot;);
        Teacher teacher = ac.getBean(&quot;teacher&quot;, Teacher.class);
        System.out.println(teacher);
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>SpringMVC</category>
        <category>spring和springMVC的整合</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>Java</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>spring | spring简单案例</title>
    <url>/2022/01/27/spring%E7%AE%80%E5%8D%95%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<h1 id="spring简单案例"><a href="#spring简单案例" class="headerlink" title="spring简单案例"></a>spring简单案例</h1><h2 id="使用软件：STS"><a href="#使用软件：STS" class="headerlink" title="使用软件：STS"></a>使用软件：STS</h2><p><a href="https://www.cnblogs.com/larryzeal/p/5800980.html">下载地址</a></p>
<h2 id="搭建spring运行时环境"><a href="#搭建spring运行时环境" class="headerlink" title="搭建spring运行时环境"></a>搭建spring运行时环境</h2><p>1.加入JAR包<br>1)Spring自身JAR包：spring-framework-4.0.0.RELEASE\libs目录下<br>spring-beans-4.0.0.RELEASE.jar<br>spring-context-4.0.0.RELE2ASE.jar<br>spring-core-4.0.0.RELEASE.jar<br>spring-expression-4.0.0.RELEASE.jar<br>2)commons-logging-1.1.1.jar<br>注：将以上所有的jar包复制到项目中的lib目录下并全选所有jar包–&gt;右键–&gt;build path–&gt;config bulid path<br>2.在Spring Tool Suite工具中通过如下步骤创建Spring的配置文件<br>1)File-&gt;New-&gt;Spring Bean Configuration File<br>2)为文件取名字 例如：applicationContext.xml<br><img src="/2022/01/27/spring%E7%AE%80%E5%8D%95%E6%A1%88%E4%BE%8B/1.PNG"></p>
<h2 id="创建一个类：Person-java"><a href="#创建一个类：Person-java" class="headerlink" title="创建一个类：Person.java"></a>创建一个类：Person.java</h2><pre><code>package com.atguigu.spring.mod;

public class Person &#123;
    private Integer id;
    private String name;
    public Integer getId() &#123;
        return id;
    &#125;
    public void setId(Integer id) &#123;
        this.id = id;
    &#125;
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Person [id=&quot; + id + &quot;, name=&quot; + name + &quot;]&quot;;
    &#125;
    
&#125;
</code></pre>
<h2 id="常规方法操作对象"><a href="#常规方法操作对象" class="headerlink" title="常规方法操作对象"></a>常规方法操作对象</h2><p>创建一个测试类Test.java</p>
<pre><code>package com.atguigu.spring.mod;

public class Test &#123;
    public static void main(String[] args)&#123;
        Person person = new Person();
        person.setId(1);
        person.setName(&quot;zhangsan&quot;);
        System.out.println(person);
    &#125;
&#125;
</code></pre>
<h2 id="spring管理对象"><a href="#spring管理对象" class="headerlink" title="spring管理对象"></a>spring管理对象</h2><p>1.创建applicationContext.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!-- 命名空间 规定当前的文件里面能写什么--&gt;

    &lt;!--
        &lt;bean&gt;：定义spring管理的一个对象
        id:该对象的唯一标识，注意不能重复,在类型获取bean的过程中可以不设置
        class:该对象所属类的全限定名 
    --&gt;
    
    &lt;!-- 通过反射创建对象 --&gt;
    &lt;bean id=&quot;person&quot; class=&quot;com.atguigu.spring.mod.Person&quot;&gt;
        &lt;!--
            &lt;property&gt;:为对象的某个属性赋值
            name:属性名
            value:属性值 
        --&gt;
        &lt;property name=&quot;id&quot; value=&quot;1111&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;name&quot; value=&quot;小明&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    
&lt;/beans&gt;
</code></pre>
<p>2.创建一个测试类TestBySpring.java</p>
<pre><code>package com.atguigu.spring.mod;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class TestBySpring &#123;

    public static void main(String[] args) &#123;
        //初始化容器
        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        
        //通过getBean()获取对象
        Person person = (Person) ac.getBean(&quot;person&quot;);
        System.out.println(person);

    &#125;
&#125;
</code></pre>
<p><strong>注：IOC和DI</strong><br>反转控制（IOC）：对象的管理权（创建、赋值等）由程序员交给了spring容器<br>依赖注入（DI）:bean对象依赖于属性 向属性注入资源（赋值）<br>总结: IOC 就是一种反转控制的思想， 而DI是对IOC的一种具体实现。 </p>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>spring</category>
        <category>spring简单案例</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>Java</tag>
        <tag>框架</tag>
        <tag>IOC</tag>
        <tag>DI</tag>
        <tag>控制反转</tag>
        <tag>依赖注入</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | sqrt</title>
    <url>/2021/10/27/sqrt/</url>
    <content><![CDATA[<h1 id="69-sqrt-x"><a href="#69-sqrt-x" class="headerlink" title="69.sqrt(x)"></a>69.sqrt(x)</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个非负整数 x ，计算并返回 x 的 算术平方根 。<br>由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。<br>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</p>
<p><a href="https://leetcode-cn.com/problems/sqrtx/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.二分法</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):
    @staticmethod
    def my_sqrt1(a):
        &quot;&quot;&quot;二分法开根号&quot;&quot;&quot;
        # 初始化左右边界
        left, right = 0, a
        while left &lt;= right:
            mid = (left + right) // 2
            if mid ** 2 == a:
                return mid
            elif mid ** 2 &gt; a:
                right = mid - 1
            else:
                left = mid + 1
        return right


if __name__ == &quot;__main__&quot;:
    a = 3
    s = Solution()
    sqrt_a = s.my_sqrt1(a)
    print(sqrt_a)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程 | tcp三次握手四次挥手</title>
    <url>/2020/10/26/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    <content><![CDATA[<h1 id="使用tcp协议进行通信过程中的三次握手和四次挥手"><a href="#使用tcp协议进行通信过程中的三次握手和四次挥手" class="headerlink" title="使用tcp协议进行通信过程中的三次握手和四次挥手"></a>使用tcp协议进行通信过程中的三次握手和四次挥手</h1><p>TCP在真正的读写操作之前，server与client之间必须建立一个连接。<br>当读写操作完成后，双方不再需要这个连接时它们可以释放这个连接。<br>连接的<strong>建立</strong>通过<strong>三次握手</strong>，<strong>释放</strong>则需要<strong>四次挥手</strong><br><img src="/2020/10/26/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/tcp.JPG" alt="tcp三次握手和四次挥手"></p>
]]></content>
      <categories>
        <category>python</category>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>三次握手</tag>
        <tag>四次挥手</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程 | tcp与udp的稳定性</title>
    <url>/2020/10/26/tcp%E4%B8%8Eudp%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7/</url>
    <content><![CDATA[<h1 id="tcp稳定而udp不稳定的原因"><a href="#tcp稳定而udp不稳定的原因" class="headerlink" title="tcp稳定而udp不稳定的原因"></a>tcp稳定而udp不稳定的原因</h1><p><b style="color:red">在tcp中，如果有一方收到了对方的数据，一定会发送ack确认包给发送方，而在udp中，没有这个过程，因此导致了tcp稳定，而udp不稳定。</b></p>
]]></content>
      <categories>
        <category>python</category>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>TCP</tag>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程 | tcp的客户端/服务器端代码编写</title>
    <url>/2020/10/22/tcp%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99/</url>
    <content><![CDATA[<h1 id="tcp的客户端-服务器端代码编写"><a href="#tcp的客户端-服务器端代码编写" class="headerlink" title="tcp的客户端/服务器端代码编写"></a>tcp的客户端/服务器端代码编写</h1><h2 id="tcp服务器端代码编写"><a href="#tcp服务器端代码编写" class="headerlink" title="tcp服务器端代码编写"></a>tcp服务器端代码编写</h2><pre><code>#coding=utf-8
from socket import *

# 创建socket
tcpSerSocket = socket(AF_INET, SOCK_STREAM)

# 绑定本地信息
address = (&#39;&#39;, 7788)
tcpSerSocket.bind(address)

# 使用socket创建的套接字默认的属性是主动的，使用listen将其变为被动的，这样就可以接收别人的链接了
tcpSerSocket.listen(5)

# 如果有新的客户端来链接服务器，那么就产生一个新的套接字专门为这个客户端服务器
# newSocket用来为这个客户端服务
# tcpSerSocket就可以省下来专门等待其他新客户端的链接
newSocket, clientAddr = tcpSerSocket.accept()

# 接收对方发送过来的数据，最大接收1024个字节
recvData = newSocket.recv(1024)
print(&#39;接收到的数据为:%s&#39;%recvData)

# 发送一些数据到客户端
newSocket.send(&quot;thank you !&quot;)

# 关闭为这个客户端服务的套接字，只要关闭了，就意味着为不能再为这个客户端服务了，如果还需要服务，只能再次重新连接
newSocket.close()

# 关闭监听套接字，只要这个套接字关闭了，就意味着整个程序不能再接收任何新的客户端的连接
tcpSerSocket.close()
</code></pre>
<span id="more"></span>
<h2 id="tcp客户端代码编写"><a href="#tcp客户端代码编写" class="headerlink" title="tcp客户端代码编写"></a>tcp客户端代码编写</h2><pre><code>#coding=utf-8
from socket import *

# 创建socket
tcpClientSocket = socket(AF_INET, SOCK_STREAM)

# 链接服务器
serAddr = (&#39;192.168.1.102&#39;, 7788)
tcpClientSocket.connect(serAddr)

# 提示用户输入数据
sendData = input(&quot;请输入要发送的数据：&quot;)

tcpClientSocket.send(sendData)

# 接收对方发送过来的数据，最大接收1024个字节
recvData = tcpClientSocket.recv(1024)
print(&#39;接收到的数据为:%s&#39;%recvData)

# 关闭套接字
tcpClientSocket.close()
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>tcp客户端</tag>
        <tag>tcp服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>软件架构 | ten things every architect should know</title>
    <url>/2021/03/11/ten-things-every-architect-should-know/</url>
    <content><![CDATA[<h1 id="Ten-Things-Every-Architect-Should-Know"><a href="#Ten-Things-Every-Architect-Should-Know" class="headerlink" title="Ten Things Every Architect Should Know"></a>Ten Things Every Architect Should Know</h1><p>1.<b>People</b> are the platform</p>
<p>2.All solutions are obsolete</p>
<p>3.<b>Data</b> is forever</p>
<p>4.Flexibility breeds complexity</p>
<p>5.Nothing works as expected</p>
<p>6.<b>Documentation</b> is the universal source code</p>
<p>7.Know the <b>business</b></p>
<p>8.Maintain the <b>version</b></p>
<p>9.Software architext should also be coders</p>
<p>10.There is no substitute for <b>experiences</b></p>
]]></content>
      <categories>
        <category>SA</category>
      </categories>
      <tags>
        <tag>软件架构</tag>
      </tags>
  </entry>
  <entry>
    <title>python | tensorflow安装遇到问题</title>
    <url>/2021/05/13/tensorflow%E5%AE%89%E8%A3%85%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="Python中解决ModuleNotFoundError-No-module-named-‘tensorflow-api’问题"><a href="#Python中解决ModuleNotFoundError-No-module-named-‘tensorflow-api’问题" class="headerlink" title="Python中解决ModuleNotFoundError: No module named ‘tensorflow._api’问题"></a>Python中解决ModuleNotFoundError: No module named ‘tensorflow._api’问题</h1><p><a href="https://blog.csdn.net/u012270544/article/details/96424907">点击这里查看问题解决方法</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>python | ubuntu下虚拟环境的安装与配置</title>
    <url>/2021/01/28/ubuntu%E4%B8%8B%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="ubuntu下虚拟环境的安装与配置"><a href="#ubuntu下虚拟环境的安装与配置" class="headerlink" title="ubuntu下虚拟环境的安装与配置"></a>ubuntu下虚拟环境的安装与配置</h1><h2 id="为什么要搭建虚拟环境"><a href="#为什么要搭建虚拟环境" class="headerlink" title="为什么要搭建虚拟环境?"></a>为什么要搭建虚拟环境?</h2><pre><code>如果在一台电脑上, 有不同项目, 需要用到同一个包的不同版本, 新版本会覆盖以前的版本, 其它的项目就可能无法正常运行了.。
解决方法：虚拟环境
    作用：虚拟环境可以搭建独立的python运行环境`, 使得单个项目的运行环境与其它项目互不影响。
    所有的虚拟环境都位于/home/用户名下的隐藏目录.virtualenvs下。
</code></pre>
<h2 id="如何搭建虚拟环境"><a href="#如何搭建虚拟环境" class="headerlink" title="如何搭建虚拟环境?"></a>如何搭建虚拟环境?</h2><pre><code>安装虚拟环境的命令：
sudo pip install virtualenvo
sudo pip install virtualenvwrapper

安装完虚拟环境后，如果提示找不到mkvirtualenv命令，须配置环境变量：

# 1、创建目录用来存放虚拟环境
mkdir \$HOME/.virtualenvs
# 2、打开~/.bashrc文件，并添加如下：
export WORKON_HOME=$HOME/.virtualenvs
source /usr/local/bin/virtualenvwrapper.sh
# 3、运行
source ~/.bashrc

创建虚拟环境的命令 :
在python3中，创建虚拟环境

mkvirtualenv -p python3 虚拟环境名称
例 ：
mkvirtualenv -p python3 django_py3
</code></pre>
<p>创建成功后会自动工作在这个虚拟环境上,工作在虚拟环境上, 提示符最前面会出现 “虚拟环境名称”。<br>如何使用虚拟环境?</p>
<pre><code>查看虚拟环境的命令 :

workon 两次tab键 或者 回车

使用虚拟环境的命令：

workon 虚拟环境名称
例 ：使用名为django_py3的虚拟环境
workon django_py3

退出虚拟环境的命令 :

deactivate

删除虚拟环境的命令 :

rmvirtualenv 虚拟环境名称
例 ：删除虚拟环境django_py3
先退出：deactivate
再删除：rmvirtualenv django_py3
</code></pre>
<h2 id="如何在虚拟环境中安装工具包"><a href="#如何在虚拟环境中安装工具包" class="headerlink" title="如何在虚拟环境中安装工具包"></a>如何在虚拟环境中安装工具包</h2><p>workon进入虚拟环境后，再使用pip进行包的安装，其安装方法和普通的安装方式一样。</p>
<pre><code>安装指定Django版本示例:

pip install django==1.11.11

python3下的安装路径：

~/.virtualenvs/django_py3/lib/python3.5/site-packages/
</code></pre>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>虚拟环境</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程 | udp+多线程模拟QQ</title>
    <url>/2020/10/17/udp-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E6%8B%9FQQ/</url>
    <content><![CDATA[<h1 id="在linux环境下使用-udp-多线程-模拟QQ"><a href="#在linux环境下使用-udp-多线程-模拟QQ" class="headerlink" title="在linux环境下使用 udp+多线程 模拟QQ"></a>在linux环境下使用 <b>udp+多线程</b> 模拟QQ</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><strong>程序主要的两个功能</strong>：</p>
<ul>
<li>发送数据（Send Data） </li>
<li>接收数据（Reveive Data）</li>
</ul>
<p><strong>使用多线程的原因</strong><br>不使用多线程的情况下，在程序暂停等待发送方输入发送内容时，若发送方不输入内容，则程序一直卡在这里；此时另外一放发送数据由于程序暂时等待输入内容也不能打印消息。<br>使用了多线程，接收数据、发送数据的程序分别由一个线程来处理，且两个线程互不影响，发送方不输入内容时，另一方发送消息发送方就能接收到。<br><b>Note:通信的两台计算机必须在同一个局域网！！！</b></p>
<span id="more"></span>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code># coding=utf-8
# 1.receive data then print out
from threading import Thread
from socket import *

def recvData():
    while True:
        recvInfo = udpSocket.recvfrom(1024)
        print(&quot;&gt;&gt;%s:%s\n&lt;&lt;&quot;%(str(recvInfo[1]),recvInfo[0]),end=&quot;&quot;)

# 2.detect the keyboard and send the data
def sendData():
    print(&quot;&lt;&lt;&quot;,end=&quot;&quot;)
    while True:
        sendInfo =  input(&quot;&quot;)
        udpSocket.sendto(sendInfo.encode(&#39;gb2312&#39;),(destIp,destPort))

udpSocket = None
destIp = &quot;&quot;
destPort = 0 

def main():
    global udpSocket
    global destIp
    global destPort

    destIp = input(&quot;Destination ip:&quot;)
    destPort = int(input(&quot;Destination port:&quot;))

    udpSocket = socket(AF_INET,SOCK_DGRAM)
    udpSocket.bind((&quot;&quot;,4567))

    tr = Thread(target=recvData)
    ts = Thread(target=sendData)
    
    tr.start()
    ts.start()

    tr.join()
    ts.join()

if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<h2 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h2><p><img src="/2020/10/17/udp-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E6%8B%9FQQ/udp.jpg" alt="udp"></p>
]]></content>
      <categories>
        <category>python</category>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>UDP</tag>
        <tag>SOCKET</tag>
      </tags>
  </entry>
  <entry>
    <title>并发 | volatile、synchronized和原子操作</title>
    <url>/2022/05/22/volatile%E3%80%81synchronized%E5%92%8C%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="volatile、synchronized和原子操作"><a href="#volatile、synchronized和原子操作" class="headerlink" title="volatile、synchronized和原子操作"></a>volatile、synchronized和原子操作</h1><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>volatile是轻量级的synchronized，它在多处理器并发中保证了<strong>共享变量的“可见性”</strong>。可见性是指当一个线程修改一个共享变量时<br>，另外一个线程能读到这个修改的值（Java内存模型确保所有线程看到这个变量的值是一致的）。</p>
<h3 id="volatile的两条实现原则"><a href="#volatile的两条实现原则" class="headerlink" title="volatile的两条实现原则"></a>volatile的两条实现原则</h3><p>（1）Lock前缀指令会引起处理器缓存回写到内存。<br>（2）一个处理器的缓存回写到内存会导致其他处理器的缓存无效。</p>
<h3 id="volatile的使用优化"><a href="#volatile的使用优化" class="headerlink" title="volatile的使用优化"></a>volatile的使用优化</h3><p>使用追加到64字节的方式来填满高速缓冲区的缓存行，避免头节点和尾节点加载到同一个缓存行，使头、尾节点在修改时不会互相锁定。</p>
<h2 id="synchronized实现原理"><a href="#synchronized实现原理" class="headerlink" title="synchronized实现原理"></a>synchronized实现原理</h2><p>JVM基于进入和推出Monitor对象来实现方法同步和代码块同步，但两者实现细节不一样。<br>代码块同步使用monitorenter和monitorexit指令实现的。monitorenter指令在编译后插入到同步代码块的开始位置，而monitorexit是<br>插入到方法结束处和异常处，JVM要博爱正每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，<br>当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象monitor的所有权，即尝试获得对象的锁。</p>
<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>java如何实现原子操作？<br>通过循环CAS的方式实现原子操作。JVM中CAS操作使用处理器提供的CMPXCHG指令实现。自旋CAS实现的基本思路就是循环及进行CAS操作指导成功为止。</p>
<h3 id="使用CAS实现线程安全计数器"><a href="#使用CAS实现线程安全计数器" class="headerlink" title="使用CAS实现线程安全计数器"></a>使用CAS实现线程安全计数器</h3><pre><code>package concurrency;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

public class Counter &#123;
    private AtomicInteger atomicI = new AtomicInteger(0);
    private int i = 0;
    
    public static void main(String[] args) &#123;
        final Counter cas = new Counter();
        List&lt;Thread&gt; ts = new ArrayList&lt;Thread&gt;(600);
        long start = System.currentTimeMillis();
        for(int j = 0; j &lt; 100; j++)&#123;
            Thread t = new Thread(new Runnable()&#123;
                @Override
                public void run()&#123;
                    for(int i = 0; i &lt; 10000; i++)&#123;
                        cas.count();
                        cas.safeCount();
                    &#125;
                &#125;
            &#125;);
            ts.add(t);
        &#125;
        for(Thread t : ts)&#123;
            t.start();
        &#125;
        //等待所有线程执行完成
        for(Thread t : ts)&#123;
            try &#123;
                t.join();
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        System.out.println(cas.i);
        System.out.println(cas.atomicI.get());
        System.out.println(System.currentTimeMillis() - start);
    &#125;
    
    //使用CAS实现线程安全计数器
    private void safeCount()&#123;
        for(;;)&#123;
            int i = atomicI.get();
            boolean suc = atomicI.compareAndSet(i, ++i);
            if(suc)&#123;
                break;
            &#125;
        &#125;
    &#125;
    
    //非线程安全计数器
    private void count()&#123;
        i++;
    &#125;
&#125;
</code></pre>
<h2 id="CAS实现原子操作的三大问题"><a href="#CAS实现原子操作的三大问题" class="headerlink" title="CAS实现原子操作的三大问题"></a>CAS实现原子操作的三大问题</h2><p>（1）ABA问题。可以使用版本号解决。JDK Atomic AtomicStampedReference可以解决ABA问题。<br>（2）循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。<br>（3）只能保证一个共享变量的原子操作。对多个共享变量操作可以使用锁/将多个共享变量合并成一个共享变量来操作（两个共享变量i=2,j=a,合并以下ij=2a,然后采用CAS来操作）。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>volatile</tag>
        <tag>synchronized</tag>
        <tag>原子操作</tag>
      </tags>
  </entry>
  <entry>
    <title>并发 | volatile写读的内存语义和锁的释放获取的内存语义</title>
    <url>/2022/05/23/volatile%E5%86%99%E8%AF%BB%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89%E5%92%8C%E9%94%81%E7%9A%84%E9%87%8A%E6%94%BE%E8%8E%B7%E5%8F%96%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89/</url>
    <content><![CDATA[<h1 id="volatile写读的内存语义和锁的释放获取的内存语义"><a href="#volatile写读的内存语义和锁的释放获取的内存语义" class="headerlink" title="volatile写读的内存语义和锁的释放获取的内存语义"></a>volatile写读的内存语义和锁的释放获取的内存语义</h1><h2 id="volatile写、读的内存语义"><a href="#volatile写、读的内存语义" class="headerlink" title="volatile写、读的内存语义"></a>volatile写、读的内存语义</h2><p>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主存。<br><img src="/2022/05/23/volatile%E5%86%99%E8%AF%BB%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89%E5%92%8C%E9%94%81%E7%9A%84%E9%87%8A%E6%94%BE%E8%8E%B7%E5%8F%96%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89/1.PNG"><br>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。<br><img src="/2022/05/23/volatile%E5%86%99%E8%AF%BB%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89%E5%92%8C%E9%94%81%E7%9A%84%E9%87%8A%E6%94%BE%E8%8E%B7%E5%8F%96%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89/2.PNG"></p>
<h2 id="volatile内存语义的实现"><a href="#volatile内存语义的实现" class="headerlink" title="volatile内存语义的实现"></a>volatile内存语义的实现</h2><p>编译器生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。<br>JMM基于保守策略的JMM内存屏障插入策略如下：<br>（1）在每个volatile写操作的前面插入一个StoreStore屏障。<br>（2）在每个volatile写操作的后面插入一个StoreLoad屏障。<br>（3）在每个volatile读操作的后面插入一个LoadLoad屏障。<br>（4）在每个volatile读操作的后面插入一个LoadStore屏障。</p>
<h2 id="锁的释放、获取的内存语义"><a href="#锁的释放、获取的内存语义" class="headerlink" title="锁的释放、获取的内存语义"></a>锁的释放、获取的内存语义</h2><p>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。<br>当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。<br>注：锁释放与volatile写有相同的内存语义；锁获取与volatile读具有相同的内存语义。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
        <category>volatile写读的内存语义和锁的释放获取的内存语义</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>volatile</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb项目开发 | web服务器tomcat和eclipse的集成</title>
    <url>/2022/01/09/web%E6%9C%8D%E5%8A%A1%E5%99%A8tomcat%E5%92%8Ceclipse%E7%9A%84%E9%9B%86%E6%88%90/</url>
    <content><![CDATA[<h1 id="web服务器tomcat和eclipse的集成"><a href="#web服务器tomcat和eclipse的集成" class="headerlink" title="web服务器tomcat和eclipse的集成"></a>web服务器tomcat和eclipse的集成</h1><h2 id="下载tomcat"><a href="#下载tomcat" class="headerlink" title="下载tomcat"></a>下载tomcat</h2><p><a href="http://tomcat.apache.org/download-70.cgi">tomcat</a></p>
<h2 id="安装tomcat"><a href="#安装tomcat" class="headerlink" title="安装tomcat"></a>安装tomcat</h2><p>将下载的后缀为.zip的压缩文件解压即可（本项目使用tomcat 7）<br>将文件解压到不包含中文文件名的路径下（例：D://tomcat//）</p>
<h2 id="将tomcat服务器集成到eclipse中"><a href="#将tomcat服务器集成到eclipse中" class="headerlink" title="将tomcat服务器集成到eclipse中"></a>将tomcat服务器集成到eclipse中</h2><p>1.在eclipse菜单栏中点击window–&gt;preferences,然后按照下图所示顺序点击。<br><img src="/2022/01/09/web%E6%9C%8D%E5%8A%A1%E5%99%A8tomcat%E5%92%8Ceclipse%E7%9A%84%E9%9B%86%E6%88%90/1.PNG"><br>2.按照下图所示步骤添加服务器，选择版本7<br><img src="/2022/01/09/web%E6%9C%8D%E5%8A%A1%E5%99%A8tomcat%E5%92%8Ceclipse%E7%9A%84%E9%9B%86%E6%88%90/2.PNG"><br>3.选择下载并解压的tomcat服务器并选择jre<br><img src="/2022/01/09/web%E6%9C%8D%E5%8A%A1%E5%99%A8tomcat%E5%92%8Ceclipse%E7%9A%84%E9%9B%86%E6%88%90/3.PNG"><br>4.在菜单栏选择windown–&gt;show view–&gt;Other..–&gt;Server–&gt;Servers来显示配置的tomcat服务器<br><img src="/2022/01/09/web%E6%9C%8D%E5%8A%A1%E5%99%A8tomcat%E5%92%8Ceclipse%E7%9A%84%E9%9B%86%E6%88%90/4.PNG"><br>注：可以通过点击上图中的启动按钮和关闭按钮来关闭/停止服务器<br>5.双击上图中的服务器并按照下图将Deploy path修改为webapps<br><img src="/2022/01/09/web%E6%9C%8D%E5%8A%A1%E5%99%A8tomcat%E5%92%8Ceclipse%E7%9A%84%E9%9B%86%E6%88%90/5.PNG"><br>6.通过浏览器访问该服务器<br>在浏览器地址栏输入localhost:8080来访问（先通过启动按钮启动服务器）<br><img src="/2022/01/09/web%E6%9C%8D%E5%8A%A1%E5%99%A8tomcat%E5%92%8Ceclipse%E7%9A%84%E9%9B%86%E6%88%90/6.PNG"><br>如果端口8080被占用，可以在tomcat目录下/conf/server.xml中修改端口号。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb项目开发</category>
        <category>web服务器和eclipse的集成</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>web服务器和eclipse的集成</tag>
      </tags>
  </entry>
  <entry>
    <title>电脑使用小技巧 | windows关闭弹框广告</title>
    <url>/2021/01/28/windows%E5%85%B3%E9%97%AD%E5%BC%B9%E6%A1%86%E5%B9%BF%E5%91%8A/</url>
    <content><![CDATA[<h1 id="如何关闭烦人的桌面广告弹框"><a href="#如何关闭烦人的桌面广告弹框" class="headerlink" title="如何关闭烦人的桌面广告弹框"></a>如何关闭烦人的桌面广告弹框</h1><p>1.打开“控制面板”<br><img src="/2021/01/28/windows%E5%85%B3%E9%97%AD%E5%BC%B9%E6%A1%86%E5%B9%BF%E5%91%8A/1.png"><br>2.进入“网络和Internet”<br><img src="/2021/01/28/windows%E5%85%B3%E9%97%AD%E5%BC%B9%E6%A1%86%E5%B9%BF%E5%91%8A/2.png"><br>3.进入“Internet选项”<br><img src="/2021/01/28/windows%E5%85%B3%E9%97%AD%E5%BC%B9%E6%A1%86%E5%B9%BF%E5%91%8A/3.png"><br>4.选择“隐私”选项卡，勾选“启用弹出窗口阻止程序”，然后点“设置”<br><img src="/2021/01/28/windows%E5%85%B3%E9%97%AD%E5%BC%B9%E6%A1%86%E5%B9%BF%E5%91%8A/4.png"><br>5.阻止级别选“高”，点击“关闭”<br><img src="/2021/01/28/windows%E5%85%B3%E9%97%AD%E5%BC%B9%E6%A1%86%E5%B9%BF%E5%91%8A/5.png"><br>6.重启电脑</p>
]]></content>
      <categories>
        <category>电脑使用小技巧</category>
        <category>关闭弹框广告</category>
      </categories>
  </entry>
  <entry>
    <title>wxPython | wxPython控件</title>
    <url>/2021/08/03/wxPython%E6%8E%A7%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="wxPython控件"><a href="#wxPython控件" class="headerlink" title="wxPython控件"></a>wxPython控件</h1><p>1.实现三个文本输入空间和三个静态文本<br>1.1界面效果<br><img src="/2021/08/03/wxPython%E6%8E%A7%E4%BB%B6/1.png"><br>1.2示例代码</p>
<pre><code>class MyFrame(wx.Frame):
    def __init__(self):
        super().__init__(None, title=&quot;文本输入控件&quot;, size=(300, 260))
        panel = wx.Panel(parent=self)
        tc1 = wx.TextCtrl(panel)
        tc2 = wx.TextCtrl(panel, style=wx.TE_PASSWORD)
        tc3 = wx.TextCtrl(panel, style=wx.TE_MULTILINE)

        userid = wx.StaticText(panel, label=&quot;用户ID：&quot;)
        pwd = wx.StaticText(panel, label=&quot;密码：&quot;)
        content = wx.StaticText(panel, label=&quot;多行文本：&quot;)

        # 创建垂直方向的盒子布局管理器对象
        vbox = wx.BoxSizer(wx.VERTICAL)

        # 添加控件到vbox布局管理器
        vbox.Add(userid, flag=wx.EXPAND | wx.LEFT, border=10)
        vbox.Add(tc1, flag=wx.EXPAND | wx.ALL, border=10)
        vbox.Add(pwd, flag=wx.EXPAND | wx.LEFT, border=10)
        vbox.Add(tc2, flag=wx.EXPAND | wx.ALL, border=10)
        vbox.Add(content, flag=wx.EXPAND | wx.LEFT, border=10)
        vbox.Add(tc3, flag=wx.EXPAND | wx.ALL, border=10)

        # 设置面板采用vbox布局管理器
        panel.SetSizer(vbox)

        # 设置tc1初始值
        tc1.SetValue(&#39;tony&#39;)
        # 获取tc1值
        print(&#39;读取用户ID：&#123;0&#125;&#39;.format(tc1.GetValue()))

        tc2.SetValue(&#39;123&#39;)

        tc3.SetValue(&#39;这是一个多行文本！这是一个多行文本！这是一个多行文本！这是一个多行文本！这是一个多行文本！这是一个多行文本！&#39;)


app = wx.App()
frm = MyFrame()
frm.Show()
app.MainLoop()
</code></pre>
<span id="more"></span>

<p>2.实现一组复选框和一组单选按钮<br>2.1界面效果<br><img src="/2021/08/03/wxPython%E6%8E%A7%E4%BB%B6/2.png"><br>2.2示例代码</p>
<pre><code>class MyFrame(wx.Frame):
    def __init__(self):
        super().__init__(None, title=&quot;复选框和单选按钮&quot;, size=(330, 120))
        panel = wx.Panel(parent=self)

        st1 = wx.StaticText(panel, label=&quot;选择你喜欢的编程语言：&quot;)
        cb1 = wx.CheckBox(panel, id=1, label=&#39;Python&#39;)
        cb2 = wx.CheckBox(panel, id=2, label=&#39;Java&#39;)
        cb2.SetValue(True)
        cb3 = wx.CheckBox(panel, id=3, label=&#39;C++&#39;)
        self.Bind(wx.EVT_CHECKBOX, self.on_checkbox_click, id=1, id2=3)

        st2 = wx.StaticText(panel, label=&quot;选择性别：&quot;)
        radio1 = wx.RadioButton(panel, id=4, label=&#39;男&#39;, style=wx.RB_GROUP)
        radio2 = wx.RadioButton(panel, id=5, label=&#39;女&#39;)
        self.Bind(wx.EVT_RADIOBUTTON, self.on_radio1_click, id=4, id2=5)

        st3 = wx.StaticText(panel, label=&quot;是否婚配：&quot;)
        radio3 = wx.RadioButton(panel, id=6, label=&#39;Yes&#39;, style=wx.RB_GROUP)
        radio4 = wx.RadioButton(panel, id=7, label=&#39;No&#39;)
        self.Bind(wx.EVT_RADIOBUTTON, self.on_radio2_click, id=6, id2=7)

        hbox1 = wx.BoxSizer(wx.HORIZONTAL)
        hbox1.Add(st1, flag=wx.LEFT | wx.RIGHT, border=5)
        hbox1.Add(cb1)
        hbox1.Add(cb2)
        hbox1.Add(cb3)

        hbox2 = wx.BoxSizer(wx.HORIZONTAL)
        hbox2.Add(st2, flag=wx.LEFT | wx.RIGHT, border=5)
        hbox2.Add(radio1)
        hbox2.Add(radio2)

        hbox3 = wx.BoxSizer(wx.HORIZONTAL)
        hbox3.Add(st3, flag=wx.LEFT | wx.RIGHT, border=5)
        hbox3.Add(radio3)
        hbox3.Add(radio4)

        vbox = wx.BoxSizer(wx.VERTICAL)
        vbox.Add(hbox1, flag=wx.ALL, border=10)
        vbox.Add(hbox2, flag=wx.ALL, border=10)
        vbox.Add(hbox3, flag=wx.ALL, border=10)

        panel.SetSizer(vbox)

    def on_checkbox_click(self, event):
        cb = event.GetEventObject()
        print(&#39;选择&#123;0&#125;,状态&#123;1&#125;&#39;.format(cb.GetLabel(), event.IsChecked()))

    def on_radio1_click(self, event):
        rb = event.GetEventObject()
        print(&#39;第一组&#123;0&#125;被选中&#39;.format(rb.GetLabel()))

    def on_radio2_click(self, event):
        rb = event.GetEventObject()
        print(&#39;第二组&#123;0&#125;被选中&#39;.format(rb.GetLabel()))


app = wx.App()
frm = MyFrame()
frm.Show()
app.MainLoop()  
</code></pre>
<p>3.单选列表和多选列表<br>3.1界面效果<br><img src="/2021/08/03/wxPython%E6%8E%A7%E4%BB%B6/3.png"><br>3.2示例代码</p>
<pre><code>class MyFrame(wx.Frame):
    def __init__(self):
        super().__init__(None, title=&quot;列表&quot;, size=(350, 175))
        panel = wx.Panel(parent=self)

        st1 = wx.StaticText(parent=panel, label=&quot;选择你喜欢的编程语言：&quot;)
        list1 = [&#39;Python&#39;, &#39;C++&#39;, &#39;Java&#39;]
        # 创建列表控件，参数choices用于设置列表选项；参数style用于设置列表风格样式，wx.LB_SINGLE指单选列表控件
        lb1 = wx.ListBox(parent=panel, choices=list1, style=wx.LB_SINGLE)
        self.Bind(wx.EVT_LISTBOX, self.on_listbox1, lb1)

        st2 = wx.StaticText(parent=panel, label=&quot;选择你喜欢吃的水果：&quot;)
        list2 = [&#39;苹果&#39;, &#39;橘子&#39;, &#39;香蕉&#39;]
        lb2 = wx.ListBox(parent=panel, choices=list2, style=wx.LB_EXTENDED)  # style=wx.LB_EXTENDED表示创建多选列表控件
        self.Bind(wx.EVT_LISTBOX, self.on_listbox2, lb2)

        hbox1 = wx.BoxSizer(wx.HORIZONTAL)
        hbox1.Add(st1, proportion=1, flag=wx.LEFT | wx.RIGHT, border=5)
        hbox1.Add(lb1, proportion=1)

        hbox2 = wx.BoxSizer(wx.HORIZONTAL)
        hbox2.Add(st2, proportion=1, flag=wx.LEFT | wx.RIGHT, border=5)
        hbox2.Add(lb2, proportion=1)

        vbox = wx.BoxSizer(wx.VERTICAL)
        vbox.Add(hbox1, flag=wx.ALL | wx.EXPAND, border=5)
        vbox.Add(hbox2, flag=wx.ALL | wx.EXPAND, border=5)

        panel.SetSizer(vbox)

    def on_listbox1(self, event):
        listbox = event.GetEventObject()
        print(&#39;选择 &#123;0&#125;&#39;.format(listbox.GetSelection()))

    def on_listbox2(self, event):
        listbox = event.GetEventObject()
        print(&#39;选择 &#123;0&#125;&#39;.format(listbox.GetSelections()))


app = wx.App()
frm = MyFrame()
frm.Show()
app.MainLoop()
</code></pre>
<p>4.静态图片控件<br>4.1界面效果<br><img src="/2021/08/03/wxPython%E6%8E%A7%E4%BB%B6/4.png"><br>4.2示例代码</p>
<pre><code>class MyFrame(wx.Frame):
    def __init__(self):
        super().__init__(None, title=&#39;静态图片控件&#39;, size=(300, 300))
        self.panel = wx.Panel(parent=self)

        # 创建wx.Bitmap图片对象的列表
        self.bmps = [wx.Bitmap(&#39;images/1.jpg&#39;, wx.BITMAP_TYPE_JPEG),
                     wx.Bitmap(&#39;images/2.jpg&#39;, wx.BITMAP_TYPE_JPEG),
                     wx.Bitmap(&#39;images/3.jpg&#39;, wx.BITMAP_TYPE_JPEG)]

        b1 = wx.Button(self.panel, id=1, label=&#39;Button1&#39;)
        b2 = wx.Button(self.panel, id=2, label=&#39;Button2&#39;)
        self.Bind(wx.EVT_BUTTON, self.on_click, id=1, id2=2)

        self.image = wx.StaticBitmap(self.panel, bitmap=self.bmps[0])

        # 创建垂直方向的布局管理器对象vbox
        vbox = wx.BoxSizer(wx.VERTICAL)
        # 添加控件到布局管理器对象vbox
        vbox.Add(b1, proportion=1, flag=wx.EXPAND)
        vbox.Add(b2, proportion=1, flag=wx.EXPAND)
        vbox.Add(self.image, proportion=3, flag=wx.EXPAND)

        self.panel.SetSizer(vbox)

    def on_click(self, event):
        event_id = event.GetId()
        if event_id == 1:
            self.image.SetBitmap(self.bmps[1])
        else:
            self.image.SetBitmap(self.bmps[2])

        self.panel.Layout()  # 重新设置panel面板布局


app = wx.App()
frm = MyFrame()
frm.Show()
app.MainLoop()
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>wxPython</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>wxPython</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis | 一对多自定义映射、分步查询和延迟加载</title>
    <url>/2022/04/06/%E4%B8%80%E5%AF%B9%E5%A4%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E6%98%A0%E5%B0%84%E3%80%81%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2%E5%92%8C%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="一对多自定义映射、分步查询和延迟加载"><a href="#一对多自定义映射、分步查询和延迟加载" class="headerlink" title="一对多自定义映射、分步查询和延迟加载"></a>一对多自定义映射、分步查询和延迟加载</h1><p>1.项目目录<br><img src="/2022/04/06/%E4%B8%80%E5%AF%B9%E5%A4%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E6%98%A0%E5%B0%84%E3%80%81%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2%E5%92%8C%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD/1.PNG"><br>2.Dept.java<br>在”一”方添加List&lt;多&gt;</p>
<pre><code>package com.atguigu.bean;

import java.util.List;

public class Dept &#123;
    private Integer did;
    private String dname;
    private List&lt;Emp&gt; emps;
    
    public List&lt;Emp&gt; getEmps() &#123;
        return emps;
    &#125;
    public void setEmps(List&lt;Emp&gt; emps) &#123;
        this.emps = emps;
    &#125;
    public Integer getDid() &#123;
        return did;
    &#125;
    public void setDid(Integer did) &#123;
        this.did = did;
    &#125;
    public String getDname() &#123;
        return dname;
    &#125;
    public void setDname(String dname) &#123;
        this.dname = dname;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Dept [did=&quot; + did + &quot;, dname=&quot; + dname + &quot;, emps=&quot; + emps + &quot;]&quot;;
    &#125;
&#125;
</code></pre>
<p>3.EmpDeptMapper.java</p>
<pre><code>package com.atguigu.mapper;

import java.util.List;

import com.atguigu.bean.Dept;
import com.atguigu.bean.Emp;

public interface EmpDeptMapper &#123;
    List&lt;Emp&gt; getAllEmp();
    
    Emp getEmpStep(String eid);
    
    Dept getDeptEmpsByDid(String did);
    
    Dept getOnlyDeptByDid(String did);//测试一对多
    
    List&lt;Emp&gt; getEmpListByDid(String did);//测试一对多
&#125;
</code></pre>
<p>4.EmpDeptMapper.xml<br>在映射文件中做以下配置：</p>
<pre><code>&lt;resultMap type=&quot;Dept&quot; id=&quot;deptMapStep&quot;&gt;
    &lt;id column=&quot;did&quot; property=&quot;did&quot; /&gt;
    &lt;result column=&quot;dname&quot; property=&quot;dname&quot; /&gt;
    &lt;!-- &lt;collection property=&quot;emps&quot; select=&quot;com.atguigu.mapper.EmpDeptMapper.getEmpListByDid&quot; column=&quot;did&quot;&gt;&lt;/collection&gt; --&gt;
    &lt;!-- 
        fetchType:
            lazy 延迟加载
            eager 不进行延迟加载
     --&gt;
    &lt;collection property=&quot;emps&quot; select=&quot;com.atguigu.mapper.EmpDeptMapper.getEmpListByDid&quot; column=&quot;&#123;did=did&#125;&quot; fetchType=&quot;lazy&quot;&gt;&lt;/collection&gt;
&lt;/resultMap&gt;

&lt;!-- Dept getOnlyDeptByDid(String did); --&gt;
&lt;select id=&quot;getOnlyDeptByDid&quot; resultMap=&quot;deptMapStep&quot;&gt;
    select did,dname from dept where did=#&#123;did&#125;
&lt;/select&gt;

&lt;!-- List&lt;Emp&gt; getEmpListByDid(String did); --&gt;
&lt;select id=&quot;getEmpListByDid&quot; resultType=&quot;Emp&quot;&gt;
    select eid,ename,age,sex from emp where did = #&#123;did&#125;
&lt;/select&gt;
</code></pre>
<p>5.TestEmpDept.java</p>
<pre><code>package com.atguigu.test;

import java.io.IOException;
import java.io.InputStream;
import java.util.List;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import com.atguigu.bean.Dept;
import com.atguigu.bean.Emp;
import com.atguigu.mapper.EmpDeptMapper;

public class TestEmpDept &#123;
    public static void main(String[] args) throws IOException &#123;
        InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
        SqlSession sqlSession = sqlSessionFactory.openSession(true);
        EmpDeptMapper mapper = sqlSession.getMapper(EmpDeptMapper.class);
        
//        List&lt;Emp&gt; empList = mapper.getAllEmp();
//        System.out.println(empList);
        
//        Emp emp = mapper.getEmpStep(&quot;3&quot;);
//        System.out.println(emp.getEname());
//        System.out.println(emp.getDept());
        
//        Dept dept = mapper.getDeptEmpsByDid(&quot;2&quot;);
//        System.out.println(dept);
        
        Dept dept = mapper.getOnlyDeptByDid(&quot;3&quot;);
        //System.out.println(dept);
        System.out.println(dept.getDname());
        System.out.println(dept.getEmps());
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>MyBatis</category>
        <category>一对多自定义映射、分步查询和延迟加载</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>自定义映射</tag>
        <tag>分步查询</tag>
        <tag>延迟加载</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习基础 | 一文深层解决模型过拟合</title>
    <url>/2021/11/05/%E4%B8%80%E6%96%87%E6%B7%B1%E5%B1%82%E8%A7%A3%E5%86%B3%E6%A8%A1%E5%9E%8B%E8%BF%87%E6%8B%9F%E5%90%88/</url>
    <content><![CDATA[<h1 id="一文深层解决模型过拟合"><a href="#一文深层解决模型过拟合" class="headerlink" title="一文深层解决模型过拟合"></a>一文深层解决模型过拟合</h1><p><a href="https://mp.weixin.qq.com/s/RBSewyWPdUnywKplVDzeLA">参考资料</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>过拟合</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习基础 | 一文看懂各种神经网络优化算法</title>
    <url>/2021/11/05/%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82%E5%90%84%E7%A7%8D%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="一文看懂各种神经网络优化算法"><a href="#一文看懂各种神经网络优化算法" class="headerlink" title="一文看懂各种神经网络优化算法"></a>一文看懂各种神经网络优化算法</h1><p><a href="https://mp.weixin.qq.com/s/gRrZImMydyCDBNCTIgVYXw">一文看懂各种神经网络优化算法</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>优化算法</tag>
      </tags>
  </entry>
  <entry>
    <title>CNN | 卷积神经网络(一维卷积、二维卷积、三维卷积)</title>
    <url>/2021/10/26/%E4%B8%80%E7%BB%B4%E5%8D%B7%E7%A7%AF%E4%BA%8C%E7%BB%B4%E5%8D%B7%E7%A7%AF%E4%B8%89%E7%BB%B4%E5%8D%B7%E7%A7%AF/</url>
    <content><![CDATA[<h1 id="卷积神经网络-一维卷积、二维卷积、三维卷积"><a href="#卷积神经网络-一维卷积、二维卷积、三维卷积" class="headerlink" title="卷积神经网络(一维卷积、二维卷积、三维卷积)"></a>卷积神经网络(一维卷积、二维卷积、三维卷积)</h1><p><a href="https://www.cnblogs.com/szxspark/p/8445406.html">一维卷积、二维卷积、三维卷积</a><br><a href="https://blog.csdn.net/weixin_44378513/article/details/112307989?spm=1001.2101.3001.6650.17&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-17.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-17.no_search_link">1D CNN+2D CNN+3D CNN</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
        <category>CNN</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>一维卷积</tag>
        <tag>二维卷积</tag>
        <tag>三维卷积</tag>
      </tags>
  </entry>
  <entry>
    <title>pdfplumber | 一键提取PDF中的表格到Excel</title>
    <url>/2021/10/28/%E4%B8%80%E9%94%AE%E6%8F%90%E5%8F%96PDF%E4%B8%AD%E7%9A%84%E8%A1%A8%E6%A0%BC%E5%88%B0Excel/</url>
    <content><![CDATA[<h1 id="一键提取PDF中的表格到Excel"><a href="#一键提取PDF中的表格到Excel" class="headerlink" title="一键提取PDF中的表格到Excel"></a>一键提取PDF中的表格到Excel</h1><p>实现代码：</p>
<pre><code>import os
import pdfplumber
from openpyxl import Workbook

path = &#39;PDF&#39;  # 文件所在文件夹
files = [path + &quot;\\&quot; + i for i in os.listdir(path)]  # 获取文件夹下的文件名,并拼接完整路径
key_words = &quot;主要会计数据&quot;

for file in files:
    with pdfplumber.open(file) as p:
        wb = Workbook()  # 新建excel工作簿
        wb.remove(wb.worksheets[0])  # 删除工作簿自带的工作表

        # 获取关键词所在页及下一页的页码
        pages_wanted = []
        for index, page in enumerate(p.pages):  # 从0开始给所有页编号
            if key_words in page.extract_text():
                pages_wanted.append(index)
                pages_wanted.append(index + 1)
                break

        # 提取指定页码里的表格
        for i in pages_wanted:
            page = p.pages[i]
            tables = page.extract_tables()  # 读取表格
            if tables:  # 判断是否存在表格，若不存在，则不执行下面的语句
                ws = wb.create_sheet(f&quot;Sheet&#123;i + 1&#125;&quot;)  # 新建工作表，表名的编号与表在PDF中的页码一致
                for table in tables:  # 遍历所有列表
                    for row in table:  # 遍历列表中的所有子列表，里面保存着行数据
                        ws.append(row)  # 写入excel表
        wb.save(&quot;Excel\\&#123;&#125;.xlsx&quot;.format(file.split(&quot;\\&quot;)[1].split(&quot;.&quot;)[0]))
</code></pre>
<p>PDF:<br><a href="东旭蓝天：2019年年度报告.PDF">东旭蓝天：2019年年度报告.PDF</a><br><a href="华特气体：2019年年度报告（修订版）.PDF">华特气体：2019年年度报告（修订版）.PDF</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>pdfplumber</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>openpyxl</tag>
        <tag>pdfplumber</tag>
      </tags>
  </entry>
  <entry>
    <title>pandas | 一键更新Excel中的图表</title>
    <url>/2021/11/01/%E4%B8%80%E9%94%AE%E6%9B%B4%E6%96%B0Excel%E4%B8%AD%E7%9A%84%E5%9B%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="一键更新Excel中的图表"><a href="#一键更新Excel中的图表" class="headerlink" title="一键更新Excel中的图表"></a>一键更新Excel中的图表</h1><p><strong>场景：</strong> 小编每周都要更新最近12周的“生产订单周报”给老板，而且要对比最近两年相同周数的数据。主要是两张图，一张是“一周生产订单对比”，另一张是“各部门订单比例”。虽然在Excel表中建了数据透视表，但是每周都还是需要花时间进行一通凶猛的操作，才能搞定。可不可以每周一键更新，并得到这两张图呢？</p>
<span id="more"></span>
<p><strong>代码实现：</strong></p>
<pre><code>import pandas as pd

file = &#39;生产订单.xlsx&#39;
df = pd.read_excel(file)
df.fillna(0, inplace=True)
df[&quot;数量&quot;] = df[&quot;数量&quot;].astype(&#39;int&#39;)

# 增加周数字段
df[&quot;周数&quot;] = df[&quot;日期&quot;].dt.week
df[&quot;年份&quot;] = df[&quot;日期&quot;].dt.year
# print(df.head())

# 获取当前周数
import datetime

year, current_week, day = datetime.datetime.now().isocalendar()
# print(current_week)

# 只获取最近12周的数据
df_required = df[(df[&quot;周数&quot;] &gt;= (current_week - 36)) &amp; (df[&quot;周数&quot;] &lt;= (current_week - 24))]
# print(df_required[&#39;年份&#39;])

result = df_required.groupby([&quot;周数&quot;, &quot;年份&quot;])[&#39;数量&#39;].sum().reset_index()  # reset后才是DF，不然是Series
# print(result)
#
# # print(result[result[&quot;年份&quot;]==2019][&quot;数量&quot;])
#
# 如果有中文，需要配置中文字体，不然会显示成方框
import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np

plt.rcParams[&#39;font.sans-serif&#39;] = [&#39;SimHei&#39;]  # 用来正常显示中文标签
# 数据和标签
qty_2019 = result[result[&quot;年份&quot;] == 2019][&quot;数量&quot;]
qty_2020 = result[result[&quot;年份&quot;] == 2020][&quot;数量&quot;]
print(qty_2020)
x_label = result[result[&quot;年份&quot;] == 2019][&quot;周数&quot;]

# 设置字体大小
mpl.rcParams[&#39;font.size&#39;] = 12
# 设置图片大小
plt.figure(figsize=(12, 6))
# 设置柱形图宽度
bar_width = 0.45

index = np.arange(13)
qty_2019_list = [qty for qty in qty_2019]
qty_2020_list = [qty for qty in qty_2020]
print(f&quot;index: &#123;len(index)&#125;&quot;)
print(len(qty_2019_list))

print(len(qty_2020_list))
# 绘制2019年数据
qty1 = plt.bar(index, qty_2019, bar_width, color=&#39;#336633&#39;, label=&quot;2019&quot;)
# 绘制2020年数据
qty2 = plt.bar(index + bar_width, qty_2020, bar_width, color=&#39;#6666CC&#39;, label=&quot;2020&quot;)

# X,Y轴标题
plt.xticks(index + bar_width, x_label)
plt.xlabel(&quot;周数&quot;, fontsize=14)
plt.ylabel(&quot;产品数量/台&quot;, fontsize=14)
# 图表标题
plt.title(u&#39;每周生产订单对比&#39;, fontsize=20)
# 图例显示
plt.legend()


# 添加数据标签
def add_labels(qtys):
    for qty in qtys:
        height = qty.get_height()
        plt.text(qty.get_x() + qty.get_width() / 2, height, height, ha=&#39;center&#39;, va=&#39;bottom&#39;)
        # 柱形图边缘用白色填充
        qty.set_edgecolor(&#39;white&#39;)


add_labels(qty1)
add_labels(qty2)

plt.savefig(&#39;prod_order.png&#39;)

# 按部门计算订单数量
order_2019 = df_required[df_required[&quot;年份&quot;] == 2019]
# print(order_2019)
dept_2019 = order_2019[&quot;部门&quot;].value_counts()
# print(dept_2019)
order_2020 = df_required[df_required[&quot;年份&quot;] == 2020]
# print(order_2020)
dept_2020 = order_2020[&quot;部门&quot;].value_counts()
# print(dept_2020)

# 绘制饼图
import matplotlib as mpl
import numpy as np

plt.rcParams[&#39;font.sans-serif&#39;] = [&#39;SimHei&#39;]  # 用来正常显示中文标签
mpl.rcParams[&#39;font.size&#39;] = 12
fig = plt.figure(figsize=(12, 6))
axl = fig.add_subplot(1, 2, 1)


def my_label(pct, allvals):
    absolute = int(pct / 100. * np.sum(allvals))
    return &quot;&#123;:.1f&#125;%\n(&#123;:d&#125;)&quot;.format(pct, absolute)


explode = (0.1, 0, 0, 0, 0)
plt.pie(dept_2019, autopct=lambda x: my_label(x, dept_2019), explode=explode, labels=dept_2019.index, shadow=True,
        startangle=150)
plt.title(&quot;各部门订单比例\n(最近12周)_2019&quot;, fontsize=20)
# plt.label(&quot;2019&quot;,fontsize = 14)
ax2 = fig.add_subplot(1, 2, 2)
plt.pie(dept_2020, autopct=lambda x: my_label(x, dept_2020), explode=explode, labels=dept_2020.index, shadow=True,
        startangle=150)
plt.title(&quot;各部门订单比例\n(最近12周)_2020&quot;, fontsize=20)

plt.savefig(&#39;order_byDept.png&#39;)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>pandas</category>
      </categories>
      <tags>
        <tag>matplotlib</tag>
        <tag>pandas</tag>
        <tag>numpy</tag>
        <tag>datetime</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 15.三数之和</title>
    <url>/2022/06/27/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h1><p><strong>题目描述：</strong><br>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。<br>注意：答案中不可以包含重复的三元组。<br><a href="https://leetcode.cn/problems/3sum">三数之和</a><br><strong>示例 1：</strong></p>
<pre><code>输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
</code></pre>
<p><strong>代码</strong></p>
<pre><code>class Solution:
    # 三重循环
    def threeSum1(self, nums):
        nums.sort()
        n = len(nums)
        result = []
        for first in range(0, n):
            if first == 0 or nums[first] != nums[first - 1]:
                for second in range(first + 1, n):
                    if second == first + 1 or nums[second] != nums[second - 1]:
                        for third in range(second + 1, n):
                            if third == second + 1 or nums[third] != nums[third - 1]:
                                if nums[first] + nums[second] + nums[third] == 0:
                                    result.append([nums[first], nums[second], nums[third]])
        return result
    
    # 排序+双指针
    def threeSum(self, nums):
        n = len(nums)
        nums.sort()
        ans = list()
        
        # 枚举 a
        for first in range(n):
            # 需要和上一次枚举的数不相同
            if first &gt; 0 and nums[first] == nums[first - 1]:
                continue
            # c 对应的指针初始指向数组的最右端
            third = n - 1
            target = -nums[first]
            # 枚举 b
            for second in range(first + 1, n):
                # 需要和上一次枚举的数不相同
                if second &gt; first + 1 and nums[second] == nums[second - 1]:
                    continue
                # 需要保证 b 的指针在 c 的指针的左侧
                while second &lt; third and nums[second] + nums[third] &gt; target:
                    third -= 1
                # 如果指针重合，随着 b 后续的增加
                # 就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环
                if second == third:
                    break
                if nums[second] + nums[third] == target:
                    ans.append([nums[first], nums[second], nums[third]])
        
        return ans


if __name__ == &quot;__main__&quot;:
    slt = Solution()
    nums = [-1, 0, 1, 2, -1, -4]
    # res = slt.threeSum(nums)
    res = slt.threeSum1(nums)  # [[-1, -1, 2], [-1, 0, 1]]
    print(res)
        
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>数组</category>
        <category>15.三数之和</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>并发 | 上下文切换和死锁</title>
    <url>/2022/05/22/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="上下文切换和死锁"><a href="#上下文切换和死锁" class="headerlink" title="上下文切换和死锁"></a>上下文切换和死锁</h1><h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，再切换前会保存上一个任务的<br>状态，以便切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。频繁的上下文<br>切换会影响多线程的执行速度。</p>
<h2 id="如何减少上下文切换"><a href="#如何减少上下文切换" class="headerlink" title="如何减少上下文切换"></a>如何减少上下文切换</h2><p>（1）无锁并发编程。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁（如采用分段锁，不同的线程处理不同段的数据）<br>（2）CAS算法。<br>（3）使用最小线程。避免创建不需要的线程（任务很少，创建了很多线程，造成大量线程阻塞等待）</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁产生的条件"><a href="#死锁产生的条件" class="headerlink" title="死锁产生的条件"></a>死锁产生的条件</h3><p>（1）互斥。一个资源同一时刻只能被一个线程拥有。<br>（2）请求和保持。线程在请求新的资源时，不释放已经拥有的资源。<br>（3）不剥夺条件。进程所获得的资源在未使用完之前，不被其他的线程强行剥夺。<br>（4）循环等待。竞争资源的各个线程形成一个线程等待环路。</p>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>破坏产生死锁的条件：<br>（2）在进程开始执行时就申请他所需的全部资源<br>（3）一个进程不能获得所需要的全部资源时便处于等待状态，等待期间他占有的资源将被隐式的释放重新加入到系统的资源列表中<br>，可以被其他的进程使用，而等待的进程只有重新获得自己原有的资源以及新申请的资源才可以重新启动、执行。<br>（4）资源有序分配（银行家算法）</p>
<h3 id="死锁Demo"><a href="#死锁Demo" class="headerlink" title="死锁Demo"></a>死锁Demo</h3><pre><code>package concurrency;

public class DeadLockDemo &#123;
    private static String A = &quot;A&quot;;
    private static String B = &quot;B&quot;;
    
    public static void main(String[] args) &#123;
        new DeadLockDemo().deadLock();
    &#125;
    
    private void deadLock()&#123;
        Thread t1 = new Thread(new Runnable()&#123;
            @Override
            public void run()&#123;
                synchronized(A)&#123;
                    try &#123;
                        Thread.currentThread().sleep(2000);
                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;
                    synchronized(B)&#123;
                        System.out.println(&quot;1&quot;);
                    &#125;
                &#125;
            &#125;
        &#125;);
        
        Thread t2 = new Thread(new Runnable()&#123;
            @Override
            public void run() &#123;
                synchronized(B)&#123;
                    synchronized(A)&#123;
                        System.out.println(&quot;2&quot;);
                    &#125;
                &#125;
            &#125;
        &#125;);
        
        t1.start();
        t2.start();
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
        <category>上下文切换</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>死锁</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC | 上传和下载文件</title>
    <url>/2022/03/16/%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="上传和下载文件"><a href="#上传和下载文件" class="headerlink" title="上传和下载文件"></a>上传和下载文件</h1><p>注意：上传文件需要在springMVC.xml中配置如下所示bean：</p>
<pre><code>&lt;!-- 
    处理文件，将客户端上传的File文件处理为MultipartFile
    注意：文件解析器bean中的id必须设置为multipartResolver 
--&gt;
&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
    &lt;!-- 设置文件解析的编码，注意一定要和页面的pageEncoding保持一致 --&gt;
    &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;&gt;&lt;/property&gt;
    &lt;!-- 设置最大上传文件大小 --&gt;
    &lt;property name=&quot;maxUploadSize&quot; value=&quot;88888888&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<span id="more"></span>
<p><strong>file.jsp</strong></p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;a href=&quot;down&quot;&gt;下载图片&lt;/a&gt;
    
    &lt;form action=&quot;up&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
        头像：&lt;input type=&quot;file&quot; name=&quot;uploadFile&quot; /&gt;
        描述：&lt;input type=&quot;text&quot; name=&quot;desc&quot; /&gt;
        &lt;input type=&quot;submit&quot; value=&quot;上传&quot; /&gt;
    &lt;/form&gt;
    
    &lt;form action=&quot;up_old&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
        头像：&lt;input type=&quot;file&quot; name=&quot;uploadFile&quot; /&gt;
        描述：&lt;input type=&quot;text&quot; name=&quot;desc&quot; /&gt;
        &lt;input type=&quot;submit&quot; value=&quot;上传&quot; /&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>TestUploadAndDownController.java</strong></p>
<pre><code>package com.atguigu.test;

import java.io.File;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.UUID;

import javax.servlet.http.HttpSession;

import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.multipart.MultipartFile;

import com.sun.org.apache.xalan.internal.xsltc.trax.OutputSettings;

@Controller
public class TestUploadAndDownController&#123;
    @RequestMapping(&quot;/down&quot;)
    public ResponseEntity&lt;byte[]&gt; down(HttpSession session) throws IOException&#123;
        //获取下载文件的路径
        String realPath = session.getServletContext().getRealPath(&quot;img&quot;);
        String finalPath = realPath + File.separator + &quot;1.jpg&quot;;
        InputStream is = new FileInputStream(finalPath);
        //available():获取输入流所读取的文件的最大字节数
        byte[] b = new byte[is.available()];
        is.read(b);
        //设置请求头
        HttpHeaders headers = new HttpHeaders();
        headers.add(&quot;Content-Disposition&quot;, &quot;attachment;filename=zzz.jpg&quot;);
        HttpStatus statusCode = HttpStatus.OK;
        ResponseEntity&lt;byte[]&gt; entity = new ResponseEntity&lt;byte[]&gt;(b, headers, statusCode);
        return entity;
    &#125;
    
    //第一种上传方式
    @RequestMapping(value=&quot;/up_old&quot;, method=RequestMethod.POST)
    public String up_old(String desc, MultipartFile uploadFile, HttpSession session) throws IOException&#123;
        //String name = uploadFile.getName();
        //String originalFilename = uploadFile.getOriginalFilename();
        //System.out.println(name+&quot;,&quot;+originalFilename);
        
        //获取上传文件的名称
        String filename = uploadFile.getOriginalFilename();
        String path = session.getServletContext().getRealPath(&quot;photo&quot;) + File.separator + filename;
        
        //获取输入流
        InputStream is = uploadFile.getInputStream();
        
        //获取输出流
        File file = new File(path);
        OutputStream os = new FileOutputStream(file);
        
        //文件上传
//        int i = 0;
//        while((i = is.read()) != -1)&#123;
//            os.write(i);
//        &#125;
        
        int i = 0;
        byte[] b = new byte[1024];
        while((i = is.read(b)) != -1)&#123;
            os.write(b, 0, i);
        &#125;
        
        //关闭流
        os.close();
        is.close();
        return &quot;success&quot;;
    &#125;
    
    //第二种上传方式
    @RequestMapping(value=&quot;/up&quot;, method=RequestMethod.POST)
    public String up(String desc, MultipartFile uploadFile, HttpSession session) throws IOException&#123;
        //获取上传文件的名称
        String fileName = uploadFile.getOriginalFilename();
        String finalFileName = UUID.randomUUID() + fileName.substring(fileName.lastIndexOf(&quot;.&quot;));
        String path = session.getServletContext().getRealPath(&quot;photo&quot;) + File.separator + finalFileName;
        
        File file = new File(path);
        uploadFile.transferTo(file);
        return &quot;success&quot;;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>SpringMVC</category>
        <category>上传和下载文件</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 下一个更大元素</title>
    <url>/2021/08/27/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="496-下一个更大元素"><a href="#496-下一个更大元素" class="headerlink" title="496.下一个更大元素"></a>496.下一个更大元素</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。<br>请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。<br>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/next-greater-element-i/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.暴力解法<br>对于每一个 nums1[i] 中的元素，先在 nums2 中找到它，然后向右遍历找到第 1 个大于 nums1[i] 的元素。<br>2.单调栈<br>步骤：<br>1）使用单调栈先对 nums2 中的每一个元素，求出它的右边第一个更大的元素；<br>2）将上一步的对应关系放入哈希表（HashMap）中；<br>3）再遍历数组 nums1，根据哈希表找出答案。<br>维护单调栈：<br>我们维护的栈恰好保证了单调性：栈中的元素从栈顶到栈底是单调不降的。<br>当我们遇到一个新的元素 nums2[i] 时，我们判断栈顶元素是否小于 nums2[i]，<br>如果是，那么栈顶元素的下一个更大元素即为 nums2[i]，我们将栈顶元素出栈。<br>重复这一操作，直到栈为空或者栈顶元素大于 nums2[i]。此时我们将 nums2[i] 入栈，<br>保持栈的单调性，并对接下来的 nums2[i + 1], nums2[i + 2] … 执行同样的操作。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):
    def nextGreaterElement(self, nums1, nums2):
        &quot;&quot;&quot;
        暴力解法
        对于每一个 nums1[i] 中的元素，先在 nums2 中找到它，然后向右遍历找到第 1 个大于 nums1[i] 的元素。

        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: List[int]
        &quot;&quot;&quot;
        # 使用内置方法list.index()/list.append()
        # next_greater_index = []  # 存储下一个更大元素下标的列表
        #
        # if len(nums1) &lt; 1:
        #     return next_greater_index
        #
        # for num in nums1:  # 遍历nums1中的每一个元素
        #     index = nums2.index(num)  # 定位nums1中的元素在nums2中的下标
        #     for i in range(index+1, len(nums2)):  # 遍历nums1中元素在nums2中所在位置之后的元素
        #         if nums2[i] &gt; num:  # 如果找到比nums1中元素更大的元素，则将下标加入下标列表
        #             next_greater_index.append(nums2[i])
        #             break
        #     else:
        #         next_greater_index.append(-1)
        #
        # return next_greater_index

        # 不使用内置方法list.index()/list.append()
        len1 = len(nums1)
        len2 = len(nums2)

        res = list()

        if len1 &lt; 1:
            return res

        for i in range(len1):
            cur_val = nums1[i]
            j = 0
            while j &lt; len2 and nums2[j] != cur_val:
                j += 1

            # nums2[j] = nums1[i]
            j += 1
            while j &lt; len2 and nums2[j] &lt; cur_val:
                j += 1

            if j == len2:
                res[i] = -1
                continue

            res[i] = nums2[j]
        return res

    def nextGreaterElement1(self, nums1, nums2):
        &quot;&quot;&quot;
        栈（单调栈）

        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: List[int]
        &quot;&quot;&quot;
        stack = list()
        map = &#123;&#125;
        # 对nums2中的每一个元素，求出它的右边第一个更大的元素；
        # 将对应关系放入哈希表（HashMap）中
        for i in range(len(nums2)):
            while len(stack) != 0 and stack[-1] &lt; nums2[i]:
                map[stack.pop()] = nums2[i]

            stack.append(nums2[i])

        # 遍历数组nums1，根据哈希表找出答案
        res = list()
        for j in range(len(nums1)):
            res.append(map.get(nums1[j], -1))

        return res


if __name__ == &quot;__main__&quot;:
    slt = Solution()

    res_list = slt.nextGreaterElement1([4, 1, 2], [1, 3, 4, 2])

    print(res_list)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>urllib.request | 下载图片</title>
    <url>/2021/08/05/%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h1 id="使用urllib-request库从互联网上下载图片"><a href="#使用urllib-request库从互联网上下载图片" class="headerlink" title="使用urllib.request库从互联网上下载图片"></a>使用urllib.request库从互联网上下载图片</h1><pre><code># coding=utf-8

import urllib.request as request

url = &#39;http://localhost:8080/NoteWebService/logo.png&#39;

with request.urlopen(url) as response:
    data = response.read()
    f_name = &#39;download.png&#39;
    with open(f_name, &#39;wb&#39;) as f:
        f.write(data)
        print(&#39;下载文件成功&#39;)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>内置模块</category>
        <category>urllib</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>urllib</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 两数之和</title>
    <url>/2021/08/27/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="1-两数相加"><a href="#1-两数相加" class="headerlink" title="1.两数相加"></a>1.两数相加</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。<br>你可以按任意顺序返回答案。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/two-sum/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.暴力枚举法<br>枚举数组中的每一个数x，寻找数组中是否存在target-x<br>2.哈希表<br>改进了方法1中寻找数组中是否存在target-x的过程</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):
    def twoSum(self, nums, target):  # O(N^2)
        &quot;&quot;&quot;
        暴力枚举法

        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        &quot;&quot;&quot;
        for i in range(len(nums)):
            for j in range(i+1, len(nums)):
                if nums[i] + nums[j] == target:
                    return [i, j]

    def twoSum1(self, nums, target):  # O(N)
        hashtable = dict()
        for i, num in enumerate(nums):
            if target - num in hashtable:
                return [hashtable[target - num], i]
            hashtable[nums[i]] = i
        return []


if __name__ == &quot;__main__&quot;:
    slt = Solution()
    t = slt.twoSum([2, 7, 11, 15], 9)
    print(t)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 两数相加</title>
    <url>/2021/08/27/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。<br>请你将两个数相加，并以相同形式返回一个表示和的链表。<br>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/add-two-numbers/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对应位置元素带进位相加</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># Definition for singly-linked list.
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):
    def addTwoNumbers(self, l1, l2):
        &quot;&quot;&quot;
        对应位置元素带进位相加
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        extra = 0
        root = n = ListNode(0)
        while l1 or l2 or extra:
            v1 = v2 = 0
            if l1:
                v1 = l1.val
                l1 = l1.next
            if l2:
                v2 = l2.val
                l2 = l2.next
            extra, val = divmod(v1 + v2 + extra, 10)
            n.next = ListNode(val)
            n = n.next
        return root.next

    def create_linked_list(self, num):
        link_list = ListNode(num % 10)
        r = link_list
        while num &gt;= 10:
            num = num // 10
            node = ListNode(num % 10)
            r.next = node
            r = r.next
        r.next = None
        return link_list

    def len_list(self, link_list):
        count = 0
        p = link_list
        while p is not None:
            count += 1
            p = p.next

        return count

class Solution1:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:
        &quot;&quot;&quot;
        将两个链表分别转化为一个整数,然后将两个整数相加,将结果的逆序构建成一个单链表
  
        t = 1
        res1 = 0

        while l1 is not None:
            res1 += l1.val * t
            t *= 10
            l1 = l1.next

        t = 1
        res2 = 0
        while l2 is not None:
            res2 += l2.val * t
            t *= 10
            l2 = l2.next

        res = res1 + res2
        print(res)

        res_list = ListNode(res % 10)
        r = res_list
        while res &gt;= 10:
            res //= 10
            node = ListNode(res % 10)
            r.next = node
            r = node
        r.next = None

        return res_list

if __name__ == &#39;__main__&#39;:
    slt = Solution()
    l1 = slt.create_linked_list(342)
    l2 = slt.create_linked_list(465)
    res = slt.addTwoNumbers1(l1, l2)

    while res is not None:
        print(res.val)
        res = res.next

    print(slt.len_list(l1))
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 为什么需要非线性激活函数</title>
    <url>/2021/06/23/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="为什么需要非线性激活函数"><a href="#为什么需要非线性激活函数" class="headerlink" title="为什么需要非线性激活函数?"></a>为什么需要非线性激活函数?</h1><p>为什么神经网络需要非线性激活函数？如果使用线性激活函数(恒等激励函数)，那么神经网络只是把输入线性组合<br>再输出。对于深度神经网络来说，如果使用了线性激活函数或者没有使用激活函数，那么无论你的神经网络有多少<br>层，它做的只是计算线性函数，这样的做法与直接去掉全部隐藏层无异。因此，必须通过非线性激活函数来引入非线性。</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>激活函数</tag>
      </tags>
  </entry>
  <entry>
    <title>伪迹移除 | 主成分分析</title>
    <url>/2021/02/23/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h1><p><b style="color: red">PCA is a type of spatial filter that transforms the time domain datasets into a different space by rotating axes in an N-dimensional space(where n is the number of variables or EEG channels) such that each dimension in the new space has minimum variance and the axes are orthogonal to each other.</b></p>
<p>PCA reduces data dimension and highlights specific features of data,which is usually difficult to identify in the spatially unfiltered data as the new components are created by weighted combinations of all EEG channels.</p>
<h2 id="One-important-limitation-of-PCA-or-SVD"><a href="#One-important-limitation-of-PCA-or-SVD" class="headerlink" title="One important limitation of PCA (or SVD)"></a>One important limitation of PCA (or SVD)</h2><p>it fails to separate/identify ocular or similar artifacts from<br>EEG when amplitudes are comparable since PCA depends on<br>the higher order statistical property</p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>伪迹移除</category>
      </categories>
      <tags>
        <tag>伪迹移除</tag>
        <tag>ICA</tag>
        <tag>EEG</tag>
        <tag>PCA</tag>
      </tags>
  </entry>
  <entry>
    <title>spring | 事务管理</title>
    <url>/2022/03/07/%E4%BA%8B%E5%8A%A1-1/</url>
    <content><![CDATA[<h1 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h1><p>1.项目目录<br><img src="/2022/03/07/%E4%BA%8B%E5%8A%A1-1/1.PNG"><br>book包—&gt;使用注解管理事务<br>book_xml—&gt;使用xml方式管理事务</p>
<span id="more"></span>

<p>数据库表(book,stock,money)<br><img src="/2022/03/07/%E4%BA%8B%E5%8A%A1-1/2.PNG"><br><img src="/2022/03/07/%E4%BA%8B%E5%8A%A1-1/3.PNG"><br><img src="/2022/03/07/%E4%BA%8B%E5%8A%A1-1/4.PNG"><br>2.使用注解管理事务<br>2.1 BookController.java</p>
<pre><code>package com.atguigu.book.controller;

import java.util.ArrayList;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;

import com.atguigu.book.service.BookService;
import com.atguigu.book.service.Cashier;

@Controller
public class BookController &#123;
    @Autowired
    private BookService service;
    
    @Autowired
    private Cashier cashier;
    
    public void buyBook()&#123;
        service.buyBook(&quot;1&quot;, &quot;1001&quot;);
    &#125;
    
    public void checkOut()&#123;
        List&lt;String&gt; bids = new ArrayList&lt;&gt;();
        bids.add(&quot;1&quot;);
        bids.add(&quot;2&quot;);
        cashier.checkOut(&quot;1001&quot;, bids);
    &#125;
&#125;
</code></pre>
<p>2.2 BookDao.java</p>
<pre><code>package com.atguigu.book.dao;

public interface BookDao &#123;
    Integer selectPrice(String bid);
    
    void updateSt(String bid);
    
    void updateBalance(String uid, Integer price);
&#125;
</code></pre>
<p>2.3 BookDaoImpl.java</p>
<pre><code>package com.atguigu.book.dao.impl;

import javax.management.RuntimeErrorException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import com.atguigu.book.dao.BookDao;
import com.atguigu.book.exception.MyException;

@Repository
public class BookDaoImpl implements BookDao&#123;
    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Override
    public Integer selectPrice(String bid) &#123;
        String sql = &quot;select price from book where bid = ?&quot;;
        Integer price = jdbcTemplate.queryForObject(sql, new Object[]&#123;bid&#125;, Integer.class);
        return price;
    &#125;

    @Override
    public void updateSt(String bid) &#123;
        //获取该书记的库存
        String sql = &quot;select st from stock where sid = ?&quot;;
        Integer st = jdbcTemplate.queryForObject(sql, new Object[]&#123;bid&#125;, Integer.class);
        if(st &lt;= 0)&#123;
            throw new RuntimeException();
        &#125;else&#123;
            jdbcTemplate.update(&quot;update stock set st = st - 1 where sid = ?&quot;, bid);
        &#125;
    &#125;

    @Override
    public void updateBalance(String uid, Integer price) &#123;
        Integer balance = jdbcTemplate.queryForObject(&quot;select balance from money where uid = ?&quot;, new Object[]&#123;uid&#125;, Integer.class);
        if(balance &lt; price)&#123;
            throw new MyException(&quot;余额不足&quot;);
        &#125;else&#123;
            jdbcTemplate.update(&quot;update money set balance = balance - ? where uid = ?&quot;, price, uid);
        &#125;
    &#125;
&#125;
</code></pre>
<p>2.4 BookService.java</p>
<pre><code>package com.atguigu.book.service;

public interface BookService &#123;
    void buyBook(String bid, String uid);
&#125;
</code></pre>
<p>2.5 BookServiceImpl.java</p>
<pre><code>package com.atguigu.book.service.impl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import com.atguigu.book.dao.BookDao;
import com.atguigu.book.exception.MyException;
import com.atguigu.book.service.BookService;

@Service
//@Transactional
public class BookServiceImpl implements BookService&#123;
    @Autowired
    private BookDao dao;
    
    /**
     * @Transactional:对方法中所有的操作作为一个事务进行管理
     * 在方法上使用，只对方法有效果
     * 在类上使用，对类中所有的方法都有效果
     * @Transactional中可以设置的属性：
     * propagation:A方法和B方法都有事务，当A在调用B时，会将A中的事务传播给B方法，
     * B方法对于事务的处理方式就是事务的传播行为
     * Propagation.REQUIRED:必须使用调用者的事务（默认值）
     * Propagation.REQUIRES_NEW:将调用者的事务挂起，不使用调用者的事务，使用新的事务进行处理
     * isolation:事务的隔离级别，在并发的情况下，操作数据的一种规定
     *         读未提交(1)：脏读（读到没有意义的数据）---&gt;对于字段来说
     *         读已提交(2)：不可重复读（重复读到的数据不一致）---&gt;对于字段来说
     *         可重复读(4)：幻读（重复读到整张表的数据不一致，第一次读一部分，第二次读多了一些数据）---&gt;对于记录来说
     *         串行化(8)：性能低，消耗大
     * timeout:在事务强制回滚前最多可以执行（等待）的时间
     * 
     * readOnly:指定当前事务中的一系列的操作是否为只读
     * 若设置为只读，不管事务中有没有写的操作，MySQL都会在请求访问数据的时候，不加锁，提高性能
     * 如果有写操作的情况，建议一定不能设置只读
     * 
     * rollbackFor|rollbackForClassName|noRollbackFor|noRollbakForClassName
     */
    @Transactional(propagation=Propagation.REQUIRES_NEW, timeout=3, noRollbackFor=&#123;NullPointerException.class, MyException.class&#125;)
    public void buyBook(String bid, String uid)&#123;
//        try &#123;
//            Thread.sleep(5000);
//        &#125; catch (InterruptedException e) &#123;
//            e.printStackTrace();
//        &#125;
        Integer price = dao.selectPrice(bid);

        dao.updateSt(bid);
        
        dao.updateBalance(uid, price);
    &#125;    
&#125;
</code></pre>
<p>2.6 Cashier.java</p>
<pre><code>package com.atguigu.book.service;

import java.util.List;

public interface Cashier &#123;
    void checkOut(String uid, List&lt;String&gt; bids);
&#125;
</code></pre>
<p>2.7 CashierServiceImpl.java</p>
<pre><code>package com.atguigu.book.service.impl;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.atguigu.book.service.BookService;
import com.atguigu.book.service.Cashier;

@Service
@Transactional
public class CashierServiceImpl implements Cashier&#123;
    @Autowired
    private BookService service;
    
    @Override
    public void checkOut(String uid, List&lt;String&gt; bids) &#123;
        // TODO Auto-generated method stub
        for (String bid : bids) &#123;
            service.buyBook(bid, uid);
        &#125;
    &#125;
&#125;
</code></pre>
<p>2.8 MyException.java</p>
<pre><code>package com.atguigu.book.exception;

public class MyException extends RuntimeException&#123;

    public MyException() &#123;
        super();
        // TODO Auto-generated constructor stub
    &#125;

    public MyException(String arg0, Throwable arg1, boolean arg2, boolean arg3) &#123;
        super(arg0, arg1, arg2, arg3);
        // TODO Auto-generated constructor stub
    &#125;

    public MyException(String arg0, Throwable arg1) &#123;
        super(arg0, arg1);
        // TODO Auto-generated constructor stub
    &#125;

    public MyException(String arg0) &#123;
        super(arg0);
        // TODO Auto-generated constructor stub
    &#125;

    public MyException(Throwable arg0) &#123;
        super(arg0);
        // TODO Auto-generated constructor stub
    &#125;

&#125;
</code></pre>
<p>2.9 Test.java</p>
<pre><code>package com.atguigu.book;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import com.atguigu.book.controller.BookController;

public class Test &#123;
    public static void main(String[] args)&#123;
        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;book.xml&quot;);
        
        BookController controller = ac.getBean(&quot;bookController&quot;, BookController.class);
        controller.buyBook();
        
        //controller.checkOut();
    &#125;
&#125;
</code></pre>
<p>2.10 db.properties</p>
<pre><code>jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/ssm
jdbc.username=root
jdbc.password=root   
</code></pre>
<p>2.11 book.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd
        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd&quot;&gt;

    &lt;context:component-scan base-package=&quot;com.atguigu.book&quot;&gt;&lt;/context:component-scan&gt;
    
    &lt;!-- 引入属性文件 --&gt;
    &lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;
        &lt;property name=&quot;location&quot; value=&quot;db.properties&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    
    &lt;!-- 引入属性文件 --&gt;
    &lt;context:property-placeholder location=&quot;db.properties&quot;/&gt;
    
    &lt;!-- 创建数据源 --&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    
    &lt;!-- 通过数据源配置JdbcTemplate --&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    
    &lt;!-- 配置事务管理器 --&gt;
    &lt;bean id=&quot;dataSourceTransactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    
    &lt;!-- 开启注解驱动，即对事务相关的注解进行扫描，解析含义并执行功能 --&gt;
    &lt;tx:annotation-driven transaction-manager=&quot;dataSourceTransactionManager&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<p>3.使用xml方式管理事务<br>3.1 BookServiceImpl.java</p>
<pre><code>package com.atguigu.book_xml.service.impl;
import org.springframework.beans.factory.annotation.Autowired;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import com.atguigu.book_xml.dao.BookDao;
import com.atguigu.book_xml.exception.MyException;
import com.atguigu.book_xml.service.BookService;

@Service
public class BookServiceImpl implements BookService&#123;
    @Autowired
    private BookDao dao;
    
    public void buyBook(String bid, String uid)&#123;
//        try &#123;
//            Thread.sleep(5000);
//        &#125; catch (InterruptedException e) &#123;
//            e.printStackTrace();
//        &#125;
        Integer price = dao.selectPrice(bid);

        dao.updateSt(bid);
        
        dao.updateBalance(uid, price);
    &#125;    
&#125;
</code></pre>
<p>3.2 book_xml.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd
        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd
        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd&quot;&gt;

    &lt;context:component-scan base-package=&quot;com.atguigu.book_xml&quot;&gt;&lt;/context:component-scan&gt;
    
    &lt;!-- 引入属性文件 --&gt;
    &lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;
        &lt;property name=&quot;location&quot; value=&quot;db.properties&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    
    &lt;!-- 引入属性文件 --&gt;
    &lt;context:property-placeholder location=&quot;db.properties&quot;/&gt;
    
    &lt;!-- 创建数据源 --&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    
    &lt;!-- 通过数据源配置JdbcTemplate --&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    
    &lt;!-- 配置事务管理器(相当于一个切面),不管时用注解方式或xml方式配置事务，一定要有DataSourceTransactionManager事务管理器的支持 --&gt;
    &lt;bean id=&quot;dataSourceTransactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    
    &lt;!-- 配置事务通知 --&gt;
    &lt;tx:advice id=&quot;tx&quot; transaction-manager=&quot;dataSourceTransactionManager&quot;&gt;
        &lt;tx:attributes&gt;
            &lt;!-- 在设置好的切入点表达式下再次进行事务设置 --&gt;
            &lt;tx:method name=&quot;buyBook&quot;/&gt;
            &lt;tx:method name=&quot;checkOut&quot;/&gt;
            
            &lt;!-- 只有select开头的方法才会被事务处理 --&gt;
            &lt;tx:method name=&quot;select*&quot; read-only=&quot;true&quot;/&gt;
            &lt;tx:method name=&quot;insert*&quot;/&gt;
            &lt;tx:method name=&quot;update*&quot;/&gt;
            &lt;tx:method name=&quot;delete*&quot;/&gt;
            
            &lt;tx:method name=&quot;*&quot;/&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;
    
    &lt;!-- 配置切入点表达式 --&gt;
    &lt;aop:config&gt;
        &lt;aop:pointcut expression=&quot;execution(* com.atguigu.book_xml.service.impl.*.*(..))&quot; id=&quot;pointCut&quot;/&gt;
        &lt;aop:advisor advice-ref=&quot;tx&quot; pointcut-ref=&quot;pointCut&quot;/&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
<p>3.3 Test.java</p>
<pre><code>package com.atguigu.book_xml;

import org.springframework.context.ApplicationContext;

import org.springframework.context.support.ClassPathXmlApplicationContext;

import com.atguigu.book_xml.controller.BookController;

public class Test &#123;
    public static void main(String[] args)&#123;
        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;book_xml.xml&quot;);
        
        BookController controller = ac.getBean(&quot;bookController&quot;, BookController.class);
        controller.buyBook();
        
        //controller.checkOut();
    &#125;
&#125;
</code></pre>
<p>3.4 其他代码与注解方式管理事务相同</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>spring</category>
        <category>事务管理</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>事务管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis | 事务</title>
    <url>/2022/05/07/%E4%BA%8B%E5%8A%A1-2/</url>
    <content><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="Redis中事务的定义"><a href="#Redis中事务的定义" class="headerlink" title="Redis中事务的定义"></a>Redis中事务的定义</h2><p>Redis事务是一个单独的隔离操作：<strong>事务中的所有命令都会序列化、按顺序地执行</strong>。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断<br>Redis事务的主要作用就是<strong>串联多个命令防止别的命令插队</strong>。</p>
<h2 id="事务相关的命令-multi、exec、discard"><a href="#事务相关的命令-multi、exec、discard" class="headerlink" title="事务相关的命令(multi、exec、discard)"></a>事务相关的命令(multi、exec、discard)</h2><p>1.从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，至到输入Exec后，Redis会将之前的命令队列中的命令依次执行。<br>2.组队的过程中可以通过discard来放弃组队。 </p>
<span id="more"></span>
<h2 id="事务中的错误处理"><a href="#事务中的错误处理" class="headerlink" title="事务中的错误处理"></a>事务中的错误处理</h2><p>1.组队中某个命令出现了报告错误，执行时整个的所有队列会都会被取消。<br>2.如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。</p>
<h2 id="Redis事务的使用"><a href="#Redis事务的使用" class="headerlink" title="Redis事务的使用"></a>Redis事务的使用</h2><p>1.WATCH key[key….]<br>在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。<br>2.unwatch<br>取消 WATCH 命令对所有 key 的监视。<br>如果在执行 WATCH 命令之后， EXEC 命令或 DISCARD 命令先被执行了的话，那么就不需要再执行 UNWATCH 了。<br>3.三特性<br>3.1单独的隔离操作<br>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。<br>3.2没有隔离级别的概念<br>队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，也就不存在“事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头痛的问题 <br>3.3不保证原子性<br>Redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚 </p>
]]></content>
      <categories>
        <category>Redis</category>
        <category>事务</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb项目开发 | 事务</title>
    <url>/2022/01/26/%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>当我们一次需要执行多条sql语句时就要考虑控制事务以避免出现一些错误。<br>例如：当我们从一个账户给另一个账户转账时，假设第一个账户的余额已经扣除，此时电脑断电了，<br>第二个账户的余额也没有增加；为了避免此类事情的发生，我们可以对事物进行控制，要么增扣除和增加都成功，<br>要么扣除、增加都失败。<br><strong>创建表user</strong></p>
<pre><code>CREATE TABLE user(
id INT PRIMARY KEY AUTO_INCREMENT NOT NULL,
NAME VARCHAR(20),
balance DOUBLE
);
</code></pre>
<p><strong>创建测试类Test1.java</strong></p>
<pre><code>package com.oracle.test;

import java.sql.SQLException;

import org.apache.commons.dbutils.QueryRunner;

import com.oracle.utils.DataSourceUtils;

public class Test1 &#123;

    public static void main(String[] args)&#123;
        try &#123;
            //开启事务
            DataSourceUtils.startTransaction();
            //创建QueryRunner对象
            QueryRunner qr = new QueryRunner();
            //编写sql语句
            String sql1 = &quot;update user set balance=balance-500 where id=1&quot;;
            String sql2 = &quot;update user set balance=balance+500 where id=2&quot;;
            //执行sql
            qr.update(DataSourceUtils.getConnection(), sql1);
            
            //失败
            int c=100/0;
            
            qr.update(DataSourceUtils.getConnection(), sql2);
            //事务提交
            DataSourceUtils.commitAndRelease();
            //关闭事务
            DataSourceUtils.closeConnection();
        &#125; catch (Exception e) &#123;
            //失败则回滚
            try &#123;
                DataSourceUtils.rollback();
            &#125; catch (Exception e1) &#123;
                // TODO Auto-generated catch block
                e1.printStackTrace();
            &#125;
        &#125;
    &#125;

&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb项目开发</category>
        <category>事务</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>事务</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 二叉树的最小深度</title>
    <url>/2022/01/16/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，找出其最小深度。<br>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。<br>说明：叶子节点是指没有子节点的节点。</p>
<p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>方法一：深度优先搜索<br>首先可以想到使用深度优先搜索的方法，遍历整棵树，记录最小深度。<br>对于每一个非叶子节点，我们只需要分别计算其左右子树的最小叶子节点深度。这样就将一个大问题转化为了小问题，可以递归地解决该问题。<br>方法二：广度优先搜索<br>使用广度优先搜索的方法，遍历整棵树。<br>当我们找到一个叶子节点时，直接返回这个叶子节点的深度。广度优先搜索的性质保证了最先搜索到的叶子节点的深度一定最小。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># Definition for a binary tree node.
import collections


class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):
    def minDepth(self, root):
        &quot;&quot;&quot;
        深度优先搜索
        :type root: TreeNode
        :rtype: int
        &quot;&quot;&quot;
        def get_depth(root):
            if root is None:
                return 0
            left_depth = get_depth(root.right)
            right_depth = get_depth(root.left)
            return min(right_depth, left_depth) + 1

        return get_depth(root)

    def minDepth1(self, root):
        &quot;&quot;&quot;深度优先搜索&quot;&quot;&quot;
        if not root:
            return 0

        if not root.left and not root.right:
            return 1

        min_depth = 10 ** 9
        if root.left:
            min_depth = min(self.minDepth1(root.left), min_depth)
        if root.right:
            min_depth = min(self.minDepth1(root.right), min_depth)
        return min_depth + 1

    def minDepth2(self, root):
        &quot;&quot;&quot;深度优先搜索&quot;&quot;&quot;
        if not root:
            return 0

        que = collections.deque([(root, 1)])
        while que:
            node, depth = que.popleft()
            if not node.left and not node.right:
                return depth
            if node.left:
                que.append((node.left, depth + 1))
            if node.right:
                que.append((node.right, depth + 1))

        return 0

    def create_binary_tree(self, nodes_list):
        node1 = TreeNode(nodes_list[1])
        node3 = TreeNode(nodes_list[3])
        node4 = TreeNode(nodes_list[4])
        node2 = TreeNode(nodes_list[2], node3, node4)
        root = TreeNode(nodes_list[0], node1, node2)
        return root


if __name__ == &quot;__main__&quot;:
    slt = Solution()
    root = slt.create_binary_tree([3, 9, 20, 15, 7])
    print(slt.minDepth(root))
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 二进制求和</title>
    <url>/2021/08/29/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/</url>
    <content><![CDATA[<h1 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67.二进制求和"></a>67.二进制求和</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两个二进制字符串，返回它们的和（用二进制表示）。<br>输入为 非空 字符串且只包含数字 1 和 0。</p>
<span id="more"></span>
<p>示例 1:<br>输入: a = “11”, b = “1”<br>输出: “100”</p>
<p><a href="https://leetcode-cn.com/problems/add-binary/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.先将 a 和 b 转化成十进制数，求和后再转化为二进制数<br>2.列竖式<br>末尾对齐，逐位相加，逢二进一<br>具体的，我们可以取 n=max{∣a∣,∣b∣}，循环 n 次，从最低位开始遍历。我们使用一个变量 carry 表示上一个位置的进位，初始值为 0。记当前位置对其的两个位为 ai​ 和 bi​，则每一位的答案为 (carry+ai+bi) mod 2，下一位的进位为 ⌊(carry+ai+bi)/2⌋。重复上述步骤，直到数字 a 和 b 的每一位计算完毕。最后如果 carry 的最高位不为 0，则将最高位添加到计算结果的末尾。<br>注意，为了让各个位置对齐，你可以先反转这个代表二进制数字的字符串，然后低下标对应低位，高下标对应高位。当然你也可以直接把 a 和 b 中短的那一个补 0 直到和长的那个一样长，然后从高位向低位遍历，对应位置的答案按照顺序存入答案字符串内，最终将答案串反转。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def addBinary(self, a: str, b: str) -&gt; str:
        &quot;&quot;&quot;
        先将 aaa 和 bbb 转化成十进制数，求和后再转化为二进制数
        :param a:
        :param b:
        :return:
        &quot;&quot;&quot;
        # a = int(a, 2)  # 将二进制数转为十进制
        # b = int(b, 2)
        # print(a)
        # print(b)
        # return bin(a+b)[2:]

        return &#39;&#123;0:b&#125;&#39;.format(int(a, 2) + int(b, 2))

    def addBinary1(self, a: str, b: str) -&gt; str:
        ans = list()
        n = max(len(a), len(b))
        carry = 0

        list_a = []
        list_b = []
        for e in a:
            list_a.append(int(e))

        for e in b:
            list_b.append(int(e))

        print(list_a)
        print(list_b)

        for i in range(n):
            carry += list_a[len(a) - i - 1] if i &lt; len(a) else 0
            carry += list_b[len(b) - i - 1] if i &lt; len(b) else 0
            ans.append(str(int(carry % 2)))
            carry /= 2

        if carry &gt; 0:
            ans.append(&#39;1&#39;)

        return &#39;&#39;.join(ans[::-1])


if __name__ == &#39;__main__&#39;:
    s = Solution()
    a = &quot;11&quot;
    b = &quot;1&quot;
    res = s.addBinary1(a, b)
    print(res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>OS | 什么是操作系统</title>
    <url>/2021/10/14/%E4%BB%80%E4%B9%88%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统?"></a>什么是操作系统?</h1><p>“操作系统（operating system，简称OS）是管理计算机硬件与软件资源的计算机程序,是硬件软件之间的一座桥梁。</p>
<p><img src="/2021/10/14/%E4%BB%80%E4%B9%88%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.JPG"></p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>xlrd | 从Excel表中批量复制粘贴数据到新表</title>
    <url>/2021/11/05/%E4%BB%8EExcel%E8%A1%A8%E4%B8%AD%E6%89%B9%E9%87%8F%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E6%95%B0%E6%8D%AE%E5%88%B0%E6%96%B0%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="从Excel表中批量复制粘贴数据到新表"><a href="#从Excel表中批量复制粘贴数据到新表" class="headerlink" title="从Excel表中批量复制粘贴数据到新表"></a>从Excel表中批量复制粘贴数据到新表</h1><p>程序实现从Excel表中批量复制粘贴部分数据到新表。</p>
<span id="more"></span>
<p>代码：</p>
<pre><code># 读取xls文件中的数据
import xlrd

file = &quot;原表.xls&quot;
wb = xlrd.open_workbook(file)  # 读取工作簿
ws = wb.sheets()[0]  # 选第一个工作表
data = []

for row in range(7, ws.nrows):
    name = ws.cell(row, 1).value.strip()  # 科室名称
    total1 = ws.cell(row, 2).value  # 总计
    total2 = ws.cell(row, 3).value  # 计
    avg = ws.cell(row, 20).value  # 平均每日人次

    info_list = [name, total1, total2, avg]

    if info_list[0] != &quot;&quot;:  # 去除空数据
        data.append(info_list)

from openpyxl import load_workbook
from openpyxl.styles import Border, Side, PatternFill, Font, GradientFill, Alignment  # 设置单元格格式

thin = Side(border_style=&quot;thin&quot;, color=&quot;000000&quot;)  # 定义边框粗细及颜色

file = &quot;统计表模板.xlsx&quot;
wb = load_workbook(file)
ws = wb.active

# 写入数据
for i in data:
    ws.append(i)

# 设置字号，对齐，缩小字体填充，加边框
# Font(bold=True)可加粗字体
for row_number in range(3, ws.max_row + 1):
    ws.row_dimensions[row_number].height = 25  # 设置行高
    for col_number in range(1, 5):
        c = ws.cell(row=row_number, column=col_number)
        c.font = Font(size=11, bold=True)
        c.border = Border(top=thin, left=thin, right=thin, bottom=thin)
        c.alignment = Alignment(horizontal=&quot;center&quot;, vertical=&quot;center&quot;)

wb.save(&quot;统计表.xlsx&quot;)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>xlrd</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>openpyxl</tag>
        <tag>xlrd</tag>
      </tags>
  </entry>
  <entry>
    <title>pandas | 从原Excel表中抽出数据存入同一文件的新的Sheet</title>
    <url>/2021/10/29/%E4%BB%8E%E5%8E%9FExcel%E8%A1%A8%E4%B8%AD%E6%8A%BD%E5%87%BA%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5%E5%90%8C%E4%B8%80%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B0%E7%9A%84Sheet/</url>
    <content><![CDATA[<h1 id="从原Excel表中抽出数据存入同一文件的新的Sheet"><a href="#从原Excel表中抽出数据存入同一文件的新的Sheet" class="headerlink" title="从原Excel表中抽出数据存入同一文件的新的Sheet"></a>从原Excel表中抽出数据存入同一文件的新的Sheet</h1><p>实现代码：</p>
<pre><code>import pandas as pd

df = pd.read_excel(&quot;物料表.xlsx&quot;, header=2)
df.head()
#     请求单号     单位     物料编号     架位     批号     数量     日期
# 0     A19X9239156     EA     11010XR0073700     LC000001     PC00001     3     2019-01-03
# 1     A19X9239156     EA     11020XR0025500     LC000002     PC00002     10     2019-01-03
# 2     A19X9239156     EA     11030XR0013200     LC000003     PC00003     3     2019-01-03
# 3     A19X9239156     EA     11140XR0000100     LC000004     PC00004     3     2019-01-03
# 4     A19X9239156     EA     12121XR0172300     LC000005     PC00005     3     2019-01-03

df[&#39;月份&#39;] = df[&#39;日期&#39;].dt.month
df.head()
#     请求单号     单位     物料编号     架位     批号     数量     日期     月份
# 0     A19X9239156     EA     11010XR0073700     LC000001     PC00001     3     2019-01-03     1
# 1     A19X9239156     EA     11020XR0025500     LC000002     PC00002     10     2019-01-03     1
# 2     A19X9239156     EA     11030XR0013200     LC000003     PC00003     3     2019-01-03     1
# 3     A19X9239156     EA     11140XR0000100     LC000004     PC00004     3     2019-01-03     1
# 4     A19X9239156     EA     12121XR0172300     LC000005     PC00005     3     2019-01-03     1

df5 = df[df[&#39;月份&#39;] == 5]
df5.head()
#     请求单号     单位     物料编号     架位     批号     数量     日期     月份
# 9649     A19X9280200     EA     36012XR0413200     LC009650     PC09650     66     2019-05-03     5
# 9650     A19X9280200     EA     60022XR2298300     LC009651     PC09651     66     2019-05-03     5
# 9651     A19X9280561     EA     72004XR2000001     LC009652     PC09652     604     2019-05-03     5
# 9652     A19X9286759     EA     62010XR0161048     LC009653     PC09653     50     2019-05-03     5
# 9653     A19X9286759     EA     62010XR0502208     LC009654     PC09654     100     2019-05-03     5

df8 = df[df[&#39;月份&#39;] == 8]
df8.head()


#     请求单号     单位     物料编号     架位     批号     数量     日期     月份
# 17213     A19X9317364     EA     62010XR0500126     LC017214     PC17214     230     2019-08-01     8
# 17214     A19X9317364     EA     61010XR1120100     LC017215     PC17215     230     2019-08-01     8
# 17215     A19X9317364     EA     62012XR0102262     LC017216     PC17216     230     2019-08-01     8
# 17216     A19X9317364     EA     62010XR050150A     LC017217     PC17217     950     2019-08-01     8
# 17217     A19X9317364     EA     61011XR1150500     LC017218     PC17218     230     2019-08-01     8


# 去掉不需要的月份的数据
def Remove_data(df, month=[]):
    for i in month:
        df = df[df[&#39;月份&#39;] != i]
    return df


df_rest = Remove_data(df, [5, 8])
df_rest.head()
#     请求单号     单位     物料编号     架位     批号     数量     日期     月份
# 0     A19X9239156     EA     11010XR0073700     LC000001     PC00001     3     2019-01-03     1
# 1     A19X9239156     EA     11020XR0025500     LC000002     PC00002     10     2019-01-03     1
# 2     A19X9239156     EA     11030XR0013200     LC000003     PC00003     3     2019-01-03     1
# 3     A19X9239156     EA     11140XR0000100     LC000004     PC00004     3     2019-01-03     1
# 4     A19X9239156     EA     12121XR0172300     LC000005     PC00005     3     2019-01-03     1

with pd.ExcelWriter(&#39;物料表_1.xlsx&#39;, engine=&#39;openpyxl&#39;,
                    datetime_format=&#39;YYYY-MM-DD&#39;) as writer:
    df5.drop(&#39;月份&#39;, axis=1).to_excel(writer, sheet_name=&#39;5月&#39;, index=False)
    df8.drop(&#39;月份&#39;, axis=1).to_excel(writer, sheet_name=&#39;8月&#39;, index=False)
    df_rest.drop(&#39;月份&#39;, axis=1).to_excel(writer, sheet_name=&#39;剩余月份&#39;, index=False)

from openpyxl import load_workbook
from openpyxl.styles import Border, Side, PatternFill, Font, GradientFill, Alignment

thin = Side(border_style=&quot;thin&quot;, color=&quot;000000&quot;)  # 定义边框粗细及颜色
wb = load_workbook(&quot;物料表_1.xlsx&quot;)
for sheetname in wb.sheetnames:
    ws = wb[sheetname]

    # 调整列宽
    ws.column_dimensions[&#39;A&#39;].width = 12
    ws.column_dimensions[&#39;C&#39;].width = 15.5
    ws.column_dimensions[&#39;G&#39;].width = 10

    # 设置字号，对齐，缩小字体填充，加边框
    for row_number in range(2, ws.max_row + 1):
        for col_number in range(1, ws.max_column + 1):
            c = ws.cell(row=row_number, column=col_number)
            c.font = Font(size=10)
            c.border = Border(top=thin, left=thin, right=thin, bottom=thin)
            c.alignment = Alignment(horizontal=&quot;left&quot;, vertical=&quot;center&quot;)
wb.save(&quot;物料表_1.xlsx&quot;)
</code></pre>
<p><a href="物料表.xlsx">物料表.xlsx</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>pandas</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>openpyxl</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>openpyxl | 从多路径多Excel表中获取数据并存入新表</title>
    <url>/2021/10/29/%E4%BB%8E%E5%A4%9A%E8%B7%AF%E5%BE%84%E5%A4%9AExcel%E8%A1%A8%E4%B8%AD%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%AD%98%E5%85%A5%E6%96%B0%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="从多路径多Excel表中获取数据并存入新表"><a href="#从多路径多Excel表中获取数据并存入新表" class="headerlink" title="从多路径多Excel表中获取数据并存入新表"></a>从多路径多Excel表中获取数据并存入新表</h1><p>实现代码：</p>
<pre><code>import os

work_path = os.getcwd() + &quot;\\资料&quot;  # 获取当前工作路径，指定“资料”文件夹
# 获取路径下所有.xlsx文件，并存入列表
pathss = []  # 存储文件夹内所有文件的路径（包括子目录内的文件）
for root, dirs, files in os.walk(work_path):
    path = [os.path.join(root, name) for name in files]  # 将目录和文件名连接起来，才是完整文件路径
    for i in range(len(path)):  # 遍历所有文件的地址
        if path[i].endswith(&quot;.xlsx&quot;):  # 只提取后缀为xlsx的文件
            pathss.append(path[i])

# 定义函数，获取Excel表格中的ID数据
from openpyxl import load_workbook  # 用于读取Excel中的信息


def Get_system_ID(file):
    wb = load_workbook(file)
    ws = wb.active

    ID_list = []
    for row in range(2, ws.max_row + 1):
        ID = ws[&quot;A&quot; + str(row)].value  # ID信息在A列
        if ID != None:  # 过滤空值
            ID_list.append(ID)
    return ID_list


# 获取数据，存入总列表
total_list = []
for file in pathss:
    info = Get_system_ID(file)
    total_list += info

# 写入数据到新的excel表，并设置格式
from openpyxl import Workbook
from openpyxl.styles import Font, colors, Alignment  # 字体，颜色，对齐
from openpyxl.styles import PatternFill  # 单元格填充

wb = Workbook()  # 新建Excel工作簿
ws = wb.active  # 使用活动工作表
ws.column_dimensions[&#39;A&#39;].width = 18.5  # 设定A列宽度
ws.cell(row=1, column=1, value=&quot;ID&quot;)  # 写入字段名
color_fill = PatternFill(fill_type=&#39;solid&#39;, fgColor=&quot;B3CFA1&quot;)  # 设置底色
ws.cell(row=1, column=1).fill = color_fill  # 填充底色

# 批量从列表中提取数据并写入
for row in range(1, len(total_list) + 1):
    ws.cell(row=row + 1, column=1, value=total_list[row - 1])

# 设置字号及对齐
font_set = Font(name=&#39;Arial&#39;, size=9)
for i in range(1, ws.max_row + 1):
    ws.cell(row=i, column=1).font = font_set
    ws.cell(row=i, column=1).alignment = Alignment(horizontal=&#39;left&#39;, vertical=&#39;center&#39;, shrink_to_fit=True)

wb.save(os.getcwd() + &quot;\\ID.xlsx&quot;)

print(f&quot;\n共获取到 &#123;len(pathss)&#125; 个 Excel表，共 &#123;len(total_list)&#125; 个ID。&quot;)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>openpyxl</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>os</tag>
        <tag>openpyxl</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程 | 从浏览器访问百度的整个访问过程</title>
    <url>/2020/10/26/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BF%E9%97%AE%E7%99%BE%E5%BA%A6%E7%9A%84%E6%95%B4%E4%B8%AA%E8%AE%BF%E9%97%AE%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="从浏览器访问百度的整个访问过程"><a href="#从浏览器访问百度的整个访问过程" class="headerlink" title="从浏览器访问百度的整个访问过程"></a>从浏览器访问百度的整个访问过程</h1><h2 id="实际场景"><a href="#实际场景" class="headerlink" title="实际场景"></a>实际场景</h2><p>在浏览器的地址输入栏，输入<a href="http://www.baidu.com访问百度./">www.baidu.com访问百度。</a></p>
<h2 id="访问过程"><a href="#访问过程" class="headerlink" title="访问过程"></a>访问过程</h2><ol>
<li>1.先要解析出baidu.com对应的ip地址</li>
<ol>
<li>1.先要知道默认网关的MAC地址</li>
<ol>
<li>1.使用ARP获取默认网关的MAC地址</li>
</ol>
<li>2.组织数据发送给默认网关（IP还是DNS服务器的IP，但MAC地址是默认网关的MAC地址）</li>
<li>3.默认网关拥有转发数据的能力，把数据转发给路由器</li>
<li>4.路由器根据自己的路由协议来选择一个合适的较快的路径转发数据给目的网关</li>
<li>5.目的网关（DNS服务器所在的网关），把数据转发给DNS服务器</li>
<li>6.DNS服务器查询解析出baidu.com对应的IP地址，并把它原路返回给请求这个域名的客户端</li>
</ol>
<li>2.得到了baidu.com对应的IP地址后会发送TCP的3次握手，进行连接</li>
<li>3.使用HTTP协议发送请求数据给WEB服务器</li>
<li>4.WEB服务器收到请求数据之后，通过查询自己的服务器得到响应的结果，原路返回个浏览器</li>
<li>5.浏览器接收到数据后，通过浏览器自己的渲染功能来显示这个网页</li>
<li>6.浏览器关闭TCP连接，即4次挥手</li>
</ol>


]]></content>
      <categories>
        <category>python</category>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 | 代理模式</title>
    <url>/2022/03/21/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p><a href="https://victory-liao.github.io/2022/03/10/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/">动态代理</a><br><a href="https://victory-liao.github.io/2022/03/10/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/">静态代理</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>代理模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>代理模式</tag>
        <tag>动态代理</tag>
        <tag>静态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>spring | 以XML方式配置切面</title>
    <url>/2022/03/06/%E4%BB%A5XML%E6%96%B9%E5%BC%8F%E9%85%8D%E7%BD%AE%E5%88%87%E9%9D%A2/</url>
    <content><![CDATA[<h1 id="以XML方式配置切面"><a href="#以XML方式配置切面" class="headerlink" title="以XML方式配置切面"></a>以XML方式配置切面</h1><p>1.项目目录<br><img src="/2022/03/06/%E4%BB%A5XML%E6%96%B9%E5%BC%8F%E9%85%8D%E7%BD%AE%E5%88%87%E9%9D%A2/1.PNG"></p>
<p>2.MathI.java(接口)</p>
<pre><code>package com.atguigu.spring.aopxml;

public interface MathI &#123;
    int add(int i, int j);
    int sub(int i, int j);
    int mul(int i, int j);
    int div(int i, int j);
&#125;
</code></pre>
<p>3.MathImpl.java(实现类)</p>
<pre><code>package com.atguigu.spring.aopxml;

import org.springframework.stereotype.Component;

@Component
public class MathImpl implements MathI&#123;

    @Override
    public int add(int i, int j) &#123;
        int result = i + j;
        return result;
    &#125;
    
    @Override
    public int sub(int i, int j) &#123;
        int result = i - j;
        return result;
    &#125;

    @Override
    public int mul(int i, int j) &#123;
        int result = i * j;
        return result; 
    &#125;

    @Override
    public int div(int i, int j) &#123;
        int result = i / j;
        return result;
    &#125;
&#125;
</code></pre>
<p>4.MyLogger.java(切面)</p>
<pre><code>package com.atguigu.spring.aopxml;

import org.springframework.stereotype.Component;

@Component
public class MyLogger &#123;
    public void before()&#123;
        System.out.println(&quot;前置通知&quot;);
    &#125;
&#125;
</code></pre>
<p>5.aop-xml.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd
        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd&quot;&gt;

    &lt;context:component-scan base-package=&quot;com.atguigu.spring.aopxml&quot;&gt;&lt;/context:component-scan&gt;
    
    &lt;!-- 以XML方式配置切面  --&gt;
    &lt;aop:config&gt;
        &lt;!-- 切面 --&gt;
        &lt;aop:aspect ref=&quot;myLogger&quot;&gt;
            &lt;!-- 前置通知 通知通过切入点表达式作用于连接点--&gt;
            &lt;!-- &lt;aop:before method=&quot;before&quot; pointcut=&quot;execution(* com.atguigu.spring.aopxml.*.*(..))&quot;/&gt; --&gt;
            
            &lt;aop:pointcut expression=&quot;execution(* com.atguigu.spring.aopxml.*.*(..))&quot; id=&quot;cut&quot;/&gt;
            &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;cut&quot;/&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
<p>6.Test.java(测试类)</p>
<pre><code>package com.atguigu.spring.aopxml;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test &#123;

    public static void main(String[] args) &#123;
        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;aop-xml.xml&quot;);
        MathI math = ac.getBean(&quot;mathImpl&quot;, MathI.class);
        int add = math.add(2, 2);
        System.out.println(add);
    &#125;

&#125;
</code></pre>
<p>7.运行结果</p>
<pre><code>前置通知
4
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>spring</category>
        <category>以XML方式配置切面</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>伪迹移除 | 伪迹去除方法比较总结</title>
    <url>/2021/02/25/%E4%BC%AA%E8%BF%B9%E5%8E%BB%E9%99%A4%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="伪迹去除方法比较总结"><a href="#伪迹去除方法比较总结" class="headerlink" title="伪迹去除方法比较总结"></a>伪迹去除方法比较总结</h1><p>1.(定性比较 or 定量比较)很难对不同伪迹去除方法基于它们去除伪迹的能力进行一个比较，通常只能做一个<b>定性(qualitative)</b>的比较<br>2.(自动 or 半自动)很多基于EEG的应用需要<b>自动信息处理</b>，尤其是一些对<b>在线/实时(需要效率很高的算法和足够低的计算复杂度)</b>有要求的应用。基于<b>BSS(盲源分离)</b>的方法通常是<b>半自动</b>的,因为伪迹成分的识别需要一些训练或参数选择/调整。涉及ICA的伪迹检测/去除方法需要另一个方法才能实现全过程的自动<br>3.(单通道 or 多通道)基于<b>盲源分离</b>的方法需要<b>多通道</b>才能起作用，通道数量越多，越能很好的分离出单个的源(这种方法不能用于低通道 e.g. 4-6或者基于单通道的应用)。基于<b>小波变换和经验模态分解</b>的方法可以通过将单个数据序列分解为多个成分进行<b>单通道</b>分析。<br>4.(参考信号)大多数方法需要参考信号。</p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>伪迹移除</category>
      </categories>
      <tags>
        <tag>伪迹移除</tag>
        <tag>EEG</tag>
      </tags>
  </entry>
  <entry>
    <title>使用ForkJoin框架计算整数相加的结果</title>
    <url>/2022/06/06/%E4%BD%BF%E7%94%A8ForkJoin%E6%A1%86%E6%9E%B6%E8%AE%A1%E7%AE%97%E6%95%B4%E6%95%B0%E7%9B%B8%E5%8A%A0%E7%9A%84%E7%BB%93%E6%9E%9C/</url>
    <content><![CDATA[<h1 id="使用ForkJoin框架计算整数相加的结果"><a href="#使用ForkJoin框架计算整数相加的结果" class="headerlink" title="使用ForkJoin框架计算整数相加的结果"></a>使用ForkJoin框架计算整数相加的结果</h1><p><strong>需求：</strong> 使用Fork/Join框架计算1+2+3+4的结果。<br><strong>分析：</strong> 使用Fork/Join框架首先要考虑到的是如何分割任务，如果希望每个子任务最多执行两个数的相加<br>，那么我们设置分割的阈值是2，由于是四个数字相加，所以Fork/Join框架会把这个任务fork成两个子<br>任务，子任务1负责计算1+2，子任务2负责3+4，然后再join两个子任务的结果。因为是有结果的任务，所<br>以必须继承RecursiveTask。<br><strong>实现代码：</strong></p>
<pre><code>package concurrency.forkjoin;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.Future;
import java.util.concurrent.RecursiveTask;

public class CountTask extends RecursiveTask&lt;Integer&gt;&#123;
    private static final int THRESHOLD = 2;//阈值
    private int start;
    private int end;
    
    public CountTask(int start, int end)&#123;
        this.start = start;
        this.end = end;
    &#125;

    @Override
    protected Integer compute() &#123;
        int sum = 0;
        
        //如果任务足够小就计算任务
        boolean canCompute = (end - start) &lt;= THRESHOLD;
        if(canCompute)&#123;
            for(int i = start; i &lt;= end; i++)&#123;
                sum += i;
            &#125;
        &#125;else&#123;
            //如果任务大虚与之，就分裂成两个子任务计算
            int middle = (start + end) / 2;
            CountTask leftTask = new CountTask(start, middle);
            CountTask rightTask = new CountTask(middle + 1, end);
            //执行子任务
            leftTask.fork();
            rightTask.fork();
            //等待子任务执行完，并得到其结果
            int leftResult = leftTask.join();
            int rightResult = rightTask.join();
            //合并子任务
            sum = leftResult + rightResult;
        &#125;
        return sum;
    &#125;
    
    public static void main(String[] args)&#123;
        ForkJoinPool forkJoinPool = new ForkJoinPool();
        //生成一个计算任务，负责计算1+2+3+4
        CountTask task = new CountTask(1, 4);
        //执行一个任务
        Future&lt;Integer&gt; result = forkJoinPool.submit(task);
        try&#123;
            System.out.println(result.get());
        &#125;catch(InterruptedException e)&#123;
            e.printStackTrace();
        &#125;catch(ExecutionException e)&#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>并发</category>
        <category>ForkJoin</category>
        <category>使用ForkJoin框架计算整数相加的结果</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>ForkJoin</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb项目开发 | 使用filter解决项目编码问题</title>
    <url>/2022/01/11/%E4%BD%BF%E7%94%A8filter%E8%A7%A3%E5%86%B3%E9%A1%B9%E7%9B%AE%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="使用filter解决项目编码问题"><a href="#使用filter解决项目编码问题" class="headerlink" title="使用filter解决项目编码问题"></a>使用filter解决项目编码问题</h1><p>在开发JavaWeb项目时，前端的编码使用的时utf-8编码方式，服务器端使用的是ISO-8859-1编码方式，故在开发中会出现乱码。</p>
<h2 id="解决方案（使用filter）"><a href="#解决方案（使用filter）" class="headerlink" title="解决方案（使用filter）"></a>解决方案（使用filter）</h2><p>实现EncodingFilter来解决项目乱码问题</p>
<p><strong>乱码情形举例：</strong></p>
<ol>
<li>写一个b.html文件</li>
</ol>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;a href=&quot;/filtertest/demox?username=张三&quot;&gt;向服务器发送请求&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="2">
<li>再写一个servlet处理请求</li>
</ol>
<pre><code>package com.oracle.servlet;

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class DemoxServlet extends HttpServlet &#123;
    private static final long serialVersionUID = 1L;

    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        String username = request.getParameter(&quot;username&quot;);
        System.out.println(username);
        
        response.getWriter().println(&quot;王五&quot;);
    &#125;

    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        doGet(request, response);
    &#125;
&#125;
</code></pre>
<ol start="3">
<li>servlet写到浏览器的内容和servlet从浏览器接收到的请求数据会出现乱码<br><img src="/2022/01/11/%E4%BD%BF%E7%94%A8filter%E8%A7%A3%E5%86%B3%E9%A1%B9%E7%9B%AE%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/1.PNG"><br><img src="/2022/01/11/%E4%BD%BF%E7%94%A8filter%E8%A7%A3%E5%86%B3%E9%A1%B9%E7%9B%AE%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/2.PNG"></li>
</ol>
<p><strong>EncodingFilter:</strong></p>
<pre><code>package com.oracle.filter;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.Map;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletRequestWrapper;
import javax.servlet.http.HttpServletResponse;
/**
 * 统一编码
 * @author Administrator
 *
 */
public class EncodingFilter implements Filter &#123;

    @Override
    public void init(FilterConfig filterConfig) throws ServletException &#123;
        // TODO Auto-generated method stub

    &#125;

    @Override
    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException &#123;
        //1.强转
        HttpServletRequest request=(HttpServletRequest) req;
        HttpServletResponse response=(HttpServletResponse) resp;
        response.setContentType(&quot;text/html;charset=utf-8&quot;);
        //2.放行
        chain.doFilter(new MyRequest(request), response);
    &#125;

    @Override
    public void destroy() &#123;
        // TODO Auto-generated method stub

    &#125;

&#125;
class MyRequest extends HttpServletRequestWrapper&#123;
    private HttpServletRequest request;
    private boolean flag=true;
    
    
    public MyRequest(HttpServletRequest request) &#123;
        super(request);
        this.request=request;
    &#125;
    
    @Override
    public String getParameter(String name) &#123;  
        if(name==null || name.trim().length()==0)&#123;
            return null;
        &#125;
        String[] values = getParameterValues(name);
        if(values==null || values.length==0)&#123;
            return null;
        &#125;
        
        return values[0];
    &#125;
    
    @Override
    /**
     * hobby=[eat,drink]
     */
    public String[] getParameterValues(String name) &#123;
        if(name==null || name.trim().length()==0)&#123;
            return null;
        &#125;
        Map&lt;String, String[]&gt; map = getParameterMap();
        if(map==null || map.size()==0)&#123;
            return null;
        &#125;
        
        return map.get(name);
    &#125;
    
    @Override
    /**
     * map&#123; username=[tom],password=[123],hobby=[eat,drink]&#125;
     */
    public Map&lt;String,String[]&gt; getParameterMap() &#123;  
        
        /**
         * 首先判断请求方式
         * 若为post  request.setchar...(utf-8)
         * 若为get 将map中的值遍历编码就可以了
         */
        String method = request.getMethod();
        if(&quot;post&quot;.equalsIgnoreCase(method))&#123;
            try &#123;
                request.setCharacterEncoding(&quot;utf-8&quot;);
                return request.getParameterMap();
            &#125; catch (UnsupportedEncodingException e) &#123;
                // TODO Auto-generated catch block
                e.printStackTrace();
            &#125;
        &#125;else if(&quot;get&quot;.equalsIgnoreCase(method))&#123;
            Map&lt;String,String[]&gt; map = request.getParameterMap();
            if(flag)&#123;
                for (String key:map.keySet()) &#123;
                    String[] arr = map.get(key);
                    //继续遍历数组
                    for(int i=0;i&lt;arr.length;i++)&#123;
                        //编码
                        try &#123;
                            arr[i]=new String(arr[i].getBytes(&quot;iso8859-1&quot;),&quot;utf-8&quot;);
                        &#125; catch (UnsupportedEncodingException e) &#123;
                            e.printStackTrace();
                        &#125;
                    &#125;
                &#125;
                flag=false;
            &#125;
            //需要遍历map 修改value的每一个数据的编码
            
            return map;
        &#125;
        
        return super.getParameterMap();
    &#125;
    
&#125;
</code></pre>
<p><strong>配置web.xml文件:</strong></p>
<pre><code>&lt;!-- 配置项目编码 --&gt;
  &lt;filter&gt;
    &lt;filter-name&gt;EncodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;com.oracle.filter.EncodingFilter&lt;/filter-class&gt;
  &lt;/filter&gt;
  &lt;filter-mapping&gt;
    &lt;filter-name&gt;EncodingFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb项目开发</category>
        <category>filter</category>
        <category>filter解决项目编码问题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>filter</tag>
        <tag>解决项目编码问题</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb项目开发 | 使用jsp查询所有商品案例实现</title>
    <url>/2022/01/11/%E4%BD%BF%E7%94%A8jsp%E6%9F%A5%E8%AF%A2%E6%89%80%E6%9C%89%E5%95%86%E5%93%81%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="使用jsp查询所有商品案例实现"><a href="#使用jsp查询所有商品案例实现" class="headerlink" title="使用jsp查询所有商品案例实现"></a>使用jsp查询所有商品案例实现</h1><ol>
<li>创建表product<br><img src="/2022/01/11/%E4%BD%BF%E7%94%A8jsp%E6%9F%A5%E8%AF%A2%E6%89%80%E6%9C%89%E5%95%86%E5%93%81%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0/1.PNG"></li>
<li>项目目录(按下图导入jar包、c3p0-config.xml)<br><img src="/2022/01/11/%E4%BD%BF%E7%94%A8jsp%E6%9F%A5%E8%AF%A2%E6%89%80%E6%9C%89%E5%95%86%E5%93%81%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0/2.PNG"></li>
<li>创建jsp页面<span id="more"></span>


</li>
</ol>
<pre><code>&lt;%@page import=&quot;com.oracle.bean.Product&quot;%&gt;
&lt;%@page import=&quot;java.util.ArrayList&quot;%&gt;
&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;a href=&quot;/jsptest/product&quot;&gt;点击查看商品&lt;/a&gt;
    
    &lt;hr&gt;
    
    &lt;%
        ArrayList&lt;Product&gt; arr = (ArrayList&lt;Product&gt;)request.getAttribute(&quot;list&quot;);
    %&gt;
    
    &lt;table border=&quot;1px&quot; width=&quot;60%&quot; height=&quot;200px&quot; align=&quot;center&quot;&gt;
        &lt;tr&gt;
            &lt;th&gt;商品的id&lt;/th&gt;
            &lt;th&gt;商品的名称&lt;/th&gt;
            &lt;th&gt;商品的价格&lt;/th&gt;
            &lt;th&gt;商品的描述&lt;/th&gt;
        &lt;/tr&gt;
        &lt;%
        if(arr!=null)&#123;
            for(Product p: arr)&#123;
            %&gt;
            &lt;tr&gt;
                &lt;td&gt;&lt;%=p.getId() %&gt;&lt;/td&gt;
                &lt;td&gt;&lt;%=p.getPname() %&gt;&lt;/td&gt;
                &lt;td&gt;&lt;%=p.getPrice() %&gt;&lt;/td&gt;
                &lt;td&gt;&lt;%=p.getPdesc() %&gt;&lt;/td&gt;
            &lt;/tr&gt;
            &lt;% 
            &#125;
        &#125;
        %&gt;
    &lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="4">
<li>创建product bean Product.java</li>
</ol>
<pre><code>package com.oracle.bean;

public class Product &#123;
    private int id;
    private String pname;
    private double price;
    private String pdesc;
    public Product(int id, String pname, double price, String pdesc) &#123;
        super();
        this.id = id;
        this.pname = pname;
        this.price = price;
        this.pdesc = pdesc;
    &#125;
    public Product() &#123;
        super();
        // TODO Auto-generated constructor stub
    &#125;
    public int getId() &#123;
        return id;
    &#125;
    public void setId(int id) &#123;
        this.id = id;
    &#125;
    public String getPname() &#123;
        return pname;
    &#125;
    public void setPname(String pname) &#123;
        this.pname = pname;
    &#125;
    public double getPrice() &#123;
        return price;
    &#125;
    public void setPrice(double price) &#123;
        this.price = price;
    &#125;
    public String getPdesc() &#123;
        return pdesc;
    &#125;
    public void setPdesc(String pdesc) &#123;
        this.pdesc = pdesc;
    &#125;
&#125;
</code></pre>
<ol start="5">
<li>创建ProductServlet</li>
</ol>
<pre><code>package com.oracle;

import java.util.List;
import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.dbutils.QueryRunner;
import org.apache.commons.dbutils.handlers.BeanListHandler;

import com.oracle.bean.Product;
import com.oracle.utils.DataSourceUtils;

public class ProductServlet extends HttpServlet &#123;
    private static final long serialVersionUID = 1L;

    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        try &#123;
            //查询数据库当中的所有数据
            QueryRunner qr = new QueryRunner(DataSourceUtils.getDataSource());
            
            String sql = &quot;select * from product&quot;;
            
            List&lt;Product&gt; list = qr.query(sql, new BeanListHandler&lt;&gt;(Product.class));
            
            //把list放入域对象中
            request.setAttribute(&quot;list&quot;, list);
            
            //请求转发到aa.jsp中
            request.getRequestDispatcher(&quot;/aa.jsp&quot;).forward(request, response);
            
        &#125; catch (Exception e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125;
    &#125;

    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        doGet(request, response);
    &#125;
&#125;
</code></pre>
<ol start="6">
<li>效果<br>访问aa.jsp页面：<br><img src="/2022/01/11/%E4%BD%BF%E7%94%A8jsp%E6%9F%A5%E8%AF%A2%E6%89%80%E6%9C%89%E5%95%86%E5%93%81%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0/3.PNG"><br>点击超链接查询商品：<br><img src="/2022/01/11/%E4%BD%BF%E7%94%A8jsp%E6%9F%A5%E8%AF%A2%E6%89%80%E6%9C%89%E5%95%86%E5%93%81%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0/4.PNG"></li>
</ol>
<p>注：项目编码问题的解决参考本博客的<a href="https://victory-liao.github.io/categories/Java/JavaWeb%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/filter/filter%E8%A7%A3%E5%86%B3%E9%A1%B9%E7%9B%AE%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/">使用filter解决项目编码问题一文</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb项目开发</category>
        <category>jsp</category>
        <category>使用jsp查询所有商品案例实现</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>jsp</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程 | 使用tftp从服务器下载文件到客户端</title>
    <url>/2020/10/18/%E4%BD%BF%E7%94%A8tftp%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E5%88%B0%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
    <content><![CDATA[<h1 id="使用tftp协议从服务器下载文件到客户端"><a href="#使用tftp协议从服务器下载文件到客户端" class="headerlink" title="使用tftp协议从服务器下载文件到客户端"></a>使用tftp协议从服务器下载文件到客户端</h1><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code>import struct
from socket import *
import time
import os

def main():


    #0. 获取要下载的文件名字:
    downloadFileName = raw_input(&quot;请输入要下载的文件名:&quot;)    

    #1.创建socket
    udpSocket = socket(AF_INET, SOCK_DGRAM)

    requestFileData = struct.pack(&quot;!H%dsb5sb&quot;%len(downloadFileName), 1, downloadFileName, 0, &quot;octet&quot;, 0)

    #2. 发送下载文件的请求
    udpSocket.sendto(requestFileData, (&quot;192.168.119.215&quot;, 69))

    flag = True #表示能够下载数据，即不擅长，如果是false那么就删除
    num = 0
    f = open(downloadFileName, &quot;w&quot;)

    while True:
        #3. 接收服务发送回来的应答数据
        responseData = udpSocket.recvfrom(1024)

        # print(responseData)
        recvData, serverInfo = responseData

        opNum = struct.unpack(&quot;!H&quot;, recvData[:2])

        packetNum = struct.unpack(&quot;!H&quot;, recvData[2:4])

        print(packetNum[0])

        # print(&quot;opNum=%d&quot;%opNum)
        # print(opNum)

        # if 如果服务器发送过来的是文件的内容的话:
        if opNum[0] == 3: #因为opNum此时是一个元组(3,)，所以需要使用下标来提取某个数据
            

            #计算出这次应该接收到的文件的序号值，应该是上一次接收到的值的基础上+1
            num = num + 1

            # 如果一个下载的文件特别大，即接收到的数据包编号超过了2个字节的大小
            # 那么会从0继续开始，所以这里需要判断，如果超过了65535 那么就改为0
            if num==65536:
                num = 0

            # 判断这次接收到的数据的包编号是否是 上一次的包编号的下一个
            # 如果是才会写入到文件中，否则不能写入（因为会重复）
            if num == packetNum[0]:
                # 把收到的数据写入到文件中
                f.write(recvData[4:])
                num = packetNum[0]

            #整理ACK的数据包
            ackData = struct.pack(&quot;!HH&quot;, 4, packetNum[0])
            udpSocket.sendto(ackData, serverInfo)

        elif opNum[0] == 5:
            print(&quot;sorry，没有这个文件....&quot;)
            flag = False

        # time.sleep(0.1)

        if len(recvData)&lt;516:
            break

    if flag == True:
        f.close()
    else:
        os.unlink(downloadFileName)#如果没有要下载的文件，那么就需要把刚刚创建的文件进行删除

if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>tftp</tag>
      </tags>
  </entry>
  <entry>
    <title>spring | 使用注解配置bean</title>
    <url>/2022/03/06/%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AEbean/</url>
    <content><![CDATA[<h1 id="使用注解配置bean"><a href="#使用注解配置bean" class="headerlink" title="使用注解配置bean"></a>使用注解配置bean</h1><p>1.项目目录<br><img src="/2022/03/06/%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AEbean/1.PNG"></p>
<p>2.UserController.java</p>
<pre><code>package com.atguigu.ioc.userMod.controller;

import org.springframework.stereotype.Controller;

@Controller
public class UserController &#123;

    public UserController() &#123;
        System.out.println(&quot;UserController&quot;);
    &#125;
    
&#125;
</code></pre>
<p>3.UserDao.java</p>
<pre><code>package com.atguigu.ioc.userMod.dao;

public interface UserDao &#123;

&#125;
</code></pre>
<p>4.UserDaoImpl.java(UserDao接口的实现类)</p>
<pre><code>package com.atguigu.ioc.userMod.dao;

import org.springframework.stereotype.Repository;

@Repository
public class UserDaoImpl implements UserDao&#123;
    public UserDaoImpl()&#123;
        System.out.println(&quot;UserDaoImpl&quot;);
    &#125;
&#125;
</code></pre>
<p>5.UserService.java</p>
<pre><code>package com.atguigu.ioc.userMod.service;

public interface UserService &#123;

&#125;
</code></pre>
<p>6.UserServiceImpl.java(UserService接口的实现类)</p>
<pre><code>package com.atguigu.ioc.userMod.service;

import org.springframework.stereotype.Service;

@Service
public class UserServiceImpl implements UserService&#123;

    public UserServiceImpl() &#123;
        System.out.println(&quot;UserServiceImpl&quot;);
    &#125;

&#125;
</code></pre>
<p>7.user.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&gt;
    
    &lt;!-- 
        &lt;context:component-scan&gt;:扫描组件，对设置的包下面的类进行扫描，会将加上注解的类作为spring的组件进行加载
        组件：指spring中管理的bean
        作为spring的组件进行加载：会自动在spring的配置文件中生成相对应的bean，这些bean的id会以类的首字母小写为值
        
        &lt;context:include-filter&gt;:在设定的包结构下再次通过注解或类型具体包含到某个或某几个类
        注意：在使用包含时，一定要设置use-default-filters=&quot;false&quot;，将默认（即扫描包下所有的类）的过滤关闭
        
        &lt;context:exclude-filter&gt;:在设定的包结构下，再次通过注解或类型具体排除某个或某几个类
        注意：在使用排除时，一定要设置use-default-filters=&quot;true&quot;，将默认（即扫描包下所有的类）的过滤打开
        
        切记：一个&lt;context:component-scan&gt;中可以出现多个include，也可以同时出现多个exclude，但是两个不能同时出现
     --&gt;
    &lt;context:component-scan base-package=&quot;com.atguigu.ioc.userMod&quot; use-default-filters=&quot;true&quot;&gt;
        &lt;!-- &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; --&gt;
        &lt;!-- &lt;context:include-filter type=&quot;assignable&quot; expression=&quot;com.atguigu.ioc.userMod.service.UserServiceImpl&quot;/&gt; --&gt;
        &lt;!-- &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Repository&quot;/&gt; --&gt;
        &lt;!-- &lt;context:exclude-filter type=&quot;assignable&quot; expression=&quot;com.atguigu.ioc.userMod.dao.UserDaoImpl&quot;/&gt; --&gt;
    &lt;/context:component-scan&gt;
    
    &lt;!-- &lt;bean id=&quot;userController&quot; class=&quot;com.atguigu.ioc.userMod.controller.UserController&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;userServiceImpl&quot; class=&quot;com.atguigu.ioc.userMod.service.UserServiceImpl&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;userDaoImpl&quot; class=&quot;com.atguigu.ioc.userMod.dao.UserDaoImpl&quot;&gt;&lt;/bean&gt; --&gt;
&lt;/beans&gt;
</code></pre>
<p>8.Test.java</p>
<pre><code>package com.atguigu.ioc.userMod;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import com.atguigu.ioc.userMod.controller.UserController;
import com.atguigu.ioc.userMod.dao.UserDao;
import com.atguigu.ioc.userMod.dao.UserDaoImpl;
import com.atguigu.ioc.userMod.service.UserService;
import com.atguigu.ioc.userMod.service.UserServiceImpl;

public class Test &#123;
    public static void main(String[] args) &#123;
        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;user.xml&quot;);
        
        UserController uc = ac.getBean(&quot;userController&quot;, UserController.class);
        System.out.println(uc);//com.atguigu.ioc.userMod.controller.UserController@4b553d26
        
        UserService us = ac.getBean(&quot;userServiceImpl&quot;, UserServiceImpl.class);
        System.out.println(us);//com.atguigu.ioc.userMod.service.UserServiceImpl@69a3d1d
        
        UserDao ud = ac.getBean(&quot;userDaoImpl&quot;, UserDaoImpl.class);
        System.out.println(ud);//com.atguigu.ioc.userMod.dao.UserDaoImpl@86be70a
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>spring</category>
        <category>使用注解配置bean</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>openpyxl | 修改excel表中的单元格内容</title>
    <url>/2021/10/16/%E4%BF%AE%E6%94%B9excel%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%8D%95%E5%85%83%E6%A0%BC%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<h1 id="修改excel表中的单元格内容"><a href="#修改excel表中的单元格内容" class="headerlink" title="修改excel表中的单元格内容"></a>修改excel表中的单元格内容</h1><p>以下代码实现了修改 领料单（每日）.xlsx 中的所有表中某单元格的内容。</p>
<span id="more"></span>

<pre><code>from openpyxl import load_workbook

wb = load_workbook(&quot;领料单（每日）.xlsx&quot;)
print(wb.sheetnames)

for sheet_name in wb.sheetnames:  # 遍历每个工作表，更改A4单元格的数据
    print(sheet_name)
    ws = wb[sheet_name]
    ws[&#39;A4&#39;].value = &quot;零件测试领料单&quot; #直接将A4单元格的值改为需要的

wb.save(&quot;资料单（每日）-更改后.xlsx&quot;)
</code></pre>
<p><a href="https://blog.csdn.net/weixin_41546513/article/details/109555832">openpyxl参考资料</a><br><a href="https://openpyxl.readthedocs.io/en/stable/index.html">openpyxl官方文档</a><br><a href="领料单（每日）.xlsx">下载领料单（每日）.xlsx</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>openpyxl</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>openpyxl</tag>
      </tags>
  </entry>
  <entry>
    <title>python | 偏函数</title>
    <url>/2021/11/07/%E5%81%8F%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h1><p><strong>作用：</strong> 通过设定参数的默认值，降低函数调用的难度<br>函数在执行时，要带上所有必要的参数进行调用。但是，有时参数可以在函数被调用之前提前获知。这种情况下，一个函数有一个或多个参数预先就能用上，以便函数能用更少的参数进行调用。<br>偏函数是将所要承载的函数作为partial()函数的第一个参数，原函数的各个参数依次作为partial()函数后续的参数，除非使用关键字参数。</p>
<span id="more"></span>
<p><strong>示例1：</strong></p>
<h2 id="一般函数调用"><a href="#一般函数调用" class="headerlink" title="一般函数调用"></a>一般函数调用</h2><pre><code>def student_info(name, age, city):
    print(f&#39;我的名字叫&#123;name&#125;, 今年&#123;age&#125;岁，来自&#123;city&#125;&#39;)

student_info(&#39;Molly&#39;,18,&#39;北京&#39;)
</code></pre>
<h2 id="带关键字参数函数的调用"><a href="#带关键字参数函数的调用" class="headerlink" title="带关键字参数函数的调用"></a>带关键字参数函数的调用</h2><pre><code>def student_info(name, age, city=&#39;北京&#39;):
    print(f&#39;我的名字叫&#123;name&#125;, 今年&#123;age&#125;岁，来自&#123;city&#125;&#39;)

student_info(&#39;Molly&#39;,18)
</code></pre>
<h2 id="使用偏函数"><a href="#使用偏函数" class="headerlink" title="使用偏函数"></a>使用偏函数</h2><pre><code>from functools import partial

def student_info(name, age, city):
    print(f&#39;我的名字叫&#123;name&#125;, 今年&#123;age&#125;岁，来自&#123;city&#125;&#39;)

student_info_beijing = partial(student_info, city=&#39;北京&#39;)

student_info_beijing(&#39;Molly&#39;,18)

student_info_beijing(&#39;Molly&#39;,18, city=&#39;上海&#39;)
</code></pre>
<p><strong>示例2：</strong></p>
<pre><code>def add_xy(x,y):
    return x+y

add_100 = partial(add_xy, y=100)

add_100(10)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
        <category>偏函数</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>偏函数</tag>
      </tags>
  </entry>
  <entry>
    <title>免费看视频</title>
    <url>/2021/06/19/%E5%85%8D%E8%B4%B9%E7%9C%8B%E8%A7%86%E9%A2%91/</url>
    <content><![CDATA[<h1 id="免费看视频"><a href="#免费看视频" class="headerlink" title="免费看视频"></a>免费看视频</h1><p><b>在视频链接前加wn.run/</b></p>
]]></content>
      <tags>
        <tag>免费看视频</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 关于python or numpy在实现神经网络中的一些建议</title>
    <url>/2021/06/21/%E5%85%B3%E4%BA%8Epython-or-numpy%E5%9C%A8%E5%AE%9E%E7%8E%B0%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BB%BA%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="关于python-or-numpy在实现神经网络中的一些建议"><a href="#关于python-or-numpy在实现神经网络中的一些建议" class="headerlink" title="关于python or numpy在实现神经网络中的一些建议"></a>关于python or numpy在实现神经网络中的一些建议</h1><p>在编写神经网络时：<br>1.不要使用秩为1的一维数组<br>2.总是使用n x 1维矩阵(列向量-column vector)或者1 X n维矩阵(行向量-row vector)<br>3.敢于使用reshape()来确保你的矩阵或向量所需要的维数<br>4.在不完全确定一个向量的维维度时使用assert()语句<br>（Python assert（断言）用于判断一个表达式，在表达式条件为 false 的时候触发异常。<br>断言可以在条件不满足程序运行的情况下直接返回错误，而不必等待程序运行后出现崩溃的情况。）</p>
<p><b>demo:</b></p>
<pre><code>a = np.random.randn(5) # Don&#39;t use
# a.shape = (5,) # rank 1 array

a = np.random.randn(5,1) # a.shape=(5,1) column vector

a = np.random.randn(1,5) # a.shape=(1,5) row vector

assert(a.shape == (5,1))

a = a.reshape((5,1))
</code></pre>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>写论文神器</title>
    <url>/2021/12/16/%E5%86%99%E8%AE%BA%E6%96%87%E7%A5%9E%E5%99%A8/</url>
    <content><![CDATA[<h1 id="写论文神器-CTeX"><a href="#写论文神器-CTeX" class="headerlink" title="写论文神器-CTeX"></a>写论文神器-CTeX</h1><p><a href="http://www.ctex.org/CTeX">CTeX下载地址</a></p>
<p><a href="https://zhiqianghe.blog.csdn.net/article/details/102978653?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link">CTeX安装教程</a></p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>CTeX写论文神器</category>
      </categories>
      <tags>
        <tag>CTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习 | 决策树</title>
    <url>/2021/02/22/%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    <content><![CDATA[<h1 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h1><p>决策树(Decision Tree)是一种基本的<b>分类与回归方法</b>。决策树由结点(Node)和有向边(Directed Edge)组成。结点有两种类型：内部结点(Internnal Node)和叶结点(Leaf Node)。内部结点表示一个特征或属性，叶结点表示一个类。决策树还有一个唯一的根结点(Root Node)。</p>
<p>我们可以把<b>决策树</b>看成一个<b>if-then规则的集合</b>,将决策树转换成if-then规则的过程是这样的：<br><br>由决策树的根结点到叶结点的每一条路径构建一条规则；路径上内部结点的特征对应着规则的条件，而叶结点对应着规则的结论。<br><br>决策树的路径或其对应的if-then规则集合具有一个重要性质：<b>互斥并且完备</b>(每一个实例都只能被一条路径或一条规则所覆盖(覆盖：实例的特征与路径上的特征一致或实例满足规则的条件))。<br></p>
<h2 id="决策树做预测的步骤"><a href="#决策树做预测的步骤" class="headerlink" title="决策树做预测的步骤"></a>决策树做预测的步骤</h2><p>1.收集数据<br>2.准备数据(将收集的数据按照一定规则整理出来,方便后续进行处理)<br>3.分析数据(在决策树构造完成后，检查决策树图形是否符合预期)<br>4.训练算法(构造决策树/决策树学习—&gt;构造一个决策树的数据结构)<br>5.测试算法(使用经验树计算错误率。当错误率达到可接受范围，这个决策树就可以投放使用)<br>6.使用算法(<b>决策树可以更好地理解数据的内在含义</b>)</p>
<h2 id="如何构建决策树？—构建决策树的3个步骤"><a href="#如何构建决策树？—构建决策树的3个步骤" class="headerlink" title="如何构建决策树？—构建决策树的3个步骤"></a>如何构建决策树？—构建决策树的3个步骤</h2><h3 id="1-特征选择"><a href="#1-特征选择" class="headerlink" title="1.特征选择"></a>1.特征选择</h3><p><b>特征选择就是决定用哪个特征来划分特征空间</b><br><b>特征选择在于选取训练数据具有分类能力的特征</b><br>特征选择的标准：信息增益(Information Gain)/信息增益比。信息增益：在划分数据集之后信息发生的变化。<br><b style="color:red">Note:信息增益最高的特征是最好的选择</b></p>
<h4 id="1-1香农熵-熵-信息论之父克劳德-香农：集合信息的度量方式。"><a href="#1-1香农熵-熵-信息论之父克劳德-香农：集合信息的度量方式。" class="headerlink" title="1.1香农熵(熵)-信息论之父克劳德.香农：集合信息的度量方式。"></a>1.1香农熵(熵)-信息论之父克劳德.香农：集合信息的度量方式。</h4><p>熵定义为信息的期望值。在信息论与概率论中，熵是表示随机变脸不确定性的度量。如果待分类的事物可能划分在多个分类之中，则符号xi的信息定义为：<br><br><img src="/2021/02/22/%E5%86%B3%E7%AD%96%E6%A0%91/1.png"><br>其中p(xi)是该分类的概率。<br><br>通过上式，我们可以得到所有类别的信息。为了计算<b>熵，我们需要计算所有类别所有可能值包含的信息期望值</b>(<b>数学期望-反应随机变量平均取值的大小<b>)，公式如下：<br><br><img src="/2021/02/22/%E5%86%B3%E7%AD%96%E6%A0%91/2.png"><br>其中n是分类的数目。<b>熵越大，随机变量的不确定性就越大。</b></b></b></p>
<p>当熵中的概率由数据估计(特别是最大似然估计-Maximum Likelihood Estimation)得到时，所对应的熵称为<b>经验熵</b>(Empirical Entropy)</p>
<p>我们定义样本数据表中的数据为训练数据集D，则训练数据集D的经验熵为H(D)，|D|表示其样本容量，及样本个数。设有K个类Ck, = 1,2,3,…,K,|Ck|为属于类Ck的样本个数，因此经验熵公式就可以写为 ：<br><img src="/2021/02/22/%E5%86%B3%E7%AD%96%E6%A0%91/3.png"></p>
<h4 id="1-2信息增益"><a href="#1-2信息增益" class="headerlink" title="1.2信息增益"></a>1.2信息增益</h4><p>如何选择特征，需要看信息增益。也就是说，信息增益是相对特征而言的，信息增益越大，特征对最终的分类结果影响也就越大，我们就应该选择对最终分类结果影响最大的那个特征作为我们的分类特征。</p>
<p><b>条件熵H(Y|X)</b>表示在一直随机变量X的条件下随机变量Y的不确定性，随机变量X给定条件下随机变量Y的条件熵(Conditional Entropy)H(Y|X)，定义为X给定条件下Y的条件概率分布的熵对X的数学期望：<br><img src="/2021/02/22/%E5%86%B3%E7%AD%96%E6%A0%91/4.jpg"><br><img src="/2021/02/22/%E5%86%B3%E7%AD%96%E6%A0%91/5.jpg"><br>当条件熵中的概率由数据估计(特别是极大似然估计)得到时，岁对应的条件熵称为<b>条件经验熵</b>(empirical conditional entropy)。</p>
<p>特征A对训练数据集D的信息增益g(D,A)，定义为集合D的经验熵H(D)与特征A给定条件下D的经验条件熵H(D|A)之差，即：<br><img src="/2021/02/22/%E5%86%B3%E7%AD%96%E6%A0%91/6.jpg"><br><b>Note:</b>一般地，熵H(D)与条件熵H(D|A)之差称为互信息(mutual information)。决策树学习中的信息增益等价于训练数据集中类与特征的互信息。</p>
<p>设特征A有n个不同的取值{a1,a2,···,an}，根据特征A的取值将D划分为n个子集{D1,D2，···,Dn}，|Di|为Di的样本个数。记子集Di中属于Ck的样本的集合为Dik，即Dik = Di ∩ Ck，|Dik|为Dik的样本个数。于是经验条件熵的公式可以些为：<br><img src="/2021/02/22/%E5%86%B3%E7%AD%96%E6%A0%91/7.jpg"></p>
<h2>总结</h2>
<h3>决策树的一些优点</h3>
1.<b>易于理解和解释</b>。决策树可以<b>可视化</b>。<br>
2.<b>几乎不需要数据预处理</b>。其他方法经常需要数据标准化，创建虚拟变量和删除缺失值。决策树还不支持缺失值。<br>
3.使用树的<b>花费</b>(例如预测数据)是训练数据点(data points)数量的<b>对数</b>。<br>
4.可以<b>同时处理数值变量和分类变量</b>。其他方法大都适用于分析一种变量的集合。<br>
5.可以处理<b>多值输出</b>变量问题<br>
6.使用<b>白盒模型</b>.如果一个情况被观察到，使用逻辑判断容易表示这种规则。相反，如果是<b>黑盒模型</b>(例如<b>人工神经网络</b>)，结果会非常<b>难解释</b>。<br>
7.即使对真实模型来说，假设无效的情况下，也可以较好的使用<br>
<h3>决策树的一些缺点</h3>
1.决策树学习可能创建一个过于复杂的树，并不能很好的预测数据。也就是<b>过拟合</b>。修剪机制（现在不支持），<b>设置一个叶子节点需要的最小样本数量，或者数的最大深度，可以避免过拟合</b>。<br>
2.<b>决策树可能是不稳定的</b>，因为即使非常小的变异，可能会产生一颗完全不同的树。这个问题通过decision trees with an ensemble来缓解。<br>
3.<b>概念难以学习</b>，因为决策树没有很好的解释他们，例如，XOR, parity or multiplexer problems(奇偶校验或多路复用器问题)。<br>
4.<b>如果某些分类占优势，决策树将会创建一棵有偏差的树</b>。因此，建议在训练之前，先抽样使样本均衡。<br>

<p><a href="https://cuijiahua.com/blog/2017/11/ml_2_decision_tree_1.html">参考资源1</a><br><a href="https://cuijiahua.com/blog/2017/11/ml_3_decision_tree_2.html">参考资源2</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>Decision Tree</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>决策树</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程 | 几种web服务器的比较</title>
    <url>/2020/10/31/%E5%87%A0%E7%A7%8Dweb%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<h1 id="几种web服务器的比较"><a href="#几种web服务器的比较" class="headerlink" title="几种web服务器的比较"></a>几种web服务器的比较</h1><h2 id="select版服务器"><a href="#select版服务器" class="headerlink" title="select版服务器"></a>select版服务器</h2><p>优点：跨平台<br>缺点：<br>单个进程能够监视的文件描述符的数量存在最大限制（1024）<br>轮询检测，效率较低</p>
<h2 id="poll版服务器"><a href="#poll版服务器" class="headerlink" title="poll版服务器"></a>poll版服务器</h2><p>优点：解决了套接字有上限的问题<br>缺点：轮询检测</p>
<h2 id="epoll版服务器"><a href="#epoll版服务器" class="headerlink" title="epoll版服务器"></a>epoll版服务器</h2><p>优点：<br>没有1024的最大限制<br>事件通知机制，效率较高</p>
]]></content>
      <categories>
        <category>python</category>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>python | 函数</title>
    <url>/2021/08/05/%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="python中的函数"><a href="#python中的函数" class="headerlink" title="python中的函数"></a>python中的函数</h1><p>python中的三种函数<br>1.函数：定义在模块中类之外的函数<br><strong>示例：</strong></p>
<pre><code>def add(a, b):
    res = a + b
    return res
</code></pre>
<p>2.嵌套函数：定义在函数中的函数<br><strong>示例：</strong></p>
<pre><code>def func1():
    def func2():
        pass
    ...
</code></pre>
<p>3.方法：定义在类中<br><strong>示例：</strong></p>
<pre><code>class A(object)：
    def _ _init_ _(self):   # 构造函数
        pass

    def a(self,...):   # 实例方法
        pass
    
    @classmethod
    def b(cls,...):  # 类方法
        pass
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis | 分步查询、分步查询延迟加载</title>
    <url>/2022/04/05/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2%E3%80%81%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="分步查询、分步查询延迟加载"><a href="#分步查询、分步查询延迟加载" class="headerlink" title="分步查询、分步查询延迟加载"></a>分步查询、分步查询延迟加载</h1><p>项目目录<br><img src="/2022/04/05/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2%E3%80%81%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD/1.PNG"><br>1.mybatis-config.xml<br>分步查询延迟加载需要在MyBatis核心配置文件中做以下配置：</p>
<pre><code>&lt;settings&gt;
    &lt;!-- 开启延迟加载 --&gt;
    &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;&gt;&lt;/setting&gt;
    &lt;!-- 是否查询所有数据 --&gt;
    &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;&gt;&lt;/setting&gt;
&lt;/settings&gt;
</code></pre>
<p>2.DeptMapper.java</p>
<pre><code>public interface DeptMapper &#123;
    Dept getDeptByDid(String did);
&#125;
</code></pre>
<p>3.DeptMapper.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
 PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
 &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
 
&lt;mapper namespace=&quot;com.atguigu.mapper.DeptMapper&quot;&gt;
    &lt;select id=&quot;getDeptByDid&quot; resultType=&quot;Dept&quot;&gt;
        select did,dname from dept where did=#&#123;did&#125;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p>4.EmpDeptMapper.java</p>
<pre><code>public interface EmpDeptMapper &#123;
    List&lt;Emp&gt; getAllEmp();
    
    Emp getEmpStep(String eid);//分步查询
&#125;
</code></pre>
<p>5.EmpDeptMapper.xml<br>添加查询语句</p>
<pre><code>&lt;resultMap type=&quot;Emp&quot; id=&quot;empMapStep&quot;&gt;
    &lt;id column=&quot;eid&quot; property=&quot;eid&quot;/&gt;
    &lt;result column=&quot;ename&quot; property=&quot;ename&quot;/&gt;
    &lt;result column=&quot;age&quot; property=&quot;age&quot;/&gt;
    &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;
    &lt;!--
        select:分步查询的SQL的id，即接口全限定名.方法名或者namespace.SQL的id
        column:分步查询的条件，注意：此条件必须是从数据库查询过的 
     --&gt;
    &lt;association property=&quot;dept&quot; select=&quot;com.atguigu.mapper.DeptMapper.getDeptByDid&quot; column=&quot;did&quot;&gt;&lt;/association&gt;
&lt;/resultMap&gt;

&lt;!-- Emp getEmpStep(String eid); --&gt;
&lt;select id=&quot;getEmpStep&quot; resultMap=&quot;empMapStep&quot;&gt;
    select eid,ename,age,sex,did from emp where eid = #&#123;eid&#125;
&lt;/select&gt;
</code></pre>
<p>6.TestEmpDept.java</p>
<pre><code>public class TestEmpDept &#123;
    public static void main(String[] args) throws IOException &#123;
        InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
        SqlSession sqlSession = sqlSessionFactory.openSession(true);
        EmpDeptMapper mapper = sqlSession.getMapper(EmpDeptMapper.class);
        
        Emp emp = mapper.getEmpStep(&quot;3&quot;);
        System.out.println(emp.getEname());
        System.out.println(emp.getDept());
    &#125;
&#125;
</code></pre>
<p>7.运行结果<br>执行emp.getEname()运行结果为前四行<br>再执行emp.getDept()运行结果为八行</p>
<pre><code>DEBUG 04-06 09:48:10,087 ==&gt;  Preparing: select eid,ename,age,sex,did from emp where eid = ?   (BaseJdbcLogger.java:145) 
DEBUG 04-06 09:48:10,102 ==&gt; Parameters: 3(String)  (BaseJdbcLogger.java:145) 
DEBUG 04-06 09:48:10,147 &lt;==      Total: 1  (BaseJdbcLogger.java:145) 
王五
DEBUG 04-06 09:48:10,147 ==&gt;  Preparing: select did,dname from dept where did=?   (BaseJdbcLogger.java:145) 
DEBUG 04-06 09:48:10,148 ==&gt; Parameters: 3(Integer)  (BaseJdbcLogger.java:145) 
DEBUG 04-06 09:48:10,149 &lt;==      Total: 1  (BaseJdbcLogger.java:145) 
Dept [did=3, dname=研发部]
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>MyBatis</category>
        <category>分步查询、分步查询延迟加载</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>分步查询</tag>
        <tag>分步查询延迟加载</tag>
      </tags>
  </entry>
  <entry>
    <title>基于JavaWeb的网上购物商城 | 分页</title>
    <url>/2022/01/15/%E5%88%86%E9%A1%B5-1/</url>
    <content><![CDATA[<h1 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h1><p><strong>实现功能</strong>：<br>当我们点击首页菜单栏的商品类别链接时，显示该分类下一定数量的商品，当该分类的总商品数大于这个数量，就会由几页数据，此时我们再点击页码时浏览器显示对应页的商品。<br><strong>实现分页功能需要的数据：</strong></p>
<table>
<thead>
<tr>
<th>数据</th>
<th>获取/计算方式</th>
</tr>
</thead>
<tbody><tr>
<td>当前页展示的数据(List<Product>)</Product></td>
<td>select * from product limit (当前页-1)*每页显示几条 每页显示几条</td>
</tr>
<tr>
<td>每页显示几条数据</td>
<td>自定义</td>
</tr>
<tr>
<td>当前页</td>
<td>从前台传递</td>
</tr>
<tr>
<td>总页数</td>
<td>总条数/每页显示多少条</td>
</tr>
<tr>
<td>总条数</td>
<td>使用count关键字    select count(*) form product</td>
</tr>
</tbody></table>
<p><strong>header.jsp</strong><br>修改属性class=”nav navbar-nav”的ul下面的菜单栏代码</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;
&lt;!DOCTYPE html&gt;
&lt;!-- 登录 注册 购物车... --&gt;
&lt;div class=&quot;container-fluid&quot;&gt;
    &lt;div class=&quot;col-md-4&quot;&gt;
        &lt;img src=&quot;img/logo2.png&quot; /&gt;
    &lt;/div&gt;
    &lt;div class=&quot;col-md-5&quot;&gt;
        &lt;img src=&quot;img/header.png&quot; /&gt;
    &lt;/div&gt;
    &lt;div class=&quot;col-md-3&quot; style=&quot;padding-top:20px&quot;&gt;
        &lt;ol class=&quot;list-inline&quot;&gt;
            &lt;c:if test=&quot;$&#123;empty user&#125;&quot;&gt;
                &lt;li&gt;&lt;a href=&quot;login.jsp&quot;&gt;登录&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href=&quot;register.jsp&quot;&gt;注册&lt;/a&gt;&lt;/li&gt;
            &lt;/c:if&gt;
            &lt;c:if test=&quot;$&#123;not empty user&#125;&quot;&gt;
                &lt;li&gt;$&#123;user.username&#125;&lt;/li&gt;
                &lt;li&gt;&lt;a href=&quot;cart.jsp&quot;&gt;购物车&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href=&quot;order_list.jsp&quot;&gt;我的订单&lt;/a&gt;&lt;/li&gt;
            &lt;/c:if&gt;
        &lt;/ol&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;!-- 导航条 --&gt;
&lt;div class=&quot;container-fluid&quot;&gt;
    &lt;nav class=&quot;navbar navbar-inverse&quot;&gt;
        &lt;div class=&quot;container-fluid&quot;&gt;
            &lt;!-- Brand and toggle get grouped for better mobile display --&gt;
            &lt;div class=&quot;navbar-header&quot;&gt;
                &lt;button type=&quot;button&quot; class=&quot;navbar-toggle collapsed&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#bs-example-navbar-collapse-1&quot; aria-expanded=&quot;false&quot;&gt;
                    &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt;
                    &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;
                    &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;
                    &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;
                &lt;/button&gt;
                &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;首页&lt;/a&gt;
            &lt;/div&gt;

            &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;bs-example-navbar-collapse-1&quot;&gt;
                &lt;ul class=&quot;nav navbar-nav&quot;&gt;
                    &lt;c:forEach items=&quot;$&#123;clist&#125;&quot; var=&quot;cate&quot;&gt;
                        &lt;li&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/product?method=findListByCate&amp;cid=$&#123;cate.cid&#125;&amp;pageNumber=1&quot;&gt;$&#123;cate.cname&#125;&lt;/a&gt;&lt;/li&gt;
                    &lt;/c:forEach&gt;
                &lt;/ul&gt;
                &lt;form class=&quot;navbar-form navbar-right&quot; role=&quot;search&quot;&gt;
                    &lt;div class=&quot;form-group&quot;&gt;
                        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Search&quot;&gt;
                    &lt;/div&gt;
                    &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Submit&lt;/button&gt;
                &lt;/form&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/nav&gt;
&lt;/div&gt;
</code></pre>
<p><strong>product_list.jsp</strong><br>修改分页部分的代码</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;
&lt;title&gt;会员登录&lt;/title&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap.min.css&quot; type=&quot;text/css&quot; /&gt;
&lt;script src=&quot;js/jquery-1.11.3.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;js/bootstrap.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;!-- 引入自定义css文件 style.css --&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot; type=&quot;text/css&quot; /&gt;

&lt;style&gt;
body &#123;
    margin-top: 20px;
    margin: 0 auto;
    width: 100%;
&#125;

.carousel-inner .item img &#123;
    width: 100%;
    height: 300px;
&#125;
&lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;


    &lt;!-- 引入header.jsp --&gt;
    &lt;jsp:include page=&quot;/header.jsp&quot;&gt;&lt;/jsp:include&gt;


    &lt;div class=&quot;row&quot; style=&quot;width: 1210px; margin: 0 auto;&quot;&gt;
        
        &lt;c:forEach items=&quot;$&#123;pb.list&#125;&quot; var=&quot;pro&quot;&gt;
            &lt;div class=&quot;col-md-2&quot;&gt;
                &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/product?method=getProById&amp;pid=$&#123;pro.pid&#125;&quot;&gt; 
                    &lt;img src=&quot;$&#123;pageContext.request.contextPath&#125;/$&#123;pro.pimage&#125;&quot; width=&quot;170&quot; height=&quot;170&quot; style=&quot;display: inline-block;&quot;&gt;
                &lt;/a&gt;
                &lt;p&gt;
                    &lt;a href=&quot;product_info.html&quot; style=&#39;color: green&#39;&gt;$&#123;pro.pname&#125;&lt;/a&gt;
                &lt;/p&gt;
                &lt;p&gt;
                    &lt;font color=&quot;#FF0000&quot;&gt;商城价：&amp;yen;$&#123;pro.shop_price&#125;&lt;/font&gt;
                &lt;/p&gt;
            &lt;/div&gt;
        &lt;/c:forEach&gt;
    &lt;/div&gt;

    &lt;!--分页 --&gt;
    &lt;div style=&quot;width: 380px; margin: 0 auto; margin-top: 50px;&quot;&gt;
        &lt;ul class=&quot;pagination&quot; style=&quot;text-align: center; margin-top: 10px;&quot;&gt;
            &lt;li class=&quot;disabled&quot;&gt;&lt;a href=&quot;#&quot; aria-label=&quot;Previous&quot;&gt;&lt;span
                    aria-hidden=&quot;true&quot;&gt;&amp;laquo;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
            &lt;c:forEach begin=&quot;1&quot; end=&quot;$&#123;pb.totalCount&#125;&quot; step=&quot;1&quot; var=&quot;n&quot;&gt;
                &lt;li&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/product?method=findListByCate&amp;cid=$&#123;cid&#125;&amp;pageNumber=$&#123;n&#125;&quot;&gt;$&#123;n&#125;&lt;/a&gt;&lt;/li&gt;
            &lt;/c:forEach&gt;
            &lt;li&gt;&lt;a href=&quot;#&quot; aria-label=&quot;Next&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;raquo;&lt;/span&gt;
            &lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;!-- 分页结束 --&gt;



    &lt;!-- 引入footer.jsp --&gt;
    &lt;jsp:include page=&quot;/footer.jsp&quot;&gt;&lt;/jsp:include&gt;

&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p><strong>PageBean.java</strong></p>
<pre><code>package com.oracle.bean;

import java.util.ArrayList;
import java.util.List;

public class PageBean &#123;
    private List&lt;Product&gt; list = new ArrayList&lt;&gt;();//显示当前页数据 select * form product limit
    private int pageSize;//每页显示几条数据 自定义
    private int pageNumber;//当前页 从前台传递过来
    private int totalCount;//(int)Math.ceil(totalSize*1.0/pageSize)
    private int totalSize;//总条数 select count(*) form product
    public List&lt;Product&gt; getList() &#123;
        return list;
    &#125;
    public void setList(List&lt;Product&gt; list) &#123;
        this.list = list;
    &#125;
    public int getPageSize() &#123;
        return pageSize;
    &#125;
    public void setPageSize(int pageSize) &#123;
        this.pageSize = pageSize;
    &#125;
    public int getPageNumber() &#123;
        return pageNumber;
    &#125;
    public void setPageNumber(int pageNumber) &#123;
        this.pageNumber = pageNumber;
    &#125;
    public int getTotalCount() &#123;
        return (int)Math.ceil(totalSize*1.0/pageSize);
    &#125;
    public void setTotalCount(int totalCount) &#123;
        this.totalCount = totalCount;
    &#125;
    public int getTotalSize() &#123;
        return totalSize;
    &#125;
    public void setTotalSize(int totalSize) &#123;
        this.totalSize = totalSize;
    &#125;
    
    //获取index索引的方法
    public int getIndex() &#123;
        return (pageNumber-1)*pageSize;
    &#125;
    public PageBean(int pageSize, int pageNumber) &#123;
        super();
        this.pageSize = pageSize;
        this.pageNumber = pageNumber;
    &#125;
&#125;
</code></pre>
<p><strong>ProductServlet.java</strong><br>变更ProductServlet.java中的findListByCate方法代码如下：</p>
<pre><code>public void findListByCate(HttpServletRequest request, HttpServletResponse response) &#123;
        // TODO Auto-generated method stub
        try &#123;
            String pn = request.getParameter(&quot;pageNumber&quot;);
            int pageNumber = Integer.parseInt(pn);
            int pageSize = 4;
            
            String cid = request.getParameter(&quot;cid&quot;);
            ProductService ps = new ProductService();
            
            //List&lt;Product&gt; plist = ps.findListByCate(cid);
            PageBean pb = ps.findListByCate(cid, pageNumber, pageSize);
            
            request.setAttribute(&quot;cid&quot;, cid);
            request.setAttribute(&quot;pb&quot;, pb);
            request.getRequestDispatcher(&quot;/product_list.jsp&quot;).forward(request, response);
        &#125; catch (Exception e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125;
        
&#125;
</code></pre>
<p><strong>ProductService.java</strong><br>变更ProductService.java中的findListByCate方法代码如下：</p>
<pre><code>public PageBean findListByCate(String cid, int pageNumber, int pageSize) throws SQLException &#123;
        // TODO Auto-generated method stub
        ProductDao pd = new ProductDao();
        //List&lt;Product&gt; plist = pd.findListByCate(cid);
        
        //查询每页显示的数据
        List&lt;Product&gt; plist = pd.findListByCate(cid, pageNumber, pageSize);
        
        //查询总条数
        int count = pd.getCount(cid);
        PageBean pb = new PageBean(pageSize, pageNumber);
        pb.setList(plist);
        pb.setTotalSize(count);
        
        return pb;
    &#125;
</code></pre>
<p><strong>ProductDao.java</strong><br>修改ProductDao.java中的findListByCate方法代码并添加getCount方法如下：</p>
<pre><code>public List&lt;Product&gt; findListByCate(String cid, int pageNumber, int pageSize) throws SQLException &#123;
    // TODO Auto-generated method stub
    QueryRunner qr = new QueryRunner(DataSourceUtils.getDataSource());
    
    PageBean pb = new PageBean(pageSize, pageNumber);
    
    String sql = &quot;select * from product where cid=? and pflag=? order by pdate desc limit ?,?&quot;;
    
    List&lt;Product&gt; plist = qr.query(sql, new BeanListHandler&lt;&gt;(Product.class), cid, 0, pb.getIndex(), pb.getPageSize());
    return plist;
&#125;

public int getCount(String cid) throws SQLException &#123;
    // TODO Auto-generated method stub
    QueryRunner qr = new QueryRunner(DataSourceUtils.getDataSource());
    
    String sql = &quot;select count(*) from product where cid=?&quot;;
    
    int count = ((Long) qr.query(sql, new ScalarHandler(), cid)).intValue();
    return count;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>项目经历</category>
        <category>JavaWeb</category>
        <category>基于JavaWeb的网上购物商城</category>
        <category>分页</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>分页</tag>
        <tag>JavaWeb</tag>
        <tag>基于JavaWeb的网上购物商城</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb项目开发 | 分页</title>
    <url>/2022/01/12/%E5%88%86%E9%A1%B5/</url>
    <content><![CDATA[<h1 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h1><h2 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h2><p><img src="/2022/01/12/%E5%88%86%E9%A1%B5/1.PNG"></p>
<span id="more"></span>
<h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><p><img src="/2022/01/12/%E5%88%86%E9%A1%B5/2.PNG"></p>
<h2 id="分页后台实现"><a href="#分页后台实现" class="headerlink" title="分页后台实现"></a>分页后台实现</h2><ol>
<li>paging.jsp(发出分页查询请求)</li>
</ol>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;a href=&quot;/paging/page?pageNumber=1&quot;&gt;分页查询&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="2">
<li>PageServlet.java(处理请求)</li>
</ol>
<pre><code>package com.oracle.servlet;

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.oracle.bean.PageBean;
import com.oracle.service.PageService;

public class PageServlet extends HttpServlet &#123;
    private static final long serialVersionUID = 1L;

    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        //获取前台传递的当前页
        String pn = request.getParameter(&quot;pageNumber&quot;);
        int pageNumber = Integer.parseInt(pn);
        int pageSize = 2;
        
        PageService ps = new PageService();
        PageBean pb = ps.getPageBean(pageNumber, pageSize);
        
        //把pb放入request域对象中
        request.setAttribute(&quot;pb&quot;, pb);
        //请求转发到前台页面
        request.getRequestDispatcher(&quot;/paging1.jsp&quot;).forward(request, response);
    &#125;

    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        doGet(request, response);
    &#125;
&#125;
</code></pre>
<ol start="3">
<li>PageService.java(编写业务逻辑)</li>
</ol>
<pre><code>package com.oracle.service;

import java.sql.SQLException;
import java.util.List;

import com.oracle.bean.PageBean;
import com.oracle.bean.Product;
import com.oracle.dao.PageDao;

public class PageService &#123;

    public PageBean getPageBean(int pageNumber, int pageSize) &#123;
        PageBean pb = null;
        try &#123;
            // TODO Auto-generated method stub
            PageDao pd = new PageDao();
            
            //组装PageBean
            pb = new PageBean(pageSize, pageNumber);
            
            //查询当前页显示的数据
            List&lt;Product&gt; list = pd.getProList(pb);
            
            //查询总条数
            int count = pd.getCount();
            
            //把数据放如pagebean中
            pb.setList(list);
            pb.setTotalSize(count);
        &#125; catch (Exception e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125;
        
        return pb;
    &#125;
&#125;
</code></pre>
<ol start="5">
<li>PageDao.java(操作数据库)</li>
</ol>
<pre><code>package com.oracle.dao;

import java.sql.SQLException;
import java.util.List;

import org.apache.commons.dbutils.QueryRunner;
import org.apache.commons.dbutils.handlers.BeanListHandler;
import org.apache.commons.dbutils.handlers.ScalarHandler;

import com.oracle.bean.PageBean;
import com.oracle.bean.Product;
import com.oracle.utils.DataSourceUtils;

public class PageDao &#123;

    public List&lt;Product&gt; getProList(PageBean pb) throws SQLException &#123;
        // TODO Auto-generated method stub
        QueryRunner qr = new QueryRunner(DataSourceUtils.getDataSource());
        
        String sql = &quot;select * from product limit ?,?&quot;;
        List&lt;Product&gt; list = qr.query(sql, new BeanListHandler&lt;&gt;(Product.class), pb.getIndex(), pb.getPageSize());
        return list;
    &#125;

    public int getCount() throws SQLException &#123;
        // TODO Auto-generated method stub
        QueryRunner qr = new QueryRunner(DataSourceUtils.getDataSource());
        
        String sql = &quot;select coutn(*) from product&quot;;
        
        int count = ((Long)qr.query(sql, new ScalarHandler())).intValue();
        
        return count;
    &#125;

&#125;
</code></pre>
<h2 id="分页前台实现"><a href="#分页前台实现" class="headerlink" title="分页前台实现"></a>分页前台实现</h2><ol>
<li>paging1.jsp(展示分页查询结果)</li>
</ol>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;table border=&quot;1px&quot; width=&quot;60%&quot; height=&quot;200px&quot; align=&quot;center&quot;&gt;
        &lt;tr&gt;
            &lt;th&gt;商品id&lt;/th&gt;
            &lt;th&gt;商品名称&lt;/th&gt;
            &lt;th&gt;商品价格&lt;/th&gt;
            &lt;th&gt;商品描述&lt;/th&gt;
        &lt;/tr&gt;
        
        &lt;c:forEach items=&quot;$&#123;pb.list&#125;&quot; var=&quot;pro&quot;&gt;
            &lt;tr&gt;
                &lt;td&gt;$&#123;pro.id&#125;&lt;/td&gt;
                &lt;td&gt;$&#123;pro.pname&#125;&lt;/td&gt;
                &lt;td&gt;$&#123;pro.price&#125;&lt;/td&gt;
                &lt;td&gt;$&#123;pro.pdesc&#125;&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/c:forEach&gt;
    &lt;/table&gt;
    
    &lt;center&gt;
        &lt;c:forEach begin=&quot;1&quot; end=&quot;$&#123;pb.totalCount&#125;&quot; step=&quot;1&quot; var=&quot;n&quot;&gt;
            &lt;a href=&quot;/paging/page?pageNumber=$&#123;n&#125;&quot;&gt;$&#123;n&#125;&lt;/a&gt;
        &lt;/c:forEach&gt;
    &lt;/center&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="2">
<li>效果<br><img src="/2022/01/12/%E5%88%86%E9%A1%B5/3.PNG"></li>
</ol>
<p><img src="/2022/01/12/%E5%88%86%E9%A1%B5/4.PNG"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb项目开发</category>
        <category>分页</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>分页</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis | 分页插件PageHelper及PageHelper模拟分页</title>
    <url>/2022/04/17/%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6PageHelper%E5%8F%8APageHelper%E6%A8%A1%E6%8B%9F%E5%88%86%E9%A1%B5/</url>
    <content><![CDATA[<h1 id="分页插件PageHelper及PageHelper模拟分页"><a href="#分页插件PageHelper及PageHelper模拟分页" class="headerlink" title="分页插件PageHelper及PageHelper模拟分页"></a>分页插件PageHelper及PageHelper模拟分页</h1><p>1.导入相关包<br>1)pagehelper-x.x.x.jar<br>2)jsqlparser-0.9.5.jar<br>2)在MyBatis全局配置文件mybatis-config.xml中配置分页插件<br><plugins><br>    <plugin interceptor="com.github.pagehelper.PageInterceptor"></plugin><br></plugins><br>3)使用PageHelper提供的方法进行分页<br>4)可以使用更强大的PageInfo封装返回结果</p>
<h2 id="模拟分页"><a href="#模拟分页" class="headerlink" title="模拟分页"></a>模拟分页</h2><p><strong>PageUtil.java</strong></p>
<pre><code>package com.atguigu.test;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;

import com.atguigu.bean.Emp;
import com.github.pagehelper.PageInfo;

/**
 * 首页 上一页 1 2 3 4 5 下一页 末页
 */
public class PageUtil &#123;
    public static String getPageInfo(PageInfo&lt;Emp&gt; pageInfo, HttpServletRequest request)&#123;
        //String path = request.getContextPath() + &quot;/&quot;;
        String path = &quot;/SSM/&quot;;
        
        StringBuilder builder = new StringBuilder();
        
        //拼接首页
        builder.append(&quot;&lt;a href=&#39;&quot;+path+&quot;emps/1&#39;&gt;首页&lt;/a&gt;&quot;);
        builder.append(&quot;&amp;nbsp;&quot;);
        
        //拼接上一页
        if(pageInfo.isHasPreviousPage())&#123;
            builder.append(&quot;&lt;a href=&#39;&quot;+path+&quot;emps/&quot;+pageInfo.getPrePage()+&quot;&#39;&gt;上一页 &lt;/a&gt;&quot;);
            builder.append(&quot;&amp;nbsp;&quot;);
        &#125;else&#123;
            builder.append(&quot;上一页&quot;);
            builder.append(&quot;&amp;nbsp;&quot;);
        &#125;
        
        //拼接页码
        int[] nums = pageInfo.getNavigatepageNums();
        for(int i : nums)&#123;
            if(i == pageInfo.getPageNum())&#123;
                builder.append(&quot;&lt;a style=&#39;color:red;&#39; href=&#39;&quot;+path+&quot;emps/&quot;+i+&quot;&#39;&gt;&quot;+i+&quot;&lt;/a&gt;&quot;);
                builder.append(&quot;&amp;nbsp;&quot;);
            &#125;else&#123;
                builder.append(&quot;&lt;a href=&#39;&quot;+path+&quot;emps/&quot;+i+&quot;&#39;&gt;&quot;+i+&quot;&lt;/a&gt;&quot;);
                builder.append(&quot;&amp;nbsp;&quot;);
            &#125;
        &#125;
        
        //拼接下一页
        if(pageInfo.isHasNextPage())&#123;
            builder.append(&quot;&lt;a href=&#39;&quot;+path+&quot;emps/&quot;+pageInfo.getNextPage()+&quot;&#39;&gt;下一页&lt;/a&gt;&quot;);
            builder.append(&quot;&amp;nbsp;&quot;);
        &#125;else&#123;
            builder.append(&quot;下一页&quot;);
            builder.append(&quot;&amp;nbsp;&quot;);
        &#125;
        
        //拼接尾页
        builder.append(&quot;&lt;a href=&#39;&quot;+path+&quot;emps/&quot;+pageInfo.getPages()+&quot;&#39;&gt;尾页&lt;/a&gt;&quot;);
        builder.append(&quot;&amp;nbsp;&quot;);
        
        return builder.toString();
    &#125;
&#125;
</code></pre>
<p><strong>TestPage.java</strong></p>
<pre><code>package com.atguigu.test;

import java.io.InputStream;
import java.util.Arrays;
import java.util.List;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.Test;

import com.atguigu.bean.Emp;
import com.atguigu.mapper.EmpMapper;
import com.github.pagehelper.PageHelper;
import com.github.pagehelper.PageInfo;

public class TestPage &#123;
    @Test
    public void testPage() throws Exception&#123;
        SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
        SqlSession sqlSession = sqlSessionFactory.openSession(true);
        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
        PageHelper.startPage(2, 2);
        List&lt;Emp&gt; list = mapper.getAllEmp();
        
        PageInfo&lt;Emp&gt; pageInfo = new PageInfo&lt;&gt;(list, 5);
//        System.out.println(pageInfo);
//        System.out.println(Arrays.toString(pageInfo.getNavigatepageNums()));
        
        System.out.println(PageUtil.getPageInfo(pageInfo, null));
        
        
        for (Emp emp : list) &#123;
            System.out.println(emp);
        &#125;
    &#125;
    
    public SqlSessionFactory getSqlSessionFactory() throws Exception&#123;
        InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
        return sqlSessionFactory;
    &#125;
&#125;
</code></pre>
<p><strong>返回结果</strong><br>字符串：</p>
<pre><code>&lt;a href=&#39;/SSM/emps/1&#39;&gt;首页&lt;/a&gt;&amp;nbsp;&lt;a href=&#39;/SSM/emps/1&#39;&gt;上一页 &lt;/a&gt;&amp;nbsp;&lt;a href=&#39;/SSM/emps/1&#39;&gt;1&lt;/a&gt;&amp;nbsp;&lt;a style=&#39;color:red;&#39; href=&#39;/SSM/emps/2&#39;&gt;2&lt;/a&gt;&amp;nbsp;&lt;a href=&#39;/SSM/emps/3&#39;&gt;3&lt;/a&gt;&amp;nbsp;&lt;a href=&#39;/SSM/emps/4&#39;&gt;4&lt;/a&gt;&amp;nbsp;&lt;a href=&#39;/SSM/emps/5&#39;&gt;5&lt;/a&gt;&amp;nbsp;&lt;a href=&#39;/SSM/emps/3&#39;&gt;下一页&lt;/a&gt;&amp;nbsp;&lt;a href=&#39;/SSM/emps/6&#39;&gt;尾页&lt;/a&gt;&amp;nbsp;
</code></pre>
<p>浏览器显示：<br><img src="/2022/04/17/%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6PageHelper%E5%8F%8APageHelper%E6%A8%A1%E6%8B%9F%E5%88%86%E9%A1%B5/1.PNG"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>MyBatis</category>
        <category>分页插件PageHelper及PageHelper模拟分页</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>分页插件PageHelper</tag>
        <tag>PageHelper模拟分页</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 划分数据集前对数据的shuffle</title>
    <url>/2021/07/02/%E5%88%92%E5%88%86%E6%95%B0%E6%8D%AE%E9%9B%86%E5%89%8D%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%9A%84shuffle/</url>
    <content><![CDATA[<h1 id="划分数据集前对数据的shuffle"><a href="#划分数据集前对数据的shuffle" class="headerlink" title="划分数据集前对数据的shuffle"></a>划分数据集前对数据的shuffle</h1><p>划分数据集前对数据集和标签的shuffle很重要！！！划分数据集前对数据集和标签的shuffle很重要！！！划分数据集前对数据集和标签的shuffle很重要！！！<br>重要的事情说三遍！</p>
<p>shuffle对模型的accuracy有较大的影响，因此在将数据输入模型之前应该将数据集进行shuffle!</p>
<p><a href="https://blog.csdn.net/qq_38412868/article/details/85473973">Python如何打乱训练数据集顺序的几种方法</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb项目开发 | 创建web项目并添加到服务器中</title>
    <url>/2022/01/10/%E5%88%9B%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E5%B9%B6%E6%B7%BB%E5%8A%A0%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD/</url>
    <content><![CDATA[<h1 id="创建web项目并添加到服务器中"><a href="#创建web项目并添加到服务器中" class="headerlink" title="创建web项目并添加到服务器中"></a>创建web项目并添加到服务器中</h1><h2 id="1-创建web项目"><a href="#1-创建web项目" class="headerlink" title="1.创建web项目"></a>1.创建web项目</h2><p>New –&gt; Web –&gt; dynamic web project,然后按照下图操作。<br><img src="/2022/01/10/%E5%88%9B%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E5%B9%B6%E6%B7%BB%E5%8A%A0%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD/1.PNG"><br>注意：Target runtime需选择与服务器对应的版本，dynamic web module version选择2.5.</p>
<h2 id="2-将创建好的web项目加入到服务器中"><a href="#2-将创建好的web项目加入到服务器中" class="headerlink" title="2.将创建好的web项目加入到服务器中"></a>2.将创建好的web项目加入到服务器中</h2><p>在服务器上右键–&gt;add and remove,然后将对应的项目加入到服务器。<br><img src="/2022/01/10/%E5%88%9B%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E5%B9%B6%E6%B7%BB%E5%8A%A0%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD/2.PNG"></p>
<h2 id="3-访问服务器上的web信息"><a href="#3-访问服务器上的web信息" class="headerlink" title="3.访问服务器上的web信息"></a>3.访问服务器上的web信息</h2><p>1.在WebContent下面创建一个简单的页面（1.html）<br>2.在浏览器地址栏输入：localhot/8080/shop/1.html<br><img src="/2022/01/10/%E5%88%9B%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E5%B9%B6%E6%B7%BB%E5%8A%A0%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD/3.PNG"><br>效果：<br><img src="/2022/01/10/%E5%88%9B%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E5%B9%B6%E6%B7%BB%E5%8A%A0%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD/4.PNG"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb项目开发</category>
        <category>创建web项目并添加到服务器中</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>创建web项目</tag>
      </tags>
  </entry>
  <entry>
    <title>Django | 创建模型对象的两种方式</title>
    <url>/2021/07/26/%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="创建模型对象的两种方式"><a href="#创建模型对象的两种方式" class="headerlink" title="创建模型对象的两种方式"></a>创建模型对象的两种方式</h1><p>使用关键字构造模型对象非常麻烦，一下介绍两种创建对象的方式。</p>
<span id="more"></span>

<p><strong>方式一：在模型类中增加一个类方法—不推荐使用</strong></p>
<pre><code>class ExampleModel(models.Model):
    ...
    @classmethod
    def create(cls, attr1, attr2, ...):
        e = ExampleModel()
        e.attr1 = attr1
        e.attr2 = attr2
        ...
        return e
</code></pre>
<p><strong>方式二：在自定义管理器中添加一个方法—推荐使用</strong></p>
<pre><code>class ExampleModelManager(models.Manager):
    def create(self, attr1, attr2, ...):
        e = ExampleModel()  # 使用在方式一中定义的模型类ExampleModel
        e.attr1 = attr1
        e.attr2 = attr2
        ...
        return e
        
</code></pre>
<p>**Note:**管理器是模型类的属性，用于将对象与数据表映射</p>
]]></content>
      <categories>
        <category>python</category>
        <category>框架</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Java | 创建线程池的7种方式</title>
    <url>/2022/04/24/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%847%E4%B8%AD%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="创建线程池的7种方式"><a href="#创建线程池的7种方式" class="headerlink" title="创建线程池的7种方式"></a>创建线程池的7种方式</h1><pre><code>import java.util.Date;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class ThreadPoolCreationTest &#123;
    public static void fixedThreadPool()&#123;
//        ExecutorService threadPool = Executors.newFixedThreadPool(2);
//        
//        Runnable runnable = new Runnable()&#123;
//            @Override
//            public void run()&#123;
//                System.out.println(&quot;任务被执行，线程：&quot; + Thread.currentThread().getName());
//            &#125;
//        &#125;;
//        
//        Future&lt;?&gt; submit = threadPool.submit(runnable);
////        System.out.println(submit);
////        System.out.println(submit.isDone());
//        threadPool.execute(runnable);
//        threadPool.execute(runnable);
//        threadPool.execute(runnable);
        
        ExecutorService threadPool = Executors.newFixedThreadPool(2);
        for(int i = 0; i &lt; 4; i++)&#123;
            threadPool.execute(() -&gt; &#123;
                System.out.println(&quot;任务被执行，线程：&quot; + Thread.currentThread().getName());
            &#125;);
        &#125;
    &#125;
    
    public static void cachedThreadPool()&#123;
        ExecutorService threadPool = Executors.newCachedThreadPool();
        for(int i=0;i&lt;10;i++)&#123;
            threadPool.execute(() -&gt; &#123;
                System.out.println(&quot;任务被执行，线程：&quot; + Thread.currentThread().getName());
            &#125;);
        &#125;
    &#125;
    
    public static void singleThreadPool()&#123;
        ExecutorService threadPool = Executors.newSingleThreadExecutor();
        for(int i = 0; i &lt; 10; i++)&#123;
            threadPool.execute(() -&gt; &#123;
                System.out.println(&quot;任务被执行，线程：&quot; + Thread.currentThread().getName());
            &#125;);
        &#125;
    &#125;
    
    public static void scheduledThreadPool()&#123;
        ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(5);
        System.out.println(&quot;添加任务，时间：&quot;+new Date());
        threadPool.schedule(()-&gt;&#123;
            System.out.println(&quot;任务被执行，时间：&quot;+new Date());
            try &#123;
                TimeUnit.SECONDS.sleep(1);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;, 1, TimeUnit.SECONDS);
    &#125;
    
    public static void singleThreadScheduledPool()&#123;
        ScheduledExecutorService threadPool = Executors.newSingleThreadScheduledExecutor();
        System.out.println(&quot;添加任务，时间：&quot;+new Date());
        threadPool.schedule(()-&gt;&#123;
            System.out.println(&quot;任务被执行，时间：&quot;+new Date());
            try &#123;
                TimeUnit.SECONDS.sleep(1);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;, 2, TimeUnit.SECONDS);
    &#125;
    
    public static void workStealingPool()&#123;
        ExecutorService threadPool = Executors.newWorkStealingPool();
        for(int i = 0; i &lt; 10; i++)&#123;
            final int index = i;
            threadPool.execute(() -&gt;&#123;
                System.out.println(index + &quot;被执行，线程名&quot;+Thread.currentThread().getName());
            &#125;);
        &#125;
        while(!threadPool.isTerminated())&#123;
            
        &#125;
    &#125;
    
    //推荐使用
    //阿里巴巴开发手册：线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。
    public static void myThreadPoolExecutor()&#123;
        final int CORE_POOL_SIZE = 5;  
        final int MAX_POOL_SIZE = 10;
        final int QUEUE_CAPACITY = 100;
        final Long KEEP_ALIVE_TIME = 1L;
        ThreadPoolExecutor threadPool = new ThreadPoolExecutor(
                CORE_POOL_SIZE,
                MAX_POOL_SIZE,
                KEEP_ALIVE_TIME,
                TimeUnit.SECONDS,
                new ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY),
                new ThreadPoolExecutor.CallerRunsPolicy()
                );
        for(int i = 0; i &lt; 10; i++)&#123;
            final int index = i;
            threadPool.execute(() -&gt; &#123;
                System.out.println(index+&quot;被执行，线程名：&quot;+Thread.currentThread().getName());
                try &#123;
                    Thread.sleep(1000);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;);
        &#125;
        
    &#125;
    
    
    public static void main(String[] args) &#123;
        //fixedThreadPool();
        //cachedThreadPool();
        //singleThreadPool();
        //scheduledThreadPool();
        //singleThreadScheduledPool();
        //workStealingPool();
        myThreadPoolExecutor();
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
        <category>创建线程池的7种方式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>Java | 创建线程的三种方式</title>
    <url>/2022/04/24/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="创建线程的三种方式"><a href="#创建线程的三种方式" class="headerlink" title="创建线程的三种方式"></a>创建线程的三种方式</h1><p>创建线程有三种方式，分别是继承Thread类、实现Runnable接口、实现Callable接口。</p>
<p>1.通过继承Thread类来创建并启动线程的步骤如下：<br>1.1定义Thread类的子类，并重写该类的run()方法，该run()方法将作为线程执行体。<br>1.2创建Thread子类的实例，即创建了线程对象。<br>1.3调用线程对象的start()方法来启动该线程。<br>2.通过实现Runnable接口来创建并启动线程的步骤如下：<br>2.1定义Runnable接口的实现类，并实现该接口的run()方法，该run()方法将作为线程执行体。<br>2.2创建Runnable实现类的实例，并将其作为Thread的target来创建Thread对象，Thread对象为线程对象。<br>2.3调用线程对象的start()方法来启动该线程。<br>3.通过实现Callable接口来创建并启动线程的步骤如下：<br>3.1创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，且该call()方法有返回值。然后再创建Callable实现类的实例。<br>3.2使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。<br>3.3使用FutureTask对象作为Thread对象的target创建并启动新线程。<br>3.4调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。</p>
<span id="more"></span>
<p><strong>代码</strong></p>
<pre><code>import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

class MyThread extends Thread&#123;
    @Override
    public void run()&#123;
        System.out.println(Thread.currentThread().getName());
    &#125;
&#125;

class MyThread1 implements Runnable&#123;

    @Override
    public void run() &#123;
        System.out.println(Thread.currentThread().getName());
    &#125;
&#125;

class MyThread2 implements Callable&#123;

    @Override
    public Object call() throws Exception &#123;
        return &quot;success&quot;;
    &#125;
&#125;

public class ThreadTest &#123;
    public static void main(String[] args) throws ExecutionException &#123;
        for(int i=0;i&lt;10;i++)&#123;
            //继承Thread类
            //new MyThread().start();
            
            //实现Runnable接口
            //new Thread(new MyThread1()).start();
            
            //实现Callable接口
            FutureTask&lt;String&gt; task = new FutureTask&lt;&gt;(new MyThread2());
            new Thread(task).start();
        
            try &#123;
                System.out.println(task.get());
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;    
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
        <category>创建线程的三种方式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 删除有序链表中的重复元素</title>
    <url>/2021/08/27/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="83-删除有序链表中的重复元素"><a href="#83-删除有序链表中的重复元素" class="headerlink" title="83.删除有序链表中的重复元素"></a>83.删除有序链表中的重复元素</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 只出现一次 。<br>返回同样按升序排列的结果链表。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>一次遍历法<br>由于链表是按照升序排序的链表，所有重复的元素是相邻的，我们只需遍历一次链表，并判断当前节点与当前节点的后一节点所对应元素是否相等，<br>如果相等则将后者删除，如果不相等，工作指针继续后移，…，以此类推，当遍历完整个链表之后，我们返回链表的头节点即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def deleteDuplicates(self, head):
        &quot;&quot;&quot;
        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        # prev = head
        # p = prev.next
        #
        # while p is not None:  #
        #     if prev.val == p.val:
        #         p = p.next
        #         prev.next = p
        #     else:
        #         prev = prev.next
        #         p = p.next
        #
        # return head


        if not head:
            return head

        cur = head
        while cur.next:
            if cur.val == cur.next.val:
                cur.next = cur.next.next
            else:
                cur = cur.next

        return head

    def create_linked_list(self, list):
        &quot;&quot;&quot;根据list中的所有元素构建单链表&quot;&quot;&quot;
        l = ListNode()  # 单链表头节点
        r = l  # 起始尾指针r指向头节点
        for e in list:
            node = ListNode(e)
            r.next = node
            r = r.next

        return l.next

    def print_linked_list(self, linked_list) -&gt; None:
        &quot;&quot;&quot;
        打印单链表中的所有元素

        :param linked_list: 单链表
        :return: 无
        &quot;&quot;&quot;
        print(&quot;----------------------------------------&quot;)
        pointer = linked_list
        while pointer is not None:
            print(pointer.val)
            pointer = pointer.next


if __name__ == &quot;__main__&quot;:
    slt = Solution()
    l1 = slt.create_linked_list([1, 1, 2, 3, 3])
    l = slt.deleteDuplicates(l1)
    slt.print_linked_list(l)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>基于JavaWeb的网上购物商城 | 删除购物车中的商品</title>
    <url>/2022/01/15/%E5%88%A0%E9%99%A4%E8%B4%AD%E7%89%A9%E8%BD%A6%E4%B8%AD%E7%9A%84%E5%95%86%E5%93%81/</url>
    <content><![CDATA[<h1 id="删除购物车中的商品"><a href="#删除购物车中的商品" class="headerlink" title="删除购物车中的商品"></a>删除购物车中的商品</h1><p><strong>实现功能：</strong><br>用户点击购物车中购物项后面的删除将这个购物项删除，总计金额减去当前购物项小计。<br><img src="/2022/01/15/%E5%88%A0%E9%99%A4%E8%B4%AD%E7%89%A9%E8%BD%A6%E4%B8%AD%E7%9A%84%E5%95%86%E5%93%81/1.PNG"></p>
<span id="more"></span>
<p><strong>cart.jsp</strong><br>为删除链接增加onclick属性，并使用js实现delCart方法。</p>
<pre><code>&lt;td&gt;
    &lt;a href=&quot;javascript:;&quot; class=&quot;delete&quot; onclick=&quot;delCart(&#39;$&#123;en.value.pro.pid&#125;&#39;, &#39;$&#123;en.value.subTotal&#125;&#39;)&quot;&gt;删除&lt;/a&gt;
&lt;/td&gt;
......
&lt;script type=&quot;text/javascript&quot;&gt;
    function delCart(pid, money)&#123;
        location.href=&quot;$&#123;pageContext.request.contextPath&#125;/product?method=delCart&amp;pid=&quot;+pid+&quot;&amp;money=&quot;+money;
    &#125;
&lt;/script&gt;
</code></pre>
<p><strong>ProductServlet.java</strong><br>在ProductServlet.java的doGet方法中添加delCart的判断，并完成delCart方法。</p>
<pre><code>public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
    String method = request.getParameter(&quot;method&quot;);
    if(&quot;getProById&quot;.equals(method)) &#123;
        getProById(request, response);
    &#125;else if(&quot;findListByCate&quot;.equals(method)) &#123;
        findListByCate(request, response);
    &#125;else if(&quot;cart&quot;.equals(method)) &#123;
        cart(request, response);
    &#125;else if(&quot;delCart&quot;.equals(method)) &#123;
        delCart(request, response);
    &#125;
&#125;

public void delCart(HttpServletRequest request, HttpServletResponse response) &#123;
    // TODO Auto-generated method stub
    try &#123;
        String pid = request.getParameter(&quot;pid&quot;);
        String money = request.getParameter(&quot;money&quot;);
        //获取购物车
        HttpSession session = request.getSession();
        Cart cart = (Cart) session.getAttribute(&quot;cart&quot;);
        HashMap&lt;String, CartItem&gt; map = cart.getMap();
        CartItem c = map.remove(pid);
        double subTotal = c.getSubTotal();
        //购物车金额-小计
        cart.setSubMoney(cart.getSubMoney()-subTotal);
        //返回购物车页面
        request.getRequestDispatcher(&quot;/cart.jsp&quot;).forward(request, response);
    &#125; catch (Exception e) &#123;
        // TODO Auto-generated catch block
        e.printStackTrace();
    &#125; 
&#125;
</code></pre>
]]></content>
      <categories>
        <category>项目经历</category>
        <category>JavaWeb</category>
        <category>基于JavaWeb的网上购物商城</category>
        <category>删除购物车中的商品</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
        <tag>基于JavaWeb的网上购物商城</tag>
        <tag>删除购物车中的商品</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 删除链表中的节点</title>
    <url>/2021/08/27/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="237.删除链表中的节点"></a>237.删除链表中的节点</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>由于单链表不能直接访问当前节点的前一个节点，现要删除当前节点，我们可以将当前节点的下一个节点的值复制到当前节点，然后改变当前节点的next指针删除当前节点的下一个节点即可达到删除当前节点的效果。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def deleteNode(self, node):
        &quot;&quot;&quot;
        :type node: ListNode
        :rtype: void Do not return anything, modify node in-place instead.
        &quot;&quot;&quot;
        node.val = node.next.val
        node.next = node.next.next
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 删除链表元素</title>
    <url>/2021/08/27/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="203-删除链表元素"><a href="#203-删除链表元素" class="headerlink" title="203.删除链表元素"></a>203.删除链表元素</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.递归<br>链表的定义具有递归的性质，因此链表题目常可以用递归的方法求解。<br>对于给定的链表，首先对除了头节点 head 以外的节点进行删除操作，然后判断 head 的节点值是否等于给定的 val。如果 head 的节点值等于 val，则 head 需要被删除，因此删除操作后的头节点为 head.next；如果 head 的节点值不等于 val，则 head\ 保留，因此删除操作后的头节点还是 head。<br>递归的终止条件是 head 为空，此时直接返回 head。当 head 不为空时，递归地进行删除操作，然后判断 head 的节点值是否等于 val 并决定是否要删除 head。<br>2.迭代<br>用 temp 表示当前节点。如果 temp 的下一个节点不为空且下一个节点的节点值等于给定的 val，则需要删除下一个节点。删除下一个节点可以通过以下做法实现：<br>temp.next=temp.next.next<br>如果 temp 的下一个节点的节点值不等于给定的 val，则保留下一个节点，将 temp 移动到下一个节点即可。<br>当 temp 的下一个节点为空时，链表遍历结束，此时所有节点值等于 val 的节点都被删除。<br>具体实现方面，由于链表的头节点 head 有可能需要被删除，因此创建哑节点 dummyHead，令 dummyHead.next=head，初始化 temp=dummyHead，然后遍历链表进行删除操作。最终返回 dummyHead.next 即为删除操作后的头节点。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def removeElements(self, head, val):
        &quot;&quot;&quot;
        移除单链表head中所有值为val的节点（迭代法）

        时间复杂度：O(n)
        空间复杂度：O(1)

        :type head: ListNode
        :type val: int
        :rtype: ListNode
        &quot;&quot;&quot;
        # # 为单链表怎加一个头节点
        # head_node = ListNode()
        # head_node.next = head
        #
        # # 定义工作指针p和工作指针的前一个节点指针prev
        # prev = head_node  # prev指向头节点
        # p = prev.next  # p指向链表的第一个节点
        #
        # while p is not None:
        #     if p.val == val:
        #         prev.next = p.next
        #         p = p.next
        #     else:
        #         prev = p
        #         p = p.next
        #
        # return head_node.next

        dummyHead = ListNode()
        dummyHead.next = head
        temp = dummyHead

        while temp.next is not None:
            if temp.next.val == val:
                temp.next = temp.next.next
            else:
                temp = temp.next
        return dummyHead.next

    def removeElements1(self, head, val):
        &quot;&quot;&quot;
        移除单链表head中所有值为val的节点（递归法）

        时间复杂度：O(n)
        空间复杂度：O(n)

        :param head:
        :param val:
        :return:
        &quot;&quot;&quot;
        if head is None:
            return head

        head.next = self.removeElements1(head.next, val)

        return head.next if head.val == val else head

    def create_linked_list(self, list):
        &quot;&quot;&quot;根据list中的所有元素构建单链表&quot;&quot;&quot;
        l = ListNode()  # 单链表头节点
        r = l  # 起始尾指针r指向头节点
        for e in list:
            node = ListNode(e)
            r.next = node
            r = r.next

        return l.next

    def print_linked_list(self, linked_list) -&gt; None:
        &quot;&quot;&quot;
        打印单链表中的所有元素

        :param linked_list: 单链表
        :return: 无
        &quot;&quot;&quot;
        print(&quot;----------------------------------------&quot;)
        pointer = linked_list
        while pointer is not None:
            print(pointer.val)
            pointer = pointer.next


if __name__ == &quot;__main__&quot;:
    slt = Solution()

    linked_list = slt.create_linked_list([1, 2, 6, 3, 4, 5, 6])
    # linked_list = slt.create_linked_list([7, 7, 7, 7])

    slt.print_linked_list(linked_list)

    deleted_linked_list = slt.removeElements1(linked_list, 6)

    slt.print_linked_list(deleted_linked_list)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>19. 删除链表中的倒数第N个节点</title>
    <url>/2022/07/09/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="19-删除链表中的倒数第N个节点"><a href="#19-删除链表中的倒数第N个节点" class="headerlink" title="19. 删除链表中的倒数第N个节点"></a>19. 删除链表中的倒数第N个节点</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。<br><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">题目链接</a></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>计算链表长度<br>删除链表的倒数第 n 个结点操作就等价于删除正数第L-n+1个节点，L为链表的长度</p>
</li>
<li><p>栈<br>遍历链表的同时将所有节点依次入栈，根据栈 先进后出 的原则，弹出栈的第n个节点就是需要删除的节点，并且弹出<br>第n个节点后的栈顶节点为待删除节点的前驱节点。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p> class ListNode(object):</p>
<pre><code> def __init__(self, val=0, next=None):
     self.val = val
     self.next = next
</code></pre>
<p> class Solution(object):</p>
<pre><code> def removeNthFromEnd(self, linkedList, n):
     &quot;&quot;&quot;
     计算链表长度
     :type head: ListNode
     :type n: int
     :rtype: ListNode
     &quot;&quot;&quot;
     dummy = ListNode(0, linkedList)
     length = self.lenOfLinkedList(dummy)
     print(length)
     cur = dummy
     for i in range(1, length - n):
         cur = cur.next
     cur.next = cur.next.next
     return dummy.next
 
 def removeNthFromEnd2(self, head, n):
     &quot;&quot;&quot;栈&quot;&quot;&quot;
     stack = list()
     cur = head
     while cur:
         stack.append(cur)
         cur = cur.next
     for i in range(n):
         stack.pop()
         
     prev = stack[-1]
     prev.next = prev.next.next
     return head
 
 def removeNthFromEnd3(self, head, n):
     &quot;&quot;&quot;双指针&quot;&quot;&quot;
     dummy = ListNode(0, head)
     first = head
     second = dummy
     for i in range(n):
         first = first.next
     
     while first:
         first = first.next
         second = second.next
     
     second.next = second.next.next
     return dummy.next
 
 def lenOfLinkedList(self, head):
     if not head:
         return 0
     p = head
     count = 0
     while p is not None:
         count += 1
         p = p.next
     return count
 
 def createLinkedList(self, list):
     head = r = ListNode(list[0])
     for num in list[1:]:
         node = ListNode(num)
         r.next = node
         r = node
     
     return head
 
 def traverseLinkedList(self, head):
     if not head:
         return
     p = head
     while p is not None:
         print(p.val, end=&quot; &quot;)
         p = p.next
     print(&quot;&quot;)
</code></pre>
<p> if <strong>name</strong> == “<strong>main</strong>“:</p>
<pre><code> slt = Solution()
 linkedList = slt.createLinkedList([1, 2, 3, 4, 5])
 print(&quot;linked list:&quot;, end=&quot;&quot;)
 slt.traverseLinkedList(linkedList)
 length = slt.lenOfLinkedList(linkedList)
 print(&quot;length of linked list:&quot;, length)
 # newLinkedList = slt.removeNthFromEnd(linkedList, 2)
 # newLinkedList = slt.removeNthFromEnd2(linkedList, 2)
 newLinkedList = slt.removeNthFromEnd3(linkedList, 2)
 print(&quot;linked list after deleting the reversed n-th node:&quot;, end=&quot;&quot;)
 slt.traverseLinkedList(newLinkedList)
</code></pre>
</li>
</ol>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>链表</category>
        <category>19. 删除链表中的倒数第N个节点</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>算法刷题 | 刷题笔记</title>
    <url>/2021/06/24/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="刷题笔记"><a href="#刷题笔记" class="headerlink" title="刷题笔记"></a>刷题笔记</h1><p><a href="https://github.com/CyC2018/CS-Notes">刷题笔记1</a></p>
<p><a href="https://github.com/Jack-Cherish/LeetCode">刷题笔记2</a></p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 前向传播和反向传播中使用的cache</title>
    <url>/2021/06/30/%E5%89%8D%E5%90%91%E4%BC%A0%E6%92%AD%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84cache/</url>
    <content><![CDATA[<h1 id="前向传播和反向传播中使用的cache"><a href="#前向传播和反向传播中使用的cache" class="headerlink" title="前向传播和反向传播中使用的cache"></a>前向传播和反向传播中使用的cache</h1><p>the “cache” records values from the forward propagation units and sends it to the backward<br>propagation units because it is needed to compute the chain rule derivatives.(“cache”记录<br>来自正向传播单元的值并将其发送到反向传播单元，因为需要链式计算导数。)</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>前向传播</tag>
        <tag>反向传播</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis | 动态SQL</title>
    <url>/2022/04/09/%E5%8A%A8%E6%80%81SQL/</url>
    <content><![CDATA[<h1 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h1><p>1.项目目录<br><img src="/2022/04/09/%E5%8A%A8%E6%80%81SQL/1.PNG"><br>2.EmpMapper.java</p>
<pre><code>package com.atguigu.mapper;

import java.util.List;

import org.apache.ibatis.annotations.Param;

import com.atguigu.bean.Emp;

public interface EmpMapper &#123;
    //根据eid,ename,age,sex多条件查询员工信息
    List&lt;Emp&gt; getEmpListByMoreTJ(Emp emp);
    
    //根据eid,ename,age,sex其中一个查询员工信息
    List&lt;Emp&gt; getEmpListByChoose(Emp emp);
    
    //添加员工信息，将0|1--&gt;女|男
    void insertEmp(Emp emp);
    
    //根据eid所组成的字符串进行批量删除
    void deleteMoreEmp(String eids);
    
    //通过list集合实现批量删除
    //void deleteMoreByList(List&lt;Integer&gt; eids);
    void deleteMoreByList(@Param(&quot;eids&quot;)List&lt;Integer&gt; eids);
    
    //批量添加
    void insertMoreByArray(Emp[] emps);
    
    //批量修改
    void updateMoreByArray(@Param(&quot;emps&quot;)Emp[] emps);
&#125;
</code></pre>
<p>3.EmpMapper.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
 PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
 &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
 
&lt;mapper namespace=&quot;com.atguigu.mapper.EmpMapper&quot;&gt;
    &lt;!--
         &lt;sql id=&quot;&quot;&gt;&lt;/sql&gt;:设置一段SQL片段，即公共SQL，可以被当前映射文件中所有的SQL语句所访问
     --&gt;
    &lt;sql id=&quot;empColumns&quot;&gt;
        select eid,ename,age,sex,did from emp
    &lt;/sql&gt;

    &lt;!-- List&lt;Emp&gt; getEmpListByMoreTJ(); --&gt;
    &lt;!--
        多条件查询：若页面中没有设置此条件，SQL语句中一定不能有该条件
     --&gt;
    &lt;!--
        &lt;if test=&quot;&quot;&gt;&lt;/if&gt;:通过test表达式拼接SQL 
        &lt;where&gt;:添加where关键字并去掉多余的and
        &lt;trim prefix=&quot;&quot; suffix=&quot;&quot; prefixOverrides=&quot;&quot; suffixOverrides=&quot;&quot;&gt;:截取并拼接
        prefix:在操作的SQL语句前加入某些内容
        suffix:在操作的SQL语句后加入某些内容
        prefixOverrides:把操作的SQL语句前的某些内容去掉
        suffixOverrides:把操作的SQL语句后的某些内容去掉
     --&gt;
    &lt;select id=&quot;getEmpListByMoreTJ&quot; resultType=&quot;Emp&quot;&gt;
        &lt;!-- select eid,ename,age,sex,did from emp
        where 1 = 1
        &lt;if test=&quot;eid != null&quot;&gt;
            and eid=#&#123;eid&#125;
        &lt;/if&gt;
        &lt;if test=&quot;ename != null and ename != &#39;&#39;&quot;&gt;
            and ename=#&#123;ename&#125;
        &lt;/if&gt;
        &lt;if test=&quot;age != null&quot;&gt;
            and age=#&#123;age&#125;
        &lt;/if&gt;
        &lt;if test=&quot;sex == &#39;1&#39; or sex == &#39;0&#39;&quot;&gt;
            and sex=#&#123;sex&#125;
        &lt;/if&gt; --&gt;
        
        
        &lt;!-- select eid,ename,age,sex,did from emp
        &lt;where&gt;
            &lt;if test=&quot;eid != null&quot;&gt;
                and eid=#&#123;eid&#125;
            &lt;/if&gt;
            &lt;if test=&quot;ename != null and ename != &#39;&#39;&quot;&gt;
                and ename=#&#123;ename&#125;
            &lt;/if&gt;
            &lt;if test=&quot;age != null&quot;&gt;
                and age=#&#123;age&#125;
            &lt;/if&gt;
            &lt;if test=&quot;sex == &#39;1&#39; or sex == &#39;0&#39;&quot;&gt;
                and sex=#&#123;sex&#125;
            &lt;/if&gt;
        &lt;/where&gt; --&gt;
        
        &lt;!-- select eid,ename,age,sex,did from emp --&gt;
        &lt;include refid=&quot;empColumns&quot;&gt;&lt;/include&gt;
        &lt;trim prefix=&quot;where&quot; suffixOverrides=&quot;and|or&quot;&gt;
            &lt;if test=&quot;eid != null&quot;&gt;
                eid=#&#123;eid&#125; and
            &lt;/if&gt;
            &lt;if test=&quot;ename != null and ename != &#39;&#39;&quot;&gt;
                ename=#&#123;ename&#125; and
            &lt;/if&gt;
            &lt;if test=&quot;age != null&quot;&gt;
                age=#&#123;age&#125; or
            &lt;/if&gt;
            &lt;if test=&quot;sex == &#39;1&#39; or sex == &#39;0&#39;&quot;&gt;
                sex=#&#123;sex&#125;
            &lt;/if&gt;
        &lt;/trim&gt;
    &lt;/select&gt;
    
    &lt;!-- List&lt;Emp&gt; getEmpListByChoose(Emp emp); --&gt;
    &lt;!--
        &lt;choose&gt;选择某一个when或otherwise执行
            &lt;when test=&quot;&quot;&gt;&lt;/when&gt;：通过test表达式拼接SQL
            .
            .
            .
            &lt;otherwise&gt;&lt;/otherwise&gt;:当when都不符合条件，就会选择otherwise拼接SQL语句
        &lt;/choose&gt; 
     --&gt;
    &lt;select id=&quot;getEmpListByChoose&quot; resultType=&quot;Emp&quot;&gt;
        select eid,ename,age,sex from emp
        where 
        &lt;choose&gt;
            &lt;when test=&quot;eid != null&quot;&gt;
                eid = #&#123;eid&#125;
            &lt;/when&gt;
            &lt;when test=&quot;ename != null and ename != &#39;&#39;&quot;&gt;
                ename = #&#123;ename&#125;
            &lt;/when&gt;
            &lt;when test=&quot;age != null&quot;&gt;
                age = #&#123;age&#125;
            &lt;/when&gt;
            &lt;otherwise&gt;
                sex = #&#123;sex&#125;
            &lt;/otherwise&gt;
        &lt;/choose&gt;
    &lt;/select&gt;
    
    &lt;!-- void insertEmp(Emp emp); --&gt;
    &lt;insert id=&quot;insertEmp&quot;&gt;
        insert into emp(eid,ename,age,sex) values(
            null,
            #&#123;ename&#125;,
            #&#123;age&#125;,
            &lt;choose&gt;
                &lt;when test=&quot;sex == 0&quot;&gt;&#39;女&#39;&lt;/when&gt;
                &lt;when test=&quot;sex == 1&quot;&gt;&#39;男&#39;&lt;/when&gt;
                &lt;otherwise&gt;&#39;不详&#39;&lt;/otherwise&gt;
            &lt;/choose&gt;
        )
    &lt;/insert&gt;
    
    &lt;!-- void deleteMoreEmp(String eids); --&gt;
    &lt;delete id=&quot;deleteMoreEmp&quot;&gt;
        delete from emp where eid in ($&#123;value&#125;)
    &lt;/delete&gt;
    
    &lt;!-- void deleteMoreByList(List&lt;Integer&gt; eids); --&gt;
    &lt;!--
        &lt;foreach collection=&quot;eids&quot; item=&quot;&quot; close=&quot;&quot; open=&quot;&quot; separator=&quot;&quot; index=&quot;&quot;&gt;&lt;/foreach&gt;
        对一个数组或集合进行遍历
        collection:指定要遍历的集合或数组
        item:设置别名
        close:设置循环体的结束内容
        open:设置循环体的开始内容
        separator:设置每一次循环之间的分隔符
        index:若遍历的是list集合，index代表下标；若遍历的是map结合，index代表键
     --&gt;
     &lt;!--
        delete from emp where eid in ();
        delete from emp where eid = 1 or eid = 2 or eid = 3 
      --&gt;
    &lt;delete id=&quot;deleteMoreByList&quot;&gt;
        &lt;!-- delete from emp where eid in 
        &lt;foreach collection=&quot;list&quot; item=&quot;eid&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt;
            #&#123;eid&#125;
        &lt;/foreach&gt; --&gt;
        
        delete from emp where
        &lt;!-- &lt;foreach collection=&quot;list&quot; item=&quot;eid&quot; separator=&quot;or&quot;&gt;
            eid = #&#123;eid&#125;
        &lt;/foreach&gt; --&gt;
        &lt;foreach collection=&quot;eids&quot; item=&quot;eid&quot; separator=&quot;or&quot;&gt;
            eid = #&#123;eid&#125;
        &lt;/foreach&gt;
    &lt;/delete&gt;
    
    &lt;!--
        delete:
            delete from emp where eid in ();
            delete from emp where eid = 1 or eid = 2 or eid = 3 
        select:
            select * from emp where eid in ();
            select * from emp where eid = 1 or eid = 2 or eid = 3 
        update:
            把每条数据修改成相同内容
            update emp set ... where eid in ();
            update emp set ... where eid = 1 or eid = 2 or eid = 3 
            把每条数据修改成对应内容,注意必须在链接地址（url）后添加?allowMultiQueries=true
            update emp set ... where eid=1;
            update emp set ... where eid=2;
            update emp set ... where eid=3;
        insert:
            insert into emp values(),(),()
     --&gt;
     
     &lt;!-- void insertMoreByArray(Emp[] emps); --&gt;
     &lt;insert id=&quot;insertMoreByArray&quot;&gt;
        insert into emp values
        &lt;foreach collection=&quot;array&quot; item=&quot;emp&quot; separator=&quot;,&quot;&gt;
            (null,#&#123;emp.ename&#125;,#&#123;emp.age&#125;,#&#123;emp.sex&#125;,1)
        &lt;/foreach&gt;
     &lt;/insert&gt;
     
     &lt;!-- void updateMoreByArray(@Param(&quot;emps&quot;)Emp[] emps); --&gt;
     &lt;update id=&quot;updateMoreByArray&quot;&gt;
        &lt;foreach collection=&quot;emps&quot; item=&quot;emp&quot;&gt;
            update emp set ename=#&#123;emp.ename&#125;, age=#&#123;emp.age&#125;, sex=#&#123;emp.sex&#125; where eid = #&#123;emp.eid&#125;;
        &lt;/foreach&gt;
     &lt;/update&gt;
&lt;/mapper&gt;
</code></pre>
<p>4.TestDynamicSQl.java</p>
<pre><code>package com.atguigu.test;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.Test;

import com.atguigu.bean.Emp;
import com.atguigu.mapper.EmpMapper;

public class TestDynamicSQL &#123;
    @Test
    public void TestMore() throws Exception&#123;
        SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
        SqlSession sqlSession = sqlSessionFactory.openSession(true);
        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
        
        //批量删除
//        List&lt;Integer&gt; eids = new ArrayList&lt;&gt;();
//        eids.add(10);
//        eids.add(16);
//        eids.add(17);
//        mapper.deleteMoreByList(eids);//只能删除id为1的员工
        
        //批量添加
        //Emp[] emps = new Emp[3];
        //Emp[] emps = new Emp[]&#123;&#125;;
        //Emp[] emps = &#123;&#125;;
//        Emp emp1 = new Emp(null, &quot;a&quot;,23,&quot;男&quot;);
//        Emp emp2 = new Emp(null, &quot;aa&quot;,23,&quot;男&quot;);
//        Emp emp3 = new Emp(null, &quot;aaa&quot;,23,&quot;男&quot;);
//        Emp[] emps = &#123;emp1, emp2, emp3&#125;;
//        mapper.insertMoreByArray(emps);
        
        //批量修改(需要在jdbc.url后加?allowMultiQueries=true)
        //jdbc.url=jdbc:mysql://localhost:3306/ssm?allowMultiQueries=true
        Emp emp1 = new Emp(20, &quot;a1&quot;,233,&quot;女&quot;);
        Emp emp2 = new Emp(21, &quot;aa1&quot;,233,&quot;女&quot;);
        Emp emp3 = new Emp(22, &quot;aaa1&quot;,233,&quot;女&quot;);
        Emp[] emps = &#123;emp1, emp2, emp3&#125;;
        mapper.updateMoreByArray(emps);
    &#125;
    
    @Test
    public void TestChoose() throws Exception&#123;
        SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
        SqlSession sqlSession = sqlSessionFactory.openSession(true);
        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
        
        //测试1
        //Emp emp = new Emp();
//        emp.setEid(1);
//        emp.setEname(&quot;张三&quot;);
//        emp.setAge(12);
        //emp.setSex(&quot;1&quot;);
//        List&lt;Emp&gt; list = mapper.getEmpListByChoose(emp);
//        for (Emp e : list) &#123;
//            System.out.println(e);
//        &#125;
        
        //测试2
//        Emp emp = new Emp();
//        emp.setEname(&quot;张三&quot;);
//        emp.setAge(12);    
//        emp.setSex(&quot;1&quot;);
//        mapper.insertEmp(emp);
        
        Emp emp = new Emp();
        emp.setEname(&quot;张三三&quot;);
        emp.setAge(12);    
        emp.setSex(&quot;123&quot;);
        mapper.insertEmp(emp);
    &#125;
    
    @Test
    public void TestIf() throws Exception&#123;
        SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
        SqlSession sqlSession = sqlSessionFactory.openSession(true);
        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
        Emp emp = new Emp();
        //emp.setEid(1);
        emp.setEname(&quot;张三&quot;);
        emp.setAge(12);
        //emp.setSex(&quot;1&quot;);
        List&lt;Emp&gt; list = mapper.getEmpListByMoreTJ(emp);
        for (Emp e : list) &#123;
            System.out.println(e);
        &#125;
    &#125;
    
    public SqlSessionFactory getSqlSessionFactory() throws Exception&#123;
        InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
        return sqlSessionFactory;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>MyBatis</category>
        <category>动态SQL</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>动态SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Java | 动态代理</title>
    <url>/2022/03/10/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h1 id="动态代理案例-JDK-动态代理机制"><a href="#动态代理案例-JDK-动态代理机制" class="headerlink" title="动态代理案例(JDK 动态代理机制)"></a>动态代理案例(JDK 动态代理机制)</h1><p>假设我们需要通过中介租房子（告诉中介对房子的要求，由中介代我们租房子）</p>
<p><strong>JDK动态代理机制和CGLIB动态代理机制的区别</strong><br>1.JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。<br>2.就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</p>
<p><a href="https://gitee.com/victory-liao/JavaGuide/blob/main/docs/java/basis/proxy.md">动态代理和静态代理的区别、两种动态代理的区别</a><br><strong>HireRoom.java(接口)</strong></p>
<pre><code>package hireroom;

public interface HireRoom &#123;
    void hireRoom(String chaoxiang, String buju, int price);
&#125;
</code></pre>
<p><strong>HireRoomImpl.java(实现类)</strong></p>
<pre><code>package hireroom;

public class HireRoomImpl implements HireRoom&#123;

    @Override
    public void hireRoom(String chaoxiang, String buju, int price) &#123;
        System.out.println(&quot;我委托中介租一个朝向：&quot; + chaoxiang + &quot;，布局：&quot; + buju + &quot;，价格：&quot; + price + &quot;的房子&quot;);
    &#125;

&#125;
</code></pre>
<p><strong>Agency.java(中介/代理类)</strong></p>
<pre><code>package hireroom;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

public class Agency implements InvocationHandler&#123;
    private Object target;
    
    public Agency(Object target)&#123;
        this.target = target;
    &#125;
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
        System.out.println(&quot;before&quot;);
        Object result = method.invoke(target, args);
        System.out.println(&quot;after&quot;);
        return result;
    &#125;

&#125;
</code></pre>
<p><strong>AgencyFactory.java(中介/代理工厂)</strong></p>
<pre><code>package hireroom;

import java.lang.reflect.Proxy;

public class AgencyFactory &#123;
    public static Object getProxy(Object target)&#123;
        return Proxy.newProxyInstance(target.getClass().getClassLoader(), 
                target.getClass().getInterfaces(), 
                new Agency(target));
    &#125;
&#125;
</code></pre>
<p><strong>Main.java(测试)</strong></p>
<pre><code>package hireroom;

public class Main &#123;
    public static void main(String[] args) &#123;
        HireRoom hireRoom = (HireRoom) AgencyFactory.getProxy(new HireRoomImpl());
        hireRoom.hireRoom(&quot;坐南朝北&quot;, &quot;两室一厅&quot;, 200000);
    &#125;
&#125;
</code></pre>
<p><strong>运行结果1</strong><br><img src="/2022/03/10/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/1.PNG"><br>再假设我们现在又有了想通过中介租车的需求，只需要再添加租车接口和实现类，然后通过上面的代理类完成租车。这也是动态代理的优点<br><strong>HireCar.java(接口)</strong></p>
<pre><code>package hireroom;

public interface HireCar &#123;
    void hireCar(String brand, int price);
&#125;
</code></pre>
<p><strong>HireCarImpl.java(实现类)</strong></p>
<pre><code>package hireroom;

public class HireCarImpl implements HireCar&#123;

    @Override
    public void hireCar(String brand, int price) &#123;
        System.out.println(&quot;租车：&quot;+brand+price);
    &#125;

&#125;
</code></pre>
<p><strong>Main.java</strong></p>
<pre><code>package hireroom;

public class Main &#123;
    public static void main(String[] args) &#123;
        HireRoom hireRoom = (HireRoom) AgencyFactory.getProxy(new HireRoomImpl());
        hireRoom.hireRoom(&quot;坐南朝北&quot;, &quot;两室一厅&quot;, 200000);
        
        HireCar hireCar = (HireCar) AgencyFactory.getProxy(new HireCarImpl());
        hireCar.hireCar(&quot;宝马&quot;, 150000);
    &#125;
&#125;
</code></pre>
<p><strong>运行结果2</strong><br><img src="/2022/03/10/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/2.PNG"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
        <category>动态代理</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>动态代理</tag>
        <tag>JDK动态代理机制</tag>
        <tag>CGLIB动态代理机制</tag>
      </tags>
  </entry>
  <entry>
    <title>spring | 动态代理之数学计算器</title>
    <url>/2022/03/06/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B9%8B%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97%E5%99%A8/</url>
    <content><![CDATA[<h1 id="动态代理-数学计算器"><a href="#动态代理-数学计算器" class="headerlink" title="动态代理-数学计算器"></a>动态代理-数学计算器</h1><p>项目目录<br><img src="/2022/03/06/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B9%8B%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97%E5%99%A8/1.PNG"></p>
<p>1.要求<br>1）计算器能够执行加减乘除运算<br>2）日志：在程序执行期间追踪正在发生的活动<br>3）验证：希望计算器只能处理正数的运算</p>
<p>2.常规实现</p>
<pre><code>**MathI.java**
package com.atguigu.proxy;

public interface MathI &#123;
    int add(int i, int j);
    int sub(int i, int j);
    int mul(int i, int j);
    int div(int i, int j);
&#125;
</code></pre>
<p><strong>MathImpl.java</strong></p>
<pre><code>package com.atguigu.proxy;

public class MathImpl implements MathI&#123;

    @Override
    public int add(int i, int j) &#123;
        System.out.println(&quot;method:add,arguments:&quot; + i + &quot;,&quot; + j);
        System.out.println(&quot;method:add,results:&quot; + (i + j));
        return i + j;
    &#125;
    
    @Override
    public int sub(int i, int j) &#123;
        System.out.println(&quot;method:sub,arguments:&quot; + i + &quot;,&quot; + j);
        System.out.println(&quot;method:sub,results:&quot; + (i - j));
        return i - j;
    &#125;

    @Override
    public int mul(int i, int j) &#123;
        System.out.println(&quot;method:mul,arguments:&quot; + i + &quot;,&quot; + j);
        System.out.println(&quot;method:mul,results:&quot; + (i * j));
        return i * j;
    &#125;

    @Override
    public int div(int i, int j) &#123;
        System.out.println(&quot;method:div,arguments:&quot; + i + &quot;,&quot; + j);
        System.out.println(&quot;method:div,results:&quot; + (i / j));
        return i / j;
    &#125;
&#125;
</code></pre>
<p><strong>常规实现方法存在的问题</strong><br>①代码混乱：越来越多的非业务需求(日志和验证等)加入后，原有的业务方法急剧膨胀。每个方法在处理核心逻辑的同时还必须兼顾其他多个关注点。<br>②代码分散: 以日志需求为例，只是为了满足这个单一需求，就不得不在多个模块（方法）里多次重复相同的日志代码。如果日志需求发生变化，必须修改所有模块。</p>
<p>3.动态代理<br><strong>MathI.java（与2中的代码相同）</strong></p>
<p><strong>MathImpl.java(2中的代码中去掉日志信息)</strong></p>
<p><strong>MyLogger.java(日志类)</strong></p>
<p><strong>ProxyUtil.java(代理类)</strong></p>
<pre><code>package com.atguigu.proxy;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.Arrays;

public class ProxyUtil&#123;
    //代理模式：1、静态代理（代理对象真实存在，是自己写好的） 2、动态代理（动态生成代理对象，不需要自己写）
    private MathImpl mathImpl;//目标对象 目标对象类必须实现接口
    
    public ProxyUtil(MathImpl mathImpl) &#123;
        super();
        this.mathImpl = mathImpl;
    &#125;

    public Object getProxy()&#123;
        //获取当前类的类加载器用来加载代理对象所属类
        ClassLoader loader = this.getClass().getClassLoader();//动态生成代理对象就需要动态代理类，代理类的执行需要类加载器
        //获取目标对象实现的所有接口的Class，代理类会和目标对象实现相同的接口，最终通过代理对象实现功能
        Class[] interfaces = mathImpl.getClass().getInterfaces();
        
        return Proxy.newProxyInstance(loader, interfaces, new InvocationHandler()&#123;

            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
                //代理对象实现功能的方式
                try&#123;
                    MyLogger.before(method.getName(), Arrays.toString(args));
                    Object result = method.invoke(mathImpl, args);//动态代理对象实现功能（调用目标对象的方法）
                    MyLogger.after(method.getName(), result);
                    return result;
                &#125;catch (Exception e)&#123;
                    MyLogger.throwing();
                    e.printStackTrace();
                &#125;finally&#123;
                    System.out.println(&quot;哪都有我&quot;);
                &#125;
                return null;
                
            &#125;
        &#125;);
    &#125;
&#125;
</code></pre>
<p><strong>Test.java(测试类)</strong></p>
<pre><code>package com.atguigu.proxy;

public class Test &#123;

    public static void main(String[] args) &#123;
//        MathI math = new MathImpl();
//        int result = math.add(1, 1);
//        System.out.println(result);
        ProxyUtil proxy = new ProxyUtil(new MathImpl());
        
        MathI math = (MathI)proxy.getProxy();
        
        int i = math.add(1, 1);
        System.out.println(i);
        
        int j = math.div(4, 0);
        System.out.println(j);
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>spring</category>
        <category>动态代理之数学计算器</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>python | 动态查找列表中的第二个number</title>
    <url>/2021/11/05/%E5%8A%A8%E6%80%81%E6%9F%A5%E6%89%BE%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%BA%8C%E4%B8%AAnumber/</url>
    <content><![CDATA[<h1 id="动态查找列表中的第二个number"><a href="#动态查找列表中的第二个number" class="headerlink" title="动态查找列表中的第二个number"></a>动态查找列表中的第二个number</h1><p>方法：先找到第一个2所在位置fist_index，切片new_list=names[index+1:]得到新的列表，<br>再从新列表中找第一个2的位置second_index.最终第二个2的位置为first_index+second_index+1</p>
<span id="more"></span>
<p><strong>代码：</strong></p>
<pre><code>names = [&#39;apple&#39;, &#39;rice&#39;, &#39;jack&#39;, &#39;rose&#39;, 2, &#39;girl&#39;, &#39;boy&#39;, 2, &#39;heather&#39;, 2]
first_index = names.index(2)
new_list = names[first_index + 1:]
second_index = new_list.index(2)
second_loction = first_index + second_index + 1  # 第二个2的位置
print(&#39;第二个2 的位置为：&#39;, second_loction)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python | 匹配第n个分组的内容</title>
    <url>/2021/08/28/%E5%8C%B9%E9%85%8D%E7%AC%ACn%E4%B8%AA%E5%88%86%E7%BB%84%E7%9A%84%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<h1 id="1…-9"><a href="#1…-9" class="headerlink" title="\1…\9"></a>\1…\9</h1><p>\1…\9用来匹配与第n(1~9)个分组的内容，必须与()配合使用<br>例：在以下代码段中\2表示匹配第2个分组（一个括号代表一个分组）的内容，即\2匹配”world”字符串</p>
<pre><code>import re
string = &quot;helloworld world&quot;
pattern = r&#39;^(\w+)(world) \2$&#39;
print(re.search(pattern, string))
</code></pre>
<p><a href="https://www.jianshu.com/p/8a4ce87ef4b2">参考资料</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>内置模块</category>
        <category>re</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>re</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程 | 单任务服务器的缺点</title>
    <url>/2020/10/30/%E5%8D%95%E4%BB%BB%E5%8A%A1%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BC%BA%E7%82%B9/</url>
    <content><![CDATA[<h1 id="单任务服务器的缺点"><a href="#单任务服务器的缺点" class="headerlink" title="单任务服务器的缺点"></a>单任务服务器的缺点</h1><p><b style="color:red">为一个顾客服务的时候，不能为其他顾客服务</b><br><strong>注意点</strong>：accept()、recv()</p>
<span id="more"></span>

<pre><code>import socket 

serverSocket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
serverSocket.bind((&#39;&#39;,8080))
serverSocket.listen(5)

while True:
    #如果没有客户端到来，程序将阻塞等待
    clientSocket,clientAddr = serverSocket.accept()
    
    while True:
        #有一个客户端到来，将一直等待客户端发数据,若客户端一直不发数据，程序将一直卡在这里,从而造成程序不能处理新的客户端的请求
        recvData = newSocket.recv(1024)
        if data:
            print(&quot;%s:%s&quot;%(str(clientAddr),recvData))
        else:
            break
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 | 单例模式</title>
    <url>/2022/03/21/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式(Singleton)，保证一个类有一个实例，并提供一个访问它的全局访问点。</p>
<p>“通常我们可以让一个全局变量使得一个对象被访问，但它不能防止你实例化多个对象。一个最好的办法就是，让类自身保存<br>它的唯一实例。这个类可以保证没有其他实例可以被创建，并且它可以提供一个访问该实例的方法。</p>
<span id="more"></span>

<pre><code>class Singleton&#123;
    private static Singleton instance;
    
    //构造方法让其private，这就堵死了外界利用new创建此类实例的可能
    private Singleton()&#123;
        
    &#125;
    
    //此方法是获得本类实例实例的唯一全局访问点
    public static Singleton getInstance()&#123;
        //若实例不存在，则new一个新的实例，否则返回已有的实例
        if(instance == null)&#123;
            instance = new Singleton();
        &#125;
        return instance;
    &#125;
&#125;

public class SingletonTest &#123;
    public static void main(String[] args) &#123;
        Singleton instance = Singleton.getInstance();
        Singleton instance2 = Singleton.getInstance();
        //比较两侧实例化后对象的结果是实例相同
        System.out.println(instance.equals(instance2));//true
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>单例模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 单词规律</title>
    <url>/2021/09/08/%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B/</url>
    <content><![CDATA[<h1 id="290-单词规律"><a href="#290-单词规律" class="headerlink" title="290.单词规律"></a>290.单词规律</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。<br>这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。</p>
<p>示例1:<br>输入: pattern = “abba”, str = “dog cat cat dog”<br>输出: true</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/word-pattern/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.哈希表<br>在本题中，我们需要判断字符与字符串之间是否恰好一一对应。即任意一个字符都对应着唯一的字符串，任意一个字符串也只被唯一的一个字符对应。在集合论中，这种关系被称为「双射」。<br>想要解决本题，我们可以利用哈希表记录每一个字符对应的字符串，以及每一个字符串对应的字符。然后我们枚举每一对字符与字符串的配对过程，不断更新哈希表，如果发生了冲突，则说明给定的输入不满足双射关系。<br>在实际代码中，我们枚举 pattern 中的每一个字符，利用双指针来均摊线性地找到该字符在 str 中对应的字符串。每次确定一个字符与字符串的组合，我们就检查是否出现冲突，最后我们再检查两字符串是否比较完毕即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):
    def wordPattern(self, pattern, s):
        &quot;&quot;&quot;
        :type pattern: str
        :type s: str
        :rtype: bool
        &quot;&quot;&quot;
        word2ch = dict()
        ch2word = dict()
        words = s.split()
        if len(pattern) != len(words):
            return False

        for ch, word in zip(pattern, words):
            if (word in word2ch and word2ch[word] != ch) or (ch in ch2word and ch2word[ch] != word):
                return False
            word2ch[word] = ch
            ch2word[ch] = word

        return True

    def wordPattern(self, pattern, s):
        dct = dict()
        s = s.split(&#39; &#39;)
        if len(s) != len(pattern):  # 两个字符串长度不相同，返回False
            return False

        for i in range(len(pattern)):
            if pattern[i] not in dct:  # 如果pattern[i]不在字典中，此时要加入pattern[i]
                if s[i] not in dct.values():  # 如果s[i]还未存在，则加入新的映射
                    dct[pattern[i]] = s[i]
                else:
                    return False  # 但是如果与dct[pattern[i]]对应的s[i]已经存在字典的值中，说明不是唯一映射
            else:
                if dct[pattern[i]] != s[i]:  # 如果pattern[i]在字典中，但是dct[pattern[i]]的值不等于s[i]，说明已存在其他映射
                    return False
        return True



if __name__ == &#39;__main__&#39;:
    slt = Solution()
    res = slt.wordPattern1(&quot;abba&quot;, &quot;dog cat cat dog&quot;)
    print(res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>哈希表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>CNN | 卷积和卷积核</title>
    <url>/2021/11/15/%E5%8D%B7%E7%A7%AF%E5%92%8C%E5%8D%B7%E7%A7%AF%E6%A0%B8/</url>
    <content><![CDATA[<h1 id="卷积和卷积核"><a href="#卷积和卷积核" class="headerlink" title="卷积和卷积核"></a>卷积和卷积核</h1><p>1.卷积<br>原理:卷积过程就是卷积核行列对称翻转后,在图像上滑动,并且依次相乘求和.(与滤波器不同的一点就是多了一个卷积核翻转的过程).然后经过池化,激活后输入下一层.<br>单个卷积层可以提取特征,当多个卷积叠加后即可逐步学习出更高语义的抽象特征.<br>2.卷积核<br>卷积核:其中卷积核主要有两类,普通卷积核和1<em>1的卷积核.普通卷积核同时改变图像的空间域和通道域,如下图所示,每个卷积核的通道数与输入相同,<br>卷积后会得到一个通道为一的特征图,我们希望卷积后的通道数有几个,卷积核就有几个.<br>1</em>1卷积核,视野大小为单个特征位点,能够实现在空间域不改变的情况下实现通道域信息的交流,<br>并且获得我们想要的通道数量(一般是降维).</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
        <category>CNN</category>
      </categories>
      <tags>
        <tag>CNN</tag>
        <tag>卷积</tag>
        <tag>卷积核</tag>
      </tags>
  </entry>
  <entry>
    <title>CNN | 卷积的三种模式</title>
    <url>/2021/11/14/%E5%8D%B7%E7%A7%AF%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="卷积的三种模式"><a href="#卷积的三种模式" class="headerlink" title="卷积的三种模式"></a>卷积的三种模式</h1><p>通常用外部api进行卷积的时候，会面临mode选择<br>其实这三种不同模式是对卷积核移动范围的不同限制<br>设 image的大小是7x7，filter的大小是3x3</p>
<span id="more"></span>
<p><strong>full mode:</strong><br>橙色部分为image, 蓝色部分为filter。full模式的意思是，从filter和image刚相交开始做卷积，白色部分为填0。filter的运动范围如图所示。<br><img src="/2021/11/14/%E5%8D%B7%E7%A7%AF%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/1.jpg"><br><strong>same mode:</strong><br>当filter的中心(K)与image的边角重合时，开始做卷积运算，可见filter的运动范围比full模式小了一圈。注意：这里的same还有一个意思，卷积之后输出的feature map尺寸保持不变(相对于输入图片)。当然，same模式不代表完全输入输出尺寸一样，也跟卷积核的步长有关系。same模式也是最常见的模式，因为这种模式可以在前向传播的过程中让特征图的大小保持不变，调参师不需要精准计算其尺寸变化(因为尺寸根本就没变化)。<br><img src="/2021/11/14/%E5%8D%B7%E7%A7%AF%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/2.jpg"><br><strong>valid mode:</strong><br>当filter全部在image里面的时候，进行卷积运算，可见filter的移动范围较same更小了。<br><img src="/2021/11/14/%E5%8D%B7%E7%A7%AF%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/3.jpg"></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
        <category>CNN</category>
        <category>卷积的三种模式</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>CNN</tag>
        <tag>valid</tag>
        <tag>same</tag>
        <tag>full</tag>
      </tags>
  </entry>
  <entry>
    <title>CNN | 卷积神经网络之卷积计算作用与思想</title>
    <url>/2021/11/15/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B9%8B%E5%8D%B7%E7%A7%AF%E8%AE%A1%E7%AE%97%E4%BD%9C%E7%94%A8%E4%B8%8E%E6%80%9D%E6%83%B3/</url>
    <content><![CDATA[<h1 id="卷积神经网络之卷积计算作用与思想"><a href="#卷积神经网络之卷积计算作用与思想" class="headerlink" title="卷积神经网络之卷积计算作用与思想"></a>卷积神经网络之卷积计算作用与思想</h1><p><a href="https://www.cnblogs.com/shine-lee/p/9932226.html">卷积神经网络之卷积计算、作用与思想</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
        <category>CNN</category>
        <category>卷积</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>CNN</tag>
        <tag>卷积</tag>
      </tags>
  </entry>
  <entry>
    <title>CNN | 卷积神经网络如何处理一维时间序列数据</title>
    <url>/2021/10/26/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%B8%80%E7%BB%B4%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="卷积神经网络如何处理一维时间序列数据"><a href="#卷积神经网络如何处理一维时间序列数据" class="headerlink" title="卷积神经网络如何处理一维时间序列数据?"></a>卷积神经网络如何处理一维时间序列数据?</h1><p><a href="https://zhuanlan.zhihu.com/p/67496559">卷积神经网络如何处理一维时间序列数据?</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
        <category>CNN</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>CNN</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式 | 双重检验锁方式实现单例模式</title>
    <url>/2022/04/23/%E5%8F%8C%E9%87%8D%E6%A3%80%E9%AA%8C%E9%94%81%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><a href>参考资料</a></p>
<pre><code>package SingletonTest;

class Singleton&#123;
    private volatile static Singleton instance;
    
    private Singleton()&#123;
        
    &#125;
    
    public static Singleton getInstance()&#123;
        if(instance == null)&#123;
            synchronized (Singleton.class) &#123;
                if(instance == null)&#123;
                    instance = new Singleton();
                &#125;
                //instance = new Singleton();
            &#125;
        &#125;
        return instance;
    &#125;
&#125;

public class MyThread extends Thread&#123;
    @Override
    public void run()&#123;
        System.out.println(Singleton.getInstance().hashCode());
    &#125;
    
    public static void main(String[] args)&#123;
        MyThread[] myThread = new MyThread[10];
        for(int i=0;i&lt;myThread.length;i++)&#123;
            myThread[i] = new MyThread();
        &#125;
        
        for(int i=0;i&lt;myThread.length;i++)&#123;
            myThread[i].start();
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>双重锁的运行结果：</strong></p>
<pre><code>1156205522
1156205522
1156205522
1156205522
1156205522
1156205522
1156205522
1156205522
1156205522
1156205522
</code></pre>
<p><strong>去掉第二重锁的运行结果（产生了多例）：</strong></p>
<pre><code>1700548907
1486202908
1486202908
1700548907
1486202908
1486202908
1700548907
1486202908
1486202908
1700548907
</code></pre>
]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>单例模式</tag>
        <tag>双重检验锁方式实现单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java | 反射</title>
    <url>/2022/04/18/%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>1.反射<br><strong>运行时分析类</strong>并调用类中的属性和方法<br>2.反射的应用场景<br>（1）spring、springboot等<strong>框架</strong>的实现<br>（2）动态代理<br>（3）注解<br>3.反射的优缺点<br>3.1优点<br>（1）灵活<br>（2）不安全（比如无视泛型参数的安全检查）<br>3.2缺点<br>性能稍差<br>4.获取Class对象的四种方式<br>（1）类.class<br>（2）Class.forName(类的全限定名)<br>（3）Instance.getClass()<br>（4）xxxClassLoader.loadClass()</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
        <category>反射</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 反转字符串</title>
    <url>/2021/08/29/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。<br>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。<br>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p>
<span id="more"></span>
<p>示例 1：<br>输入：[“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]</p>
<p><a href="https://leetcode-cn.com/problems/reverse-string">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.字符串切片 —&gt; reversString()<br>2.使用list.reverse()方法 —&gt; reversString1()<br>3.使用reversed()函数 —&gt; reversString2()<br>4.使用栈 —&gt; reversString3()<br>将s列表看作一个栈，低端作为栈底，高端作为栈顶，依次将栈顶元素出栈即可。<br>5.for —&gt; reversString4()<br>将列表中的第i个元素与倒数第i个元素交换（0&lt; i &lt; len(s)//2）<br>6.递归 —&gt; reversString5()</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):
    def reverseString(self, s):
        &quot;&quot;&quot;
        :type s: List[str]
        :rtype: None Do not return anything, modify s in-place instead.
        &quot;&quot;&quot;
        return s[::-1]

    def reverseString1(self, s):
        s.reverse()

    def reverseString2(self, s):
        s[:] = list(reversed(s))

    def reverseString3(self, s):
        result = list()

        while len(s) &gt; 0:
            result.append(s.pop())

        s[:] = result

    def reverseString4(self, s):
        for i in range(len(s)//2):
            s[i], s[len(s) - i - 1] = s[len(s) - i - 1], s[i]

    # def reverseString5(self, s):
    #     if len(s) &lt; 1:
    #         return s
    #     return self.reverseString4(s[1:]) + s[0]
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 反转字符串2</title>
    <url>/2021/09/01/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B22/</url>
    <content><![CDATA[<h1 id="541-反转字符串2"><a href="#541-反转字符串2" class="headerlink" title="541.反转字符串2"></a>541.反转字符串2</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串 s 和一个整数 k，从字符串开头算起，每 2k 个字符反转前 k 个字符。<br>    如果剩余字符少于 k 个，则将剩余字符全部反转。<br>    如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p>
<span id="more"></span>
<p>示例 1：<br>输入：s = “abcdefg”, k = 2<br>输出：”bacdfeg”</p>
<p><a href="https://leetcode-cn.com/problems/reverse-string-ii/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>反转每个下标从 2k 的倍数开始的，长度为 k 的子串。若该子串长度不足 k，则反转整个子串</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def reverseStr(self, s: str, k: int) -&gt; str:
        t = list(s)
        for i in range(0, len(t), 2 * k):
            t[i: i + k] = reversed(t[i: i + k])
        return &quot;&quot;.join(t)


if __name__ == &#39;__main__&#39;:
    slt = Solution()
    s = &quot;abcdefg&quot;
    k = 2
    res = slt.reverseStr(s, k)  # bacdfeg
    print(res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 反转字符串中的元音字母</title>
    <url>/2021/09/01/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D/</url>
    <content><![CDATA[<h1 id="345-反转字符串中的元音字母"><a href="#345-反转字符串中的元音字母" class="headerlink" title="345.反转字符串中的元音字母"></a>345.反转字符串中的元音字母</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 s ，仅反转字符串中的所有元音字母，并返回结果字符串。<br>元音字母包括 ‘a’、’e’、’i’、’o’、’u’，且可能以大小写两种形式出现。</p>
<span id="more"></span>

<p><a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string">题目链接</a>+</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.先将字符串中的元音字母的位置找出来，然后再将各元音字母反转<br>2.双指针<br>我们可以使用两个指针 i 和 j 对字符串相向地进行遍历。<br>具体地，指针 i 初始时指向字符串 s 的首位，指针 j 初始时指向字符串 s 的末位。在遍历的过程中，我们不停地将 i 向右移动，直到 i 指向一个元音字母（或者超出字符串的边界范围）；同时，我们不停地将 j 向左移动，直到 j 指向一个元音字母。此时，如果 i&lt;j，那么我们交换 i 和 j 指向的元音字母，否则说明所有的元音字母均已遍历过，就可以退出遍历的过程。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def reverseVowels(self, s: str) -&gt; str:
        &quot;&quot;&quot;
        find ans reverse
        :param s:
        :return:
        &quot;&quot;&quot;
        vowels = list()
        s = list(s)
        for i in range(len(s)):
            ch = s[i].lower()
            if ch == &#39;a&#39; or ch == &#39;e&#39; or ch == &#39;i&#39; or ch == &#39;o&#39; or ch == &#39;u&#39;:
                vowels.append(i)

        for i in range(len(vowels)//2):
            s[vowels[i]], s[vowels[len(vowels) - i -1]] = s[vowels[len(vowels) - i -1]], s[vowels[i]]

        return &#39;&#39;.join(s)

    def reverseVowels1(self, s: str) -&gt; str:
        &quot;&quot;&quot;双指针&quot;&quot;&quot;
        def isVowel(ch: str) -&gt; bool:
            return ch in &quot;aeiouAEIOU&quot;

        n = len(s)
        s = list(s)
        i, j = 0, n - 1
        while i &lt; j:
            while i &lt; n and not isVowel(s[i]):
                i += 1
            while j &gt; 0 and not isVowel(s[j]):
                j -= 1
            if i &lt; j:
                s[i], s[j] = s[j], s[i]
                i += 1
                j -= 1

        return &#39;&#39;.join(s)


if __name__ == &quot;__main__&quot;:
    s = Solution()
    string = &quot;hello&quot;
    res = s.reverseVowels(string)
    print(res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 反转字符串中的单词3</title>
    <url>/2021/09/02/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D3/</url>
    <content><![CDATA[<h1 id="557-反转字符串中的单词3"><a href="#557-反转字符串中的单词3" class="headerlink" title="557.反转字符串中的单词3"></a>557.反转字符串中的单词3</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p>
<span id="more"></span>
<p>示例：<br>输入：”Let’s take LeetCode contest”<br>输出：”s’teL ekat edoCteeL tsetnoc”</p>
<p><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.将字符串按照空格划分开得到字符串中的每一个单词,然后将每个单词反转<br>，在将反转后的所有单词用空格拼接起来<br>2.使用额外空间<br>开辟一个新字符串。然后从头到尾遍历原字符串，直到找到空格为止，此时找到了一个单词，并能得到单词的起止位置。随后，根据单词的起止位置，可以将该单词逆序放到新字符串当中。如此循环多次，直到遍历完原字符串，就能得到翻转后的结果。<br>3.原地解法<br>此题也可以直接在原字符串上进行操作，避免额外的空间开销。当找到一个单词的时候，我们交换字符串第一个字符与倒数第一个字符，随后交换第二个字符与倒数第二个字符……如此反复，就可以在原空间上翻转单词。<br>需要注意的是，原地解法在某些语言（比如 Java，JavaScript，python）中不适用，因为在这些语言中 String 类型是一个不可变的类型。<br>在python中可以先将字符串转为列表然后进行算法设计。</p>
<p><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/solution/python-fan-zhuan-zi-fu-chuan-zhong-dan-ci-si-lu-xi/">更多思路参考“一行流”，简直牛逼！！！</a></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def reverseWords(self, s: str) -&gt; str:
        &quot;&quot;&quot;
        将字符串按照空格划分开得到字符串中的每一个单词
        将每个单词反转
        将反转后的所有单词用空格拼接起来
        &quot;&quot;&quot;
        words = s.split(&#39; &#39;)
        reversed_words = []
        for word in words:
            reversed_words.append(self.reverseStr(word))
        return &#39; &#39;.join(reversed_words)

    def reverseStr(self, s: str) -&gt; str:
        s = list(s)
        s[:] = s[::-1]
        return &#39;&#39;.join(s)

    def reverseWords2(self, s: str) -&gt; str:
        &quot;&quot;&quot;使用额外空间&quot;&quot;&quot;
        ret = &#39;&#39;
        length = len(s)
        i = 0
        while i &lt; length:
            start = i
            # 遍历字符串找到空格位置（找到了一个单词）
            while i &lt; length and s[i] != &#39; &#39;:
                i += 1
            # 根据单词的起止位置，可以将该单词逆序放到新字符串当中
            for p in range(start, i):
                ret += s[start + i - 1 - p]
            # 拼上单词后的空格
            while i &lt; length and s[i] == &#39; &#39;:
                i += 1
                ret += &#39; &#39;

        return ret

    def reverseWords3(self, s: str) -&gt; str:
        s = list(s)  # python中字符串为不可变类型，不支持原地修改，可转列表
        length = len(s)
        i = 0
        while i &lt; length:
            start = i

            while i &lt; length and s[i] != &#39; &#39;:
                i += 1

            left = start
            right = i - 1
            while left &lt; right:
                s[left], s[right] = s[right], s[left]
                left += 1
                right -= 1

            while i &lt; length and s[i] == &#39; &#39;:
                i += 1
        return &#39;&#39;.join(s)


if __name__ == &quot;__main__&quot;:
    slt = Solution()
    s = &quot;Let&#39;s take LeetCode contest&quot;
    res = slt.reverseWords3(s)
    print(&quot;反转单词后的字符串：&quot;, res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 反转链表</title>
    <url>/2021/08/27/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.递归<br>递：将大问题分解为小问题，将整个链表依次拆解直到只剩下一个节点<br>归：在链表只剩下一个节点时开始”归“，使用head.next.next = head,head.next = None这两行代码从后往前（从原链表的视角看）将链表中的每一个连接改为反向的<br>2.迭代<br>假设链表为 1→2→3→∅，我们想要把它改成 ∅←1←2←3。<br>在遍历链表时，将当前节点的 next 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。<br>3.头插法<br>首先创建一个只有头节点的反转链表，从头到尾遍历原链表，将每次遍历到的节点按照头插法插入反转链表中，以此类推，当我们遍历完整个链表时就得到一个反转链表。<br>头插法：即每次都将将要插入的节点作为链表的首节点（不是头节点）<br>头插法代码实现：</p>
<pre><code>node.next = head.next
head.next = node
</code></pre>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def reverseList(self, head):
        &quot;&quot;&quot;
        迭代法

        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        # if not head:
        #     return head
        #
        # p = head
        #
        # reversed = ListNode()
        # while p is not None:
        #     node = ListNode(p.val)
        #     node.next = reversed.next
        #     reversed.next = node
        #
        #     p = p.next
        #
        # return reversed.next

        prev = None
        curr = head
        while curr is not None:
            next = curr.next
            curr.next = prev
            prev = curr
            curr = next
        return prev

    def reverseList1(self, head):
        &quot;&quot;&quot;
        递归法

        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        if not head or not head.next:
            return head
        new_head = self.reverseList1(head.next)
        head.next.next = head
        head.next = None
        return new_head

    def reverseList2(self, head):
        &quot;&quot;&quot;
        头插法

        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        if not head:
            return head

        p = head

        reversed = ListNode()
        while p is not None:
            node = ListNode(p.val)
            node.next = reversed.next
            reversed.next = node

            p = p.next

        return reversed.next

    def create_linked_list(self, list):
        &quot;&quot;&quot;根据list中的所有元素构建单链表&quot;&quot;&quot;
        l = ListNode()  # 单链表头节点
        r = l  # 起始尾指针r指向头节点
        for e in list:
            node = ListNode(e)
            r.next = node
            r = r.next

        return l.next

    def print_linked_list(self, linked_list) -&gt; None:
        &quot;&quot;&quot;
        打印单链表中的所有元素

        :param linked_list: 单链表
        :return: 无
        &quot;&quot;&quot;
        print(&quot;----------------------------------------&quot;)
        pointer = linked_list
        while pointer is not None:
            print(pointer.val)
            pointer = pointer.next


if __name__ == &quot;__main__&quot;:
    slt = Solution()

    linked_list = slt.create_linked_list([1, 2, 3, 4, 5])

    slt.print_linked_list(linked_list)

    reversed_linked_list = slt.reverseList1(linked_list)

    slt.print_linked_list(reversed_linked_list)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>openpyxl | 合并excel表格中上下行内容相同的单元格</title>
    <url>/2021/10/21/%E5%90%88%E5%B9%B6excel%E8%A1%A8%E6%A0%BC%E4%B8%AD%E4%B8%8A%E4%B8%8B%E8%A1%8C%E5%86%85%E5%AE%B9%E7%9B%B8%E5%90%8C%E7%9A%84%E5%8D%95%E5%85%83%E6%A0%BC/</url>
    <content><![CDATA[<h1 id="合并excel表格中上下行内容相同的单元格"><a href="#合并excel表格中上下行内容相同的单元格" class="headerlink" title="合并excel表格中上下行内容相同的单元格"></a>合并excel表格中上下行内容相同的单元格</h1><p>以下代码实现自动合并excel表格中上下行内容相同的单元格</p>
<span id="more"></span>
<pre><code># 获取Excel表格中的数据
from openpyxl import load_workbook  # 用于读取Excel中的信息


def merge_cells(ws, target_list, start_row, col):
    &quot;&quot;&quot;
    ws: 是需要操作的工作表
    target_list: 是目标列表，即含有重复数据的列表
    start_row: 是开始行，即工作表中开始比对数据的行（需要将标题除开）
    col: 是需要处理数据的列
    &quot;&quot;&quot;
    start = 0  # 开始行计数，初试值为0，对应列表中的第1个元素的位置0
    end = 0  # 结束行计数，初试值为0，对应列表中的第1个元素的位置0
    reference = target_list[0]  # 设定基准，以列表中的第一个字符串开始
    for i in range(len(target_list)):  # 遍历列表
        if target_list[i] != reference:  # 开始比对，如果内容不同执行如下
            reference = target_list[i]  # 基准变成列表中下一个字符串
            end = i - 1  # 列计数器
            ws.merge_cells(col + str(start + start_row) + &quot;:&quot; + col + str(end + start_row))
            start = end + 1
        if i == len(target_list) - 1:  # 遍历到最后一行，按如下操作
            end = i
            ws.merge_cells(col + str(start + start_row) + &quot;:&quot; + col + str(end + start_row))


wb = load_workbook(&#39;产品清单.xlsx&#39;)
sheet_names = wb.get_sheet_names()
for sheet_name in sheet_names:  # 遍历每个工作表，抓取数据，并根据要求合并单元格
    ws = wb[sheet_name]
    customer_list = []  # 客户名称
    pn_list = []  # 产品编码

    for row in range(6, ws.max_row - 2):
        customer = ws[&#39;B&#39; + str(row)].value
        pn = ws[&#39;C&#39; + str(row)].value
        customer_list.append(customer)
        pn_list.append(pn)

    # 调用以上定义的合并单元格函数`Merge_cells`做单元格合并操作
    start_row = 6  # 开始行是第六行
    merge_cells(ws, customer_list, start_row, &quot;B&quot;)  # &quot;B&quot; - 客户名称是在B列
    merge_cells(ws, pn_list, start_row, &quot;C&quot;)  # &quot;C&quot; - 产品编码是在C列

wb.save(&quot;产品清单-合并单元.xlsx&quot;)
</code></pre>
<p><a href="产品清单.xlsx">产品清单.xlsx</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>openpyxl</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>openpyxl</tag>
      </tags>
  </entry>
  <entry>
    <title>python-docx | 合并word表格中上下行那内容相同的单元格</title>
    <url>/2021/10/21/%E5%90%88%E5%B9%B6word%E8%A1%A8%E6%A0%BC%E4%B8%AD%E4%B8%8A%E4%B8%8B%E8%A1%8C%E9%82%A3%E5%86%85%E5%AE%B9%E7%9B%B8%E5%90%8C%E7%9A%84%E5%8D%95%E5%85%83%E6%A0%BC/</url>
    <content><![CDATA[<h1 id="合并word表格中上下行那内容相同的单元格"><a href="#合并word表格中上下行那内容相同的单元格" class="headerlink" title="合并word表格中上下行那内容相同的单元格"></a>合并word表格中上下行那内容相同的单元格</h1><p>以下代码实现自动合并excel表格中上下行内容相同的单元格</p>
<span id="more"></span>
<pre><code>from docx import Document


# 定义合并单元格的函数
def Merge_cells(table, target_list, start_row, col):
    &quot;&quot;&quot;
    table: 是需要操作的表格
    target_list: 是目标列表，即含有重复数据的列表
    start_row: 是开始行，即表格中开始比对数据的行（需要将标题除开）
    col: 是需要处理数据的列
    &quot;&quot;&quot;
    start = 0  # 开始行计数
    end = 0  # 结束行计数
    reference = target_list[0]  # 设定基准，以列表中的第一个字符串开始
    for i in range(len(target_list)):  # 遍历列表
        if target_list[i] != reference:  # 开始比对，如果内容不同执行如下
            reference = target_list[i]  # 基准变成列表中下一个字符串
            end = i - 1
            table.cell(start + start_row, col).merge(table.cell(end + start_row, col))
            start = end + 1
        if i == len(target_list) - 1:  # 遍历到最后一行，按如下操作
            end = i
            table.cell(start + start_row, col).merge(table.cell(end + start_row, col))


doc = Document(&quot;收货记录.docx&quot;)
# 读取word文档中的第一个表格的第二和第三列除标题和尾部总数行的数据
table = doc.tables[0]  # 已确定是第一个表格，其索引是0
supplier = []  # 存储供应商名称
pn = []  # 存储物料编码
max_row = len(table.rows)  # 获取第最大一行

# 读取第二行到29行，第2，3列中的数据
for i in range(1, max_row - 1):
    supplier_name = table.rows[i].cells[1].text  # cells[1]指表格第二列
    supplier.append(supplier_name)

for i in range(1, max_row - 1):
    material_pn = table.rows[i].cells[2].text  # cells[2]指表格第三列
    pn.append(material_pn)

Merge_cells(table, supplier, 1, 1)  # 开始合并行为2，索引为1；供应商名称是在2列，索引为1
Merge_cells(table, pn, 1, 2)  # 开始合并行为2，索引为1；物料编码是在3列，索引为2

# 重新往第2和第3列写入数据，以覆盖之前重复的数据
for row in range(1, len(supplier) + 1):
    table.cell(row, 1).text = supplier[row - 2]
    table.cell(row, 2).text = pn[row - 2]
doc.save(&quot;收货记录-合并单元格.docx&quot;)
</code></pre>
<p><a href="收货记录.docx">收货记录.docx</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>python-docx</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python-docx</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 合并两个有序链表</title>
    <url>/2021/08/27/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21.合并两个有序链表"></a>21.合并两个有序链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>方法1：递归<br>如果 l1 或者 l2 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束。<br>方法2：迭代<br>当 l1 和 l2 都不是空链表时，判断 l1 和 l2 哪一个链表的头节点的值更小，将较小值的节点添加到结果里，当一个节点被添加到结果里之后，将对应链表中的节点向后移一位。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def mergeTwoLists(self, l1, l2):
        &quot;&quot;&quot;
        迭代法

        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        if l1 is None:
            return l2
        elif l2 is None:
            return l1
        else:
            p = l1
            q = l2
            l3 = ListNode()
            r = l3  # r表示l3单链表的尾指针

            while p and q:  # 注意：此处的循环判断条件为 p and q
                if p.val &lt;= q.val:  # p指针指向的元素小，将此元素并入结果链表
                    node = ListNode(p.val)

                    # 尾插法构建链表
                    r.next = node
                    r = r.next

                    # 工作指针指向当前链表中的下一个节点
                    p = p.next
                else:  # q指针指向的元素小，将此元素并入结果链表
                    node = ListNode(q.val)
                    r.next = node
                    r = r.next

                    q = q.next
            if p is not None:
                r.next = p
            elif q is not None:
                r.next = q

            return l3.next

    def mergeTwoLists1(self, l1, l2):  # 1 2 3   1 3 4
        &quot;&quot;&quot;
        递归法
        &quot;&quot;&quot;
        if l1 is None:
            return l2
        elif l2 is None:
            return l1
        elif l1.val &lt; l2.val:
            l1.next = self.mergeTwoLists1(l1.next, l2)
            return l1
        else:
            l2.next = self.mergeTwoLists1(l1, l2.next)
            return l2

    def len_linked_list(self, linked_list):
        &quot;&quot;&quot;
        返回单链表的长度
        :param linked_list:需要返回其长度的单链表
        :return:单链表的长度
        &quot;&quot;&quot;
        p = linked_list

        n = 0
        while p is not None:
            n += 1
            p = p.next

        return n

    def print_linked_list(self, linked_list) -&gt; None:
        &quot;&quot;&quot;
        打印单链表中的所有元素

        :param linked_list: 单链表
        :return: 无
        &quot;&quot;&quot;
        print(&quot;----------------------------------------&quot;)
        pointer = linked_list
        while pointer is not None:
            print(pointer.val)
            pointer = pointer.next

    def create_linked_list(self, list):
        &quot;&quot;&quot;根据list中的所有元素构建单链表&quot;&quot;&quot;
        l = ListNode()  # 单链表头节点
        r = l  # 起始尾指针r指向头节点
        for e in list:
            node = ListNode(e)
            r.next = node
            r = r.next

        return l.next


if __name__ == &quot;__main__&quot;:
    slt = Solution()

    l1 = slt.create_linked_list([1, 2, 4])
    l2 = slt.create_linked_list([1, 3, 4])

    slt.print_linked_list(l1)
    slt.print_linked_list(l2)

    l3 = slt.mergeTwoLists1(l1, l2)

    slt.print_linked_list(l3)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>python-docx | 向Word文档中添加图片</title>
    <url>/2021/10/24/%E5%90%91Word%E6%96%87%E6%A1%A3%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h1 id="向Word文档中添加图片"><a href="#向Word文档中添加图片" class="headerlink" title="向Word文档中添加图片"></a>向Word文档中添加图片</h1><p>以下代码使用python-docx向Word文档中的指定位置添加图片</p>
<span id="more"></span>
<pre><code># 提取Excel表中的数据
from openpyxl import load_workbook  # 用于读取Excel中的信息

wb = load_workbook(&#39;数据.xlsx&#39;)
ws = wb.active
data = []
for row in range(2, ws.max_row + 1):
    number = ws[&#39;A&#39; + str(row)].value
    problem = ws[&#39;B&#39; + str(row)].value
    owner = ws[&#39;C&#39; + str(row)].value
    info_list = [number, problem, owner]
    data.append(info_list)

# print(data)

from docx import Document
from docx.shared import Cm
import os

doc = Document(&quot;6S稽查问题模板.docx&quot;)

# 将图片按修改时间排序(这样才能与图片的描述一致)，将路径存入列表，以便后面逐个插入图片时调用
path = &quot;6s_pictures&quot;
list_p = [path + &quot;\\&quot; + i for i in os.listdir(path)]  # 获取图片的文件名,并拼接完整路径
list_p.sort(key=lambda path: os.path.getmtime(path))  # 将列表中的文件按其修改时间排序，os.path.getmtime() 函数是获取文件最后修改时间

table = doc.tables[0]  # 已确定是第一个表格，其索引是0

# 增加需要的行，以便足够填入数据
for i in range(len(data) - 1):
    table.add_row()

# 写入数据及图片
for row in range(1, len(data) + 1):
    table.cell(row, 0).text = str(data[row - 1][0])  # 往第1列写入序号
    table.cell(row, 1).text = data[row - 1][1]  # 往第2列写入问题描述
    table.cell(row, 3).text = data[row - 1][2]  # 往第4列写入责任部门

    # 插入图片并调整图片的高度和宽度，以适合模板中的单元格尺寸
    run = table.cell(row, 2).paragraphs[0].add_run()  # 新增一个文字块
    picture = run.add_picture(list_p[row - 1])  # 插入图片
    picture.height = Cm(4.4)  # 设置图片高度
    picture.width = Cm(6.2)  # 设置图片宽度

doc.save(&quot;6S稽查问题.docx&quot;)
</code></pre>
<p><a href="6S稽查问题模板.docx">6S稽查问题模板.docx</a><br><a href="数据.xlsx">数据.xlsx</a><br><a href="https://github.com/victory-liao/victory-liao.github.io/tree/master/source/images/6s_pictures">6s_pictures</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>python-docx</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python-docx</tag>
        <tag>openpyxl</tag>
      </tags>
  </entry>
  <entry>
    <title>python-docx | 向word中的表格写入数据</title>
    <url>/2021/10/24/%E5%90%91word%E4%B8%AD%E7%9A%84%E8%A1%A8%E6%A0%BC%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="向word中的表格写入数据"><a href="#向word中的表格写入数据" class="headerlink" title="向word中的表格写入数据"></a>向word中的表格写入数据</h1><p>以下代码实现一键往word文档的表格中填写数据。</p>
<span id="more"></span>

<pre><code># 从Excel表中提取数据
from openpyxl import load_workbook

wb = load_workbook(&quot;收货数据.xlsx&quot;)
ws = wb.active
data = []
for row in range(2, ws.max_row + 1):
    seq = ws[&quot;A&quot; + str(row)].value
    supplier = ws[&quot;B&quot; + str(row)].value
    material_pn = ws[&quot;C&quot; + str(row)].value
    material_model = ws[&quot;D&quot; + str(row)].value
    desp = ws[&quot;E&quot; + str(row)].value
    qty = ws[&quot;F&quot; + str(row)].value
    date = ws[&quot;G&quot; + str(row)].value.date()
    info = [seq, supplier, material_pn, material_model, desp, qty, date]
    data.append(info)


# 定义数量加总函数
def Sum_list(list):
    s = 0
    for i in list:  # 累加列表中的所有数
        s += i
    return s


# 加总数量列的所有数字
qty_list = []
for i in data:
    qty_list.append(i[5])  # 数量在内层列表的第6个位置，索引是5
sum_qty = Sum_list(qty_list)  # 调用加总函数加总


# 定义合并单元格的函数
def Merge_cells(table, target_list, start_row, col):
    &#39;&#39;&#39;
    table: 是需要操作的表格
    target_list: 是目标列表，即含有重复数据的列表
    start_row: 是开始行，即表格中开始比对数据的行（需要将标题除开）
    col: 是需要处理数据的列
    &#39;&#39;&#39;
    start = 0  # 开始行计数
    end = 0  # 结束行计数
    reference = target_list[0]  # 设定基准，以列表中的第一个字符串开始
    for i in range(len(target_list)):  # 遍历列表
        if target_list[i] != reference:  # 开始比对，如果内容不同执行如下
            reference = target_list[i]  # 基准变成列表中下一个字符串
            end = i - 1
            table.cell(start + start_row, col).merge(table.cell(end + start_row, col))
            start = end + 1
        if i == len(target_list) - 1:  # 遍历到最后一行，按如下操作
            end = i
            table.cell(start + start_row, col).merge(table.cell(end + start_row, col))


# 数据提取即处理完毕后，就可以往Word的表格中写入数据了
from docx import Document

doc = Document(&quot;收货记录模板.docx&quot;)
# 读取word文档中的第一个表格的第二和第三列除标题和尾部总数行的数据
table = doc.tables[0]  # 已确定是第一个表格，其索引是0
supplier = []  # 存储供应商名称
pn = []  # 存储物料编码
for i in data:
    supplier.append(i[1])
    pn.append(i[2])
# 按需增加行，以便填写数据
for i in range(len(supplier)):  # 模板中已经有一行了，所以总共只需增加len(supplier)行
    table.add_row()
# 增加好行后先做合并单元格操作
Merge_cells(table, supplier, 1, 1)  # 开始合并行为2，索引为1；供应商名称是在2列，索引为1
Merge_cells(table, pn, 1, 2)  # 开始合并行为2，索引为1；物料编码是在3列，索引为2

# 写入数据到表格
for row in range(1, len(supplier) + 1):
    for col in range(7):
        table.cell(row, col).text = str(data[row - 1][col])

max_row = len(table.rows)  # 获取最大一行
qty_row = max_row - 1  # 确定需要写入加总数据的一行
table.cell(qty_row, 5).merge(table.cell(qty_row, 6))  # 合并右下角用于填写数量的两个单元格
table.cell(qty_row, 4).text = &#39;总数：&#39;
table.cell(qty_row, 5).text = str(sum_qty)

doc.save(&quot;收货记录3.docx&quot;)
</code></pre>
<p><a href="收货数据.xlsx">收货数据.xlsx</a><br><a href="收货记录模板.docx">收货记录模板.docx</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>python-docx</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python-docx</tag>
        <tag>openpyxl</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 吴恩达课后作业</title>
    <url>/2021/06/23/%E5%90%B4%E6%81%A9%E8%BE%BE%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<h1 id="吴恩达课后作业"><a href="#吴恩达课后作业" class="headerlink" title="吴恩达课后作业"></a>吴恩达课后作业</h1><p>这是在b站学习吴恩达深度学习课程时发现的课后作业实现，非常详细！！！点赞！！！</p>
<p><a href="https://blog.csdn.net/u013733326/article/details/79827273">链接：吴恩达深度学习课后作业</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>吴恩达</tag>
      </tags>
  </entry>
  <entry>
    <title>python | 命名空间查找顺序</title>
    <url>/2021/11/07/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%9F%A5%E6%89%BE%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="命名空间查找顺序"><a href="#命名空间查找顺序" class="headerlink" title="命名空间查找顺序"></a>命名空间查找顺序</h1><h2 id="命名空间的三种形式"><a href="#命名空间的三种形式" class="headerlink" title="命名空间的三种形式"></a>命名空间的三种形式</h2><p>1.内置命名空间（Built-in names）： 用于存放Python 的内置函数的空间，比如，print，input等不需要定义即可使用的函数就处在内置命名空间。<br>2.全局命名空间（Global names）：模块中定义的名称，记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。<br>3.局部命名空间（Local names）：函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量。在函数内定义的局部变量，在函数执行结束后就会失效，即无法在函数外直接调用函数内定义的变量。<br><img src="/2021/11/07/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%9F%A5%E6%89%BE%E9%A1%BA%E5%BA%8F/namespace.png"></p>
<span id="more"></span>
<p>##命名空间查找顺序<br>局部命名空间→全局命名空间→内置命名空间。</p>
<h2 id="命名空间的生命周期"><a href="#命名空间的生命周期" class="headerlink" title="命名空间的生命周期"></a>命名空间的生命周期</h2><p>命名空间的生命周期取决于对象的作用域，如果对象执行完成，则该命名空间的生命周期就结束。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code># 在全局命名空间中给变量a赋值，令a=1。
a = 1

# 在定义函数“function1”的同时就为其创建了一个独立的局部命名空间。
def function1():
    # 变量b在局部命名空间中被赋值“a+1”。
    b = a + 1
    # 此处所使用的print函数就是源自Python的内置命名空间。
    print(b)
    
# 执行function1时，计算机会优先找到function1局部命名空间中的“b=a+1”，然后再找到全局命名空间中的“a=1”，最后找到内置命名空间中的print将b的值打印出来。
function1()   
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
        <category>命名空间</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>命名空间</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 9.回文数</title>
    <url>/2022/07/09/%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    <content><![CDATA[<h1 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9.回文数"></a>9.回文数</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。<br>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。<br>例如，121 是回文，而 123 不是。<br><a href="https://leetcode.cn/problems/palindrome-number">题目链接</a></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.使用栈判断是否回文<br>先将每位数字依次入栈，再将栈中的所有数字依次出栈，如果入栈的数字序列与出战的数字序列相同，则该数为回文数。<br>2.将整数x转化为字符串<br>将整数x转化为字符串，将字符串反转，如果原字符串与反转字符串相等，则该数为回文数。<br>3.反转一半数字<br>反转后一半数字，并将其与前半部分数字进行比较，如果二者相同，则该数为回文数。<br>如何知道反转数字的位数已经达到原始数字位数的一半？当原始数字小于或等于反转后的数字时，就意味着我们已经处理了<br>一半位数的数字了。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):
    def isPalindrome2(self, x):
        &quot;&quot;&quot;
        使用栈实现回文
        
        先将每位数字依次入栈，再将栈中的所有数字依次出栈，如果入栈的数字序列与出战的数字序列相同，则该数为回文数。
        &quot;&quot;&quot;
        if x &lt; 0:  # 负数肯定不是回文数
            return False
        xCopy = x
        stack = list()
        while x != 0:
            stack.append(x % 10)
            x = x // 10
            
        stack = stack[::-1]  # 从个位数开始取每位数字比较方便，但是入栈的数字序列与原数字序列相反，故反转栈
        
        revertedNumber = 0
        while stack:
            revertedNumber = revertedNumber * 10 + stack.pop()
        
        if xCopy == revertedNumber:
            return True
        else:
            return False
    
    def isPalindrome1(self, x):
        x = str(x)
        return x == x[::-1]
    
    def isPalindrome(self, x):
        &quot;&quot;&quot;
        特殊情况：
        1.当x&lt;0时，x不是回文数
        2.如果数字的最后一位是0，为了使该数字为回文，则
          其第一位数字也应该是0，只有0满足
        &quot;&quot;&quot;
        if x &lt; 0 or (x % 10 == 0 and x != 0):
            return False
        
        revertedNumber = 0
        while x &gt; revertedNumber:
            revertedNumber = (revertedNumber * 10) + (x % 10)
            x //= 10
            
        # 当数字长度为奇数时，我们可以通过revertedNumber/10去除位于中位的数字。
        # 例如，当输入为12321时，在while循环末尾我们可以得到x=12，revertedNumber=123,
        # 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。
        return x == revertedNumber or x == revertedNumber // 10
    
if __name__ == &quot;__main__&quot;:
    slt = Solution()
    # res = slt.isPalindrome(12321)
    # res = slt.isPalindrome1(12321)
    res = slt.isPalindrome2(12321)
    print(&quot;是回文数&quot; if res else &quot;不是回文数&quot;)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>回文</category>
        <category>9.回文数</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>回文数</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 回文链表</title>
    <url>/2021/08/27/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234.回文链表"></a>234.回文链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.按照原链表构建一个反向链表，如果两个链表完全相同则为回文链表<br>2.将原链表中的所有节点的val顺序存储在数组中后使用双指针（array[::] == array[::-1]）<br>3.递归<br>4.快慢指针<br>将链表的后半部分反转，然后将前半部分和后半部分进行比较。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):

    def isPalindrome(self, head):
        &quot;&quot;&quot;
        按照原链表构建一个反向链表，如果两个链表完全相同则为回文链表
        :type head: ListNode
        :rtype: bool
        &quot;&quot;&quot;
        # p = head
        # reversed = ListNode()
        # while p is not None:
        #     node = ListNode(p.val)
        #     node.next = reversed.next
        #     reversed.next = node
        #
        #     p = p.next
        #
        # p1 = head
        # p2 = reversed.next
        # while p1 and p2:
        #     if p1.val == p2.val:
        #         p1 = p1.next
        #         p2 = p2.next
        #     else:
        #         break
        # if p1 is None and p2 is None:
        #     return True
        # else:
        #     return False

        reversed = self.reverseList(head)
        p1 = head
        p2 = reversed
        while p1 and p2:
            if p1.val == p2.val:
                p1 = p1.next
                p2 = p2.next
            else:
                break
        if p1 is None and p2 is None:
            return True
        else:
            return False

    def isPalindrome1(self, head):
        &quot;&quot;&quot;
        将原链表中的所有节点的val顺序存储在数组中后使用双指针
        :type head: ListNode
        :rtype: bool
        &quot;&quot;&quot;
        p = head
        vals = []
        while p:
            vals.append(p.val)
            p = p.next
        return vals[::] == vals[::-1]

    def isPalindrome2(self, head):
        &quot;&quot;&quot;
        递归法

        :type head: ListNode
        :rtype: bool
        &quot;&quot;&quot;
        self.front_pointer = head

        def recursively_check(current_node=head):
            if current_node is not None:
                if not recursively_check(current_node.next):
                    return False
                if self.front_pointer.val != current_node.val:
                    return False
                self.front_pointer = self.front_pointer.next

            return True

        return recursively_check()

    def isPalindrome3(self, head):
        &quot;&quot;&quot;
        快慢指针
        将链表的后半部分反转（修改链表结构），然后将前半部分和后半部分进行比较。

        :type head: ListNode
        :rtype: bool
        &quot;&quot;&quot;
        if head is None:
            return True

        # 找到前半部分链表的尾节点并反转后半部分链表
        first_half_end = self.end_of_first_half(head)
        second_half_start = self.reverseList(first_half_end.next)

        # 判断是否回文
        result = True
        first_position = head
        second_position =second_half_start

        while result and second_position is not None:
            if first_position.val != second_position.val:
                result = False
            first_position = first_position.next
            second_position = second_position.next

        # 还原链表并返回结果
        first_half_end.next = self.reverseList((second_half_start))
        return result

    def end_of_first_half(self, head):
        fast = head
        slow = head

        while fast.next is not None and fast.next.next is not None:
            fast = fast.next.next
            slow = slow.next

        return slow

    def reverseList(self, head):
        &quot;&quot;&quot;
        递归法反转链表

        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        if not head or not head.next:
            return head
        new_head = self.reverseList(head.next)
        head.next.next = head
        head.next = None
        return new_head

    def create_linked_list(self, list):
        &quot;&quot;&quot;根据list中的所有元素构建单链表&quot;&quot;&quot;
        l = ListNode()  # 单链表头节点
        r = l  # 起始尾指针r指向头节点
        for e in list:
            node = ListNode(e)
            r.next = node
            r = r.next

        return l.next

    def print_linked_list(self, linked_list) -&gt; None:
        &quot;&quot;&quot;
        打印单链表中的所有元素

        :param linked_list: 单链表
        :return: 无
        &quot;&quot;&quot;
        print(&quot;----------------------------------------&quot;)
        pointer = linked_list
        while pointer is not None:
            print(pointer.val)
            pointer = pointer.next


if __name__ == &quot;__main__&quot;:
    slt = Solution()

    linked_list = slt.create_linked_list([1, 2, 2, 1])

    slt.print_linked_list(linked_list)

    res = slt.isPalindrome3(linked_list)
    print(res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>openpyxl | 在Excel中按条件筛选数据并存入新的表</title>
    <url>/2021/10/25/%E5%9C%A8Excel%E4%B8%AD%E6%8C%89%E6%9D%A1%E4%BB%B6%E7%AD%9B%E9%80%89%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%AD%98%E5%85%A5%E6%96%B0%E7%9A%84%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="在Excel中按条件筛选数据并存入新的表"><a href="#在Excel中按条件筛选数据并存入新的表" class="headerlink" title="在Excel中按条件筛选数据并存入新的表"></a>在Excel中按条件筛选数据并存入新的表</h1><p>实现代码：</p>
<pre><code># 1.获取满足条件的数据
from openpyxl import load_workbook

wb = load_workbook(&quot;每月物料表.xlsx&quot;)
data = &#123;&#125;  # 储存所有工作表中满足条件的数据，以工作表名称为键
sheet_names = wb.sheetnames
for sheet_name in sheet_names:
    ws = wb[sheet_name]
    qty_list = []
    # 获取G列的数据，并用enumrate给其对应的元素编号
    for row in range(2, ws.max_row + 1):
        qty = ws[&#39;G&#39; + str(row)].value
        qty_list.append(qty)
    # print(qty_list)

    qty_idx = list(enumerate(qty_list))  # 用于编号

    # 判断数据是否大于1000，然后返回大于1000的数据所对应的行数
    row_idx = []  # 用于储存数量大于1000所对应的的行号
    for i in range(len(qty_idx)):
        if qty_idx[i][1] &gt; 1000:
            row_idx.append(qty_idx[i][0] + 2)
    # print(row_idx)

    # 获取满足条件的数据
    data_morethan1K = []
    for i in row_idx:
        data_morethan1K.append(ws[&#39;A&#39; + str(i) + &quot;:&quot; + &#39;I&#39; + str(i)])

    # print(data_morethan1K)

    data[sheet_name] = data_morethan1K

# 2.写入获取的数据
from openpyxl.styles import Border, Side, PatternFill, Font, GradientFill, Alignment

thin = Side(border_style=&quot;thin&quot;, color=&quot;000000&quot;)  # 定义边框粗细及颜色

wb = load_workbook(&quot;模板.xlsx&quot;)
ws = wb.active
for month in data.keys():
    ws_new = wb.copy_worksheet(ws)  # 复制模板中的工作表
    ws_new.title = month
    print(ws_new.title)
    # 将每个月的数据条数逐个取出并写入新的工作表
    for i in range(len(data[month])):  # 按数据行数计数，每行数据对应9列，所以每行需分别写入9个单元格
        ws_new.cell(row=i + 2, column=1).value = data[month][i][0][0].value
        ws_new.cell(row=i + 2, column=2).value = data[month][i][0][1].value
        ws_new.cell(row=i + 2, column=3).value = data[month][i][0][2].value
        ws_new.cell(row=i + 2, column=4).value = data[month][i][0][3].value.date()
        ws_new.cell(row=i + 2, column=5).value = data[month][i][0][4].value
        ws_new.cell(row=i + 2, column=6).value = data[month][i][0][5].value
        ws_new.cell(row=i + 2, column=7).value = data[month][i][0][6].value
        ws_new.cell(row=i + 2, column=8).value = data[month][i][0][7].value
        ws_new.cell(row=i + 2, column=9).value = data[month][i][0][8].value

    # 设置字号，对齐，缩小字体填充，加边框
    # Font(bold=True)可加粗字体

    for row_number in range(2, ws_new.max_row + 1):
        for col_number in range(1, 10):
            c = ws_new.cell(row=row_number, column=col_number)
            c.font = Font(size=10)
            c.border = Border(top=thin, left=thin, right=thin, bottom=thin)
            c.alignment = Alignment(horizontal=&quot;left&quot;, vertical=&quot;center&quot;, shrink_to_fit=True)
wb.save(&quot;每月(大于1K).xlsx&quot;)
</code></pre>
<p><a href="模板.xlsx">模板.xlsx</a><br><a href="每月物料表.xlsx">每月物料表.xlsx</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>openpyxl</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>openpyxl</tag>
      </tags>
  </entry>
  <entry>
    <title>python | 在python代码中使用c语言编写的函数</title>
    <url>/2020/10/16/%E5%9C%A8python%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%BD%BF%E7%94%A8c%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E7%9A%84%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="在python代码中使用c语言编写的函数-以输出Hello-World为例"><a href="#在python代码中使用c语言编写的函数-以输出Hello-World为例" class="headerlink" title="在python代码中使用c语言编写的函数-以输出Hello World为例"></a>在python代码中使用c语言编写的函数-以输出Hello World为例</h1><p><b style="color:red">linux环境下！！！</b></p>
<h2 id="Step-1-编写c语言代码-sayHello-c"><a href="#Step-1-编写c语言代码-sayHello-c" class="headerlink" title="Step 1:编写c语言代码-sayHello.c"></a>Step 1:编写c语言代码-sayHello.c</h2><pre><code>include&lt;stdio.h&gt;
void sayHello()
&#123;
    printf(&quot;Hello World!&quot;);
&#125;
</code></pre>
<h2 id="Step-2-把c语言文件编译成一个动态库"><a href="#Step-2-把c语言文件编译成一个动态库" class="headerlink" title="Step 2:把c语言文件编译成一个动态库"></a>Step 2:把c语言文件编译成一个动态库</h2><pre><code>gcc sayHello.c -shared -o lib-sayHello.so
</code></pre>
<h2 id="Step-3-编写python代码-main-py"><a href="#Step-3-编写python代码-main-py" class="headerlink" title="Step 3:编写python代码-main.py"></a>Step 3:编写python代码-main.py</h2><pre><code>from ctypes import *

#加载动态库
lib = cdll.LoadLibrary(&quot;./lib-sayHello.so&quot;)
#调用sayHello函数
lib.sayHello()
</code></pre>
<h2 id="Step-4-运行python代码"><a href="#Step-4-运行python代码" class="headerlink" title="Step 4:运行python代码"></a>Step 4:运行python代码</h2><pre><code>python3 main.py
</code></pre>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 在系统中查找重复文件</title>
    <url>/2021/09/05/%E5%9C%A8%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%9F%A5%E6%89%BE%E9%87%8D%E5%A4%8D%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="609-在系统中查找重复文件"><a href="#609-在系统中查找重复文件" class="headerlink" title="609.在系统中查找重复文件"></a>609.在系统中查找重复文件</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个目录信息列表，包括目录路径，以及该目录中的所有包含内容的文件，您需要找到文件系统中的所有重复文件组的路径。一组重复的文件至少包括二个具有完全相同内容的文件。<br>输入列表中的单个目录信息字符串的格式如下：<br>“root/d1/d2/…/dm f1.txt(f1_content) f2.txt(f2_content) … fn.txt(fn_content)”<br>这意味着有 n 个文件（f1.txt, f2.txt … fn.txt 的内容分别是 f1_content, f2_content … fn_content）在目录 root/d1/d2/…/dm 下。注意：n&gt;=1 且 m&gt;=0。如果 m=0，则表示该目录是根目录。<br>该输出是重复文件路径组的列表。对于每个组，它包含具有相同内容的文件的所有文件路径。文件路径是具有下列格式的字符串：<br>“directory_path/file_name.txt”</p>
<span id="more"></span>
<p>示例 1：<br>输入：<br>[“root/a 1.txt(abcd) 2.txt(efgh)”, “root/c 3.txt(abcd)”, “root/c/d 4.txt(efgh)”, “root 4.txt(efgh)”]<br>输出：<br>[[“root/a/2.txt”,”root/c/d/4.txt”,”root/4.txt”],[“root/a/1.txt”,”root/c/3.txt”]]</p>
<p><a href="https://leetcode-cn.com/problems/find-duplicate-file-in-system
">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.哈希表<br>首先我们通过字符串操作获取目录路径、文件名和文件内容。我们使用哈希映射（HashMap）来寻找重复文件，哈希映射中的键（key）是文件内容，值（value）是存储路径和文件名的列表。<br>我们遍历每一个文件，并把它加入哈希映射中。在这之后，我们遍历哈希映射，如果一个键对应的值列表的长度大于 1，说明我们找到了重复文件，可以把这个列表加入到答案中。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):
    def findDuplicate(self, paths):
        &quot;&quot;&quot;
        :type paths: List[str]
        :rtype: List[List[str]]
        &quot;&quot;&quot;
        map = &#123;&#125;
        for path in paths:
            values = path.split(&quot; &quot;)
            for i in range(1, len(values)):
                name_cont = values[i].split(&#39;(&#39;)[-1]
                name_cont = name_cont.replace(&#39;)&#39;, &#39;&#39;)
                value_list = map.get(name_cont, [])
                value_list.append(values[0] + &#39;/&#39; + values[i].split(&#39;(&#39;)[0])
                map[name_cont] = value_list
        res = []
        for key in map.keys():
            if len(map.get(key)) &gt; 1:
                res.append(map.get(key))

        return res


if __name__ == &#39;__main__&#39;:
    slt = Solution()
    result = slt.findDuplicate([&quot;root/a 1.txt(abcd) 2.txt(efgh)&quot;, &quot;root/c 3.txt(abcd)&quot;, &quot;root/c/d 4.txt(efgh)&quot;, &quot;root 4.txt(efgh)&quot;])
    print(result)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM | 垃圾收集器</title>
    <url>/2022/06/13/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
    <content><![CDATA[<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><table>
<thead>
<tr>
<th align="center">垃圾收集器</th>
<th align="center">串行/并行/并发</th>
<th align="center">新生代/老年代</th>
<th align="center">算法</th>
<th align="center">目标</th>
<th align="center">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Serial</td>
<td align="center">串行</td>
<td align="center">新生代</td>
<td align="center">复制算法</td>
<td align="center">响应速度优先</td>
<td align="center">单CPU环境下的Client模式</td>
</tr>
<tr>
<td align="center">Serial Old</td>
<td align="center">串行</td>
<td align="center">老年代</td>
<td align="center">标记-整理</td>
<td align="center">响应速度优先</td>
<td align="center">单CPU环境下的Client模式、CMS的后备预案</td>
</tr>
<tr>
<td align="center">ParNew</td>
<td align="center">并行</td>
<td align="center">新生代</td>
<td align="center">复制算法</td>
<td align="center">响应速度优先</td>
<td align="center">多CPU环境下在Server模式下与CMS配合</td>
</tr>
<tr>
<td align="center">Parallel Scavenge</td>
<td align="center">并行</td>
<td align="center">新生代</td>
<td align="center">复制算法</td>
<td align="center">吞吐量优先</td>
<td align="center">在后台运算而不需要太多交互任务</td>
</tr>
<tr>
<td align="center">Parallel Old</td>
<td align="center">并行</td>
<td align="center">老年代</td>
<td align="center">标记整理</td>
<td align="center">吞吐量优先</td>
<td align="center">在后台运算而不需要太多交互任务</td>
</tr>
<tr>
<td align="center">CMS</td>
<td align="center">并发</td>
<td align="center">老年代</td>
<td align="center">标记-清除</td>
<td align="center">响应速度优先</td>
<td align="center">集中在互联网网站或者基于浏览器的B/S系统的服务端上的Java应用</td>
</tr>
<tr>
<td align="center">G1</td>
<td align="center">并发</td>
<td align="center">Both</td>
<td align="center">标记-整理+复制算法</td>
<td align="center">响应速度优先</td>
<td align="center">面向服务端应用，将来替换CMS</td>
</tr>
<tr>
<td align="center">Shenandoah</td>
<td align="center">并发</td>
<td align="center">Both</td>
<td align="center">标记-整理+复制算法</td>
<td align="center">低延迟</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">ZGC</td>
<td align="center">并发</td>
<td align="center">Both</td>
<td align="center">标记-整理+复制算法</td>
<td align="center">低延迟</td>
<td align="center"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>JVM</category>
        <category>垃圾收集器</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>GC</tag>
        <tag>垃圾收集器</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb | 基于JavaWeb的网上购物商城</title>
    <url>/2022/01/12/%E5%9F%BA%E4%BA%8EJavaWeb%E7%9A%84%E7%BD%91%E4%B8%8A%E8%B4%AD%E7%89%A9%E5%95%86%E5%9F%8E/</url>
    <content><![CDATA[<h1 id="基于JavaWeb的网上购物商城"><a href="#基于JavaWeb的网上购物商城" class="headerlink" title="基于JavaWeb的网上购物商城"></a>基于JavaWeb的网上购物商城</h1><ol>
<li>项目目录<br><img src="/2022/01/12/%E5%9F%BA%E4%BA%8EJavaWeb%E7%9A%84%E7%BD%91%E4%B8%8A%E8%B4%AD%E7%89%A9%E5%95%86%E5%9F%8E/1.PNG"></li>
<li>web服务器<br>tomcat7</li>
<li>数据库和表<br><img src="/2022/01/12/%E5%9F%BA%E4%BA%8EJavaWeb%E7%9A%84%E7%BD%91%E4%B8%8A%E8%B4%AD%E7%89%A9%E5%95%86%E5%9F%8E/2.PNG"><br>category:<br><img src="/2022/01/12/%E5%9F%BA%E4%BA%8EJavaWeb%E7%9A%84%E7%BD%91%E4%B8%8A%E8%B4%AD%E7%89%A9%E5%95%86%E5%9F%8E/3.PNG"><br>orderitem:<br><img src="/2022/01/12/%E5%9F%BA%E4%BA%8EJavaWeb%E7%9A%84%E7%BD%91%E4%B8%8A%E8%B4%AD%E7%89%A9%E5%95%86%E5%9F%8E/4.PNG"><br>orders:<br><img src="/2022/01/12/%E5%9F%BA%E4%BA%8EJavaWeb%E7%9A%84%E7%BD%91%E4%B8%8A%E8%B4%AD%E7%89%A9%E5%95%86%E5%9F%8E/5.PNG"><br>product:<br><img src="/2022/01/12/%E5%9F%BA%E4%BA%8EJavaWeb%E7%9A%84%E7%BD%91%E4%B8%8A%E8%B4%AD%E7%89%A9%E5%95%86%E5%9F%8E/6.PNG"><br>user:<br><img src="/2022/01/12/%E5%9F%BA%E4%BA%8EJavaWeb%E7%9A%84%E7%BD%91%E4%B8%8A%E8%B4%AD%E7%89%A9%E5%95%86%E5%9F%8E/7.PNG"></li>
</ol>
]]></content>
      <categories>
        <category>项目经历</category>
        <category>JavaWeb</category>
        <category>基于JavaWeb的网上购物商城</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
        <tag>基于JavaWeb的网上购物商城</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer Vision | 基于ResNet的CIFAER10图像分类</title>
    <url>/2021/11/16/%E5%9F%BA%E4%BA%8EResNet%E7%9A%84CIFAER10%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="基于ResNet的CIFAER-10图像分类"><a href="#基于ResNet的CIFAER-10图像分类" class="headerlink" title="基于ResNet的CIFAER-10图像分类"></a>基于ResNet的CIFAER-10图像分类</h1><h2 id="CIFAR-10数据集"><a href="#CIFAR-10数据集" class="headerlink" title="CIFAR-10数据集"></a>CIFAR-10数据集</h2><p><strong>数据集规模</strong><br>60000张32×32的彩色图片，共有十个类别，每个类别6000张图片。共50000张训练集图片和10000测试集图片。<br><strong>数据集样本类别</strong><br>飞机、汽车、鸟、猫、鹿、狗、青蛙、马、船、卡车（汽车和卡车无重叠）—&gt; 10分类任务<br><strong>数据集网址</strong><br><a href="http://www.cs.toronto.edu/~kriz/cifar.html">http://www.cs.toronto.edu/~kriz/cifar.html</a><br><strong>网络</strong><br>ResNet18</p>
]]></content>
      <categories>
        <category>项目经历</category>
        <category>Deep Learning</category>
        <category>Computer Vision</category>
        <category>基于ResNet的CIFAER-10图像分类</category>
      </categories>
      <tags>
        <tag>基于ResNet的CIFAER-10图像分类</tag>
      </tags>
  </entry>
  <entry>
    <title>spring | 基于注解的自动装配</title>
    <url>/2022/03/06/%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/</url>
    <content><![CDATA[<h1 id="基于注解（-Autowired）的自动装配"><a href="#基于注解（-Autowired）的自动装配" class="headerlink" title="基于注解（@Autowired）的自动装配"></a>基于注解（@Autowired）的自动装配</h1><p>1.项目目录<br><img src="/2022/03/06/%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/1.PNG"></p>
<p>2.UserController.java</p>
<pre><code>package com.atguigu.ioc.userMod.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;

import com.atguigu.ioc.userMod.service.UserService;
import com.atguigu.ioc.userMod.service.UserServiceImpl;

/**
 * 基于注解的组件化管理：
 * @Component,@Controller（控制层）,@Service（业务层）,@Repository（持久曾）
 * 以上四个注解功能完全相同，不过在实际开发中，要在实现不同功能的类上加上相应的注解
 * 完成组件化管理的过程：
 * 1、在需要被spring管理的类上加上相应注解
 * 2、在配置文件中通过&lt;context：component-scan&gt;对所设置的包结构进行扫描，就会将加上注解的类作为spring的组件进行加载
 * 组件：指spring中管理的bean
 * 作为spring的组件进行加载：会自动在spring的配置文件中生成相对应的bean，这些bean的id会以类的首字母小写为值；
 * 也可以通过@Controller(&quot;beanId&quot;)为自动生成的bean指定id
 * 
 * 自动装配：在需要赋值的非字面量属性上，加上@Autowired注解，就可以在spring容器中，通过不同的方式匹配到相对应的bean
 * @Autowired装配时，会默认使用byType的方式，此时要求spring容器中只有一个能够为其赋值
 * 当byType实现不了装配时，会自动切换到byName,此时要求spring容器中，有一个bean的id和属性名一致
 * 若自动装配时，匹配到多个能够赋值的bean，可使用@Qualifire（value=&quot;beanId&quot;)指定使用的bean
 * @Autowired和@Qualifire（value=&quot;beanId&quot;)可以一起作用于一个带形参的方法上，此时，@Qualifire（value=&quot;beanId&quot;)所
 * 指定的bean作用于形参
 * 
 */

@Controller
//@Controller(value=&quot;aaa&quot;)//为自动创建的bean设置id
public class UserController &#123;
    //private UserService userService = new UserServiceImpl();
    @Autowired//基于注解的自动装配(根据类型进行自动装配 byType)
    private UserService userService;
    
    public void addUser()&#123;
        userService.addUser();
    &#125;
    
    public UserController() &#123;
        System.out.println(&quot;UserController&quot;);
    &#125;
&#125;
</code></pre>
<p>3.UserService.java</p>
<pre><code>package com.atguigu.ioc.userMod.service;

public interface UserService &#123;
    void addUser();
&#125;
</code></pre>
<p>4.UserServiceImpl.java</p>
<pre><code>package com.atguigu.ioc.userMod.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;

import com.atguigu.ioc.userMod.dao.UserDao;
import com.atguigu.ioc.userMod.dao.UserDaoImpl;

@Service
public class UserServiceImpl implements UserService&#123;
    
    //private UserDao userDao = new UserDaoImpl();
    
    @Autowired
    //@Qualifier(value=&quot;userDaoImpl&quot;)
    @Qualifier(value=&quot;userDaoMybatisImpl&quot;)
    private UserDao userDao;
    
//    @Autowired
//    @Qualifier(value=&quot;userDaoMybaticImpl&quot;)
//    public void setUserDao(UserDao userDao)&#123;
//        this.userDao = userDao;
//    &#125;
    
    public UserServiceImpl() &#123;
        System.out.println(&quot;UserServiceImpl&quot;);
    &#125;

    @Override
    public void addUser() &#123;
        // TODO Auto-generated method stub
        userDao.addUser();
    &#125;

&#125;
</code></pre>
<p>5.UserDao.java</p>
<pre><code>package com.atguigu.ioc.userMod.dao;

public interface UserDao &#123;
    void addUser();
&#125;
</code></pre>
<p>6.UserDaoImpl.java</p>
<pre><code>package com.atguigu.ioc.userMod.dao;

import org.springframework.stereotype.Repository;

@Repository
public class UserDaoImpl implements UserDao&#123;
    public UserDaoImpl()&#123;
        System.out.println(&quot;UserDaoImpl&quot;);
    &#125;

    @Override
    public void addUser() &#123;
        System.out.println(&quot;添加成功&quot;);
    &#125;
&#125;
</code></pre>
<p>7.UserDaoMybatisImpl.java</p>
<pre><code>package com.atguigu.ioc.userMod.dao;

import org.springframework.stereotype.Repository;

@Repository
public class UserDaoMybatisImpl implements UserDao&#123;

    @Override
    public void addUser() &#123;
        // TODO Auto-generated method stub
        System.out.println(&quot;UserDaoMybatisImple:添加成功&quot;);
    &#125;
&#125;
</code></pre>
<p>8.user.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&gt;
    
    &lt;!-- 
        &lt;context:component-scan&gt;:扫描组件，对设置的包下面的类进行扫描，会将加上注解的类作为spring的组件进行加载
        组件：指spring中管理的bean
        作为spring的组件进行加载：会自动在spring的配置文件中生成相对应的bean，这些bean的id会以类的首字母小写为值
        
        &lt;context:include-filter&gt;:在设定的包结构下再次通过注解或类型具体包含到某个或某几个类
        注意：在使用包含时，一定要设置use-default-filters=&quot;false&quot;，将默认（即扫描包下所有的类）的过滤关闭
        
        &lt;context:exclude-filter&gt;:在设定的包结构下，再次通过注解或类型具体排除某个或某几个类
        注意：在使用排除时，一定要设置use-default-filters=&quot;true&quot;，将默认（即扫描包下所有的类）的过滤打开
        
        切记：一个&lt;context:component-scan&gt;中可以出现多个include，也可以同时出现多个exclude，但是两个不能同时出现
     --&gt;
    &lt;context:component-scan base-package=&quot;com.atguigu.ioc.userMod&quot; use-default-filters=&quot;true&quot;&gt;
        &lt;!-- &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; --&gt;
        &lt;!-- &lt;context:include-filter type=&quot;assignable&quot; expression=&quot;com.atguigu.ioc.userMod.service.UserServiceImpl&quot;/&gt; --&gt;
        &lt;!-- &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Repository&quot;/&gt; --&gt;
        &lt;!-- &lt;context:exclude-filter type=&quot;assignable&quot; expression=&quot;com.atguigu.ioc.userMod.dao.UserDaoImpl&quot;/&gt; --&gt;
    &lt;/context:component-scan&gt;
    
    &lt;!-- &lt;bean id=&quot;userController&quot; class=&quot;com.atguigu.ioc.userMod.controller.UserController&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;userServiceImpl&quot; class=&quot;com.atguigu.ioc.userMod.service.UserServiceImpl&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;userDaoImpl&quot; class=&quot;com.atguigu.ioc.userMod.dao.UserDaoImpl&quot;&gt;&lt;/bean&gt; --&gt;
    
    &lt;!-- 测试@Autowired是根据类型来进行自动装配的（byType） --&gt;
    &lt;!-- &lt;bean id=&quot;user&quot; class=&quot;com.atguigu.ioc.userMod.dao.UserDaoImpl&quot;&gt;&lt;/bean&gt; --&gt;
    
    &lt;!-- 如果根据类型自动装配失败，则byName --&gt;
    &lt;!-- &lt;bean id=&quot;userDao&quot; class=&quot;com.atguigu.ioc.userMod.dao.UserDaoImpl&quot;&gt;&lt;/bean&gt; --&gt;
&lt;/beans&gt;
</code></pre>
<p>9.Test.java</p>
<pre><code>package com.atguigu.ioc.userMod;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import com.atguigu.ioc.userMod.controller.UserController;
import com.atguigu.ioc.userMod.dao.UserDao;
import com.atguigu.ioc.userMod.dao.UserDaoImpl;
import com.atguigu.ioc.userMod.service.UserService;
import com.atguigu.ioc.userMod.service.UserServiceImpl;

public class Test &#123;
    public static void main(String[] args) &#123;
        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;user.xml&quot;);
        
        UserController uc = ac.getBean(&quot;userController&quot;, UserController.class);
        System.out.println(uc);//com.atguigu.ioc.userMod.controller.UserController@4b553d26
        
        UserService us = ac.getBean(&quot;userServiceImpl&quot;, UserServiceImpl.class);
        System.out.println(us);//com.atguigu.ioc.userMod.service.UserServiceImpl@69a3d1d
        
        UserDao ud = ac.getBean(&quot;userDaoImpl&quot;, UserDaoImpl.class);
        System.out.println(ud);//com.atguigu.ioc.userMod.dao.UserDaoImpl@86be70a
        
        uc.addUser();
    &#125;
&#125;
</code></pre>
<p>10.运行结果</p>
<pre><code>UserController
UserServiceImpl
UserDaoImpl
com.atguigu.ioc.userMod.controller.UserController@6f195bc3
com.atguigu.ioc.userMod.service.UserServiceImpl@51e2adc7
com.atguigu.ioc.userMod.dao.UserDaoImpl@1a8a8f7c
添加成功
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>spring</category>
        <category>基于注解（@Autowired）的自动装配</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>并发 | 基于线程池技术的简单Web服务器</title>
    <url>/2022/05/30/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8A%80%E6%9C%AF%E7%9A%84%E7%AE%80%E5%8D%95Web%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h1 id="基于线程池技术的简单Web服务器"><a href="#基于线程池技术的简单Web服务器" class="headerlink" title="基于线程池技术的简单Web服务器"></a>基于线程池技术的简单Web服务器</h1><p>基于线程池技术的简单Web服务器，这个Web服务器用来处理HTTP请求(目前智能处理简单的文本和JPG图片内容)。这个服务器使用<br>main线程不断地接受可换段Socket的连接，将连接以及请求提交给线程池处理，这样使得Web服务器能够同时处理多个客户端请求。</p>
<span id="more"></span>
<p><strong>Web服务器示例代码</strong></p>
<pre><code>package concurrency.threadPool;

import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.Closeable;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;

public class SimpleHttpServer &#123;
    //处理HttpRequest的线程池
    static ThreadPool&lt;HttpRequestHandler&gt; threadPool = new DefaultThreadPool&lt;HttpRequestHandler&gt;(1);
    
    //SimpleHttpServer的根路径
    static String basePath;
    
    static ServerSocket serverSocket;
    
    //服务器监听端口
    static int port = 8080;
    
    public static void setPort(int port)&#123;
        if(port &gt; 0)&#123;
            SimpleHttpServer.port = port;
        &#125;
    &#125;
    
    public static void setBasePath(String basePath)&#123;
        if(basePath != null &amp;&amp; new File(basePath).exists() &amp;&amp; new File(basePath).isDirectory())&#123;
            SimpleHttpServer.basePath = basePath;
        &#125;
    &#125;
    
    //启动SimpleHttpServer
    public static void start() throws IOException&#123;
        serverSocket = new ServerSocket(port);
        Socket socket = null;
        while((socket = serverSocket.accept()) != null)&#123;
            //接收一个可换段Socket，生成一个HttpRequestHandler，放入线程池执行
            threadPool.execute(new HttpRequestHandler(socket));
        &#125;
        serverSocket.close();
    &#125;
    
    static class HttpRequestHandler implements Runnable&#123;
        private Socket socket;
        public HttpRequestHandler(Socket socket)&#123;
            this.socket = socket;
        &#125;
        
        @Override
        public void run() &#123;
            String line = null;
            BufferedReader br = null;
            BufferedReader reader = null;
            PrintWriter out = null;
            InputStream in = null;
            try&#123;
                reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));
                String header = reader.readLine();
                //由相对路径计算出绝对路径
                String filePath = basePath + header.split(&quot; &quot;)[1];
                out = new PrintWriter(socket.getOutputStream());
                //如果请求资源为jpg或者ico，则读取资源并输出
                if(filePath.endsWith(&quot;jpg&quot;) || filePath.endsWith(&quot;ico&quot;))&#123;
                    in = new FileInputStream(filePath);
                    ByteArrayOutputStream baos = new ByteArrayOutputStream();
                    int i = 0;
                    while((i = in.read()) != -1)&#123;
                        baos.write(i);
                    &#125;
                    byte[] array = baos.toByteArray();
                    out.println(&quot;HTTP/1.1 200 OK&quot;);
                    out.println(&quot;Server: Molly&quot;);
                    out.println(&quot;Content-Type: image/jpeg&quot;);
                    out.println(&quot;Content-Length: &quot;+array.length);
                    out.println(&quot;&quot;);
                    socket.getOutputStream().write(array, 0, array.length);
                &#125;else&#123;
                    br = new BufferedReader(new InputStreamReader(new FileInputStream(filePath)));
                    out = new PrintWriter(socket.getOutputStream());
                    out.println(&quot;HTTP/1.1 200 OK&quot;);
                    out.println(&quot;Server: Molly&quot;);
                    out.println(&quot;Content-Type: text/html; charset=UTF-8&quot;);
                    out.println(&quot;&quot;);
                    while((line = br.readLine()) != null)&#123;
                        out.println(line);
                    &#125;
                &#125;
                out.flush();
            &#125;catch(Exception ex)&#123;
                out.println(&quot;HTTP/1.1 500&quot;);
                out.println(&quot;&quot;);
                out.flush();
            &#125;finally&#123;
                close(br, in, reader, out, socket);
            &#125;
        &#125;
        
    &#125;
    
    //关闭流或者Socket
    private static void close(Closeable... closeables)&#123;
        if(closeables != null)&#123;
            for(Closeable closeable : closeables)&#123;
                try &#123;
                    closeable.close();
                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>ThreadPool.java</strong></p>
<pre><code>package concurrency.threadPool;

public interface ThreadPool&lt;Job extends Runnable&gt; &#123;
    //执行一个Job，这个Job需要实现Runnable
    void execute(Job job);
    
    //关闭线程池
    void shutdown();
    
    //增加工作者线程
    void addWorkers(int num);
    
    //减少工作者线程
    void remvoeWorkers(int num);
    
    //得到正在等待执行的任务数量
    int getJobSize();
&#125;
</code></pre>
<p><strong>DefaultThreadPool.java</strong></p>
<pre><code>package concurrency.threadPool;

import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.atomic.AtomicLong;

public class DefaultThreadPool&lt;Job extends Runnable&gt; implements ThreadPool&lt;Job&gt; &#123;
    //线程池最大数量
    private static final int MAX_WORKER_NUMBERS = 10;
    
    //线程池默认数量
    private static final int DEFAULT_WORKER_NUMBERS = 5;
    
    //线程池最小的数量
    private static final int MIN_WORKER_NUMBERS = 1;
    
    //这是一个工作列表，将会向里面插入工作
    private final LinkedList&lt;Job&gt; jobs = new LinkedList&lt;Job&gt;();//生产者
    
    //工作者列表
    private final List&lt;Worker&gt; workers = Collections.synchronizedList(new ArrayList&lt;Worker&gt;());//消费者
    
    //工作者线程的数量
    private int workerNum = DEFAULT_WORKER_NUMBERS;
    
    //线程编号的生成
    private AtomicLong threadNum = new AtomicLong();
    
    //工作者，负责消费任务
    class Worker implements Runnable&#123;
        //是否工作
        private volatile boolean running = true;
        @Override
        public void run()&#123;
            while(running)&#123;
                Job job = null;
                synchronized(jobs)&#123;
                    //如果工作者列表是空的，那么就wait
                    while(jobs.isEmpty())&#123;
                        try&#123;
                            jobs.wait();
                        &#125;catch(InterruptedException ex)&#123;
                            //感知到外部对WorkerThread的中断操作，返回
                            Thread.currentThread().interrupt();
                            return;
                        &#125;
                    &#125;
                    //取出一个Job
                    job = jobs.removeFirst();
                &#125;
                if(job != null)&#123;
                    try&#123;
                        job.run();
                    &#125;catch(Exception ex)&#123;
                        //忽略Job执行中的Exception
                    &#125;
                &#125;
            &#125;
        &#125;
        
        public void shutdown()&#123;
            running = false;
        &#125;
    &#125;
    
    //初始化线程工作者
    private void initializeWorkers(int num)&#123;
        for(int i = 0; i &lt; num; i++)&#123;
            Worker worker = new Worker();
            workers.add(worker);
            Thread thread = new Thread(worker, &quot;ThreadPool-Worker-&quot; + threadNum.incrementAndGet());
            thread.start();
        &#125;
    &#125;
    
    public DefaultThreadPool()&#123;
        initializeWorkers(DEFAULT_WORKER_NUMBERS);
    &#125;
    
    public DefaultThreadPool(int num)&#123;
        workerNum = num &gt; MAX_WORKER_NUMBERS ? MAX_WORKER_NUMBERS : num &lt; MIN_WORKER_NUMBERS ? MIN_WORKER_NUMBERS : num;
        initializeWorkers(workerNum);
    &#125;
    
    @Override
    public void execute(Job job) &#123;
        if(job != null)&#123;
            //添加一个工作，然后进行通知
            synchronized(jobs)&#123;
                jobs.addLast(job);
                jobs.notify();
            &#125;
        &#125;
    &#125;

    @Override
    public void shutdown() &#123;
        for(Worker worker : workers)&#123;
            worker.shutdown();
        &#125;
    &#125;

    @Override
    public void addWorkers(int num) &#123;
        synchronized(jobs)&#123;
            //限制新增的Worker数量不能超过最大值
            if(num + this.workerNum &gt; MAX_WORKER_NUMBERS)&#123;
                num = MAX_WORKER_NUMBERS - this.workerNum;
            &#125;
            initializeWorkers(num);
            this.workerNum += num;
        &#125;
    &#125;

    @Override
    public void remvoeWorkers(int num) &#123;
        synchronized(jobs)&#123;
            if(num &gt;= this.workerNum)&#123;
                throw new IllegalArgumentException(&quot;beyond workNum&quot;);
            &#125;
            //按照给定的数量停止Worker
            int count = 0;
            while(count &lt; num)&#123;
                Worker worker = workers.get(count);
                if(workers.remove(worker))&#123;
                    worker.shutdown();
                    count++;
                &#125;
            &#125;
            this.workerNum -= count;
        &#125;
    &#125;

    @Override
    public int getJobSize() &#123;
        return jobs.size();
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
        <category>基于线程池技术的简单Web服务器</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>基于线程池技术的简单Web服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC | 处理json</title>
    <url>/2022/03/15/%E5%A4%84%E7%90%86json/</url>
    <content><![CDATA[<h1 id="处理json"><a href="#处理json" class="headerlink" title="处理json"></a>处理json</h1><p>1.项目目录<br><img src="/2022/03/15/%E5%A4%84%E7%90%86json/1.PNG"><br><strong>注意：</strong><br>1.按照上图创建项目、导入图中所示的jar包并按照<a href="https://victory-liao.github.io/2022/03/13/REST-CRUD/">REST-CRUD</a>中的<br>web.xml、springMVC配置配置文件；<br>2.src下的dao、bean包中的代码参照REST CRUD；</p>
<span id="more"></span>
<p>3.index.jsp</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;$&#123;pageContext.servletContext.contextPath&#125;/css/index_work.css&quot; /&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;$&#123;pageContext.servletContext.contextPath&#125;/js/jquery-1.8.2.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    $(function()&#123;
        $(&quot;#btn&quot;).click(function()&#123;
            $.ajax(&#123;
                url:&quot;testJson&quot;,
                type:&quot;POST&quot;,
                dataType:&quot;json&quot;,//dataType=&quot;text&quot; 原样显示
                success:function(msg)&#123;
                    //alert(msg);
                    /*
                    [&#123;&quot;id&quot;:1001,&quot;lastName&quot;:&quot;E-AA&quot;,&quot;email&quot;:&quot;aa@163.com&quot;,&quot;gender&quot;:1,&quot;department&quot;:&#123;&quot;id&quot;:101,&quot;departmentName&quot;:&quot;D-AA&quot;&#125;&#125;,
                     &#123;&quot;id&quot;:1002,&quot;lastName&quot;:&quot;E-BB&quot;,&quot;email&quot;:&quot;bb@163.com&quot;,&quot;gender&quot;:1,&quot;department&quot;:&#123;&quot;id&quot;:102,&quot;departmentName&quot;:&quot;D-BB&quot;&#125;&#125;,
                     &#123;&quot;id&quot;:1003,&quot;lastName&quot;:&quot;E-CC&quot;,&quot;email&quot;:&quot;cc@163.com&quot;,&quot;gender&quot;:0,&quot;department&quot;:&#123;&quot;id&quot;:103,&quot;departmentName&quot;:&quot;D-CC&quot;&#125;&#125;,
                     &#123;&quot;id&quot;:1004,&quot;lastName&quot;:&quot;E-DD&quot;,&quot;email&quot;:&quot;dd@163.com&quot;,&quot;gender&quot;:0,&quot;department&quot;:&#123;&quot;id&quot;:104,&quot;departmentName&quot;:&quot;D-DD&quot;&#125;&#125;,
                     &#123;&quot;id&quot;:1005,&quot;lastName&quot;:&quot;E-EE&quot;,&quot;email&quot;:&quot;ee@163.com&quot;,&quot;gender&quot;:1,&quot;department&quot;:&#123;&quot;id&quot;:105,&quot;departmentName&quot;:&quot;D-EE&quot;&#125;&#125;]
                    */
                    /* for(var i in msg) &#123;
                        var emp = msg[i]
                        alert(&quot;id=&quot;+emp.id+&quot;,lastName=&quot;+emp.lastName+&quot;,departmentName=&quot;+emp.department.departmentName);
                    &#125; */
                    
                    //第一种实现方式
                    /* var tb = &quot;&lt;table&gt;&quot;
                    tb += &quot;&lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;lastName&lt;/th&gt;&lt;th&gt;email&lt;/th&gt;&lt;th&gt;gender&lt;/th&gt;&lt;th&gt;departmentName&lt;/th&gt;&lt;/tr&gt;&quot;
                    for(var i in msg) &#123;
                        var emp = msg[i]
                        tb += &quot;&lt;tr&gt;&lt;td&gt;&quot;+emp.id+&quot;&lt;/td&gt;&lt;td&gt;&quot;+emp.lastName+&quot;&lt;/td&gt;&lt;td&gt;&quot;+emp.email+&quot;&lt;/td&gt;&lt;td&gt;&quot;+emp.gender+&quot;&lt;/td&gt;&lt;td&gt;&quot;+emp.department.departmentName+&quot;&lt;/td&gt;&lt;/tr&gt;&quot;
                    &#125; 
                    tb += &quot;&lt;/table&gt;&quot;
                    $(&quot;body&quot;).append(tb); */
                    
                    //第二种实现方式
                    $(&quot;body&quot;).append(&quot;&lt;table&gt;&lt;/table&gt;&quot;);
                    $(&quot;table&quot;).append(&quot;&lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;lastName&lt;/th&gt;&lt;th&gt;email&lt;/th&gt;&lt;th&gt;gender&lt;/th&gt;&lt;th&gt;departmentName&lt;/th&gt;&lt;/tr&gt;&quot;)
                    for(var i in msg)&#123;
                        var emp = msg[i]
                        $(&quot;table&quot;).append(&quot;&lt;tr&gt;&lt;td&gt;&quot;+emp.id+&quot;&lt;/td&gt;&lt;td&gt;&quot;+emp.lastName+&quot;&lt;/td&gt;&lt;td&gt;&quot;+emp.email+&quot;&lt;/td&gt;&lt;td&gt;&quot;+emp.gender+&quot;&lt;/td&gt;&lt;td&gt;&quot;+emp.department.departmentName+&quot;&lt;/td&gt;&lt;/tr&gt;&quot;);
                    &#125;
                &#125;
            &#125;);
        &#125;)
    &#125;);
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;测试ajax&quot; /&gt;
    
    &lt;a href=&quot;testJson&quot;&gt;测试json&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>2.TestJsonController.java</p>
<pre><code>package com.atguigu.test;

import java.util.Collection;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import com.atguigu.bean.Employee;
import com.atguigu.dao.EmployeeDao;

@Controller
public class TestJsonController &#123;
    
    @Autowired
    private EmployeeDao dao;
    
    /**
     * springMVC处理json的四个条件
     * 1、导入jackson的jar包
     * 2、在springMVC的配置文件中开启MVC驱动，&lt;mvc:annotation-driven /&gt;
     * 3、在处理ajax请求的方法上加上注解@ResponseBody
     * 4、将要转为为json且响应到客户端的数据，直接作为该方法的返回值返回
     * @ResponseBody
     */
    @RequestMapping(&quot;testJson&quot;)
    @ResponseBody
    public Collection&lt;Employee&gt; testJson()&#123;
        Collection&lt;Employee&gt; emps = dao.getAll();
        return emps;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>SpringMVC</category>
        <category>处理json</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringMVC</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC | 处理静态资源</title>
    <url>/2022/03/13/%E5%A4%84%E7%90%86%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<h1 id="处理静态资源"><a href="#处理静态资源" class="headerlink" title="处理静态资源"></a>处理静态资源</h1><p>在使用了SpringMVC的项目中，在使用css/js等静态资源时，需要在SpringMVC的配置文件中做以下配置：</p>
<pre><code>&lt;!-- 处理静态资源 --&gt;
&lt;!-- 
    配置Tomcat中默认的servlet,DefaultServlet
    注意：当DefaultServlet所设置的&lt;url-pattern&gt;的值和开发人员所配置
        的servlet的&lt;url-pattern&gt;相同，以开发人员所配置的servlet优先
    作用： 当客户端发送请求，由于DefaultServlet所设置的&lt;url-pattern&gt;的
        值和开发人员所配置的DispatcherServlet的&lt;url-pattern&gt;都是/，
        因此先通过DispatcherServelet处理请求，找该请求是否有相对应的处理器，
        有则处理，无则交给DefaultServlet处理
--&gt;
&lt;mvc:default-servlet-handler/&gt;
&lt;!-- mvc驱动 --&gt;
&lt;mvc:annotation-driven /&gt;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>SpringMVC</category>
        <category>处理静态资源</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 外观数列</title>
    <url>/2021/08/28/%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<h1 id="38-外观数列"><a href="#38-外观数列" class="headerlink" title="38.外观数列"></a>38.外观数列</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个正整数 n ，输出外观数列的第 n 项。<br>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。</p>
<span id="more"></span>
<p>你可以将其视作是由递归公式定义的数字字符串序列：<br>    countAndSay(1) = “1”<br>    countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。<br>前五项如下：</p>
<ol>
<li><pre><code>1
</code></pre>
</li>
<li><pre><code>11
</code></pre>
</li>
<li><pre><code>21
</code></pre>
</li>
<li><pre><code>1211
</code></pre>
</li>
<li><pre><code>111221
</code></pre>
第一项是数字 1<br>描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 “11”<br>描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 “21”<br>描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 “1211”<br>描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 “111221”<br>要 描述 一个数字字符串，首先要将字符串分割为 最小 数量的组，每个组都由连续的最多 相同字符 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。</li>
</ol>
<p><a href="https://leetcode-cn.com/problems/count-and-say/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.递归<br>递归出口为n == 1时，返回”1”；<br>当n &gt; 1时，我们只需要计算countAndSay(n - 1)中每个数字的个数：<br>对于计算字符串中每个数字出现的个数，使用双指针i, j，其中i表示当前字符，j则是计数指针，向后移动判断；<br>以求n = 5，lastStr = countAndSay(4) = “1211”为例，answer = “”，一开始让i = 0, j = 1，此时’1’ != ‘2’，<br>故answer += (j - i) + lastStr.charAt(i)，ans = “11”；然后让i = j（第二个不同字符起始位置），<br>然后j++往后移动；此时i = j = 1，j = j + 1 = 2，又’2’ != ‘1’，<br>所以answer += (j - i) + lastStr.charAt(i),ans = “1112”,重复i = j = 2， j = ++j = 3；此时’1’ = ‘1’；<br>故直接j = ++j = 4 == lastStr.length()，所以跳出循环，然后把最后一次的字符个数字符加上，即执行：<br>answer += (j - i) + lastStr.charAt(i),ans = “111221”，即countAndSay(5) = “111221”。<br>2.正则表达式<br>用正则表达式匹配一个数字的重复序列和数字本身，然后将匹配的序列的长度加上数字本身替换原字符串中重复序列，…，以此类推。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def countAndSay(self, n: int) -&gt; str:
        &quot;&quot;&quot;
        递归法
        :param n:
        :return:
        &quot;&quot;&quot;
        if n == 1:  # 递归出口
            return &quot;1&quot;
        else:
            lastStr = self.countAndSay(n - 1)
            ans = &quot;&quot;
            i = 0
            j = 1

            while j &lt; len(lastStr):
                if lastStr[i] != lastStr[j]:
                    ans += str(j-i)
                    ans += str(lastStr[i])
                    i = j  # 下一个不同字符的起始位置

                j += 1

            ans += str(j - i)
            ans += str(lastStr[i])

            return str(ans)

    def countAndSay1(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: str
        &quot;&quot;&quot;
        import re

        s = &#39;1&#39;
        for _ in range(n - 1):
            s = re.sub(r&#39;(.)\1*&#39;, lambda a: str(len(a.group(0))) + a.group(1), s)  # sub(pattern, repl, string)
            # r&#39;(.)\1*&#39; (.)匹配一个任意字符作为一个分组 \1*匹配与第一个分组相同内容0次/多次
        return s


if __name__ == &#39;__main__&#39;:
    s = Solution()
    res = s.countAndSay1(5)
    print(res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>可视化 | 多个坐标轴可视化主要代码python</title>
    <url>/2021/03/11/%E5%A4%9A%E4%B8%AA%E5%9D%90%E6%A0%87%E8%BD%B4%E5%8F%AF%E8%A7%86%E5%8C%96%E4%B8%BB%E8%A6%81%E4%BB%A3%E7%A0%81python/</url>
    <content><![CDATA[<h1 id="多个坐标轴可视化主要代码"><a href="#多个坐标轴可视化主要代码" class="headerlink" title="多个坐标轴可视化主要代码"></a>多个坐标轴可视化主要代码</h1><p>在机器学习算法的使用中，我们需要使用多个坐标轴对一些过程数据/预测结果等进行可视化以便于进一步的分析，它的主要python代码如下：</p>
<span id="more"></span>

<pre><code>from matplotlib.font_manager import FontProperties  # be used to set the fonts
import matplotlib.pyplot as plt

font = FontProperties(fname=r&#39;c:\windows\fonts\simsun.ttc&#39;, size=14)

fig, axs = plt.subplots(nrows=&#39;number_of_rows&#39;, ncols=&#39;number_of_cols&#39;, sharex=&#39;False&#39;, sharey=&#39;False&#39;, figsize=(width, height))
axs[m][n].plot(x, y)  # m&lt;number_of_rows,n&lt;number_of_cols x,y:a list
title = axs[m][n].set_title(u&#39;&#39;,FontProperties=font)
ylabel = axs[m][n].set_ylabel(u&#39;&#39;,FontProperties=font)
xlabel = axs[m][n].set_xlabel(u&#39;&#39;,FontProperties=font)
plt.setp(title/xlabel/ylabel, size=&#39;&#39;, weight=&#39;&#39;, color=&#39;&#39;)
plt.show()  # show the figure
</code></pre>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>可视化(Visualization)</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis | 多对一查询自定义映射</title>
    <url>/2022/04/03/%E5%A4%9A%E5%AF%B9%E4%B8%80%E6%9F%A5%E8%AF%A2%E8%87%AA%E5%AE%9A%E4%B9%89%E6%98%A0%E5%B0%84/</url>
    <content><![CDATA[<h1 id="多对一查询自定义映射"><a href="#多对一查询自定义映射" class="headerlink" title="多对一查询自定义映射"></a>多对一查询自定义映射</h1><p>1.项目目录<br><img src="/2022/04/03/%E5%A4%9A%E5%AF%B9%E4%B8%80%E6%9F%A5%E8%AF%A2%E8%87%AA%E5%AE%9A%E4%B9%89%E6%98%A0%E5%B0%84/1.PNG"><br>2.Emp.java</p>
<pre><code>package com.atguigu.bean;

public class Emp &#123;
    private Integer eid;
    private String ename;
    private Integer age;
    private String sex;
    private Dept dept;
    
    
    public Dept getDept() &#123;
        return dept;
    &#125;
    public void setDept(Dept dept) &#123;
        this.dept = dept;
    &#125;
    public Integer getEid() &#123;
        return eid;
    &#125;
    public void setEid(Integer eid) &#123;
        this.eid = eid;
    &#125;
    public String getEname() &#123;
        return ename;
    &#125;
    public void setEname(String ename) &#123;
        this.ename = ename;
    &#125;
    public Integer getAge() &#123;
        return age;
    &#125;
    public void setAge(Integer age) &#123;
        this.age = age;
    &#125;
    public String getSex() &#123;
        return sex;
    &#125;
    public void setSex(String sex) &#123;
        this.sex = sex;
    &#125;
    
    @Override
    public String toString() &#123;
        return &quot;Emp [eid=&quot; + eid + &quot;, ename=&quot; + ename + &quot;, age=&quot; + age + &quot;, sex=&quot; + sex + &quot;, dept=&quot; + dept + &quot;]&quot;;
    &#125;
    public Emp(Integer eid, String ename, Integer age, String sex) &#123;
        super();
        this.eid = eid;
        this.ename = ename;
        this.age = age;
        this.sex = sex;
    &#125;
    public Emp() &#123;
        super();
        // TODO Auto-generated constructor stub
    &#125;
&#125;
</code></pre>
<p>3.Dept.java</p>
<pre><code>package com.atguigu.bean;

public class Dept &#123;
    private Integer did;
    private String dname;
    public Integer getDid() &#123;
        return did;
    &#125;
    public void setDid(Integer did) &#123;
        this.did = did;
    &#125;
    public String getDname() &#123;
        return dname;
    &#125;
    public void setDname(String dname) &#123;
        this.dname = dname;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Dept [did=&quot; + did + &quot;, dname=&quot; + dname + &quot;]&quot;;
    &#125;
    
&#125;
</code></pre>
<p>4.EmpDeptMapper.java</p>
<pre><code>package com.atguigu.mapper;

import java.util.List;

import com.atguigu.bean.Emp;

public interface EmpDeptMapper &#123;
    List&lt;Emp&gt; getAllEmp();
&#125;
</code></pre>
<p>5.EmpDeptMapper.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
 PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
 &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
 
&lt;mapper namespace=&quot;com.atguigu.mapper.EmpDeptMapper&quot;&gt;
    
    &lt;!-- &lt;select id=&quot;getAllEmp&quot; resultType=&quot;Emp&quot;&gt;
        select e.eid,e.ename,e.age,e.sex,e.did,d.dname from emp e left join dept d on e.did=d.did
        
            查询结果：
            [Emp [eid=1, ename=张三, age=12, sex=男, dept=null], 
            不能够查询出员工所对应的部门，需要进行自定义映射
        
    &lt;/select&gt; --&gt;
    
    &lt;!-- 自定义映射-第一种方式 --&gt;
    &lt;!-- &lt;resultMap type=&quot;Emp&quot; id=&quot;empMap&quot;&gt;
        &lt;id column=&quot;eid&quot; property=&quot;eid&quot;/&gt;
        &lt;result column=&quot;ename&quot; property=&quot;ename&quot;/&gt;
        &lt;result column=&quot;age&quot; property=&quot;age&quot;/&gt;
        &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;
        &lt;result column=&quot;did&quot; property=&quot;dept.did&quot;/&gt;
        &lt;result column=&quot;dname&quot; property=&quot;dept.dname&quot;/&gt;
    &lt;/resultMap&gt; --&gt;
    &lt;!--
        &lt;resultMap&gt;:自定义映射，处理复杂的表关系
        &lt;id/&gt;:设置主键的映射关系，column设置字段名，property设置属性名
        &lt;result/&gt;:设置非主键的映射关系， column设置字段名，property设置属性名
     --&gt;
     
     &lt;!-- 自定义映射-第二种方式 --&gt;
     &lt;resultMap type=&quot;Emp&quot; id=&quot;empMap&quot;&gt;
        &lt;id column=&quot;eid&quot; property=&quot;eid&quot;/&gt;
        &lt;result column=&quot;ename&quot; property=&quot;ename&quot;/&gt;
        &lt;result column=&quot;age&quot; property=&quot;age&quot;/&gt;
        &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;
        &lt;association property=&quot;dept&quot; javaType=&quot;Dept&quot;&gt;
            &lt;id column=&quot;did&quot; property=&quot;did&quot;/&gt;
            &lt;result column=&quot;dname&quot; property=&quot;dname&quot;/&gt;
        &lt;/association&gt;
     &lt;/resultMap&gt;
    
    &lt;!-- List&lt;Emp&gt; getAllEmp(); --&gt;
    &lt;select id=&quot;getAllEmp&quot; resultMap=&quot;empMap&quot;&gt;
        &lt;!-- select * from emp e, dept d where e.did = d.did --&gt;
        select e.eid,e.ename,e.age,e.sex,e.did,d.dname from emp e left join dept d on e.did=d.did
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p>6.TestEmpDept.java</p>
<pre><code>package com.atguigu.test;

import java.io.IOException;
import java.io.InputStream;
import java.util.List;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import com.atguigu.bean.Emp;
import com.atguigu.mapper.EmpDeptMapper;

public class TestEmpDept &#123;
    public static void main(String[] args) throws IOException &#123;
        InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
        SqlSession sqlSession = sqlSessionFactory.openSession(true);
        EmpDeptMapper mapper = sqlSession.getMapper(EmpDeptMapper.class);
        
        List&lt;Emp&gt; empList = mapper.getAllEmp();
        System.out.println(empList);
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>MyBatis</category>
        <category>多对一查询自定义映射</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>自定义映射</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 169.多数元素</title>
    <url>/2022/06/19/%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169.多数元素"></a>169.多数元素</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊n/2⌋ 的元素。<br>你可以假设数组是非空的，并且给定的数组总是存在多数元素。<br><a href="https://leetcode.cn/problems/majority-element">题目链接</a></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>HashMap<br>使用哈希表统计每个元素出现的次数，返回哈希表中值最大的键。</p>
</li>
<li><p>排序<br>如果将数组 nums 中的所有元素按照单调递增或单调递减的顺序排序，那么下标为 ⌊n/2⌋ 的元素（下标从 0 开始）一定是众数。<br>因此，对数组进行排序并返回下标为⌊n/2⌋的数组元素。</p>
</li>
<li><p>随机化<br>因为超过 ⌊n/2⌋ 的数组下标被众数占据了，这样我们随机挑选一个下标对应的元素并验证，有很大的概率能找到众数。</p>
</li>
<li><p>分治<br>如果数 a 是数组 nums 的众数，如果我们将 nums 分成两部分，那么 a 必定是至少一部分的众数。<br>我们使用经典的分治算法递归求解，直到所有的子问题都是长度为 1 的数组。长度为 1 的子数组中唯一的数显然是众数，直接返回即可。如果回溯后某区间的长度大于 1，我们必须将左右子区间的值合并。如果它们的众数相同，那么显然这一段区间的众数是它们相同的值。否则，我们需要比较两个众数在整个区间内出现的次数来决定该区间的众数。</p>
</li>
<li><p>Boyer-Moore投票算法<br>如果我们把众数记为 +1+1+1，把其他数记为 −1-1−1，将它们全部加起来，显然和大于 0，从结果本身我们可以看出众数比其他数多。</p>
<h2 id="代码-java版本"><a href="#代码-java版本" class="headerlink" title="代码(java版本)"></a>代码(java版本)</h2><p> import java.util.Arrays;<br> import java.util.HashMap;<br> import java.util.Iterator;<br> import java.util.Map;<br> import java.util.Map.Entry;<br> import java.util.Random;</p>
<p> public class MajorityElement {</p>
<pre><code> private int randRange(Random rand, int min, int max)&#123;
     return rand.nextInt(max - min) + min;
 &#125;
 
 private int countOccurences(int[] nums, int num)&#123;
     int count = 0;
     
     for(int num1 : nums)&#123;
         if(num == num1)&#123;
             count++;
         &#125;
     &#125;
     
     return count;
 &#125;
 
 public int majorityElement(int[] nums)&#123;
     Random rand = new Random();
     
     int majorityCount = nums.length / 2;
     
     while(true)&#123;
         int candidate = nums[randRange(rand, 0, nums.length)];
         if(countOccurences(nums, candidate) &gt; majorityCount)&#123;
             return candidate;
         &#125;
     &#125;
 &#125;
 
 private int countInRange(int[] nums, int num, int lo, int hi)&#123;
     int count = 0;
     for(int i = lo; i &lt;= hi; i++)&#123;
         if(nums[i] == num)&#123;
             count++;
         &#125;
     &#125;
     return count;
 &#125;
 
 private int majorityElementRec(int[] nums, int lo, int hi)&#123;
     if(lo == hi)&#123;
         return nums[lo];
     &#125;
     
     int mid = (hi - lo) / 2 + lo;
     int left = majorityElementRec(nums, lo, mid);
     int right = majorityElementRec(nums, mid + 1, hi);
     
     if(left == right)&#123;
         return left;
     &#125;
     
     int leftCount = countInRange(nums, left, lo, hi);
     int rightCount = countInRange(nums, right, lo, hi);
     
     return leftCount &gt; rightCount ? left : right;
 &#125;
 
 //方法4：分治
 public int majorityElement1(int[] nums)&#123;
     return majorityElementRec(nums, 0, nums.length - 1);
 &#125;
 
 //方法5：Boyer-Moore
 public int majorityElement2(int[] nums)&#123;
     int count = 0;
     Integer candidate = null;
     
     for (int num : nums)&#123;
         if(count == 0)&#123;
             candidate = num;
         &#125;
         count += (num == candidate) ? 1 : -1;
     &#125;
     
     return candidate;
 &#125;
 
 public static void main(String[] args) &#123;
     int[] nums = new int[]&#123;2,2,1,1,1,2,2&#125;;
     
     //方法1：HashMap
</code></pre>
<p> //        Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;();<br> //        for(Integer num : nums){<br> //            String tempNum = num.toString();<br> //            if(!map.keySet().contains(tempNum)){<br> //                map.put(tempNum, 1);<br> //<br> //            }else{<br> //                map.put(tempNum, map.get(tempNum) + 1);<br> //            }<br> //        }<br> //<br> //        Iterator&lt;Entry&lt;String, Integer&gt;&gt; iterator = map.entrySet().iterator();<br> //        for(;iterator.hasNext();){<br> //            Entry&lt;String, Integer&gt; next = iterator.next();<br> //            String key = next.getKey();<br> //            Integer value = next.getValue();<br> //            if(value &gt; (int)(nums.length / 2)){<br> //                System.out.println(key);<br> //            }<br> //        }</p>
<pre><code>     //方法2：排序
</code></pre>
<p> //        Arrays.sort(nums);<br> //        System.out.println(nums[nums.length / 2]);</p>
<pre><code>     //方法3：随机化
     MajorityElement majorityElement = new MajorityElement();
     int majority1 = majorityElement.majorityElement(nums);
     System.out.println(majority1);
     
     //方法4：分治
     int majority2 = majorityElement.majorityElement1(nums);
     System.out.println(majority2);
     
     //方法5：Boyer-Moore投票算法
     int majority3 = majorityElement.majorityElement2(nums);
     System.out.println(majority3);
 &#125;
</code></pre>
<p> }</p>
</li>
</ol>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>数组</category>
        <category>169.多数元素</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程 | 多线程下载图片</title>
    <url>/2021/08/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h1 id="多线程下载图片"><a href="#多线程下载图片" class="headerlink" title="多线程下载图片"></a>多线程下载图片</h1><p>下面的代码是一个网络爬虫程序，可以定期下载图片。这个网络爬虫程序每隔一段时间都会执行一次下载图片任务，在下载任务完成后，休眠一段时间在执行。这样反复执行，知道爬虫程序停止。</p>
<p><strong>示例代码：</strong></p>
<pre><code># coding=utf-8

import time
import threading
import urllib.request as request

# 线程停止变量
isrunning = True


# 工作线程体函数
def workthread_body():
    while isrunning:
        # 线程开始工作
        print(&#39;工作线程执行下载任务...&#39;)
        download()
        # 线程休眠
        time.sleep(5)
    print(&#39;工作线程结束&#39;)


# 控制线程体函数
def controlthread_body():
    global isrunning
    while isrunning:
        # 从键盘输入停止指令exit
        command = input(&#39;请输入停止指令&#39;)
        if command == &#39;exit&#39;:
            isrunning = False
            print(&#39;控制线程结束。&#39;)


def download():
    url = &#39;https://victory-liao.github.io/images/avatar.jpg&#39;
    req = request.Request(url)
    with request.urlopen(req) as response:
        data = response.read()
        f_name = &#39;download.jpg&#39;
        with open(f_name, &#39;wb&#39;) as f:
            f.write(data)
            print(&#39;下载文件成功&#39;)


# 主线程
# 创建工作线程对象workthread
workthread = threading.Thread(target=workthread_body)
# 启动线程workthred
workthread.start()

# 创建控制线程对象controlthread
controlthread = threading.Thread(target=controlthread_body)
# 启动线程controlthread
controlthread.start()
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>内置模块</category>
        <category>threading</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>多线程</tag>
        <tag>threading</tag>
      </tags>
  </entry>
  <entry>
    <title>系统编程 | 多进程拷贝文件</title>
    <url>/2020/10/14/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="多进程拷贝文件"><a href="#多进程拷贝文件" class="headerlink" title="多进程拷贝文件"></a>多进程拷贝文件</h1><h2 id="实现流程分析"><a href="#实现流程分析" class="headerlink" title="实现流程分析"></a>实现流程分析</h2><ol>
<li>获取要copy的文件夹的名字</li>
<li>创建一个文件夹</li>
<li>获取old文件夹中的所有的文件名字</li>
<li>使用多进程方式copy原文件夹中的所有文件到新的文件夹中</li>
</ol>

<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code>from multiprocessing import Pool,Manager
import os
import time

def copyFileTask(name,oldFolderName,newFolderName,queue):
    &quot;complete the function of coping a file&quot;
    fr = open(oldFolderName+&quot;/&quot;+name)
    fw = open(newFolderName+&quot;/&quot;+name,&quot;w&quot;)
    content = fr.read()
    fw.write(content)
    fr.close()
    fw.close()
    queue.put(name)

def main():
    #0.get the file name you want to copy
    oldFolderName = input(&quot;Please input the file name:&quot;)
    #1.create a file directory
    newFolderName = oldFolderName+&quot;-copy&quot;
    #pmrint(newFolderName)
    os.mkdir(newFolderName)
    #2.get all file name of old file directory
    fileNames = os.listdir(oldFolderName)
    #print(fileNames)
    #3.copy all file of old file directory to a new file directory
    pool = Pool(5)
    queue = Manager().Queue()
    for name in fileNames:
        pool.apply_async(copyFileTask,args=(name,oldFolderName,newFolderName,queue))
    num = 0
    allNum = len(fileNames)
    while num &lt; allNum:
        queue.get()
        num += 1
        copyRate = num/allNum
        print(&quot;\rcopy process:%.2f%% &quot;%(copyRate*100),end=&quot;&quot;)
        time.sleep(1)
    print(&#39;\ncompleted&#39;)
    pool.close()
    pool.join()
if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>系统编程</category>
      </categories>
      <tags>
        <tag>多进程</tag>
        <tag>系统编程</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 大胆新奇的卷积神经网络设计</title>
    <url>/2021/11/05/%E5%A4%A7%E8%83%86%E6%96%B0%E5%A5%87%E7%9A%84%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p><a href="https://mp.weixin.qq.com/s/6HbPBYQvLMU5okI-tIUBcg">大胆又新奇的卷积网络结构设计</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>如何计算深度学习代码实践中的trainsteps</title>
    <url>/2021/08/02/%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E8%B7%B5%E4%B8%AD%E7%9A%84trainsteps/</url>
    <content><![CDATA[<h1 id="如何计算深度学习代码实践中的trainsteps"><a href="#如何计算深度学习代码实践中的trainsteps" class="headerlink" title="如何计算深度学习代码实践中的trainsteps?"></a>如何计算深度学习代码实践中的trainsteps?</h1><p>深度学习中已经有epoch参数了，为什么还要再定义steps参数？</p>
<p>epoch:全体训练数据过几遍</p>
<p>steps:模型会计算几次loss,即模型参数会更新几次梯度</p>
<p>当我们训练模型时，epoch变成了一个间接的关注对象，我们关系模型能更新多少次，这些才知道循环多少次，计算多少次loss。其实最主要的一点是训练步数与模型的参数会有相关关系，比如如果要采用自适应学习率，那每步都是有一个不同的学习率的。</p>
<p>train steps通常按以下公式进行计算：<br>train steps = len(data) // batch_size</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>train steps</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 字符串中的单词数</title>
    <url>/2021/09/01/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0/</url>
    <content><![CDATA[<h1 id="434-字符串中的单词数"><a href="#434-字符串中的单词数" class="headerlink" title="434.字符串中的单词数"></a>434.字符串中的单词数</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。<br>请注意，你可以假定字符串里不包括任何不可打印的字符。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/number-of-segments-in-a-string/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.使用语言内置函数split()<br>2.原地法<br>计算单词的数量，就等同于计数单词开始的下标个数。因此，只需要定义好下标的条件，就可以遍历整个字符串，检测每个下标。定义如下：若该下标前为空格（或者为初始下标），且自身不为空格，则其为单词开始的下标。该条件可以以常数时间检测。最后，返回满足条件的下标个数。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def countSegments(self, s: str) -&gt; int:
        list_s = s.split(&#39; &#39;)
        for i in range(list_s.count(&#39;&#39;)):
            list_s.remove(&#39;&#39;)
        if not list_s:
            return 0
        return len(list_s)

    def countSegments1(self, s):
        return len(s.split())

    def countSegments2(self, s):
        segment_count = 0

        for i in range(len(s)):
            if (i == 0 or s[i-1] == &#39; &#39;) and s[i] != &#39; &#39;:
                segment_count +=1

        return segment_count


if __name__ == &#39;__main__&#39;:
    slt = Solution()
    # s = &quot;      &quot;
    s = &quot;The one-hour drama series Westworld is a dark odyssey about the dawn of artificial consciousness and the evolution of sin. Set at the intersection of the near future and the reimagined past, it explores a world in which every human appetite, no matter how noble or depraved, can be indulged.&quot;
    res = slt.countSegments2(s)
    print(res)

    # 分割文本
    # s = &quot;The sky is very blue.&quot;
    # words = s.split(&quot; &quot;)
    # print(words)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 字符串相乘</title>
    <url>/2021/09/05/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</url>
    <content><![CDATA[<h1 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43.字符串相乘"></a>43.字符串相乘</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p>
<p>示例 1:<br>输入: num1 = “2”, num2 = “3”<br>输出: “6”</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/multiply-strings">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.将num1、num2两个字符串转为整数相乘，然后将结果转为字符串返回<br>2.使用python内置函数eval()执行num1 * num2表达式，将eval函数返回结果转为字符串返回<br>3.做加法（<a href="https://leetcode-cn.com/problems/multiply-strings/solution/zi-fu-chuan-xiang-cheng-by-leetcode-solution/">详细思路见leetcode题解</a>）<br>4.做乘法（<a href="https://leetcode-cn.com/problems/multiply-strings/solution/zi-fu-chuan-xiang-cheng-by-leetcode-solution/">详细思路见leetcode题解</a>）</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):
    def multiply(self, num1, num2):
        &quot;&quot;&quot;
        将num1、num2两个字符串转为整数相乘，然后将结果转为字符串返回

        :type num1: str
        :type num2: str
        :rtype: str
        &quot;&quot;&quot;
        return str(int(num1) * int(num2))

    def multiply1(self, num1: str, num2: str) -&gt; str:
        &quot;&quot;&quot;
        将num1、num2两个字符串转为整数相乘，然后将结果转为字符串返回
        :param num1:
        :param num2:
        :return:
        &quot;&quot;&quot;
        if num1 == &quot;0&quot; or num2 == &quot;0&quot;:
            return &quot;0&quot;

        num1_to_int = 0
        num2_to_int = 0

        t = 1
        for i in range(1, len(num1)+1):
            num1_to_int += int(num1[-i]) * t
            t = t * 10

        t = 1
        for i in range(1, len(num2)+1):
            num2_to_int += int(num2[-i]) * t
            t = t * 10

        return str(num1_to_int * num2_to_int)

    def multiply2(self, num1: str, num2: str) -&gt; str:
        &quot;&quot;&quot;使用python内置函数eval()执行num1 * num2表达式，将eval函数返回结果转为字符串返回&quot;&quot;&quot;
        if num1 == &quot;0&quot; or num2 == &quot;0&quot;:
            return &quot;0&quot;

        return str(eval(num1 + &#39;*&#39; + num2))  # eval() 函数用来执行一个字符串表达式，并返回表达式的值。

    def multiply3(self, num1: str, num2: str) -&gt; str:
        &quot;&quot;&quot;做加法&quot;&quot;&quot;
        if num1 == &quot;0&quot; or num2 == &quot;0&quot;:
            return &quot;0&quot;

        ans = &quot;0&quot;
        m, n = len(num1), len(num2)
        for i in range(n - 1, -1, -1):
            add = 0
            y = int(num2[i])
            curr = [&quot;0&quot;] * (n - i - 1)  # num2除了最低位以外，其余的每一位的运算结果都需要补0
            print(&quot;curr:&quot;, curr)
            for j in range(m - 1, -1, -1):
                product = int(num1[j]) * y + add
                curr.append(str(product % 10))
                add = product // 10
            if add &gt; 0:
                curr.append(str(add))
            curr = &quot;&quot;.join(curr[::-1])
            ans = self.addStrings(ans, curr)
        return ans

    def addStrings(self, num1: str, num2: str) -&gt; str:
        i, j = len(num1) - 1, len(num2) - 1
        add = 0
        ans = list()
        while i &gt;= 0 or j &gt;= 0 or add != 0:
            x = int(num1[i]) if i &gt;= 0 else 0
            y = int(num2[j]) if j &gt;= 0 else 0
            result = x + y + add
            ans.append(str(result % 10))
            add = result // 10
            i -= 1
            j -= 1
        return &#39;&#39;.join(ans[::-1])

    def multiply4(self, num1: str, num2: str) -&gt; str:
        &quot;&quot;&quot;做乘法&quot;&quot;&quot;
        if num1 == &quot;0&quot; or num2 == &quot;0&quot;:
            return &quot;0&quot;

        m, n = len(num1), len(num2)
        ansArr = [0] * (m + n)
        for i in range(m - 1, -1, -1):
            x = int(num1[i])
            for j in range(n - 1, -1, -1):
                ansArr[i + j + 1] += x * int(num2[j])

        for i in range(m + n - 1, 0, -1):
            ansArr[i-1] += ansArr[i] // 10
            ansArr[i] %= 10

        index = 1 if ansArr[0] == 0 else 0
        ans = &quot;&quot;.join(str(x) for x in ansArr[index:])
        return ans


if __name__ == &quot;__main__&quot;:
    slt = Solution()
    result = slt.multiply4(&quot;12&quot;, &quot;34&quot;)
    print(result)
    print(type(result))
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 学生出勤记录1</title>
    <url>/2021/09/02/%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E8%AE%B0%E5%BD%951/</url>
    <content><![CDATA[<h1 id="551-学生出勤记录1"><a href="#551-学生出勤记录1" class="headerlink" title="551.学生出勤记录1"></a>551.学生出勤记录1</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 s 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：<br>    ‘A’：Absent，缺勤<br>    ‘L’：Late，迟到<br>    ‘P’：Present，到场<br>如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：<br>    按 总出勤 计，学生缺勤（’A’）严格 少于两天。<br>    学生 不会 存在 连续 3 天或 连续 3 天以上的迟到（’L’）记录。<br>如果学生可以获得出勤奖励，返回 true ；否则，返回 false 。</p>
<span id="more"></span>
<p>示例 1：<br>输入：s = “PPALLP”<br>输出：true<br>解释：学生缺勤次数少于 2 次，且不存在 3 天或以上的连续迟到记录。</p>
<p><a href>题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.一次遍历<br>可奖励的出勤记录要求缺勤次数少于 2 和连续迟到次数少于 3。判断出勤记录是否可奖励，只需要遍历出勤记录，判断这两个条件是否同时满足即可。<br>遍历过程中，记录缺勤次数和连续迟到次数，根据遍历到的字符更新缺勤次数和连续迟到次数：<br>    如果遇到 ‘A’，即缺勤，则将缺勤次数加 1，否则缺勤次数不变；<br>    如果遇到 ‘L’，即迟到，则将连续迟到次数加 1，否则将连续迟到次数清零。<br>如果在更新缺勤次数和连续迟到次数之后，出现缺勤次数大于或等于 2 或者连续迟到次数大于或等于 3，则该出勤记录不满足可奖励的要求，返回 false。如果遍历结束时未出现出勤记录不满足可奖励的要求的情况，则返回 true。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def checkRecord(self, s: str) -&gt; bool:
        # 统计字符串中出现‘A’的的次数
        count_A = s.count(&#39;A&#39;)
        # 字符串中是否有连续3个以上的‘L&#39;
        for i in range(len(s)):
            if i + 2 &lt; len(s) and s[i] == &#39;L&#39; and s[i+1] == &#39;L&#39; and s[i+2] == &#39;L&#39;:
                    return False

        return True if count_A &lt; 2 else False

    def checkRecord1(self, s: str) -&gt; bool:
        absents = lates = 0
        for char in s:
            if char == &quot;A&quot;:
                absents += 1
                lates = 0
            elif char == &quot;L&quot;:
                lates += 1
            else:
                lates = 0

            if lates &gt;= 3 or absents &gt; 1:
                return False

        return True
        # absents = lates = 0
        # for i, c in enumerate(s):
        #     if c == &quot;A&quot;:
        #         absents += 1
        #         if absents &gt;= 2:
        #             return False
        #
        #     if c == &quot;L&quot;:
        #         lates += 1
        #         if lates &gt;= 3:
        #             return False
        #     else:
        #         lates = 0
        #
        # return True


if __name__ == &quot;__main__&quot;:
    slt = Solution()
    # res = slt.checkRecord2(&quot;PPALLL&quot;)
    res = slt.checkRecord2(&quot;PPALLP&quot;)
    print(res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Django | 安装mysql_python失败</title>
    <url>/2021/07/25/%E5%AE%89%E8%A3%85mysql-python%E5%A4%B1%E8%B4%A5/</url>
    <content><![CDATA[<h1 id="安装mysql-python失败"><a href="#安装mysql-python失败" class="headerlink" title="安装mysql_python失败"></a>安装mysql_python失败</h1><p><a href="https://blog.csdn.net/qq_37431752/article/details/87965695">解决办法！！！</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>框架</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>实现strStr方法</title>
    <url>/2021/08/27/%E5%AE%9E%E7%8E%B0strStr%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="28-实现strStr"><a href="#28-实现strStr" class="headerlink" title="28.实现strStr()"></a>28.实现strStr()</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>实现 strStr() 函数。<br>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。<br><a href="https://leetcode-cn.com/problems/implement-strstr/">题目链接</a></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.直接调用python内置方法<br>2.暴力匹配<br>让字符串 needle 与字符串 haystack 的所有长度为 m（needle字符串的长度） 的子串均匹配一次。<br>为了减少不必要的匹配，我们每次匹配失败即立刻停止当前子串的匹配，对下一个子串继续匹配。如果当前子串匹配成功，我们返回当前子串的开始位置即可。如果所有子串都匹配失败，则返回 −1-1−1。<br><strong style="color:red">3.kmp算法</strong><br>kmp算法的目的：为了避免不必要的指针回溯<br>主串指针i不回溯，模式串指针j的变化取决于模式串的结构是否有重复<br>pi数组值的计算：<br>pi数组的值为最长相同前后缀长度+1(串本身不能作为前后缀)<br>pi[1]=0,其他情况next[]=1.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    &quot;&quot;&quot;
    kmp算法的目的：为了避免不必要的指针回溯

    主串指针i不回溯，模式串指针j的变化取决于模式串的结构是否有重复

    pi数组值的计算：
    pi数组的值为最长相同前后缀长度+1(串本身不能作为前后缀)
    pi[1]=0,其他情况next[]=1.
    &quot;&quot;&quot;
    def strStr(self, haystack: str, needle: str) -&gt; int:
        # 获取主串和模式串的长度
        n = len(haystack)
        m = len(needle)

        # 如果模式串的长度为0，则返回0
        if m == 0:
            return 0

        pi = [0]*m

        # 求模式串的前缀函数值
        i = 1
        j = 0
        while i &lt; m:
            while j &gt; 0 and needle[i] != needle[j]:
                j = pi[j-1]  # 回溯

            if needle[i] == needle[j]:
                j += 1

            pi[i] = j

            i += 1

        print(&quot;模式串的前缀函数值:&quot;, pi)

        # kmp
        i = 0
        j = 0
        while i &lt; n:
            while j &gt; 0 and haystack[i] != needle[j]:
                j = pi[j-1]  # 回溯

            if haystack[i] == needle[j]:
                j += 1

            if j == m:
                return i - m + 1

            i += 1

        return -1

    def strStr1(self, haystack: str, needle: str) -&gt; int:
        &quot;&quot;&quot;调用内置方法&quot;&quot;&quot;
        # 方法1
        # return haystack.find(needle)

        # 方法2
        if not needle:
            return 0

        try:
            return haystack.index(needle)
        except ValueError:
            return -1

    def strStr2(self, haystack: str, needle: str) -&gt; int:
        &quot;&quot;&quot;暴力匹配&quot;&quot;&quot;
        n = len(haystack)
        m = len(needle)

        i = 0

        while i + m &lt;= n:
            flag = True

            j = 0
            while j &lt; m:
                if haystack[i + j] != needle[j]:
                    flag = False
                    break

                j += 1

            if flag:
                return i

            i += 1
        return -1


if __name__ == &quot;__main__&quot;:
    s = Solution()
    # print(s.strStr(&quot;mississippi&quot;, &quot;issip&quot;))  # [0, 0, 0, 1, 0]
    # print(s.strStr1(&quot;mississippi&quot;, &quot;issip&quot;))  # [0, 0, 0, 1, 0]
    print(s.strStr2(&quot;mississippi&quot;, &quot;issip&quot;))  # [0, 0, 0, 1, 0]
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>kmp算法</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程 | 实现线程体的两种方式</title>
    <url>/2021/08/05/%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E4%BD%93%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="实现线程体的两种方式"><a href="#实现线程体的两种方式" class="headerlink" title="实现线程体的两种方式"></a>实现线程体的两种方式</h1><p>实现线程体主要有以下两种方式：<br>1.自定义函数实现线程体<br>代码实例：</p>
<pre><code># coding=utf-8

import threading
import time


# 线程体函数
def thread_body():
    # 当前线程对象
    t = threading.current_thread()
    for n in range(5):
        # 当前线程名
        print(&#39;第&#123;0&#125;次执行线程&#123;1&#125;&#39;.format(n, t.name))
        # 线程休眠
        time.sleep(2)
    print(&#39;线程&#123;0&#125;执行完成！&#39;.format(t.name))


# 主线程
# 创建线程对象t1
t1 = threading.Thread(target=thread_body)
# 创建线程对象t2
t2 = threading.Thread(target=thread_body, name=&#39;MyThread&#39;)
# 启动线程t1
t1.start()
# 启动线程t2
t2.start()
</code></pre>
<p>2.自定义线程类实现线程体<br>代码实例：</p>
<pre><code># coding=utf-8

import time
import threading


class SmallThread(threading.Thread):
    def __init__(self, name=None):
        super().__init__(name=name)

    # 线程体函数
    def run(self):
        # 当前线程对象
        t = threading.current_thread()
        for n in range(5):
            # 当前线程名
            print(&#39;第&#123;0&#125;次执行线程&#123;1&#125;&#39;.format(n, t.name))
            # 线程休眠
            time.sleep(2)
        print(&#39;线程&#123;0&#125;执行完成&#39;.format(t.name))


# 主线程
# 创建线程对象t1
t1 = SmallThread()  # 通过自定义线程类，创建线程对象
# 创建线程对象t2
t2 = SmallThread(name=&#39;MyThread&#39;)
# 启动线程t1
t1.start()
# 启动线程t2
t2.start()
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>内置模块</category>
        <category>threading</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>多线程</tag>
        <tag>threading</tag>
      </tags>
  </entry>
  <entry>
    <title>sviewgui | 对数据文件中的数据进行可视化</title>
    <url>/2021/10/19/%E5%AF%B9%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<h1 id="使用sviewgui对csv文件或Pandas的DataFrame的数据可视化"><a href="#使用sviewgui对csv文件或Pandas的DataFrame的数据可视化" class="headerlink" title="使用sviewgui对csv文件或Pandas的DataFrame的数据可视化"></a>使用sviewgui对csv文件或Pandas的DataFrame的数据可视化</h1><p><a href="https://mp.weixin.qq.com/s/6ftmwDzlyuCgN5YsX81pKQ">参考资料</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>sviewgui</category>
      </categories>
      <tags>
        <tag>sviewgui</tag>
      </tags>
  </entry>
  <entry>
    <title>伪迹移除 | 小波变换</title>
    <url>/2021/02/23/%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="小波变换-Wavelet-Transform-WT"><a href="#小波变换-Wavelet-Transform-WT" class="headerlink" title="小波变换(Wavelet Transform,WT)"></a>小波变换(Wavelet Transform,WT)</h1><p>小波变化是一个时间尺度的表示方法，它把信号分解成时间和尺度的基函数(母小波基函数的扩展/变体)</p>
<h2 id="一些基于小波理论的技术"><a href="#一些基于小波理论的技术" class="headerlink" title="一些基于小波理论的技术"></a>一些基于小波理论的技术</h2><p>1.wavelet packets<br>2.wavelet approximation and decomposition<br>3.discrete and continuous wavelet transform<br>…<br>其中，最常用的技术是离散小波变换(Discrete Wavelet Transform);<br>离散小波变换是由离散输入的连续小波变换得到的；<br>离散小波变换将信号输入到低通滤波器中，得到低频分量，进入高通滤波器得到高频分量。</p>
<h2 id="离散小波变换进行2级分解的示例结构"><a href="#离散小波变换进行2级分解的示例结构" class="headerlink" title="离散小波变换进行2级分解的示例结构"></a>离散小波变换进行2级分解的示例结构</h2><p><img src="/2021/02/23/%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2/1.png"><br>where g[n] is a low pass filter and h[n] is a high pass filter</p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>伪迹移除</category>
      </categories>
      <tags>
        <tag>伪迹移除</tag>
        <tag>EEG</tag>
        <tag>小波变换</tag>
      </tags>
  </entry>
  <entry>
    <title>spring | 属性赋值</title>
    <url>/2022/03/05/%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC/</url>
    <content><![CDATA[<h1 id="属性赋值-字面量和ref"><a href="#属性赋值-字面量和ref" class="headerlink" title="属性赋值-字面量和ref"></a>属性赋值-字面量和ref</h1><p>spring管理对象时，可以使用<property></property>标签给对象的属性赋值。<br>1.字面量<br><property name="name" vlaue="张三"></property><br><property name="age" vlaue="23"></property><br>…..<br>2.外部已声明的bean引用其他的bean(使用ref属性)<br>3.内部bean<br>4.集合属性赋值（list/array/set）<br>示例：<br>1.项目目录<br><img src="/2022/03/05/%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC/2.PNG"><br>2.Student.java</p>
<pre><code>package com.atguigu.spring.di;

public class Student &#123;
    private Integer id;
    private String name;
    private Integer age;
    private String sex;
    private Double score;
    private Teacher teacher;
    
    
    public Teacher getTeacher() &#123;
        return teacher;
    &#125;

    public void setTeacher(Teacher teacher) &#123;
        this.teacher = teacher;
    &#125;

    public Double getScore() &#123;
        return score;
    &#125;
    
    public void setScore(Double score) &#123;
        this.score = score;
    &#125;
    
    public Integer getId() &#123;
        return id;
    &#125;
    
    public void setId(Integer id) &#123;
        this.id = id;
    &#125;
    
    public String getName() &#123;
        return name;
    &#125;
    
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    
    public Integer getAge() &#123;
        return age;
    &#125;
    
    public void setAge(Integer age) &#123;
        this.age = age;
    &#125;
    
    public String getSex() &#123;
        return sex;
    &#125;
    
    public void setSex(String sex) &#123;
        this.sex = sex;
    &#125;
    
    @Override
    public String toString() &#123;
        return &quot;Student [id=&quot; + id + &quot;, name=&quot; + name + &quot;, age=&quot; + age + &quot;, sex=&quot; + sex + &quot;, score=&quot; + score
                + &quot;, teacher=&quot; + teacher + &quot;]&quot;;
    &#125;

    public Student() &#123;
        super();
        // TODO Auto-generated constructor stub
    &#125;
    
    public Student(Integer id, String name, Integer age, String sex) &#123;
        super();
        this.id = id;
        this.name = name;
        this.age = age;
        this.sex = sex;
    &#125;
    
    public Student(Integer id, String name, Double score, String sex)&#123;
        this.id = id;
        this.name = name;
        this.score = score;
        this.sex = sex;
    &#125;
&#125;
</code></pre>
<p>3.Teacher.java</p>
<pre><code>package com.atguigu.spring.di;

import java.util.List;
import java.util.Map;

public class Teacher &#123;
    private Integer tid;
    
    private String tname;
    
    private List&lt;String&gt; cls;
    
    private List&lt;Student&gt; students;
    
    private Map&lt;String, String&gt; bossMap;
    
    public Map&lt;String, String&gt; getBossMap() &#123;
        return bossMap;
    &#125;
    public void setBossMap(Map&lt;String, String&gt; bossMap) &#123;
        this.bossMap = bossMap;
    &#125;
    public List&lt;Student&gt; getStudents() &#123;
        return students;
    &#125;
    public void setStudents(List&lt;Student&gt; students) &#123;
        this.students = students;
    &#125;
    public List&lt;String&gt; getCls() &#123;
        return cls;
    &#125;
    public void setCls(List&lt;String&gt; cls) &#123;
        this.cls = cls;
    &#125;
    public Integer getTid() &#123;
        return tid;
    &#125;
    public void setTid(Integer tid) &#123;
        this.tid = tid;
    &#125;
    public String getTname() &#123;
        return tname;
    &#125;
    public void setTname(String tname) &#123;
        this.tname = tname;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Teacher [tid=&quot; + tid + &quot;, tname=&quot; + tname + &quot;, cls=&quot; + cls + &quot;, students=&quot; + students + &quot;, bossMap=&quot;
                + bossMap + &quot;]&quot;;
    &#125;
    
    
&#125;
</code></pre>
<p>5.beans-di.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
    xmlns:util=&quot;http://www.springframework.org/schema/util&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd&quot;&gt;

    &lt;bean id=&quot;s1&quot; class=&quot;com.atguigu.spring.di.Student&quot;&gt;
        &lt;!-- 通过set方法注入 --&gt;
        &lt;property name=&quot;id&quot; value=&quot;10010&quot;&gt;&lt;/property&gt;
        &lt;!-- 
            &lt;property name=&quot;id&quot;&gt;
                &lt;value&gt;10010&lt;/value&gt;
            &lt;/property&gt;
         --&gt;
         
        &lt;property name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;sex&quot; value=&quot;男&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
        
    &lt;bean id=&quot;s2&quot; class=&quot;com.atguigu.spring.di.Student&quot;&gt;
        &lt;!-- 通过构造方法注入 --&gt;
        &lt;constructor-arg value=&quot;10086&quot;&gt;&lt;/constructor-arg&gt;
        &lt;constructor-arg value=&quot;李四&quot;&gt;&lt;/constructor-arg&gt;
        &lt;constructor-arg value=&quot;24&quot;&gt;&lt;/constructor-arg&gt;
        &lt;constructor-arg value=&quot;女&quot;&gt;&lt;/constructor-arg&gt;
    &lt;/bean&gt;
    
    &lt;bean id=&quot;s3&quot; class=&quot;com.atguigu.spring.di.Student&quot;&gt;
        &lt;!-- 通过构造方法注入 --&gt;
        &lt;constructor-arg value=&quot;10022&quot;&gt;&lt;/constructor-arg&gt;
        &lt;constructor-arg value=&quot;王五&quot;&gt;&lt;/constructor-arg&gt;
        &lt;constructor-arg value=&quot;90&quot; index=&quot;2&quot; type=&quot;java.lang.Double&quot;&gt;&lt;/constructor-arg&gt;
        &lt;constructor-arg value=&quot;女&quot;&gt;&lt;/constructor-arg&gt;
    &lt;/bean&gt;
    
    &lt;!-- Namespaces勾选p（beans标签会增加内容xmlns:p=&quot;http://www.springframework.org/schema/p&quot;） --&gt;
    &lt;bean id=&quot;s4&quot; class=&quot;com.atguigu.spring.di.Student&quot; p:id=&quot;10033&quot; p:name=&quot;赵六&quot; p:age=&quot;26&quot; p:sex=&quot;男&quot; p:teacher-ref=&quot;teacher&quot;&gt;&lt;/bean&gt;
    
    &lt;!-- 给bean的级联属性赋值 --&gt;
    &lt;bean id=&quot;s5&quot; class=&quot;com.atguigu.spring.di.Student&quot;&gt;
        &lt;property name=&quot;id&quot; value=&quot;10055&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;name&quot; value=&quot;张三三&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;sex&quot; value=&quot;男&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;teacher&quot; ref=&quot;teacher&quot;&gt;&lt;/property&gt;
        
        &lt;!-- 级联测试 给bean的级联属性赋值--&gt;
        &lt;property name=&quot;teacher.tname&quot; value=&quot;小红&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
        
    &lt;!-- 外部已声明的bean、引用其他的bean --&gt;
    &lt;bean id=&quot;teacher&quot; class=&quot;com.atguigu.spring.di.Teacher&quot;&gt;
        &lt;property name=&quot;tid&quot; value=&quot;10000&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;tname&quot; value=&quot;小明&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    
    &lt;!-- 内部bean --&gt;
    &lt;bean id=&quot;s6&quot; class=&quot;com.atguigu.spring.di.Student&quot;&gt;
        &lt;property name=&quot;id&quot; value=&quot;10066&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;name&quot; value=&quot;崔八&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;sex&quot; value=&quot;男&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;teacher&quot;&gt;
            &lt;bean id=&quot;tt&quot; class=&quot;com.atguigu.spring.di.Teacher&quot;&gt;
                &lt;property name=&quot;tid&quot; value=&quot;2222&quot;&gt;&lt;/property&gt;
                &lt;property name=&quot;tname&quot; value=&quot;admin&quot;&gt;&lt;/property&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    &lt;!-- 定义在某个bean内部的bean，只能在当前bean中使用 --&gt;
    &lt;!-- 
        &lt;bean id=&quot;s7&quot; class=&quot;com.atguigu.spring.di.Student&quot;&gt;
            &lt;property name=&quot;id&quot; value=&quot;10066&quot;&gt;&lt;/property&gt;
            &lt;property name=&quot;name&quot; value=&quot;崔八&quot;&gt;&lt;/property&gt;
            &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/property&gt;
            &lt;property name=&quot;sex&quot; value=&quot;男&quot;&gt;&lt;/property&gt;
            &lt;property name=&quot;teacher&quot; ref=&quot;tt&quot;&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
     --&gt;
     
     &lt;!-- list属性赋值1 --&gt;
     &lt;bean id=&quot;t1&quot; class=&quot;com.atguigu.spring.di.Teacher&quot;&gt;
        &lt;property name=&quot;tid&quot; value=&quot;0000&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;tname&quot; value=&quot;佟老师&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;cls&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;A&lt;/value&gt;
                &lt;value&gt;B&lt;/value&gt;
                &lt;value&gt;C&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
     &lt;/bean&gt;
     
     &lt;!-- list属性赋值2 --&gt;
     &lt;bean id=&quot;t2&quot; class=&quot;com.atguigu.spring.di.Teacher&quot;&gt;
        &lt;property name=&quot;tid&quot; value=&quot;10002&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;tname&quot; value=&quot;婷姐&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;students&quot;&gt;
            &lt;list&gt;
                &lt;ref bean=&quot;s1&quot;/&gt;
                &lt;ref bean=&quot;s2&quot;/&gt;
                &lt;ref bean=&quot;s3&quot;/&gt;
            &lt;/list&gt;
        &lt;/property&gt;
     &lt;/bean&gt;
     
     &lt;!-- array属性赋值 --&gt;
     &lt;!-- set属性赋值 --&gt;
     
     &lt;!-- map属性赋值 --&gt;
     &lt;bean id=&quot;t3&quot; class=&quot;com.atguigu.spring.di.Teacher&quot;&gt;
        &lt;property name=&quot;tid&quot; value=&quot;10003&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;tname&quot; value=&quot;admin&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;bossMap&quot;&gt;
            &lt;map&gt;
                &lt;entry&gt;
                    &lt;key&gt;
                        &lt;value&gt;10001&lt;/value&gt;
                    &lt;/key&gt;
                    &lt;value&gt;佟老师&lt;/value&gt;
                &lt;/entry&gt;
                
                &lt;entry&gt;
                    &lt;key&gt;
                        &lt;value&gt;10002&lt;/value&gt;
                    &lt;/key&gt;
                    &lt;value&gt;陈老师&lt;/value&gt;
                &lt;/entry&gt;
            &lt;/map&gt;
        &lt;/property&gt;
     &lt;/bean&gt;
     
     &lt;bean id=&quot;t4&quot; class=&quot;com.atguigu.spring.di.Teacher&quot;&gt;
        &lt;property name=&quot;tid&quot; value=&quot;10004&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;tname&quot; value=&quot;root&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;students&quot; ref=&quot;students&quot;&gt;&lt;/property&gt;
     &lt;/bean&gt;
    
    &lt;util:list id=&quot;students&quot;&gt;
        &lt;ref bean=&quot;s4&quot;/&gt;
        &lt;ref bean=&quot;s5&quot;/&gt;
        &lt;ref bean=&quot;s6&quot;/&gt;
    &lt;/util:list&gt;
    
    &lt;util:map id=&quot;map&quot;&gt;
        &lt;entry&gt;
            &lt;key&gt;
                &lt;value&gt;1&lt;/value&gt;
            &lt;/key&gt;
            &lt;value&gt;张三&lt;/value&gt;
        &lt;/entry&gt;
    &lt;/util:map&gt;
&lt;/beans&gt;
</code></pre>
<p>6.Test.java</p>
<pre><code>package com.atguigu.spring.di;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test &#123;

    public static void main(String[] args) &#123;
        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans-di.xml&quot;);
        
        Student s1 = ac.getBean(&quot;s1&quot;, Student.class);
        Student s2 = ac.getBean(&quot;s2&quot;, Student.class);
        Student s3 = ac.getBean(&quot;s3&quot;, Student.class);
        Student s4 = ac.getBean(&quot;s4&quot;, Student.class);
        Student s5 = ac.getBean(&quot;s5&quot;, Student.class);
        Student s6 = ac.getBean(&quot;s6&quot;, Student.class);
        Teacher t1 = ac.getBean(&quot;t1&quot;, Teacher.class);
        Teacher t2 = ac.getBean(&quot;t2&quot;, Teacher.class);
        Teacher t3 = ac.getBean(&quot;t3&quot;, Teacher.class);
        Teacher t4 = ac.getBean(&quot;t4&quot;, Teacher.class);
        
        System.out.println(s1);
        System.out.println(s2);
        System.out.println(s3);
        System.out.println(s4);
        System.out.println(s5);
        System.out.println(s6);
        System.out.println(t1);
        System.out.println(t2);
        System.out.println(t3);
        System.out.println(t4);
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>spring</category>
        <category>依赖注入</category>
        <category>属性赋值</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 | 工厂方法模式</title>
    <url>/2022/03/21/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><p><strong>why 工厂方法模式？</strong><br>简单工厂模式违背了开放封闭原则（开放了拓展，也开放了修改），如果需要增加功能就需要在工厂类中修改逻辑判断，于是工厂方法模式应运而生。</p>
<p>工厂方法模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法是一个类的实例化延迟到子类。</p>
<span id="more"></span>
<p><strong>案例</strong><br>类图：<br><img src="/2022/03/21/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/2.jpg"></p>
<pre><code>class Operation&#123;
    private double numberA = 0;
    private double numberB = 0;
    public double getNumberA() &#123;
        return numberA;
    &#125;
    public void setNumberA(double numberA) &#123;
        this.numberA = numberA;
    &#125;
    public double getNumberB() &#123;
        return numberB;
    &#125;
    public void setNumberB(double numberB) &#123;
        this.numberB = numberB;
    &#125;
    public double getResult() throws Exception&#123;
        double result = 0;
        return result;
    &#125;
&#125;

class Add extends Operation&#123;
    public double getResult()
    &#123;
        double result = 0;
        result = getNumberA() + getNumberB();
        return result;
    &#125;
&#125;

class Sub extends Operation&#123;
    public double getResult()
    &#123;
        double result = 0;
        result = getNumberA() - getNumberB();
        return result;
    &#125;
&#125;

class Mul extends Operation&#123;
    public double getResult()
    &#123;
        double result = 0;
        result = getNumberA() * getNumberB();
        return result;
    &#125;
&#125;

class Div extends Operation&#123;
    public double getResult() throws Exception
    &#123;
        double result = 0;
        if (getNumberB() == 0)&#123;
            throw new Exception(&quot;除数不能为0&quot;);
        &#125;
        result = getNumberA() / getNumberB();
        return result;
    &#125;
&#125;

//定义一个用于创建对象的接口
interface IFactory
&#123;
    Operation createOperation();
&#125;

class AddFactory implements IFactory&#123;
    @Override
    public Operation createOperation() &#123;
        return new Add();
    &#125;
&#125;

class SubFactory implements IFactory&#123;
    @Override
    public Operation createOperation() &#123;
        return new Add();
    &#125;
&#125;

class MulFactory implements IFactory&#123;
    @Override
    public Operation createOperation() &#123;
        return new Add();
    &#125;
&#125;

class DivFactory implements IFactory&#123;
    @Override
    public Operation createOperation() &#123;
        return new Add();
    &#125;
&#125;


public class FactoryMethodPatternTest &#123;
    public static void main(String[] args) throws Exception &#123;
        IFactory operFactory = new AddFactory();
        Operation oper = operFactory.createOperation();
        oper.setNumberA(1);
        oper.setNumberB(2);
        double result = oper.getResult();
        System.out.println(result);
    &#125;
&#125;
</code></pre>
<p>在使用工厂方法模式的情况下，如果我们要增加新的功能，比如说现在要增加一个求余操作，我们只需在上面代码的基础上增加两个类，即可实现。</p>
<pre><code>class Mod extends Operation&#123;
    public double getResult()&#123;
        double result = 0;
        result = getNumberA() % getNumberB();
        return result;
    &#125;
&#125;

class ModFactory implements IFactory&#123;

    @Override
    public Operation createOperation() &#123;
        return new Mod();
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>工厂方法模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>工厂方法模式</tag>
      </tags>
  </entry>
  <entry>
    <title>wxPython | 布局管理器嵌套</title>
    <url>/2021/08/03/%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8%E5%B5%8C%E5%A5%97/</url>
    <content><![CDATA[<h1 id="布局管理器嵌套"><a href="#布局管理器嵌套" class="headerlink" title="布局管理器嵌套"></a>布局管理器嵌套</h1><p><strong>实现效果：</strong><br>单击Button1按钮，显示“Button1单击”静态文本，单击Button2按钮，显示“Button2单击”静态文本。</p>
<p><strong>示例代码：</strong></p>
<h1 id="布局管理器嵌套-1"><a href="#布局管理器嵌套-1" class="headerlink" title="布局管理器嵌套"></a>布局管理器嵌套</h1><pre><code># coding=utf-8
import wx

class MyFrame(wx.Frame):
    def __init__(self):
        super().__init__(None, title=&quot;布局管理器嵌套&quot;, size=(300, 120))
        panel = wx.Panel(parent=self)
        self.static_text = wx.StaticText(parent=panel, label=&quot;请单击按钮&quot;)
        b1 = wx.Button(parent=panel, id=10, label=&#39;Button1&#39;)
        b2 = wx.Button(parent=panel, id=11, label=&#39;Button2&#39;)

        # 创建水平方向的盒子布局管理器hbox对象
        hbox = wx.BoxSizer(wx.HORIZONTAL)
        # 添加b1到hbox布局管理器
        hbox.Add(b1, proportion=1, flag=wx.EXPAND|wx.ALL, border=10)
        hbox.Add(b2, proportion=1, flag=wx.EXPAND|wx.ALL, border=10)

        # 创建垂直方向的盒子布局管理器对象vbox
        vbox = wx.BoxSizer(wx.VERTICAL)
        # 添加静态文本到vbox布局管理器
        vbox.Add(self.static_text, proportion=1, flag=wx.CENTER | wx.FIXED_MINSIZE | wx.TOP, border=10)
        # 将水平hbox布局管理器对象添加到垂直vbox布局管理器对象
        vbox.Add(hbox, proportion=1, flag=wx.CENTER)

        # 设置面板（panel）采用vbox布局管理器
        panel.SetSizer(vbox)

        # 将两个按钮（b1和b2）的单击事件绑定到self.on_click办法
        self.Bind(wx.EVT_BUTTON, self.on_click, id=10, id2=11)

    def on_click(self, event):
        event_id = event.GetId()
        print(event_id)
        if event_id == 10:
            self.static_text.SetLabelText(&#39;Button1单击&#39;)
        else:
            self.static_text.SetLabelText(&#39;Button2单击&#39;)


app = wx.App()  # 创建应用程序对象
frm = MyFrame()  # 创建窗口对象
frm.Show()  # 显示窗口
app.MainLoop()  # 进入主事件循环
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>wxPython</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>wxPython</tag>
      </tags>
  </entry>
  <entry>
    <title>入门指南 | 开发遇到问题怎么解决？</title>
    <url>/2021/02/20/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="开发遇到问题怎么解决？"><a href="#开发遇到问题怎么解决？" class="headerlink" title="开发遇到问题怎么解决？"></a>开发遇到问题怎么解决？</h1><p>我们在做开发的过程中常常会遇到这样、那样的问题，软件安装出错、配置出错、代码运行报错等等令人十分痛苦的问题，那么我们遇到问题时应该怎样去solve?<br><b>Answer:</b>我们在开发中遇到的百分之八九十的问题可以通过<br><b style="color:red">“官方文档+github+stack overflow”</b>去解决！</p>
]]></content>
      <categories>
        <category>入门指南</category>
      </categories>
  </entry>
  <entry>
    <title>SpringMVC | 异常处理</title>
    <url>/2022/03/17/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>1.在SpringMVC配置文件（springMVC.xml）中做以下配置：</p>
<pre><code>&lt;!-- 异常处理 --&gt;
&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt;
    &lt;property name=&quot;exceptionMappings&quot;&gt;
        &lt;props&gt;
            &lt;prop key=&quot;java.lang.NullPointerException&quot;&gt;error&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<span id="more"></span>
<p>2.index.jsp</p>
<pre><code>&lt;a href=&quot;testException&quot;&gt;测试异常&lt;/a&gt;
</code></pre>
<p>3.TestExceptionController.java</p>
<pre><code>package com.atguigu.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

@Controller
public class TestExceptionController &#123;
    @RequestMapping(value=&quot;/testException&quot;, method=RequestMethod.GET)
    public String testException()&#123;
        String s = null;
        System.err.println(s.substring(0, 5));
        return &quot;success&quot;;
    &#125;
&#125;
</code></pre>
<p>4.error.jsp</p>
<pre><code>&lt;a href=&quot;&quot;&gt;操作异常，请稍后重试&lt;/a&gt;

$&#123;exception&#125;
</code></pre>
<p>5.运行结果<br><img src="/2022/03/17/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/1.PNG"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>SpringMVC</category>
        <category>异常处理</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringMVC</tag>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title>spring | 引用外部属性文件</title>
    <url>/2022/03/05/%E5%BC%95%E7%94%A8%E5%A4%96%E9%83%A8%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="引用外部属性文件"><a href="#引用外部属性文件" class="headerlink" title="引用外部属性文件"></a>引用外部属性文件</h1><p>1.项目目录<br><img src="/2022/03/05/%E5%BC%95%E7%94%A8%E5%A4%96%E9%83%A8%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6/1.PNG"></p>
<p>2.导入druid-1.1.9.jar、mysql-connector-java-5.1.7-bin.jar</p>
<p>3.db.properties</p>
<pre><code># k = v
jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/test
jdbc.username=root
jdbc.password=123456
</code></pre>
<p>4.datasource.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&gt;
    
    &lt;!-- 直接配置 --&gt;
    &lt;!-- &lt;bean id=&quot;datasource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;password&quot; value=&quot;123456&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt; --&gt;
    
    &lt;!-- 加载资源文件（引用外部资源文件） --&gt;
    &lt;!-- &lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;
        &lt;property name=&quot;location&quot; value=&quot;db.properties&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;datasource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt; --&gt;
    
    &lt;!-- 使用context标签加载资源文件（引用外部属性文件） --&gt;
    &lt;context:property-placeholder location=&quot;db.properties&quot;/&gt;
    &lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;
        &lt;property name=&quot;location&quot; value=&quot;db.properties&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;datasource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt; 
&lt;/beans&gt;
</code></pre>
<p>5.Test.java</p>
<pre><code>package com.atguigu.ioc.datasource;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import com.alibaba.druid.pool.DruidDataSource;

public class Test &#123;

    public static void main(String[] args) throws Exception &#123;
        // TODO Auto-generated method stub
        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;datasource.xml&quot;);
        
        DruidDataSource bean = ac.getBean(&quot;datasource&quot;, DruidDataSource.class);
        
        System.out.println(bean);
        
        //System.out.println(bean.getConnection());
    &#125;

&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>spring</category>
        <category>引用外部属性文件</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>基础知识 | 归一化</title>
    <url>/2021/02/21/%E5%BD%92%E4%B8%80%E5%8C%96/</url>
    <content><![CDATA[<h1 id="归一化-Normalization"><a href="#归一化-Normalization" class="headerlink" title="归一化(Normalization)"></a>归一化(Normalization)</h1><p>在使用机器学习算法进行分类工作时，有时候我们发现某个特征对计算结果的影响最大，然而本质上用于分类的几个特征是同等重要的，而某个特征对计算结果影响大这一现象的原因仅仅是因为这个特征的特征值值比其他特征值大。因此<b style="color:red">在处理这种不同范围的特征值时，我们通常采用的方法是将数值归一化</b>，如将取值范围处理为0到1/-1到1之间。<br><b>例</b>：将任意取值范围的特征值转化为0到1区间内的值:<br><b style="red">newValue = (oldValue - min)/(max-min)</b><br>其中min和max分别是数据集中的最小特征值和最大特征值<br><b>Note:改变数值范围增加了分类器的复杂度</b></p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>归一化</tag>
      </tags>
  </entry>
  <entry>
    <title>装系统 | 微软官网工具安装纯净win10</title>
    <url>/2021/11/06/%E5%BE%AE%E8%BD%AF%E5%AE%98%E7%BD%91%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E7%BA%AF%E5%87%80win10/</url>
    <content><![CDATA[<h1 id="微软官网工具安装纯净win10"><a href="#微软官网工具安装纯净win10" class="headerlink" title="微软官网工具安装纯净win10"></a>微软官网工具安装纯净win10</h1><p><a href="https://zhuanlan.zhihu.com/p/92129617">参考资料</a></p>
]]></content>
      <categories>
        <category>电脑使用小技巧</category>
        <category>装系统</category>
      </categories>
      <tags>
        <tag>装系统</tag>
      </tags>
  </entry>
  <entry>
    <title>openpyxl | 快速提取一串字符中的中文</title>
    <url>/2021/10/21/%E5%BF%AB%E9%80%9F%E6%8F%90%E5%8F%96%E4%B8%80%E4%B8%B2%E5%AD%97%E7%AC%A6%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%87/</url>
    <content><![CDATA[<h1 id="快速提取一串字符中的中文"><a href="#快速提取一串字符中的中文" class="headerlink" title="快速提取一串字符中的中文"></a>快速提取一串字符中的中文</h1><p>以下代码实现了快速提取（正则表达式）一串字符串中的中文。</p>
<span id="more"></span>
<pre><code>import re
from openpyxl import load_workbook

data = []
wb = load_workbook(&#39;data/data.xlsx&#39;)
ws = wb.active
for row in range(2, ws.max_row + 1):  # 从第二行开始遍历excel文件所有行
    info = ws[&#39;A&#39; + str(row)].value
    data.append(info)

chinese_list = []
for i in data:
    chinese = re.findall(&#39;[\u4e00-\u9fa5]&#39;, i)
    chinese_list.append(&#39;&#39;.join(chinese))

for row in range(2, ws.max_row + 1):
    ws[&#39;B&#39; + str(row)].value = chinese_list[row - 2]
wb.save(&quot;./data/data_chinese.xlsx&quot;)
</code></pre>
<p><a href="data.xlsx">下载data.xlsx</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>openpyxl</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>openpyxl</tag>
        <tag>re</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 情绪识别想法与实践的起点</title>
    <url>/2021/07/02/%E6%83%85%E7%BB%AA%E8%AF%86%E5%88%AB%E6%83%B3%E6%B3%95%E4%B8%8E%E5%AE%9E%E8%B7%B5%E7%9A%84%E8%B5%B7%E7%82%B9/</url>
    <content><![CDATA[<h1 id="情绪识别想法与实践的起点"><a href="#情绪识别想法与实践的起点" class="headerlink" title="情绪识别想法与实践的起点"></a>情绪识别想法与实践的起点</h1><p>步入研一以来，about我的研究方向，一开始聚焦在脑电伪迹去除，大约看了10篇左右论文，后来在与给老师的汇报和交流中，关于研究方向<br>的keywords变成了：深度学习、脑电、分类、音乐、情绪识别，偶然我遇到了下面这篇论文，题目的每一个字都与我的research密切对应，<br>因此一场深度学习情绪分类的战役由此拉开。。。</p>
<p><b>Paper title:</b> Spatiotemporal Emotion Recognition using Deep CNN Based on EEG during Music Listening<br><a href="https://www.researchgate.net/publication/336736347_Spatiotemporal_Emotion_Recognition_using_Deep_CNN_Based_on_EEG_during_Music_Listening">论文地址</a></p>
<p>这篇论文的作者有几篇关于脑电情绪分类的研究文章，详细信息查看researchgate!<br><a href="https://www.researchgate.net/profile/Panayu-Keelawat">researcher researchgate site</a></p>
<h2 id="论文简要介绍"><a href="#论文简要介绍" class="headerlink" title="论文简要介绍"></a>论文简要介绍</h2><p><b>Considerations:</b><br>1.explore the model’s capabilities in varied window sizes and electrode orders<br>2.model’s complexity:(3conv ~ 6conv)</p>
<p><b>Results:</b><br>temporal information in distinct window sizes significantly affects recognition performance</p>
<p><b>Used Megthod:CNN</b><br>without mannually extracting features</p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>脑电分类</category>
        <category>网络</category>
        <category>CNN</category>
      </categories>
      <tags>
        <tag>脑电分类</tag>
        <tag>深度学习</tag>
        <tag>CNN</tag>
        <tag>EEG</tag>
        <tag>情绪识别</tag>
      </tags>
  </entry>
  <entry>
    <title>CNN | 感受野</title>
    <url>/2021/11/11/%E6%84%9F%E5%8F%97%E9%87%8E/</url>
    <content><![CDATA[<h1 id="感受野"><a href="#感受野" class="headerlink" title="感受野"></a>感受野</h1><p><a href="https://www.cnblogs.com/shine-lee/p/12069176.html">Click Here!</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
        <category>CNN</category>
      </categories>
      <tags>
        <tag>感受野</tag>
      </tags>
  </entry>
  <entry>
    <title>基于JavaWeb的网上购物商城 | 我的订单</title>
    <url>/2022/01/17/%E6%88%91%E7%9A%84%E8%AE%A2%E5%8D%95/</url>
    <content><![CDATA[<h1 id="我的订单"><a href="#我的订单" class="headerlink" title="我的订单"></a>我的订单</h1><p><strong>实现功能：</strong><br>当用户点击”我的订单时“展示用户提交过的所有订单信息、购买商品信息等。<br><img src="/2022/01/17/%E6%88%91%E7%9A%84%E8%AE%A2%E5%8D%95/1.PNG"></p>
<span id="more"></span>
<p><strong>header.jsp</strong><br>更改”我的订单”链接的地址。</p>
<pre><code>&lt;div class=&quot;col-md-3&quot; style=&quot;padding-top:20px&quot;&gt;
    &lt;ol class=&quot;list-inline&quot;&gt;
        &lt;c:if test=&quot;$&#123;empty user&#125;&quot;&gt;
            &lt;li&gt;&lt;a href=&quot;login.jsp&quot;&gt;登录&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;register.jsp&quot;&gt;注册&lt;/a&gt;&lt;/li&gt;
        &lt;/c:if&gt;
        &lt;c:if test=&quot;$&#123;not empty user&#125;&quot;&gt;
            &lt;li&gt;$&#123;user.username&#125;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;cart.jsp&quot;&gt;购物车&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/product?method=myOrder&quot;&gt;我的订单&lt;/a&gt;&lt;/li&gt;
        &lt;/c:if&gt;
    &lt;/ol&gt;
&lt;/div&gt;
</code></pre>
<p><strong>ProductServlet.java</strong><br>在ProductServlet的doGet方法中添加myOrder的判断并完成myOrder方法。</p>
<pre><code>public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
    String method = request.getParameter(&quot;method&quot;);
    if(&quot;getProById&quot;.equals(method)) &#123;
        getProById(request, response);
    &#125;else if(&quot;findListByCate&quot;.equals(method)) &#123;
        findListByCate(request, response);
    &#125;else if(&quot;cart&quot;.equals(method)) &#123;
        cart(request, response);
    &#125;else if(&quot;delCart&quot;.equals(method)) &#123;
        delCart(request, response);
    &#125;else if(&quot;clearCart&quot;.equals(method)) &#123;
        clearCart(request, response);
    &#125;else if(&quot;showOrder&quot;.equals(method)) &#123;
        showOrder(request, response);
    &#125;else if(&quot;submitOrder&quot;.equals(method)) &#123;
        submitOrder(request, response);
    &#125;else if(&quot;myOrder&quot;.equals(method)) &#123;
        myOrder(request, response);
    &#125;
&#125;

public void myOrder(HttpServletRequest request, HttpServletResponse response) &#123;
    // TODO Auto-generated method stub
    try &#123;
        User user = (User)request.getSession().getAttribute(&quot;user&quot;);
        String uid = user.getUid();
        
        ProductService ps = new ProductService();
        List&lt;Order&gt; list = ps.findOrderList(uid);
        
        //循环读出item项
        for(Order o:list) &#123;
            List&lt;OrderItem&gt; arr = ps.findItemList(o.getOid());
            
            for(OrderItem oo:arr) &#123;
                Product pro = ps.getProById(oo.getPid());
                oo.setPro(pro);
            &#125;
            o.setList(arr);
        &#125;
        
        //返回到订单列表页面
        request.setAttribute(&quot;list&quot;, list);
        try &#123;
            request.getRequestDispatcher(&quot;/order_list.jsp&quot;).forward(request, response);
        &#125; catch (Exception e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125; 
    &#125; catch (SQLException e) &#123;
        // TODO Auto-generated catch block
        e.printStackTrace();
    &#125;
&#125;
</code></pre>
<p><strong>ProductService.java</strong><br>在ProductService中添加findOrderList、findItemList方法。</p>
<pre><code>public List&lt;Order&gt; findOrderList(String uid) throws SQLException &#123;
    // TODO Auto-generated method stub
    ProductDao pd = new ProductDao();
    List&lt;Order&gt; list = pd.findOrderList(uid);
    return list;
&#125;

public List&lt;OrderItem&gt; findItemList(String oid) throws SQLException &#123;
    // TODO Auto-generated method stub
    ProductDao pd = new ProductDao();
    List&lt;OrderItem&gt; list = pd.findItemList(oid);
    return list;
&#125;
</code></pre>
<p><strong>ProductDao.java</strong><br>在ProductDao中添加findOrderList、findItemList方法。</p>
<pre><code>public List&lt;Order&gt; findOrderList(String uid) throws SQLException &#123;
    // TODO Auto-generated method stub
    QueryRunner qr = new QueryRunner(DataSourceUtils.getDataSource());
    
    String sql = &quot;select * from orders where uid=? order by ordertime desc&quot;;
    
    List&lt;Order&gt; list = qr.query(sql, new BeanListHandler&lt;&gt;(Order.class), uid);
    return list;
&#125;

public List&lt;OrderItem&gt; findItemList(String oid) throws SQLException &#123;
    // TODO Auto-generated method stub
    QueryRunner qr = new QueryRunner(DataSourceUtils.getDataSource());
    
    String sql = &quot;select * from orderitem where oid=?&quot;;
    
    List&lt;OrderItem&gt; list = qr.query(sql, new BeanListHandler&lt;&gt;(OrderItem.class), oid);
    return list;
&#125;
</code></pre>
<p><strong>order_list.jsp</strong><br>在order_list.jsp页面解析所有订单。</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;

&lt;head&gt;
&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;
&lt;title&gt;会员登录&lt;/title&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap.min.css&quot; type=&quot;text/css&quot; /&gt;
&lt;script src=&quot;js/jquery-1.11.3.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;js/bootstrap.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;!-- 引入自定义css文件 style.css --&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot; type=&quot;text/css&quot; /&gt;

&lt;style&gt;
body &#123;
    margin-top: 20px;
    margin: 0 auto;
&#125;

.carousel-inner .item img &#123;
    width: 100%;
    height: 300px;
&#125;
&lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;!-- 引入header.jsp --&gt;
    &lt;jsp:include page=&quot;/header.jsp&quot;&gt;&lt;/jsp:include&gt;

    &lt;div class=&quot;container&quot;&gt;
        &lt;div class=&quot;row&quot;&gt;
            &lt;div style=&quot;margin: 0 auto; margin-top: 10px; width: 950px;&quot;&gt;
                &lt;strong&gt;我的订单&lt;/strong&gt;
                &lt;table class=&quot;table table-bordered&quot;&gt;
                    &lt;tbody&gt;
                        &lt;c:forEach items=&quot;$&#123;list&#125;&quot; var=&quot;orders&quot;&gt;
                                &lt;tr class=&quot;success&quot;&gt;
                                    &lt;th colspan=&quot;2&quot;&gt;订单编号:$&#123;orders.oid&#125;&lt;/th&gt;
                                    &lt;th colspan=&quot;2&quot; style=&quot;text-align:center&quot;&gt;订单时间:$&#123;orders.ordertime&#125;&lt;/th&gt;
                                    &lt;th colspan=&quot;1&quot; &gt;是否支付:
                                        &lt;c:if test=&quot;$&#123;orders.state==1&#125;&quot;&gt;已支付&lt;/c:if&gt;
                                        &lt;c:if test=&quot;$&#123;orders.state==0&#125;&quot;&gt;未支付&lt;/c:if&gt;
                                    &lt;/th&gt;
                                &lt;/tr&gt;
                                &lt;tr class=&quot;warning&quot;&gt;
                                    &lt;th&gt;图片&lt;/th&gt;
                                    &lt;th&gt;商品&lt;/th&gt;
                                    &lt;th&gt;价格&lt;/th&gt;
                                    &lt;th&gt;数量&lt;/th&gt;
                                    &lt;th&gt;小计&lt;/th&gt;
                                &lt;/tr&gt;
                                &lt;c:forEach items=&quot;$&#123;orders.list&#125;&quot; var=&quot;item&quot;&gt;
                                    &lt;tr class=&quot;active&quot;&gt;
                                        &lt;td width=&quot;60&quot; width=&quot;40%&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;id&quot;
                                            value=&quot;22&quot;&gt; &lt;img src=&quot;$&#123;pageContext.request.contextPath&#125;/$&#123;item.pro.pimage&#125;&quot; width=&quot;70&quot;
                                            height=&quot;60&quot;&gt;&lt;/td&gt;
                                        &lt;td width=&quot;30%&quot;&gt;&lt;a target=&quot;_blank&quot;&gt;$&#123;item.pro.pname&#125;&lt;/a&gt;&lt;/td&gt;
                                        &lt;td width=&quot;20%&quot;&gt;￥$&#123;item.pro.shop_price&#125;&lt;/td&gt;
                                        &lt;td width=&quot;10%&quot;&gt;$&#123;item.count&#125;&lt;/td&gt;
                                        &lt;td width=&quot;15%&quot;&gt;&lt;span class=&quot;subtotal&quot;&gt;￥$&#123;item.subtotal&#125;&lt;/span&gt;&lt;/td&gt;
                                    &lt;/tr&gt;
                                &lt;/c:forEach&gt;
                                
                        &lt;/c:forEach&gt;
                        
                    &lt;/tbody&gt;
                &lt;/table&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div style=&quot;text-align: center;&quot;&gt;
            &lt;ul class=&quot;pagination&quot;&gt;
                &lt;li class=&quot;disabled&quot;&gt;&lt;a href=&quot;#&quot; aria-label=&quot;Previous&quot;&gt;&lt;span
                        aria-hidden=&quot;true&quot;&gt;&amp;laquo;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
                &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;1&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;2&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;3&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;4&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;5&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;6&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;7&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;8&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;9&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href=&quot;#&quot; aria-label=&quot;Next&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;raquo;&lt;/span&gt;
                &lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;!-- 引入footer.jsp --&gt;
    &lt;jsp:include page=&quot;/footer.jsp&quot;&gt;&lt;/jsp:include&gt;
    
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
]]></content>
      <categories>
        <category>项目经历</category>
        <category>JavaWeb</category>
        <category>基于JavaWeb的网上购物商城</category>
        <category>我的订单</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
        <tag>基于JavaWeb的网上购物商城</tag>
        <tag>我的订单</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 感知机</title>
    <url>/2021/06/24/%E6%84%9F%E7%9F%A5%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h1><p><a href="https://mp.weixin.qq.com/s/OKUCFdBLuwkJMxRz-gvthQ">点这里查看更多关于感知机的知识！！！</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>感知机</tag>
      </tags>
  </entry>
  <entry>
    <title>python-docx | 批量修改word文件中的段落格式</title>
    <url>/2021/10/28/%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9word%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%AE%B5%E8%90%BD%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="批量修改word文件中的段落格式"><a href="#批量修改word文件中的段落格式" class="headerlink" title="批量修改word文件中的段落格式"></a>批量修改word文件中的段落格式</h1><p>实现代码：</p>
<pre><code>import os
import docx
# 定义字体格式
from docx.shared import Pt  # 用于设定字体大小（磅值）
from docx.oxml.ns import qn  # 用于应用中文字体


def F_title(run):
    # 标题文字
    run.font.size = Pt(22)  # 文字大小磅值
    run.bold = True  # 加粗
    run.font.name = &quot;方正小标宋_GBK&quot;  # 字体
    r = run._element.rPr.rFonts
    r.set(qn(&quot;w:eastAsia&quot;), &quot;方正小标宋_GBK&quot;)  # 字体


def F_name_dept(run):
    # 姓名，部门，日期
    run.font.size = Pt(17)  # 文字大小磅值
    run.bold = False  # 加粗
    run.font.name = &quot;楷体&quot;  # 字体
    r = run._element.rPr.rFonts
    r.set(qn(&quot;w:eastAsia&quot;), &quot;楷体&quot;)  # 字体


def F_main(run):
    # 正文的格式
    run.font.size = Pt(17)  # 文字大小磅值
    run.bold = False  # 加粗
    run.font.name = &quot;仿宋&quot;  # 字体
    r = run._element.rPr.rFonts
    r.set(qn(&quot;w:eastAsia&quot;), &quot;仿宋&quot;)  # 字体


def F_title1(run):
    # 标题一的格式
    run.font.size = Pt(17)  # 文字大小磅值
    run.bold = False  # 加粗
    run.font.name = &quot;黑体&quot;  # 字体
    r = run._element.rPr.rFonts
    r.set(qn(&quot;w:eastAsia&quot;), &quot;黑体&quot;)  # 字体


def F_title2(run):
    # 标题二的格式
    run.font.size = Pt(17)  # 文字大小磅值
    run.bold = True  # 加粗
    run.font.name = &quot;楷体&quot;  # 字体
    r = run._element.rPr.rFonts
    r.set(qn(&quot;w:eastAsia&quot;), &quot;楷体&quot;)  # 字体


# 获取待处理的文件的路径
path = &#39;待处理文件&#39;  # 文件所在文件夹
files = [path + &quot;\\&quot; + i for i in os.listdir(path)]  # 获取文件夹下的文件名,并拼接完整路径
# print(files)
# 逐个提取文件，设置字体格式
for file in files:
    doc = docx.Document(file)
    for run in doc.paragraphs[0].runs:  # 总标题字体格式
        F_title(run)

    for para in doc.paragraphs[1:3]:  # 部门、姓名及日期字体格式
        for run in para.runs:
            F_name_dept(run)

    title1 = [&quot;一、&quot;, &quot;二、&quot;, &quot;三、&quot;, &quot;四、&quot;]  # 标题一的唯一特征字符串
    title2 = [&quot;1、&quot;, &quot;2、&quot;, &quot;3、&quot;, &quot;4、&quot;]  # 标题二的唯一特征字符串
    for para in doc.paragraphs[3:]:
        if any(i in para.text for i in title1):  # 若该段落是标题一，则应用标题一的字体格式
            for run in para.runs:
                F_title1(run)
        elif any(j in para.text for j in title2):  # 若该段落是标题二，则应用标题二的字体格式
            for run in para.runs:
                F_title2(run)
        else:
            for run in para.runs:  # 其余都应用正文的字体格式
                F_main(run)
    doc.save(&#39;已处理文件\\&#123;&#125;&#39;.format(file.split(&quot;\\&quot;)[1]))
    
</code></pre>
<p>已处理文件：<br><a href="报告-何十.docx">报告-何十.docx</a><br><a href="报告-刘七.docx">报告-刘七.docx</a><br><a href="报告-张三.docx">报告-张三.docx</a><br><a href="报告-朱八.docx">报告-朱八</a><br><a href="报告-李四.docx">报告-李四.docx</a><br><a href="报告-猪八戒.docx">报告-猪八戒.docx</a><br><a href="报告-王五.docx">报告-王五.docx</a><br><a href="报告-秦九.docx">报告-秦九.docx</a><br><a href="报告-赵六.docx">报告-赵六.docx</a><br><a href="报告-黄二.docx">报告-黄二.docx</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>python-docx</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python-docx</tag>
      </tags>
  </entry>
  <entry>
    <title>PIL | 批量压缩图片</title>
    <url>/2021/10/24/%E6%89%B9%E9%87%8F%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h1 id="批量压缩图片"><a href="#批量压缩图片" class="headerlink" title="批量压缩图片"></a>批量压缩图片</h1><p>实现代码：</p>
<pre><code># 将图片按修改时间排序(这样才能与图片的描述一致)，将路径存入列表，以便后面逐个插入图片时调用
import os
from PIL import Image
from docx import Document

path = &quot;6s_pictures&quot;
list_p = [path + &quot;\\&quot; + i for i in os.listdir(path)]  # 获取图片的文件名,并拼接完整路径
list_p.sort(key=lambda path: os.path.getmtime(path))  # 将列表中的文件按其修改时间排序，os.path.getmtime() 函数是获取文件最后修改时间
print(list_p)

# 按比例缩小图片尺寸
for infile in list_p:
    im = Image.open(infile)
    (x, y) = im.size  # 读取图片尺寸（像素）
    x_s = 165  # 定义缩小后的标准宽度
    y_s = int(y * x_s / x)  # 基于标准宽度计算缩小后的高度
    out = im.resize((x_s, y_s), Image.ANTIALIAS)  # 改变尺寸，保持图片高品质
    out.save(r&quot;6s_pictures_new\&#123;&#125;&quot;.format(infile.split(&quot;\\&quot;)[-1]))

path = &quot;6s_pictures_new&quot;
list_p = [path + &quot;\\&quot; + i for i in os.listdir(path)]  # 获取图片的文件名,并拼接完整路径
list_p.sort(key=lambda path: os.path.getmtime(path))  # 将列表中的文件按其修改时间排序，os.path.getmtime() 函数是获取文件最后修改时间

doc = Document(&quot;6S稽查问题模板.docx&quot;)
table = doc.tables[0]  # 已确定是第一个表格，其索引是0

# 增加需要的行，以便足够填入数据
for i in range(len(list_p) - 1):
    table.add_row()

# 写入数据及图片
for row in range(1, len(list_p) + 1):
    # 插入图片
    run = table.cell(row, 2).paragraphs[0].add_run()  # 新增一个文字块
    picture = run.add_picture(list_p[row - 1])  # 插入图片

doc.save(&quot;6S稽查问题.docx&quot;)
</code></pre>
<p><a href="https://github.com/victory-liao/victory-liao.github.io/tree/master/source/images/6s_pictures">6s_pictures</a><br><a href="6S稽查问题模板.docx">6S稽查问题模板.docx</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>PIL</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>PIL</tag>
        <tag>python-docx</tag>
      </tags>
  </entry>
  <entry>
    <title>pypiwin32 | 批量发送不同内容的邮件给不同的收件人</title>
    <url>/2021/10/27/%E6%89%B9%E9%87%8F%E5%8F%91%E9%80%81%E4%B8%8D%E5%90%8C%E5%86%85%E5%AE%B9%E7%9A%84%E9%82%AE%E4%BB%B6%E7%BB%99%E4%B8%8D%E5%90%8C%E7%9A%84%E6%94%B6%E4%BB%B6%E4%BA%BA/</url>
    <content><![CDATA[<h1 id="批量发送不同内容的邮件给不同的收件人"><a href="#批量发送不同内容的邮件给不同的收件人" class="headerlink" title="批量发送不同内容的邮件给不同的收件人"></a>批量发送不同内容的邮件给不同的收件人</h1><p>程序实现自动将’年假_按部门’下各个部门的年假情况Excel表格发送给’邮件地址.xlsx’中各个部门的负责人。</p>
<span id="more"></span>
<p>实现代码：</p>
<pre><code>import os
from openpyxl import load_workbook

wb = load_workbook(&quot;邮件地址.xlsx&quot;)
ws = wb.active
address = &#123;&#125;
for i in range(2, ws.max_row + 1):
    dept = ws[&quot;A&quot; + str(i)].value
    to_add = ws[&quot;B&quot; + str(i)].value
    cc_add = ws[&quot;C&quot; + str(i)].value
    address[dept] = [to_add, cc_add]

import win32com.client as win32


def Send_mail(to_add, cc_add, file_path, dept):
    &#39;&#39;&#39;
    传入参数说明：
    to_add,收件人地址
    cc_add,抄送地址
    file_path,附件路径
    dept,部门名称
    &#39;&#39;&#39;
    outlook = win32.Dispatch(&#39;Outlook.Application&#39;)  # 调用windows outlook应用
    mail = outlook.CreateItem(0)  # 创建邮件
    mail.to = to_add  # 收件人
    mail.cc = cc_add  # 抄送人
    mail.Subject = &quot;&#123;&#125;年假情况&quot;.format(dept)  # 主题
    mail.Attachments.Add(file_path)  # 添加附件。若有多个附件，则多调用几次即可
    mail.Body = &#39;&#39;&#39;Dear All,\n这是&#123;&#125;的年假情况，请查收！谢谢。\n\nBest regards!\n人事部 小李&#39;&#39;&#39;.format(dept)  # 正文内容
    mail.Send()  # 发送邮件


# 发送邮件到各部门
for dept in address.keys():
    to_add = address[dept][0]
    cc_add = address[dept][1]
    file_path = os.getcwd() + &#39;\\年假_按部门\\年假情况_&#123;&#125;.xlsx&#39;.format(dept)
    Send_mail(to_add, cc_add, file_path, dept)

print(&quot;邮件发送完成。&quot;)
</code></pre>
<p>‘年假_按部门’文件夹包括以下内容：<br><a href="年假情况_人事部.xlsx">年假情况_人事部.xlsx</a><br><a href="年假情况_关务部.xlsx">年假情况_关务部.xlsx</a><br><a href="年假情况_品质部.xlsx">年假情况_品质部.xlsx</a><br><a href="年假情况_工程部.xlsx">年假情况_工程部.xlsx</a><br><a href="年假情况_总务部.xlsx">年假情况_总务部.xlsx</a><br><a href="年假情况_物料部.xlsx">年假情况_物料部.xlsx</a><br><a href="年假情况_生产部.xlsx">年假情况_生产部.xlsx</a><br><a href="年假情况_研发部.xlsx">年假情况_研发部.xlsx</a><br><a href="年假情况_船务部.xlsx">年假情况_船务部.xlsx</a><br><a href="年假情况_采购部.xlsx">年假情况_采购部.xlsx</a></p>
<p><a href="邮件地址.xlsx">邮件地址.xlsx</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>pypiwin32</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>openpyxl</tag>
        <tag>pypiwin32</tag>
      </tags>
  </entry>
  <entry>
    <title>win32api | 批量打印文件</title>
    <url>/2021/10/29/%E6%89%B9%E9%87%8F%E6%89%93%E5%8D%B0%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="定义打印函数，以便重复调用"><a href="#定义打印函数，以便重复调用" class="headerlink" title="定义打印函数，以便重复调用"></a>定义打印函数，以便重复调用</h1><p>实现代码：</p>
<pre><code>import win32api


def Print(fileName):
    win32api.ShellExecute(
        0,  # 指定父窗口句柄，搞不懂
        &quot;print&quot;,  # 指定操作，这里的&quot;print&quot;表示启动打印应用程序
        fileName,  # 要打印的文件名
        None,  # 打印机设置，若是&quot;None&quot;，则使用windows设置的默认打印机
        &quot;.&quot;,  # 指定默认目录，照抄的，搞不懂
        0  # 若fileName参数是一个可执行程序，则此参数指定程序窗口的初始显示方式，否则此参数应设置为0
    )


# 获取待打印文件的路径
import os

path = &#39;文件&#39;  # 文件所在文件夹
files = [path + &quot;\\&quot; + i for i in os.listdir(path)]  # 获取文件夹下的文件名,并拼接完整路径

# 批量打印
for file in files:
    Print(file)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>win32api</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>os</tag>
        <tag>win32api</tag>
      </tags>
  </entry>
  <entry>
    <title>os | 批量新建文件夹</title>
    <url>/2021/11/04/%E6%89%B9%E9%87%8F%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/</url>
    <content><![CDATA[<h1 id="批量新建文件夹"><a href="#批量新建文件夹" class="headerlink" title="批量新建文件夹"></a>批量新建文件夹</h1><p>程序实现在指定目录下批量生成文件夹。</p>
<span id="more"></span>
<p>代码：</p>
<pre><code>import os
from datetime import datetime
from time import time, localtime, strftime
from tkinter import Tk, Entry, Button, Listbox, X, Y, END, Scrollbar, RIGHT, BOTTOM, HORIZONTAL, StringVar, Label
from tkinter.filedialog import askdirectory


class MainGUI():
    def __init__(self):
        myWindow = Tk()
        myWindow.title(&quot;批量新建文件夹&quot;)
        # 设置窗口大小
        myWindow.geometry(&#39;590x400&#39;)
        # 增加标签
        self.label_1 = Label(myWindow, text=&#39; 目标目录:&#39;)
        self.label_1.place(x=10, y=10, width=70, height=30)
        self.label_2 = Label(myWindow, text=&#39;文件夹数量:&#39;)
        self.label_2.place(x=10, y=50, width=70, height=30)

        # 增加文本框
        addr = StringVar(value=&#39;C:\\Users\\xxxx\\Desktop&#39;)  # 文本框默认显示的内容
        self.input_entry = Entry(myWindow, highlightcolor=&#39;red&#39;, highlightthickness=1, textvariable=addr)
        self.input_entry.place(x=80, y=10, width=410, height=30)
        self.btn_in = Button(myWindow, text=&#39;选择目录&#39;, command=self.select_dir1, width=10, height=1)
        self.btn_in.place(x=500, y=10)

        folder_quantity = str(self.get_folder_qty())  # 从日志文件`log.txt`中读取最近使用过的文件夹数量
        def_qty = StringVar(value=folder_quantity)
        self.folderQty_entry = Entry(myWindow, highlightcolor=&#39;blue&#39;, highlightthickness=1, textvariable=def_qty)
        self.folderQty_entry.place(x=80, y=50, width=410, height=30)
        self.btn_exe = Button(myWindow, text=&#39;执行新建&#39;, command=self.create_folders, width=10, height=1)
        self.btn_exe.place(x=500, y=50)

        # 增加列表框
        self.result_show = Listbox(myWindow, bg=&#39;Azure&#39;)
        self.result_show.place(x=10, y=100, width=570, height=290)
        self.sbY = Scrollbar(self.result_show, command=self.result_show.yview)  # 在列表框中增加Y轴滚动条
        self.sbY.pack(side=RIGHT, fill=Y)
        self.result_show.config(yscrollcommand=self.sbY.set)
        self.sbX = Scrollbar(self.result_show, command=self.result_show.xview, orient=HORIZONTAL)  # 在列表框中增加X轴滚动条
        self.sbX.pack(side=BOTTOM, fill=X)
        self.result_show.config(xscrollcommand=self.sbX.set)

        myWindow.mainloop()

    def select_dir1(self):
        self.input_entry.delete(0, END)
        self.input_entry.insert(0, askdirectory(initialdir=&quot;D:\\&quot;))

    def create_folders(self):
        date = self.get_current_date()  # 获取日期
        qty = int(self.folderQty_entry.get())  # 获取文本框中文件夹数量，并转为整数
        for i in range(1, qty + 1):
            folder = self.input_entry.get() + &quot;\\&quot; + date + &#39;-&#39; + str(i)
            # 判断是否已经存在该目录
            if not os.path.exists(folder):
                # 目录不存在，进行创建操作
                os.makedirs(folder)  # 使用os.makedirs()方法创建目录
                f = f&quot;目录新建成功：&#123;folder&#125;&quot;  # 创建一个显示项
                self.result_show.insert(&quot;end&quot;, f)  # 将结果添加到列表框中
            else:
                f = f&quot;目录已存在：&#123;folder&#125;&quot;  # 创建一个显示项
                self.result_show.insert(&quot;end&quot;, f)  # 将结果添加到列表框中
        f = &quot;-&quot; * 100  # 创建分割线
        self.result_show.insert(&quot;end&quot;, f)  # 将分割线添加到列表框
        f = f&quot;程序运行完成，请关闭窗口退出.&quot;  # 创建一个显示项
        self.result_show.insert(&quot;end&quot;, f)  # 将结果添加到列表框
        f = &quot; &quot; * 100
        self.result_show.insert(&quot;end&quot;, f)  # 将以上空格添加到列表框
        self.save_recent_folder_qty()  # 保存最新的文件夹数量

    @staticmethod
    def get_current_date():
        time_stamp = time()
        local_time = localtime(time_stamp)
        str_time_month = int(strftime(&#39;%m&#39;, local_time))
        str_time_day = int(strftime(&#39;%d&#39;, local_time))
        return str(str_time_month) + &quot;.&quot; + str(str_time_day)

    @staticmethod
    def get_folder_qty():
        &#39;&#39;&#39;从log.txt文件中获取最近的文件夹数量，若没有则返回0&#39;&#39;&#39;
        log_file = os.getcwd() + &quot;\\log.txt&quot;
        if os.path.exists(log_file):
            with open(log_file, &quot;r&quot;) as f:
                qty = f.readline()
                return int(qty)
        else:
            return 0

    def save_recent_folder_qty(self):
        &quot;&quot;&quot;保存最近的文件夹数量&quot;&quot;&quot;
        log_file = os.getcwd() + &quot;\\log.txt&quot;
        with open(log_file, &quot;w&quot;) as f:
            recent_qty = str(self.folderQty_entry.get())
            f.write(recent_qty)


if __name__ == &quot;__main__&quot;:
    MainGUI()
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>内置模块</category>
        <category>os</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>python-pptx | 批量生成PPT版荣誉证书</title>
    <url>/2021/10/16/%E6%89%B9%E9%87%8F%E7%94%9F%E6%88%90PPT%E7%89%88%E8%8D%A3%E8%AA%89%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<h1 id="批量生成PPT版荣誉证书"><a href="#批量生成PPT版荣誉证书" class="headerlink" title="批量生成PPT版荣誉证书"></a>批量生成PPT版荣誉证书</h1><p>以下代码实现了根据一个excel名单和一个荣誉证书模板批量生成名单中所有人的荣誉证书。</p>
<span id="more"></span>

<pre><code>import time
from pptx import Presentation
from openpyxl import load_workbook

prs = Presentation(r&#39;data\荣誉证书模板.pptx&#39;)
slide = prs.slides.add_slide(prs.slide_layouts[0])  # 第一个模板的第0个板式
for ph in slide.placeholders:  # 遍历这页PPT的所有占位符
    phf = ph.placeholder_format  # 获取占位符的格式
    print(phf.idx)  # 打印其ID编号
    ph.text = str(phf.idx)  # 将编号写入PPT对应的位置中，以便后面一一对应
# 以上读取到占位符的ID方便后面调用
prs.save(r&#39;data\荣誉证书模板-占位符编号.pptx&#39;)


wb = load_workbook(r&quot;data\名单.xlsx&quot;)
ws = wb.active
data = &#123;&#125;
for row in range(2, ws.max_row + 1):
    class_id = ws[&#39;A&#39; + str(row)].value
    name = ws[&#39;B&#39; + str(row)].value
    data.setdefault(class_id, [])
    data[class_id].append(name)

t0 = time.time()  # 程序开始运行的时间

prs = Presentation(r&#39;data\荣誉证书模板.pptx&#39;)
slide_layout = prs.slide_layouts[0]  # 调用设置好的母版，因为是母版的第一版式，所以取[0]
for class_id in data:
    for name in data[class_id]:
        slide = prs.slides.add_slide(slide_layout)  # 以母版的版式为基础新增一页幻灯片
        # 往幻灯片中写入内容
        slide.placeholders[10].text = &quot;&#123;&#125; 班 &#123;&#125; 同学：&quot;.format(class_id, name)  # 此处是班级和姓名
        slide.placeholders[11].text = &quot;在2019-2020学年度第一学期获得&quot;
        slide.placeholders[12].text = &quot;“好孩子”称号。&quot;
        slide.placeholders[13].text = &quot;特发此证，以资鼓励。&quot;
        slide.placeholders[14].text = &quot;市幼儿园&quot;
        slide.placeholders[15].text = &quot;2020年1月&quot;
prs.save(&#39;data\荣誉证书(总).pptx&#39;)
t1 = time.time()

print(&#39;程序用时：&#39;, str(round(t1 - t0)) + &#39;秒。&#39;)
</code></pre>
<p><a href="荣誉证书模板.pptx">荣誉证书模板.pptx</a><br><a href="名单.xlsx">下载名单.xlsx</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>python-pptx</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>openpyxl</tag>
        <tag>python-pptx</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 把隐藏层数量当做参数</title>
    <url>/2021/06/24/%E6%8A%8A%E9%9A%90%E8%97%8F%E5%B1%82%E6%95%B0%E9%87%8F%E5%BD%93%E5%81%9A%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h1 id="把隐藏层数量当做参数"><a href="#把隐藏层数量当做参数" class="headerlink" title="把隐藏层数量当做参数"></a>把隐藏层数量当做参数</h1><p>在搭建深度网络时，不一定非要使用很多隐藏层，在刚开始解决一个新问题时，通常可以从<br>logistic回归开始，再试试一到两个隐层，把隐藏层数量当做参数、超参数一样去调试，这样<br>去找比较合适的深度。</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 | 抽象工厂模式</title>
    <url>/2022/03/21/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>抽象工厂模式(Abstract Factory),提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
<p><a href="https://blog.csdn.net/qq_33732195/article/details/110101808">抽象工厂模式(通俗易懂)</a></p>
<span id="more"></span>
<p><strong>案例</strong><br>类图：<br><img src="/2022/03/21/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/1.jpg"></p>
<pre><code>class Department&#123;
    private int id;
    private String deptName;
    
    public int getId() &#123;
        return id;
    &#125;
    
    public void setId(int id) &#123;
        this.id = id;
    &#125;
    
    public String getDeptName() &#123;
        return deptName;
    &#125;
    
    public void setDeptName(String deptName) &#123;
        this.deptName = deptName;
    &#125;
&#125;

interface IDepartment
&#123;
    void insert(Department deparment);
    Department getDepartment(int id);
&#125;

//用于访问SQL Server中的Department
class SqlserverDepartment implements IDepartment&#123;
    @Override
    public void insert(Department department) &#123;
        System.out.println(&quot;在SQL Server中给Department表增加一条记录&quot;);
    &#125;

    @Override
    public Department getDepartment(int id) &#123;
        System.out.println(&quot;在SQL Server中根据ID得到Department表一条记录&quot;);
        return null;
    &#125;
&#125;

//用于访问Access的Department
class AccessDepartment implements IDepartment&#123;

    @Override
    public void insert(Department deparment) &#123;
        System.out.println(&quot;在Access中给Department表增加一条记录&quot;);
    &#125;

    @Override
    public Department getDepartment(int id) &#123;
        System.out.println(&quot;在Access中根据ID得到Department表一条记录&quot;);
        return null;
    &#125;
&#125;

class User&#123;
    private int id;
    private String name;
    
    public int getId() &#123;
        return id;
    &#125;
    
    public void setId(int id) &#123;
        this.id = id;
    &#125;
    
    public String getName() &#123;
        return name;
    &#125;
    
    public void setName(String name) &#123;
        this.name = name;
    &#125;
&#125;

interface IUser&#123;
    public void insert(User user);
    public User getUser(int id);
&#125;

//用于访问SQL Server中的User
class SqlserverUser implements IUser&#123;
    @Override
    public void insert(User user) &#123;
        System.out.println(&quot;在SQL Server中给User表增加一条记录&quot;);
    &#125;

    @Override
    public User getUser(int id) &#123;
        System.out.println(&quot;在SQL Server中根据ID得到User表一条记录&quot;);
        return null;
    &#125;
&#125;

//用于访问Access的User
class AccessUser implements IUser&#123;

    @Override
    public void insert(User user) &#123;
        System.out.println(&quot;在Access中给User表增加一条记录&quot;);
    &#125;

    @Override
    public User getUser(int id) &#123;
        System.out.println(&quot;在Access中根据ID得到User表一条记录&quot;);
        return null;
    &#125;
&#125;

//定义创建访问User、Department表对象的抽象的工厂接口
interface IFactory1&#123;
    IUser createUser();
    IDepartment createDepartment();
&#125;

//实现IFactory1接口，实例化SqlserverUser和SqlserverDepartment
class SqlserverFactory implements IFactory1&#123;

    @Override
    public IUser createUser() &#123;
        return new SqlserverUser();
    &#125;

    @Override
    public IDepartment createDepartment() &#123;
        return new SqlserverDepartment();
    &#125;
&#125;

//实现IFactory1接口，实例化AccessUser和AccessDepartment
class AccessFactory implements IFactory1&#123;

    @Override
    public IUser createUser() &#123;
        return new AccessUser();
    &#125;

    @Override
    public IDepartment createDepartment() &#123;
        return new AccessDepartment();
    &#125;
&#125;


public class AbstractFactory &#123;
    public static void main(String[] args) &#123;
        User user = new User();
        Department dept = new Department();
        
        //只需确定实例化哪一个数据库访问对象给factory
        IFactory1 factory = new SqlserverFactory();
        //IFactory1 factory = new AccessFactory();
        
        IUser iu = factory.createUser();
        
        iu.insert(user);
        iu.getUser(1);
        
        IDepartment id = factory.createDepartment();
        id.insert(dept);
        id.getDepartment(1);
        
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>抽象工厂模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>抽象工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础 | 折半查找</title>
    <url>/2021/05/24/%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h1 id="递归折半查找算法"><a href="#递归折半查找算法" class="headerlink" title="递归折半查找算法"></a>递归折半查找算法</h1><pre><code>def recursive_binary_search(arr, low, high, key):
        if low &lt;= high:
                mid = (low + high) // 2
            if arr[mid] == key:
                    return mid
            elif key &lt; arr[mid]:
                    return recursive_binary_search(arr, low, mid-1, key)
            else:
                    return recursive_binary_search(arr, mid+1, high, key)

        return -1
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
        <category>算法基础</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>折半查找</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC | 拦截器</title>
    <url>/2022/03/17/%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    <content><![CDATA[<h1 id="拦截器-HandlerInterceptor"><a href="#拦截器-HandlerInterceptor" class="headerlink" title="拦截器 HandlerInterceptor"></a>拦截器 HandlerInterceptor</h1><p>1.在SpringMVC配置文件（springMVC.xml）中进行以下配置：</p>
<pre><code>&lt;mvc:interceptors&gt;
    &lt;!-- 默认拦截所有请求 --&gt;
    &lt;!-- 第一种方式 --&gt;
    &lt;bean class=&quot;com.atguigu.interceptor.FirstInterceptor&quot;&gt;&lt;/bean&gt;
    &lt;bean class=&quot;com.atguigu.interceptor.SecondInterceptor&quot;&gt;&lt;/bean&gt;
    &lt;!-- 
        第二种方式
        此方式要求拦截器上必须加注解@Component
     --&gt;
    &lt;!-- &lt;ref bean=&quot;firstInterceptor&quot; /&gt; --&gt;
    
    &lt;!-- 设置自定义拦截方式 --&gt;
    &lt;!-- &lt;mvc:interceptor&gt;
        &lt;bean&gt;&lt;/bean&gt;
        &lt;mvc:mapping path=&quot;&quot;/&gt;
        &lt;mvc:exclude-mapping path=&quot;&quot;/&gt;
    &lt;/mvc:interceptor&gt; --&gt;
&lt;/mvc:interceptors&gt;
</code></pre>
<span id="more"></span>
<p>2.test.jsp</p>
<pre><code>&lt;a href=&quot;testInterceptor&quot;&gt;测试拦截器&lt;/a&gt;
</code></pre>
<p>3.TestInterceptorController.java(测试类)</p>
<pre><code>package com.atguigu.test;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class TestInterceptorController &#123;
    /**
     * 当有多个拦截器时，
     * preHandle:按照拦截器数组正向顺序执行
     * postHandle:按照拦截器数组反向顺序执行
     * afterCompletion:按照拦截器数组反向顺序执行
     * 
     * 当多个拦截器的preHandle有不同的值时
     * 第一个返回false，第二个返回false：只有第一个的preHandle会执行
     * 
     * 第一个返回true，第二个返回false：两个（全部）拦截器的preHandle都会执行，
     * 但是（全部）postHandle都不会执行，
     * 而afterCompletion只有第一个（返回false的拦截器之前的所有afterCompletion）会执行
     * 
     * 第一个返回false，第二个返回true：只有第一个的preHandle会执行
     */
    @RequestMapping(&quot;/testInterceptor&quot;)
    public String testInterceptor()&#123;
        //System.out.println(1/0);
        return &quot;success&quot;;
    &#125;
&#125;
</code></pre>
<p>4.FirstInterceptor.java</p>
<pre><code>package com.atguigu.interceptor;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

@Component
public class FirstInterceptor implements HandlerInterceptor&#123;

    @Override
    public void afterCompletion(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3)
            throws Exception &#123;
        System.out.println(&quot;First:afterCompletion&quot;);
    &#125;

    @Override
    public void postHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, ModelAndView arg3)
            throws Exception &#123;
        System.out.println(&quot;First:posthandle&quot;);
    &#125;

    @Override
    public boolean preHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2) throws Exception &#123;
        System.out.println(&quot;First:preHandle&quot;);
        return true;//true:放行 false:拦截
    &#125;
&#125;
</code></pre>
<p>5.SecondInterceptor.java</p>
<pre><code>package com.atguigu.interceptor;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

@Component
public class SecondInterceptor implements HandlerInterceptor&#123;

    @Override
    public void afterCompletion(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3)
            throws Exception &#123;
        System.out.println(&quot;Second:afterCompletion&quot;);
    &#125;

    @Override
    public void postHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, ModelAndView arg3)
            throws Exception &#123;
        System.out.println(&quot;Second:posthandle&quot;);
    &#125;

    @Override
    public boolean preHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2) throws Exception &#123;
        System.out.println(&quot;Second:preHandle&quot;);
        return false;//true:放行 false:拦截
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>SpringMVC</category>
        <category>拦截器 HandlerInterceptor</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringMVC</tag>
        <tag>拦截器</tag>
        <tag>HandlerInterceptor</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 括号生成</title>
    <url>/2021/09/05/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<h1 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22.括号生成"></a>22.括号生成</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。<br>有效括号组合需满足：左括号必须以正确的顺序闭合。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/generate-parentheses/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>1.暴力法</strong><br>可以生成所有 2^2n 个 ‘(‘ 和 ‘)’ 字符构成的序列，然后我们检查每一个是否有效即可。<br><strong>2.回溯法</strong><br>方法一还有改进的余地：我们可以只在序列仍然保持有效时才添加 ‘(‘ or ‘)’，而不是像 方法一 那样每次添加。我们可以通过跟踪到目前为止放置的左括号和右括号的数目来做到这一点，<br>如果左括号数量不大于 n，我们可以放一个左括号。如果右括号数量小于左括号的数量，我们可以放一个右括号。<br>3.按括号序列的长度递归</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>from functools import lru_cache

class Solution(object):
    def generateParenthesis(self, n):
        &quot;&quot;&quot;
        暴力法
        :type n: int
        :rtype: List[str]
        &quot;&quot;&quot;
        # 生成所有括号组合，然后判断是否是有效括号
        def generate(A):
            if len(A) == 2 * n:
                # print(A)
                if valid(A):
                    ans.append(&quot;&quot;.join(A))
            else:
                A.append(&#39;(&#39;)
                generate(A)
                A.pop()
                A.append(&#39;)&#39;)
                generate(A)
                A.pop()

        def valid(A):
            bal = 0  # 表示左括号的数量减去右括号的数量
            for c in A:
                if c == &#39;(&#39;:
                    bal += 1
                else:
                    bal -= 1

                if bal &lt; 0:
                    return False

            return bal == 0

        ans = []
        generate([])
        return ans

    def generateParenthesis1(self, n):
        &quot;&quot;&quot;
        回溯法

        对暴力解法的改进：
        只在序列仍然保持有效时才添加 &#39;(&#39; or &#39;)&#39;，而不是像 暴力解法 那样每次添加
        我们可以通过跟踪到目前为止放置的左括号和右括号的数目来做到这一点

        如果左括号数量不大于 n，我们可以放一个左括号
        如果右括号数量小于左括号的数量，我们可以放一个右括号
        &quot;&quot;&quot;
        def backtrack(S, left, right):
            if len(S) == 2 * n:
                ans.append(&#39;&#39;.join(S))
                return
            if left &lt; n:
                S.append(&#39;(&#39;)
                backtrack(S, left + 1, right)
                S.pop()
            if right &lt; left:
                S.append(&#39;)&#39;)
                backtrack(S, left, right + 1)
                S.pop()

        ans = []
        backtrack([], 0, 0)
        return ans


class Solution1:
    @lru_cache(None)
    def generateParenthesis(self, n: int):
        &quot;&quot;&quot;按括号序列的长度递归&quot;&quot;&quot;
        if n == 0:
            return [&#39;&#39;]
        ans = []
        for c in range(n):
            for left in self.generateParenthesis(c):
                for right in self.generateParenthesis(n-1-c):
                    ans.append(&#39;(&#123;&#125;)&#123;&#125;&#39;.format(left, right))
        return ans


if __name__ == &#39;__main__&#39;:
    slt = Solution1()
    parenthesis_list = slt.generateParenthesis(3)
    print(parenthesis_list)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>基于JavaWeb的网上购物商城 | 提交订单</title>
    <url>/2022/01/15/%E6%8F%90%E4%BA%A4%E8%AE%A2%E5%8D%95/</url>
    <content><![CDATA[<h1 id="提交订单"><a href="#提交订单" class="headerlink" title="提交订单"></a>提交订单</h1><p><strong>实现功能：</strong><br>用户在购物车页面点击“提交订单”，向数据库中写入用户信息、购买的商品、数量等。</p>
<span id="more"></span>
<p><strong>cart.jsp</strong><br>为提交订单链接添加onclick属性并完成showOrder()方法。</p>
<pre><code>&lt;div style=&quot;text-align:right;margin-top:10px;margin-bottom:10px;&quot;&gt;
    &lt;a href=&quot;#&quot; id=&quot;clear&quot; class=&quot;clear&quot; onclick=&quot;clearCart()&quot;&gt;清空购物车&lt;/a&gt;
    &lt;a href=&quot;#&quot; onclick=&quot;showOrder()&quot;&gt;
        &lt;input type=&quot;submit&quot; width=&quot;100&quot; value=&quot;提交订单&quot; name=&quot;submit&quot; border=&quot;0&quot; style=&quot;background: url(&#39;./images/register.gif&#39;) no-repeat scroll 0 0 rgba(0, 0, 0, 0);
        height:35px;width:100px;color:white;&quot;&gt;
    &lt;/a&gt;
&lt;/div&gt;
</code></pre>
<p><strong>OrderItem.java</strong></p>
<pre><code>package com.oracle.bean;

public class OrderItem &#123;
    private String itemid;
    private int count;
    private double subtotal;
    private String pid;
    private String oid;
    private Product pro;
    
    public Product getPro() &#123;
        return pro;
    &#125;
    public void setPro(Product pro) &#123;
        this.pro = pro;
    &#125;
    public OrderItem() &#123;
        super();
        // TODO Auto-generated constructor stub
    &#125;
    public OrderItem(String itemid, int count, double subtotal, String pid, String oid) &#123;
        super();
        this.itemid = itemid;
        this.count = count;
        this.subtotal = subtotal;
        this.pid = pid;
        this.oid = oid;
    &#125;
    public String getItemid() &#123;
        return itemid;
    &#125;
    public void setItemid(String itemid) &#123;
        this.itemid = itemid;
    &#125;
    public int getCount() &#123;
        return count;
    &#125;
    public void setCount(int count) &#123;
        this.count = count;
    &#125;
    public double getSubtotal() &#123;
        return subtotal;
    &#125;
    public void setSubtotal(double subtotal) &#123;
        this.subtotal = subtotal;
    &#125;
    public String getPid() &#123;
        return pid;
    &#125;
    public void setPid(String pid) &#123;
        this.pid = pid;
    &#125;
    public String getOid() &#123;
        return oid;
    &#125;
    public void setOid(String oid) &#123;
        this.oid = oid;
    &#125;
    
&#125;
</code></pre>
<p><strong>Order.java</strong></p>
<pre><code>package com.oracle.bean;

import java.util.ArrayList;
import java.util.List;

public class Order &#123;
    private String oid;
    private String ordertime;
    private double total;
    private int state;
    private String address;
    private String name;
    private String telephone;
    private String uid;
    
    private List&lt;OrderItem&gt; list = new ArrayList&lt;&gt;();

    public Order() &#123;
        super();
        // TODO Auto-generated constructor stub
    &#125;

    public Order(String oid, String ordertime, double total, int state, String address, String name, String telephone,
            String uid, List&lt;OrderItem&gt; list) &#123;
        super();
        this.oid = oid;
        this.ordertime = ordertime;
        this.total = total;
        this.state = state;
        this.address = address;
        this.name = name;
        this.telephone = telephone;
        this.uid = uid;
        this.list = list;
    &#125;

    public String getOid() &#123;
        return oid;
    &#125;

    public void setOid(String oid) &#123;
        this.oid = oid;
    &#125;

    public String getOrdertime() &#123;
        return ordertime;
    &#125;

    public void setOrdertime(String ordertime) &#123;
        this.ordertime = ordertime;
    &#125;

    public double getTotal() &#123;
        return total;
    &#125;

    public void setTotal(double total) &#123;
        this.total = total;
    &#125;

    public int getState() &#123;
        return state;
    &#125;

    public void setState(int state) &#123;
        this.state = state;
    &#125;

    public String getAddress() &#123;
        return address;
    &#125;

    public void setAddress(String address) &#123;
        this.address = address;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public String getTelephone() &#123;
        return telephone;
    &#125;

    public void setTelephone(String telephone) &#123;
        this.telephone = telephone;
    &#125;

    public String getUid() &#123;
        return uid;
    &#125;

    public void setUid(String uid) &#123;
        this.uid = uid;
    &#125;

    public List&lt;OrderItem&gt; getList() &#123;
        return list;
    &#125;

    public void setList(List&lt;OrderItem&gt; list) &#123;
        this.list = list;
    &#125;
    
&#125;
</code></pre>
<p><strong>ProductServlet.java</strong><br>在ProductServlet的doGet方法中添加showOrder的判断并完成showOrder方法。</p>
<pre><code>public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
    String method = request.getParameter(&quot;method&quot;);
    if(&quot;getProById&quot;.equals(method)) &#123;
        getProById(request, response);
    &#125;else if(&quot;findListByCate&quot;.equals(method)) &#123;
        findListByCate(request, response);
    &#125;else if(&quot;cart&quot;.equals(method)) &#123;
        cart(request, response);
    &#125;else if(&quot;delCart&quot;.equals(method)) &#123;
        delCart(request, response);
    &#125;else if(&quot;clearCart&quot;.equals(method)) &#123;
        clearCart(request, response);
    &#125;else if(&quot;showOrder&quot;.equals(method)) &#123;
        showOrder(request, response);
    &#125;
&#125;

public void showOrder(HttpServletRequest request, HttpServletResponse response) &#123;
    // TODO Auto-generated method stub
    try &#123;
        HttpSession session = request.getSession();
        Cart cart = (Cart)session.getAttribute(&quot;cart&quot;);
        User user = (User)session.getAttribute(&quot;user&quot;);
        
        if(user==null) &#123;
            request.getRequestDispatcher(&quot;/login.jsp&quot;).forward(request, response);
            return;
        &#125;
        
        //订单表的id
        String oid = UUID.randomUUID().toString();
        
        //向订单项中封装数据
        OrderItem oi = new OrderItem();
        Map&lt;String, CartItem&gt; map = cart.getMap();
        
        Product p = new Product();
        ProductService ps = new ProductService();
        
        ArrayList&lt;OrderItem&gt; arr = new ArrayList&lt;&gt;();
        
        for(String s:map.keySet()) &#123;
            String id = UUID.randomUUID().toString();
            oi.setItemid(id);
            CartItem ci = map.get(s);
            oi.setCount(ci.getCount());
            oi.setPid(ci.getPro().getPid());
            
            Product pro = ps.getProById(ci.getPro().getPid());
            
            oi.setPro(pro);
        
            oi.setSubtotal(ci.getSubTotal());
            oi.setOid(oid);
            
            arr.add(oi);
        &#125;
        
        //向订单中封装数据
        Order od = new Order();
        od.setOid(oid);
        //获取当前时间
        DateFormat df = DateFormat.getDateInstance();
        String dateTime = df.format(new Date());
        od.setOrdertime(dateTime);
        od.setState(0);
        od.setTotal(cart.getSubMoney());
        od.setUid(user.getUid());
        od.setList(arr);
        
        //向service发送请求
        ps.insertOrderAndItem(od);
        
        //把订单放入session
        session.setAttribute(&quot;order&quot;, od);
        
        //跳转到order_info.jsp
        request.getRequestDispatcher(&quot;order_info.jsp&quot;).forward(request, response);
    &#125; catch (Exception e) &#123;
        // TODO Auto-generated catch block
        e.printStackTrace();
    &#125; 
&#125;
</code></pre>
<p><strong>ProductService.java</strong><br>在ProductService中添加insertOrderAndItem方法。</p>
<pre><code>public void insertOrderAndItem(Order od) &#123;
    // TODO Auto-generated method stub
    try &#123;
        //开启事务
        DataSourceUtils.startTransaction();
        ProductDao pd = new ProductDao();
        pd.insertOrder(od);
        
        List&lt;OrderItem&gt; list = od.getList();
        for(OrderItem o:list) &#123;
            pd.insertItem(o);
        &#125;
        DataSourceUtils.commitAndRelease();
        
    &#125; catch (Exception e) &#123;
        // TODO Auto-generated catch block
        try &#123;
            DataSourceUtils.rollback();
            e.printStackTrace();
        &#125; catch (Exception e1) &#123;
            // TODO Auto-generated catch block
            e1.printStackTrace();
        &#125;
    &#125;
    
&#125;
</code></pre>
<p><strong>ProductDao.java</strong><br>在ProductDao中添加insertOrder和insertItem方法。</p>
<pre><code>public void insertOrder(Order od) throws SQLException &#123;
    // TODO Auto-generated method stub
    QueryRunner qr = new QueryRunner();
    
    String sql = &quot;insert into orders(oid,ordertime,total,state,uid)values(?,?,?,?,?)&quot;;
    
    qr.update(DataSourceUtils.getConnection(), sql, od.getOid(),od.getOrdertime(),od.getTotal(),od.getState(),od.getUid());
&#125;

public void insertItem(OrderItem o) throws SQLException &#123;
    // TODO Auto-generated method stub
    QueryRunner qr = new QueryRunner();
    
    String sql = &quot;insert into orderitem(itemid,count,subtotal,pid,oid)values(?,?,?,?,?)&quot;;
    
    qr.update(DataSourceUtils.getConnection(), sql, o.getItemid(), o.getCount(), o.getSubtotal(), o.getPid(), o.getOid());
&#125;
</code></pre>
<p><strong>order_info.jsp</strong><br>在order_info页面解析订单信息。</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;
&lt;title&gt;会员登录&lt;/title&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap.min.css&quot; type=&quot;text/css&quot; /&gt;
&lt;script src=&quot;js/jquery-1.11.3.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;js/bootstrap.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;!-- 引入自定义css文件 style.css --&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot; type=&quot;text/css&quot; /&gt;
&lt;style&gt;
body &#123;
    margin-top: 20px;
    margin: 0 auto;
&#125;

.carousel-inner .item img &#123;
    width: 100%;
    height: 300px;
&#125;
&lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;!-- 引入header.jsp --&gt;
    &lt;jsp:include page=&quot;/header.jsp&quot;&gt;&lt;/jsp:include&gt;
    
    &lt;div class=&quot;container&quot;&gt;
        &lt;div class=&quot;row&quot;&gt;
            &lt;div style=&quot;margin: 0 auto; margin-top: 10px; width: 950px;&quot;&gt;
                &lt;strong&gt;订单详情&lt;/strong&gt;
                &lt;table class=&quot;table table-bordered&quot;&gt;
                    &lt;tbody&gt;
                        &lt;tr class=&quot;warning&quot;&gt;
                            &lt;th colspan=&quot;5&quot;&gt;订单编号:9005&lt;/th&gt;
                        &lt;/tr&gt;
                        &lt;tr class=&quot;warning&quot;&gt;
                            &lt;th&gt;图片&lt;/th&gt;
                            &lt;th&gt;商品&lt;/th&gt;
                            &lt;th&gt;价格&lt;/th&gt;
                            &lt;th&gt;数量&lt;/th&gt;
                            &lt;th&gt;小计&lt;/th&gt;
                        &lt;/tr&gt;
                        
                        &lt;c:forEach items=&quot;$&#123;order.list&#125;&quot; var=&quot;oi&quot;&gt;
                            &lt;tr class=&quot;active&quot;&gt;
                                &lt;td width=&quot;60&quot; width=&quot;40%&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;id&quot;
                                    value=&quot;22&quot;&gt; &lt;img src=&quot;$&#123;pageContext.request.contextPath&#125;/$&#123;oi.pro.pimage&#125;&quot; width=&quot;70&quot;
                                    height=&quot;60&quot;&gt;&lt;/td&gt;
                                &lt;td width=&quot;30%&quot;&gt;&lt;a target=&quot;_blank&quot;&gt;$&#123;oi.pro.pname&#125;&lt;/a&gt;&lt;/td&gt;
                                &lt;td width=&quot;20%&quot;&gt;￥$&#123;oi.pro.shop_price&#125;&lt;/td&gt;
                                &lt;td width=&quot;10%&quot;&gt;$&#123;oi.count&#125;&lt;/td&gt;
                                &lt;td width=&quot;15%&quot;&gt;&lt;span class=&quot;subtotal&quot;&gt;￥$&#123;oi.subtotal&#125;&lt;/span&gt;&lt;/td&gt;
                            &lt;/tr&gt;
                        &lt;/c:forEach&gt;
                        
                    &lt;/tbody&gt;
                &lt;/table&gt;
            &lt;/div&gt;

            &lt;div style=&quot;text-align: right; margin-right: 120px;&quot;&gt;
                商品金额: &lt;strong style=&quot;color: #ff6600;&quot;&gt;￥$&#123;order.total&#125;元&lt;/strong&gt;
            &lt;/div&gt;

        &lt;/div&gt;

        &lt;div&gt;
            &lt;hr /&gt;
            &lt;form class=&quot;form-horizontal&quot;
                style=&quot;margin-top: 5px; margin-left: 150px;&quot;&gt;
                &lt;div class=&quot;form-group&quot;&gt;
                    &lt;label for=&quot;username&quot; class=&quot;col-sm-1 control-label&quot;&gt;地址&lt;/label&gt;
                    &lt;div class=&quot;col-sm-5&quot;&gt;
                        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;username&quot;
                            placeholder=&quot;请输入收货地址&quot;&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div class=&quot;form-group&quot;&gt;
                    &lt;label for=&quot;inputPassword3&quot; class=&quot;col-sm-1 control-label&quot;&gt;收货人&lt;/label&gt;
                    &lt;div class=&quot;col-sm-5&quot;&gt;
                        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;inputPassword3&quot;
                            placeholder=&quot;请输收货人&quot;&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div class=&quot;form-group&quot;&gt;
                    &lt;label for=&quot;confirmpwd&quot; class=&quot;col-sm-1 control-label&quot;&gt;电话&lt;/label&gt;
                    &lt;div class=&quot;col-sm-5&quot;&gt;
                        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;confirmpwd&quot;
                            placeholder=&quot;请输入联系方式&quot;&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/form&gt;

            &lt;hr /&gt;

            &lt;div style=&quot;margin-top: 5px; margin-left: 150px;&quot;&gt;
                
                
                &lt;hr /&gt;
                &lt;p style=&quot;text-align: right; margin-right: 100px;&quot;&gt;
                    &lt;a href=&quot;javascript:document.getElementById(&#39;orderForm&#39;).submit();&quot;&gt;
                        &lt;img src=&quot;./images/finalbutton.gif&quot; width=&quot;204&quot; height=&quot;51&quot;
                        border=&quot;0&quot; /&gt;
                    &lt;/a&gt;
                &lt;/p&gt;
                &lt;hr /&gt;

            &lt;/div&gt;
        &lt;/div&gt;

    &lt;/div&gt;

    &lt;!-- 引入footer.jsp --&gt;
    &lt;jsp:include page=&quot;/footer.jsp&quot;&gt;&lt;/jsp:include&gt;

&lt;/body&gt;

&lt;/html&gt;
</code></pre>
]]></content>
      <categories>
        <category>项目经历</category>
        <category>JavaWeb</category>
        <category>基于JavaWeb的网上购物商城</category>
        <category>提交订单</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
        <tag>基于JavaWeb的网上购物商城</tag>
        <tag>提交订单</tag>
      </tags>
  </entry>
  <entry>
    <title>python-pptx | 提取ppt中的文字到word中</title>
    <url>/2021/10/21/%E6%8F%90%E5%8F%96ppt%E4%B8%AD%E7%9A%84%E6%96%87%E5%AD%97%E5%88%B0word%E4%B8%AD/</url>
    <content><![CDATA[<h1 id="提取ppt中的文字到word中"><a href="#提取ppt中的文字到word中" class="headerlink" title="提取ppt中的文字到word中"></a>提取ppt中的文字到word中</h1><p>以下代码实现了将ppt中的所有文字提取到word中。</p>
<span id="more"></span>
<pre><code>from pptx import Presentation

data = []
prs = Presentation(&#39;data\制造业必修课.pptx&#39;)
for slide in prs.slides:  # 遍历每页ppt
    for shape in slide.shapes:  # 遍历ppt中的每个形状
        if shape.has_text_frame:  # 判断该形状是否包含文本，保证有文本才提取
            for paragraph in shape.text_frame.paragraphs:  # 按文本框中的段落提取
                data.append(paragraph.text)  # 提取一个段落的文本，就存到列表data中

# 写入文本文件
TxtFile = open(&#39;data\制造业必修课.txt&#39;, &#39;w&#39;, encoding=&#39;utf-8&#39;)
for i in data:
    TxtFile.write(i + &#39;\n&#39;)  # 写入并换行，以保证正确分段
TxtFile.close()  # 保存

# 写入word文件
import docx

doc = docx.Document()  # 创建一个word文件对象
for i in data:
    doc.add_paragraph(i)  # 增加一个段落，并将列表中的一个字符串写入word文件
doc.save(&#39;data\制造业必修课.docx&#39;)
</code></pre>
<p><a href="制造业必修课.pptx">制造业必修课.pptx</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>python-pptx</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python-docx</tag>
        <tag>python-pptx</tag>
      </tags>
  </entry>
  <entry>
    <title>支持向量机</title>
    <url>/2021/03/20/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="支持向量机-Support-Vector-Machine-SVM"><a href="#支持向量机-Support-Vector-Machine-SVM" class="headerlink" title="支持向量机(Support Vector Machine,SVM)"></a>支持向量机(Support Vector Machine,SVM)</h1><p>支持向量机是我们用于分类的一种算法。</p>
<h2 id="小故事理解SVM"><a href="#小故事理解SVM" class="headerlink" title="小故事理解SVM:"></a>小故事理解SVM:</h2><p>当一个分类问题，数据是线性可分的，也就是用一根棍就可以将两种小球分开的时候，我们只要将棍的位置放在让小球距离棍的距离最大化的位置即可，寻找这个最大间隔的过程，就叫做最优化。但是，现实往往是很残酷的，一般的数据是线性不可分的，也就是找不到一个棍将两种小球很好的分类。这个时候，我们就需要像大侠一样，将小球拍起，用一张纸代替小棍将小球进行分类。想要让数据飞起，我们需要的东西就是核函数(kernel)，用于切分小球的纸，就是超平面。<br>问题是从线性可分延伸到线性不可分的</p>
<h2 id="线性SVM"><a href="#线性SVM" class="headerlink" title="线性SVM"></a>线性SVM</h2><p><img src="/2021/03/20/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/1.png"><br>上图中的(a)是已有的数据，红色和蓝色分别代表两个不同的类别。数据显然是线性可分的，但是将两类数据点分开的直线显然不止一条。上图的(b)和(c)分别给出了B、C两种不同的分类方案，其中黑色实线为分界线，术语称为“决策面”。每个决策面对应了一个线性分类器。虽然从分类结果上看，分类器A和分类器B的效果是相同的。但是他们的性能是有差距的，看下图：<br><img src="/2021/03/20/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/2.png"><br>在”决策面”不变的情况下，我又添加了一个红点。可以看到，分类器B依然能很好的分类结果，而分类器C则出现了分类错误。显然分类器B的”决策面”放置的位置优于分类器C的”决策面”放置的位置，SVM算法也是这么认为的，它的依据就是分类器B的分类间隔比分类器C的分类间隔大。这里涉及到第一个SVM独有的概念”分类间隔”。在保证决策面方向不变且不会出现错分样本的情况下移动决策面，会在原来的决策面两侧找到两个极限位置（越过该位置就会产生错分现象），如虚线所示。虚线的位置由决策面的方向和距离原决策面最近的几个样本的位置决定。而这两条平行虚线正中间的分界线就是在保持当前决策面方向不变的前提下的最优决策面。两条虚线之间的垂直距离就是这个最优决策面对应的分类间隔。显然每一个可能把数据集正确分开的方向都有一个最优决策面（有些方向无论如何移动决策面的位置也不可能将两类样本完全分开），而不同方向的最优决策面的分类间隔通常是不同的，那个具有“最大间隔”的决策面就是SVM要寻找的最优解。而这个真正的最优解对应的两侧虚线所穿过的样本点，就是SVM中的支持样本点，称为”支持向量”。</p>
<h2 id="数学建模"><a href="#数学建模" class="headerlink" title="数学建模"></a>数学建模</h2><p>决策面方程<br>分类间隔方程<br>约束条件</p>
<h2 id="最优化问题的两个基本因素："><a href="#最优化问题的两个基本因素：" class="headerlink" title="最优化问题的两个基本因素："></a>最优化问题的两个基本因素：</h2><p>1.目标函数 你希望什么东西的什么指标达到最好<br>2.优化对象 你期望通过改变哪些因素来使你的目标函数达到最优<br>Example:<br>在线性SVM算法中，目标函数就是分类间隔，优化对象就是决策面</p>
<h2 id="最优化问题的分类："><a href="#最优化问题的分类：" class="headerlink" title="最优化问题的分类："></a>最优化问题的分类：</h2><p>1.无约束优化问题 min f(x)<br>求解方法：费马大定理(求f(x)的导数，令其为0，求得候选最优值，再在这些候选值中验证；如果是凸函数，可以保证是最优解)<br>2.有等式约束的优化问题<br>min f(x)<br>s.t. hi(x)=0,i=1,2,…,n<br>求解方法：拉格朗日乘子法(把等式约束hi(x)用一个系数与f(x)写成一个式子，称为拉格朗日函数，而系数称为拉格朗日乘子。通过拉格朗日函数对各个变量求导，令其为0，求得候选值集合，然后验证求得最优值)<br>3.有不等式约束的优化问题<br>min f(x)<br>s.t. gi(x)&lt;=0,i=1,2,…,n<br>hj(x)=0,j=1,2,…,m<br>求解方法：拉格朗日+KKT条件 把所有的等式、不等式约束与f(x)写成一个式子，也叫拉格朗日函数，系数也称为拉格朗日乘子，通过一些条件可以求出最优值的必要条件，这个条件称为KKT条件。</p>
<p>KKT条件的全称是Karush-Kuhn-Tucker条件，KKT条件是说最优值条件必须满足以下条件：<br>条件一：经过拉格朗日函数处理之后的新目标函数L(w,b,α)对x求导为零：<br>条件二：h(x) = 0；<br>条件三：α*g(x) = 0；</p>
<p><b>使用拉格朗日方程的目的：</b><br>将约束条件放到目标函数中，将有约束优化问题转换为无约束优化问题（我们知道我们要求解的是最小化问题，所以一个直观的想法是如果我能够构造一个函数，使得该函数在可行解区域内与原目标函数完全一致，而在可行解区域外的数值非常大，甚至是无穷大，那么这个没有约束条件的新目标函数的优化问题就与原来有约束条件的原始目标函数的优化问题是等价的问题。）</p>
<p>使用拉格朗日获得的函数使用求导方法求解依然困难，进而需要对问题进行一次转换，即使用一个数学技巧：拉格朗日对偶(将最小值和最大值的计算位置交换)</p>
<p><b>拉个朗日优化问题的两个步骤：</b><br>1.将有约束的原始目标函数转换为无约束的新构造的拉格朗日目标函数<br>2.使用拉格朗日对偶性，将不易求解的优化问题转化为容易求解的优化问题</p>
<p><b>求解对偶问题的三个步骤：</b><br>1.首先要让L(w,b,α)关于w和b最小化<br>2.求对α的极大<br>3.利用SMO算法求解对偶问题中的拉格朗日乘子</p>
<h2 id="SMO算法"><a href="#SMO算法" class="headerlink" title="SMO算法"></a>SMO算法</h2><p>1996年，John Platt发布了一个称为SMO的强大算法，用于训练SVM。SMO表示序列最小化(Sequential Minimal Optimizaion)。Platt的SMO算法是将大优化问题分解为多个小优化问题来求解的。这些小优化问题往往很容易求解，并且对它们进行顺序求解的结果与将它们作为整体来求解的结果完全一致的。在结果完全相同的同时，SMO算法的求解时间短很多。</p>
<p><b>SMO算法的目标:</b><br>求出一系列alpha和b，一旦求出了这些alpha，就很容易计算出权重向量w并得到分隔超平面。</p>
<p><b>SMO算法的工作原理是：</b><br>每次循环中选择两个alpha进行优化处理。一旦找到了一对合适的alpha，那么就增大其中一个同时减小另一个。这里所谓的”合适”就是指两个alpha必须符合以下两个条件，条件之一就是两个alpha必须要在间隔边界之外，而且第二个条件则是这两个alpha还没有进行过区间化处理或者不在边界上。</p>
<p><b>注意：</b><br>实际上，对于目标函数，是存在一个假设(数据100%线性可分)的，但现实中的数据都不那么干净，这时我们就可以通过引入松弛变量ξ(slack variable)和惩罚参数C来允许有些数据点可以处于超平面的错误的一侧—&gt;约束条件的改变—&gt;目标函数的改变</p>
<h2 id="SMO算法优化"><a href="#SMO算法优化" class="headerlink" title="SMO算法优化"></a>SMO算法优化</h2><p>启发式选择第二个alpha值</p>
<h2 id="非线性SVM"><a href="#非线性SVM" class="headerlink" title="非线性SVM"></a>非线性SVM</h2><h3 id="核技巧"><a href="#核技巧" class="headerlink" title="核技巧"></a>核技巧</h3><p>对于非线性情况：SVM的处理方式是选择一个核函数。简而言之：在线性不可分的情况下，SVM通过某种事先选择的非线性映射（核函数）将输入变量映到一个高维特征空间，将其变成在高维空间线性可分，在这个高维空间中构造最优分类超平面。</p>
<h3 id="建立非线性学习器分为两步："><a href="#建立非线性学习器分为两步：" class="headerlink" title="建立非线性学习器分为两步："></a>建立非线性学习器分为两步：</h3><p>1.首先使用一个非线性映射将数据变换到一个特征空间F；<br>2.然后在特征空间使用线性学习器分类。</p>
<h3 id="核函数方法"><a href="#核函数方法" class="headerlink" title="核函数方法"></a>核函数方法</h3><p>在特征空间中直接计算内积 &lt;ϕ(xi),ϕ(x)&gt;的方法称为核函数方法</p>
<p>核是一个函数k，对所有x,z∈X，满足k(x,z)=&lt;ϕ(xi),ϕ(x)&gt;，这里ϕ(·)是从原始输入空间X到内积空间F的映射。</p>
<p>简而言之：如果不是用核技术，就会先计算线性映ϕ(x1)和ϕ(x2)，然后计算这它们的内积，使用了核技术之后，先把ϕ(x1)和ϕ(x2)的一般表达式&lt;ϕ(x1),ϕ(x2)&gt;=k(&lt;ϕ(x1),ϕ(x2) &gt;)计算出来，这里的&lt;·，·&gt;表示内积，k(·，·)就是对应的核函数</p>
<p>将内积替换成核函数的方式被称为核技巧(kernel trick)。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="SVM的优缺点"><a href="#SVM的优缺点" class="headerlink" title="SVM的优缺点"></a>SVM的优缺点</h3><p>优点：<br>1.可用于线性/非线性分类，也可以用于回归，泛化错误率低，也就是说具有良好的学习能力，且学到的结果具有很好的推广性。<br>2.可以解决小样本情况下的机器学习问题，可以解决高维问题，可以避免神经网络结构选择和局部极小点问题。<br>3.SVM是最好的现成的分类器，现成是指不加修改可直接使用。并且能够得到较低的错误率，SVM可以对训练集之外的数据点做很好的分类决策。</p>
<p>缺点：对参数调节和和函数的选择敏感。</p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>SVM</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>SVM</tag>
        <tag>支持向量机</tag>
      </tags>
  </entry>
  <entry>
    <title>数据中的缺失值的处理</title>
    <url>/2021/03/19/%E6%95%B0%E6%8D%AE%E4%B8%AD%E7%9A%84%E7%BC%BA%E5%A4%B1%E5%80%BC%E7%9A%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="数据中的缺失值的处理"><a href="#数据中的缺失值的处理" class="headerlink" title="数据中的缺失值的处理"></a>数据中的缺失值的处理</h1><p>1.使用可用特征的均值来填补缺失值；<br>2.使用特殊值来填补缺失值，如-1；<br>3.忽略有缺失值的样本；<br>4.使用相似样本的均值添补缺失值；<br>5.使用另外的机器学习算法预测缺失值。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>数据缺失值处理</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 旋转链表</title>
    <url>/2021/08/27/%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61.旋转链表"></a>61.旋转链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/rotate-list/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>方法一：</strong> 闭合为环<br>记给定链表的长度为 n，注意到当向右移动的次数 k≥n 时，我们仅需要向右移动 k mod n 次即可。因为每 n 次移动都会让链表变为原状。这样我们可以知道，新链表的最后一个节点为原链表的第 (n−1)−(k mod n) 个节点（从 0 开始计数）。<br>这样，我们可以先将给定的链表连接成环，然后将指定位置断开。<br>具体代码中，我们首先计算出链表的长度 n，并找到该链表的末尾节点，将其与头节点相连。这样就得到了闭合为环的链表。然后我们找到新链表的最后一个节点（即原链表的第 (n−1)−(k mod n) 个节点），将当前闭合为环的链表断开，即可得到我们所需要的结果。<br><strong>方法二：</strong> 将后k个节点移到前n-k个节点之前（n为链表长度）<br><strong>特别地，当链表长度不大于 1，或者 k 为 n 的倍数时，新链表将与原链表相同，我们无需进行任何处理。</strong></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def rotateRight(self, head, k):
        &quot;&quot;&quot;
        :type head: ListNode
        :type k: int
        :rtype: ListNode
        &quot;&quot;&quot;
        # 如果链表为空直接返回head
        # 如果右旋转的次数为0直接返回head
        if head is None or head.next is None or k == 0 :
            return head

        # 统计head链表的长度
        p1 = head
        count = 0
        while p1:
            count += 1
            p1 = p1.next

        # 如果链表只有一个节点，直接返回head
        # 如果右旋转次数除以链表长度的余数为0,直接返回head
        if k % count == 0:
            return head

        i = 0
        p2 = head
        k = k % count  # 去掉整圈的旋转
        while i &lt; count - k - 1:  # 找到后k个节点的前一个节点
            p2 = p2.next
            i += 1
        second = p2.next  # second为后k个节点组成的链表
        p2.next = None  # 将前count - k个节点的最后一个节点的next值置空

        p3 = second
        while p3.next is not None:  # 找到后k个节点组成的链表的最后一个节点
            p3 = p3.next

        p3.next = head  # 将后k个节点组成的链表与前count-k个节点组成的链表连接起来

        return second

    def rotateRight1(self, head, k):
        &quot;&quot;&quot;
        :type head: ListNode
        :type k: int
        :rtype: ListNode
        &quot;&quot;&quot;
        if k == 0 or not head or not head.next:
            return head

        # 求链表长度
        n = 1
        cur = head
        while cur.next:
            cur = cur.next
            n += 1

        add = n - k % n
        if add == n:
            return head

        # 链表闭合成环
        cur.next = head
        while add:
            cur = cur.next
            add -= 1

        ret = cur.next
        cur.next = None  # 将闭合为环的链表断开
        return ret

    def create_linked_list(self, list):
        &quot;&quot;&quot;根据list中的所有元素构建单链表&quot;&quot;&quot;
        l = ListNode()  # 单链表头节点
        r = l  # 起始尾指针r指向头节点
        for e in list:
            node = ListNode(e)
            r.next = node
            r = r.next

        return l.next

    def print_linked_list(self, linked_list) -&gt; None:
        &quot;&quot;&quot;
        打印单链表中的所有元素

        :param linked_list: 单链表
        :return: 无
        &quot;&quot;&quot;
        print(&quot;----------------------------------------&quot;)
        pointer = linked_list
        while pointer is not None:
            print(pointer.val)
            pointer = pointer.next


if __name__ == &quot;__main__&quot;:
    slt = Solution()

    linked_list = slt.create_linked_list([1, 2])

    slt.print_linked_list(linked_list)

    rotated_linked_list = slt.rotateRight1(linked_list, 2)

    slt.print_linked_list(rotated_linked_list)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 无重复字符的最长子串</title>
    <url>/2021/08/27/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a>3.无重复字符的最长子串</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>找出字符串中所有不包含重复字符的字串,返回长度最长的一个子串</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def lengthOfLongestSubstring(self, s: str) -&gt; int:
        &quot;&quot;&quot;找出字符串中所有不包含重复字符的字串,返回长度最长的一个子串&quot;&quot;&quot;
        s_list = list(s)  # 将字符串转化为列表
        max_length = 0  # 最大字串长度

        # 找出以字符串中的每个字母开头的不包含重复字符的字串
        for i in range(0, len(s_list)):
            sub_str_list = []
            sub_str_list.append(s_list[i])
            for j in range(i + 1, len(s_list)):
                if s_list[j] not in sub_str_list:
                    sub_str_list.append(s_list[j])
                else:  # 遇到字串中已有的字符,则结束当前子串的寻找
                    break
            # print(&quot;sub_str_list:&quot;, sub_str_list)

            if len(sub_str_list) &gt; max_length:
                max_length = len(sub_str_list)
                # print(&quot;max_length:&quot;, max_length)
                sub_str = &quot;&quot;
                for e in sub_str_list:
                    sub_str += e
                # print(&quot;sub_str:&quot;, sub_str)
                # print(&quot;long_sub_str:&quot;, sub_str)

        print(&quot;无重复字符的最长字串是&#123;&#125;,长度为&#123;&#125;&quot;.format(sub_str, max_length))

        return max_length

    def lengthOfLongestSubstring1(self, s: str) -&gt; int:
        # 哈希集合，记录每个字符是否出现过
        occ = set()
        n = len(s)
        # 右指针，初始值为-1，相当于我们在字符串的左边界的左侧，还没有开始移动
        rk, ans = -1, 0
        for i in range(n):
            if i != 0:
                # 左指针向右移动一格，移动一个字符
                occ.remove(s[i - 1])
            while rk + 1 &lt; n and s[rk + 1] not in occ:
                # 不断地移动右指针
                occ.add(s[rk + 1])
                rk += 1
            # 第i到rk个字符是一个极长的无重复字符字串
            ans = max(ans, rk - i + 1)
        return ans


if __name__ == &quot;__main__&quot;:
    s = &quot;pwwkew&quot;
    slt = Solution()
    len_long_sub_str = slt.lengthOfLongestSubstring1(s)
    print(len_long_sub_str)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>伪迹移除 | 时频表示</title>
    <url>/2021/02/23/%E6%97%B6%E9%A2%91%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<h1 id="时频表示-Time-Frequency-Representation"><a href="#时频表示-Time-Frequency-Representation" class="headerlink" title="时频表示(Time Frequency Representation)"></a>时频表示(Time Frequency Representation)</h1><p>时频表示基于短时傅里叶变换(Short-Time Fourier Transfrom,STFT)。</p>
<h2 id="同时使用时间、频率域分析的原因："><a href="#同时使用时间、频率域分析的原因：" class="headerlink" title="同时使用时间、频率域分析的原因："></a>同时使用时间、频率域分析的原因：</h2><p>脑电信号的非稳定特性</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>在所有的频率范围有统一的时频分辨率，然而我们感兴趣的脑电的频率通常小于30Hz,很多伪迹的频率小于10Hz，这就需要在低频范围有STFT(短时傅里叶变换)不能提供的高频分辨率。</p>
<h2 id="问题的解决"><a href="#问题的解决" class="headerlink" title="问题的解决"></a>问题的解决</h2><p>采用基于小波的方法-小波变换（适合为脑电信号的每一个频带提供相应的分辨率）</p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>伪迹移除</category>
      </categories>
      <tags>
        <tag>EEG</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 最小栈</title>
    <url>/2021/08/27/%E6%9C%80%E5%B0%8F%E6%A0%88/</url>
    <content><![CDATA[<h1 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155.最小栈"></a>155.最小栈</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。<br>    push(x) —— 将元素 x 推入栈中。<br>    pop() —— 删除栈顶的元素。<br>    top() —— 获取栈顶元素。<br>    getMin() —— 检索栈中的最小元素。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/min-stack/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>栈的性质：先进后出</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class MinStack(object):
    def __init__(self):
        &quot;&quot;&quot;
        initialize your data structure here.
        &quot;&quot;&quot;
        self.stack = list()

    def push(self, val):
        &quot;&quot;&quot;
        :type val: int
        :rtype: None
        &quot;&quot;&quot;
        self.stack.append(val)

    def pop(self):
        &quot;&quot;&quot;
        :rtype: None
        &quot;&quot;&quot;
        if len(self.stack) != 0:
            self.stack.pop()

    def top(self):
        &quot;&quot;&quot;
        :rtype: int
        &quot;&quot;&quot;
        if len(self.stack) != 0:
            return self.stack[-1]

    def getMin(self):
        &quot;&quot;&quot;
        :rtype: int
        &quot;&quot;&quot;
        if len(self.stack) != 0:
            return min(self.stack)

# Your MinStack object will be instantiated and called as such:
# obj = MinStack()
# obj.push(val)
# obj.pop()
# param_3 = obj.top()
# param_4 = obj.getMin()

import math

class MinStack1:
    &quot;&quot;&quot;辅助栈&quot;&quot;&quot;
    def __init__(self):
        self.stack = []
        self.min_stack = [math.inf]

    def push(self, x: int) -&gt; None:
        self.stack.append(x)
        self.min_stack.append(min(x, self.min_stack[-1]))

    def pop(self) -&gt; None:
        self.stack.pop()
        self.min_stack.pop()

    def top(self) -&gt; int:
        return self.stack[-1]

    def getMin(self) -&gt; int:
        return self.min_stack[-1]



if __name__ == &quot;__main__&quot;:
    # min_stack = MinStack()
    min_stack = MinStack1()
    min_stack.push(-2)
    min_stack.push(0)
    min_stack.push(-3)
    print(min_stack.getMin())
    min_stack.pop()
    print(min_stack.top())
    print(min_stack.getMin())
    print(math.inf)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>最新SCI期刊查询及投稿分析系统</title>
    <url>/2021/12/16/%E6%9C%80%E6%96%B0SCI%E6%9C%9F%E5%88%8A%E6%9F%A5%E8%AF%A2%E5%8F%8A%E6%8A%95%E7%A8%BF%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="最新SCI期刊查询及投稿分析系统"><a href="#最新SCI期刊查询及投稿分析系统" class="headerlink" title="最新SCI期刊查询及投稿分析系统"></a>最新SCI期刊查询及投稿分析系统</h1><p><a href="https://www.letpub.com.cn/">最新SCI期刊查询及投稿分析系统</a></p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>最新SCI期刊查询及投稿分析系统</category>
      </categories>
      <tags>
        <tag>SCI期刊查询</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 最简单的神经网络</title>
    <url>/2021/06/20/%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="最简单的神经网络"><a href="#最简单的神经网络" class="headerlink" title="最简单的神经网络"></a>最简单的神经网络</h1><p><img src="/2021/06/20/%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/1.png"></p>
<p>其中：X为神经网络的输入 Y为神经网络的输出<br>描述：输入X通过一个节点（一个单独的神经元），最终输出Y<br>例：把房屋的面积作为神经网络的输入，通过一个神经元，最终输出了房屋的价格</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 最长公共前缀</title>
    <url>/2021/08/27/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
    <content><![CDATA[<h1 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14.最长公共前缀"></a>14.最长公共前缀</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。<br>如果不存在公共前缀，返回空字符串 “”。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/longest-common-prefix/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.横向扫描<br>用 LCP(S1…Sn)\textit{LCP}(S_1 \ldots S_n)LCP(S1​…Sn​) 表示字符串 S1…SnS_1 \ldots S_nS1​…Sn​ 的最长公共前缀。<br>可以得到以下结论：<br>LCP(S1…Sn)=LCP(LCP(LCP(S1,S2),S3),…Sn)<br>基于该结论，可以得到一种查找字符串数组中的最长公共前缀的简单方法。依次遍历字符串数组中的每个字符串，对于每个遍历到的字符串，更新最长公共前缀，当遍历完所有的字符串以后，即可得到字符串数组中的最长公共前缀。<br>如果在尚未遍历完所有的字符串时，最长公共前缀已经是空串，则最长公共前缀一定是空串，因此不需要继续遍历剩下的字符串，直接返回空串即可。<br>2.纵向扫描<br>纵向扫描时，从前往后遍历所有字符串的每一列，比较相同列上的字符是否相同，如果相同则继续对下一列进行比较，如果不相同则当前列不再属于公共前缀，当前列之前的部分为最长公共前缀。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def longestCommonPrefix(self, strs) -&gt; str:
        if not strs:
            return &quot;&quot;

        prefix, count = strs[0], len(strs)
        for i in range(1, count):
            prefix = self.lcp(prefix, strs[i])
            if not prefix:
                break

        return prefix

    def lcp(self, str1, str2):
        length, index = min(len(str1), len(str2)), 0
        while index &lt; length and str1[index] == str2[index]:
            index += 1

        return str1[:index]

    def longestCommonPrefix1(self, strs) -&gt; str:
        if not strs:
            return &#39;&#39;

        length, count = len(strs[0]), len(strs)
        for i in range(length):
            c = strs[0][i]
            for j in range(1, count):
                if i == len(strs[j]) or strs[j][i] != c:
                    return strs[0][:i]

        return strs[0]


if __name__ == &quot;__main__&quot;:
    slt = Solution()

    # strs = [&quot;&quot;]
    # strs = [&quot;&quot;, &quot;&quot;]
    # strs = [&#39;ab&#39;, &#39;a&#39;]
    # strs = [&quot;dog&quot;, &quot;racecar&quot;, &quot;car&quot;]
    # strs = [&#39;abcd&#39;, &#39;abcf&#39;, &#39;abcde&#39;]
    strs = [&quot;flower&quot;, &quot;flow&quot;, &quot;flight&quot;]

    prefix = slt.longestCommonPrefix1(strs)
    print(&quot;当前&#123;&#125;个字符串的最长公共前缀为：&#123;&#125;&quot;.format(len(strs), prefix))
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 最长回文串</title>
    <url>/2021/09/03/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="5-最长回文串"><a href="#5-最长回文串" class="headerlink" title="5.最长回文串"></a>5.最长回文串</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 s，找到 s 中最长的回文子串。</p>
<span id="more"></span>
<p>示例 1：<br>输入：s = “babad”<br>输出：”bab”<br>解释：”aba” 同样是符合题意的答案。</p>
<p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.暴力解法<br><strong>2.动态规划</strong><br><strong>3.中心扩展算法</strong><br>4.Manacher 算法<br>注：算法详情请参考leetcode题解</p>
<p><a href="https://writings.sh/post/algorithm-longest-palindromic-substring">几种方法的总结！！！强烈推荐！！！</a></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def longestPalindrome(self, s: str) -&gt; str:
        &quot;&quot;&quot;暴力解法（超出时间限制）&quot;&quot;&quot;
        # max_len = 0
        # longest_palindrome = &quot;&quot;
        # for i in range(0, len(s)):
        #     for j in range(i+1, len(s)+1):
        #         string = s[i:j]
        #         # print(string)
        #         if self.isPalindrome(string):
        #             if len(string) &gt; max_len:
        #                 max_len = len(string)
        #                 longest_palindrome = string
        #
        # return longest_palindrome

        len_s = len(s)
        if len_s &lt; 2:
            return s

        max_len = 1
        begin = 0
        # 枚举所有长度严格大于1的字串
        for i in range(0, len_s-1):
            for j in range(i + 1, len_s):
                if j - i + 1 &gt; max_len and self.isPalindrome(s[i: j+1]):
                    max_len = j - i + 1
                    begin = i

        return s[begin:begin + max_len]

    def isPalindrome(self, s: str) -&gt; bool:
        &quot;&quot;&quot;
        筛选+判断（判断反转字符串是否与原字符串相同）
        &quot;&quot;&quot;
        new_s = &quot;&quot;.join(ch.lower() for ch in s if ch.isalnum())
        return new_s == new_s[::-1]

    def longestPalindrome1(self, s: str) -&gt; str:
        &quot;&quot;&quot;
        动态规划算法

        一个回文串去掉两头以后，剩下的部分依然是回文

        -状态：dp[i][j]表示字串s[i..j]是否为回文子串
        -得到状态转移方程：dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]
         边界条件：j - 1 - (i + 1) + 1 &lt; 2,整理得j - i &lt; 3 &lt;===&gt; j - i + 1 &lt; 4
         (s[i][j]长度为2或者3时，不用检查字串是否回文)
        -初始化：dp[i][i] = true
        -输出：在得到一个状态的值为true的时候，记录起始位置和长度，填表完成以后再截取

        状态转移方程：dp[i][j] = (s[i] == s[j]) and (j - i &lt; 3 or dp[i + 1][j - 1]
        &quot;&quot;&quot;
        n = len(s)
        if n &lt; 2:
            return s

        max_len = 1
        begin = 0

        # dp[i][j]表示s[i..j]是否是回文串
        dp = [[False] * n for _ in range(n)]
        for i in range(n):
            dp[i][i] = True

        # 注意：先填左下角
        for j in range(1, n):
            for i in range(0, j):
                if s[i] != s[j]:
                    dp[i][j] = False
                else:
                    if j - i &lt; 3:
                        dp[i][j] = True
                    else:
                        dp[i][j] = dp[i + 1][j-1]

                # 只要 dp[i][j] == true 成立，就表示子串 s[i..j] 是回文，此时记录回文长度和起始位置
                if dp[i][j] and j - i + 1 &gt; max_len:
                    max_len = j - i + 1
                    begin = i
        return s[begin:begin + max_len]

    def longestPalindrome2(self, s: str) -&gt; str:
        &quot;&quot;&quot;中心扩展算法&quot;&quot;&quot;
        start = 0  # 最长回文串的起始位置
        end = 0  # 最长回文串的结束位置
        for i in range(len(s)):
            left1, right1 = self.expandAroundCenter(s, i, i)  # 边界情况1：子串长度为1的情况
            left2, right2 = self.expandAroundCenter(s, i, i + 1)  # # 边界情况2：子串长度为2的情况
            if right1 - left1 &gt; end - start:  # 扩展的新回文串长度大于当前最长回文串
                start, end = left1, right1
            if right2 - left2 &gt; end - start:
                start, end = left2, right2
        return s[start:end + 1]

    def expandAroundCenter(self, s, left, right):
        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return left + 1, right - 1

    def expand(self, s, left, right):
        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return (right - left - 2) // 2

    def longestPalindrome3(self, s: str) -&gt; str:
        &quot;&quot;&quot;Manacher 算法&quot;&quot;&quot;
        end = -1
        start = 0
        s = &#39;#&#39; + &#39;#&#39;.join(list(s)) + &#39;#&#39;
        arm_len = []
        right = -1
        j = -1
        for i in range(len(s)):
            if right &gt;= i:
                i_sym = 2 * j - i
                min_arm_len = min(arm_len[i_sym], right - i)
                cur_arm_len = self.expand(s, i - min_arm_len, i + min_arm_len)
            else:
                cur_arm_len = self.expand(s, i, i)
            arm_len.append(cur_arm_len)
            if i + cur_arm_len &gt; right:
                j = i
                right = i + cur_arm_len
            if 2 * cur_arm_len + 1 &gt; end - start:
                start = i - cur_arm_len
                end = i + cur_arm_len
        return s[start + 1:end + 1:2]


if __name__ == &#39;__main__&#39;:
    slt = Solution()
    s = &quot;abad&quot;
    res = slt.longestPalindrome(s)
    print(&quot;最长的回文串为：&quot;, res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 最长特殊序列</title>
    <url>/2021/09/01/%E6%9C%80%E9%95%BF%E7%89%B9%E6%AE%8A%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="521-最长特殊序列"><a href="#521-最长特殊序列" class="headerlink" title="521.最长特殊序列"></a>521.最长特殊序列</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两个字符串，请你从这两个字符串中找出最长的特殊序列。<br>「最长特殊序列」定义如下：该序列为某字符串独有的最长子序列（即不能是其他字符串的子序列）。<br>子序列 可以通过删去字符串中的某些字符实现，但不能改变剩余字符的相对顺序。空序列为所有字符串的子序列，任何字符串为其自身的子序列。<br>输入为两个字符串，输出最长特殊序列的长度。如果不存在，则返回 -1。</p>
<span id="more"></span>
<p>刷到这道题目时我表示有点没看懂，然后就看了leetcode的评论，也有许多人没看懂，最后就看了题解。。。<br>我认为，本题按照leetcode官方题解解法二的解决方案容易理解。</p>
<p><a href="https://leetcode-cn.com/problems/longest-uncommon-subsequence-i/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>字符串 aaa 和 bbb 共有 3 种情况：<br>    a=b。如果两个字符串相同，则没有特殊子序列，返回 -1。<br>    length(a)=length(b) 且 a≠b。例如：abc 和 abd。这种情况下，一个字符串一定不会是另外一个字符串的子序列，因此可以将任意一个字符串看作是特殊子序列，返回 length(a) 或 length(b)。<br>    length(a)≠length(b)。例如：abcd 和 abc。这种情况下，长的字符串一定不会是短字符串的子序列，因此可以将长字符串看作是特殊子序列，返回 max(length(a),length(b))。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def findLUSlength(self, a: str, b: str) -&gt; int:
        if a == b:
            return -1

        return max(len(a), len(b))


if __name__ == &quot;__main__&quot;:
    slt = Solution()
    a = &quot;aaa&quot;
    b = &quot;bbb&quot;
    res = slt.findLUSlength(a, b)
    print(res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>有效的括号</title>
    <url>/2021/08/27/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。<br>有效字符串需满足：<br>    左括号必须用相同类型的右括号闭合。<br>    左括号必须以正确的顺序闭合。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/valid-parentheses/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>遍历字符串，遇到右括号将右括号入栈，遇到左括号判断此左括号是否与栈顶括号相同，若相同则将栈顶元素出栈，…，最后在遍历结束后判断栈是否为空，若为空则为有效括号。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):
    def isValid(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: bool
        &quot;&quot;&quot;
        if len(s) % 2 == 1:
            return False

        stack = []
        for ch in s:
            if ch == &#39;(&#39; or ch == &#39;[&#39; or ch == &#39;&#123;&#39;:
                stack.append(ch)
            elif ch == &#39;)&#39; and len(stack) != 0:
                    if stack[-1] == &#39;(&#39;:
                        stack.pop()
                    else:
                        return False
            elif ch == &#39;]&#39; and len(stack) != 0:
                    if stack[-1] == &#39;[&#39;:
                        stack.pop()
                    else:
                        return False
            elif ch == &#39;&#125;&#39; and len(stack) != 0:
                    if stack[-1] == &#39;&#123;&#39;:
                        stack.pop()
                    else:
                        return False
            else:
                return False

        if len(stack) == 0:
            return True
        else:
            return False

    def isValid1(self, s):
        if len(s) % 2 == 1:
            return False

        pairs = &#123;
            &quot;)&quot;: &quot;(&quot;,
            &quot;]&quot;: &quot;[&quot;,
            &quot;&#125;&quot;: &quot;&#123;&quot;
        &#125;
        stack = list()
        for ch in s:
            if ch in pairs:
                if not stack or stack[-1] != pairs[ch]:
                    return False
                stack.pop()
            else:
                stack.append(ch)

        return not stack




if __name__ == &quot;__main__&quot;:
    slt = Solution()
    # s = &quot;()&quot;
    # s = &quot;()[]&#123;&#125;&quot;
    # s = &quot;(]&quot;
    # s = &quot;([)]&quot;
    # s = &quot;&#123;[]&#125;&quot;
    s = &quot;]&quot;
    ret = slt.isValid1(s)
    print(ret)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>本地与服务器互传文件</title>
    <url>/2021/04/18/%E6%9C%AC%E5%9C%B0%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BA%92%E4%BC%A0%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="本地与服务器互传文件"><a href="#本地与服务器互传文件" class="headerlink" title="本地与服务器互传文件"></a>本地与服务器互传文件</h1><p>命令安装：yum install lrzsz</p>
<p>从服务器发送文件到客户端： sz filename</p>
<p>从客户端上传文件到服务端： rz</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习 | 朴素贝叶斯</title>
    <url>/2021/03/05/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/</url>
    <content><![CDATA[<h1 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h1><p>朴素贝叶斯算法(Naive Bayes)是<b>有监督(supervised)</b>的学习算法，解决的是<b>分类</b>问题(例如：客户是否流失、是否值得投资、信用等级评定等<b>多分类</b>问题)</p>
<span id="more"></span>
<h2 id="朴素贝叶斯理论"><a href="#朴素贝叶斯理论" class="headerlink" title="朴素贝叶斯理论"></a>朴素贝叶斯理论</h2><p><b style="color:red">朴素贝叶斯理论的核心思想：选择具有最高概率的决策</b></p>
<p>假设现在我们用p1(x,y)表示数据点(x,y)属于类别1的概率，用p2(x,y)表示数据点(x,y)属于类别2的概率，那么对于一个新的数据点，可以用以下规则来进行判断：</p>
<li>如果p1(x,y) > p2(x,y),那么类别为1</li>
<li>如果p1(x,y) < p2(x,y),那么类别为2</li>

<h2 id="条件概率-Conditional-probability"><a href="#条件概率-Conditional-probability" class="headerlink" title="条件概率(Conditional probability)"></a>条件概率(Conditional probability)</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>条件概率指在事件B发生的情况下，事件A发生的概率，用P(A|B)来表示。</p>
<h3 id="条件概率计算公式"><a href="#条件概率计算公式" class="headerlink" title="条件概率计算公式"></a>条件概率计算公式</h3><p><b style="color:red">P(A|B)=P(B|A)P(A)/P(B)</b></p>
<h2 id="全概率公式"><a href="#全概率公式" class="headerlink" title="全概率公式"></a>全概率公式</h2><p><img src="/2021/03/05/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/1.jpg"><br>全概率公式：<br><img src="/2021/03/05/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/2.jpg"><br>条件概率的另一种写法：<br><img src="/2021/03/05/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/3.jpg"></p>
<h2 id="贝叶斯推断"><a href="#贝叶斯推断" class="headerlink" title="贝叶斯推断"></a>贝叶斯推断</h2><p>对条件概率公式进行变形，得到：<br><img src="/2021/03/05/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/4.jpg"><br>其中，P(A)称为“<b>先验概率</b>”(Prior probability),即在B事件发生之前，我们对A事件概率的一个判断。<br><br>P(A|B)称为“<b>后验概率</b>”，即在B事件发生之后，我们对A事件概率的重新判断。<br><br>P(B|A)/P(B)称为“可能性函数”，即调整因子，使得预估概率更接近真实概率。可能性函数&gt;1：意味着先验概率被增强，事件A发生的可能性变大；可能性函数=1：意味着B事件无助于判断事件A的可能性；可能性函数&lt;1:意味着先验概率被削弱，事件A的可能性变小</p>
<p>因此，我们可以把条件概率理解成：<br><b>后验概率 = 先验概率 * 调整因子</b></p>
<p><b style="color:red">贝叶斯推断的含义：我们先预估一个“先验概率”，然后加入实验结果，看这个实验结果到底是增强还是削弱了“先验概率”，由此得到更接近事实的”后验概率”</b></p>
<h2 id="朴素贝叶斯推断"><a href="#朴素贝叶斯推断" class="headerlink" title="朴素贝叶斯推断"></a>朴素贝叶斯推断</h2><p>贝叶斯和朴素贝叶斯的概念是不同的，区别就在于“朴素”二字，朴素贝叶斯对条件概率分布做了条件独立性的假设。<br></p>
<p>假设有n个特征：<br><img src="/2021/03/05/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/5.jpg"><br>由于每个特征都是独立的，故：<br><img src="/2021/03/05/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/6.jpg"></p>
<h2 id="朴素贝叶斯改进之拉普拉斯平滑"><a href="#朴素贝叶斯改进之拉普拉斯平滑" class="headerlink" title="朴素贝叶斯改进之拉普拉斯平滑"></a>朴素贝叶斯改进之拉普拉斯平滑</h2><p>1.利用贝叶斯分类器进行分类时，要计算多个概率的乘积，如果其中有一个概率值为0，那么最后的结果为0。<br>solution:拉普拉斯平滑(Laplace Smoothing)-加一平滑(比较常用的平滑方法，可以解决0概率问题)<br>2.很多很小的数相乘，造成下溢出<br>solution:可以通过求对数避免下溢出或浮点数舍入导致的错误</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="朴素贝叶斯推断的一些优点："><a href="#朴素贝叶斯推断的一些优点：" class="headerlink" title="朴素贝叶斯推断的一些优点："></a>朴素贝叶斯推断的一些优点：</h3><li>生成式模型，通过计算概率来进行分类，可以用来处理<b>多分类问题</b></li>
<li>对小规模数据表现很好，适合<b>多分类任务</b>，适合增量式训练，算法也比较简单</li>
<li>简单易懂、学习效率高，在某些领域的分类问题中能够与决策树、神经网络相媲美</li>

<h3 id="朴素贝叶斯推断的一些缺点："><a href="#朴素贝叶斯推断的一些缺点：" class="headerlink" title="朴素贝叶斯推断的一些缺点："></a>朴素贝叶斯推断的一些缺点：</h3><li>对输入数据的表现形式敏感</li>
<li>由于朴素贝叶斯的“朴素”特点(算法以自变量之间的独立性(条件特征独立)和连续变量的正态性假设为前提)，所以会带来一些准确率上的损失</li>
<li>需要计算先验概率，分类决策存在错误率</li>

<p><a href="https://cuijiahua.com/blog/2017/11/ml_4_bayes_1.html">参考资源1</a><br><a href="https://cuijiahua.com/blog/2017/11/ml_5_bayes_2.html">参考资源2</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>Naive Bayes</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>朴素贝叶斯</tag>
        <tag>Naive Bayes</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 机器人能否返回原点</title>
    <url>/2021/09/03/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%83%BD%E5%90%A6%E8%BF%94%E5%9B%9E%E5%8E%9F%E7%82%B9/</url>
    <content><![CDATA[<h1 id="657-机器人能够返回原点"><a href="#657-机器人能够返回原点" class="headerlink" title="657.机器人能够返回原点"></a>657.机器人能够返回原点</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在二维平面上，有一个机器人从原点 (0, 0) 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 (0, 0) 处结束。<br>移动顺序由字符串表示。字符 move[i] 表示其第 i 次移动。机器人的有效动作有 R（右），L（左），U（上）和 D（下）。如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。<br>注意：机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。</p>
<span id="more"></span>

<p><a href="https://leetcode-cn.com/problems/robot-return-to-origin/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>起始时机器人的坐标为 (0,0)，在遍历完所有指令并对机器人进行移动之后，判断机器人的坐标是否为 (0,0) 即可。</p>
<p>具体来说，我们用两个变量 x 和 y 来表示机器人当前所在的坐标为 (x,y)，起始时 x=0，y=0。接下来我们遍历指令并更新机器人的坐标：<br>    如果指令是 U，则令 y=y−1<br>    如果指令是 D，则令 y=y+1<br>    如果指令是 L，则令 x=x−1<br>    如果指令是 R，则令 x=x+1<br>最后判断 (x,y) 是否为 (0,0) 即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def judgeCircle(self, moves: str) -&gt; bool:
        if len(moves) % 2 != 0:
            return False

        pos_x = 0
        pos_y = 0

        for move in moves:
            if move == &#39;U&#39;:
                pos_y += 1
            elif move == &#39;D&#39;:
                pos_y -= 1
            elif move == &#39;R&#39;:
                pos_x += 1
            elif move == &#39;L&#39;:
                pos_x -= 1

        if pos_x == 0 and pos_y == 0:
            return True
        else:
            return False

    def judgeCircle1(self, moves: str) -&gt; bool:
        if moves.count(&#39;L&#39;) == moves.count(&#39;R&#39;) and moves.count(&#39;U&#39;) == moves.count(&#39;D&#39;):
            return True
        else:
            return False


if __name__ == &quot;__main__&quot;:
    slt = Solution()
    res = slt.judgeCircle(&quot;UD&quot;)
    # res = slt.judgeCircle1(&quot;LLL&quot;)
    print(res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习 | 机器学习中分类标签次数统计代码模板</title>
    <url>/2021/02/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%88%86%E7%B1%BB%E6%A0%87%E7%AD%BE%E6%AC%A1%E6%95%B0%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="机器学习中分类标签次数统计代码模板"><a href="#机器学习中分类标签次数统计代码模板" class="headerlink" title="机器学习中分类标签次数统计代码模板"></a>机器学习中分类标签次数统计代码模板</h1><p>在使用机器学习的算法进行分类时，很多时候我们需要去统计各个分类标签在数据集中出现的次数，它的实现代码模板如下：</p>
<pre><code>def class_count(class_list):  # class_list:数据集数据的所有标签列表
    # 存放各个分类出现的次数
    class_counts = &#123;&#125;
    # 统计class_list中每个元素出现的次数
    for cla in class_list:
        if cla not in class_counts.keys():
            class_counts[cla] = 0
        class_counts[cla] += 1
    # 排序
    sorted_class_count = sorted(class_counts.items(), key=operator.itemgetter(1), reverse=True)
    return sorted_class_count
</code></pre>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习 | 机器学习分类的一般步骤</title>
    <url>/2021/05/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%88%86%E7%B1%BB%E7%9A%84%E4%B8%80%E8%88%AC%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<h1 id="机器学习分类的一般步骤"><a href="#机器学习分类的一般步骤" class="headerlink" title="机器学习分类的一般步骤"></a>机器学习分类的一般步骤</h1><p>1.get data from file<br>2.data preprocess<br>3.get data and label<br>4.design the model used here<br>5.train the model<br>6.validate the model<br>7.test the model<br>8.save the model with best accuracy<br>note: pay more attention on<br><b>1)how to deal with the source data that model can process.</b><br>In general,the size of the input of the model is [B, C, H, W],<br>where B is batch size,C is number of channels,H ans W is two dimension of the input data respectively.<br><b>2)how to calculate ‘in_features’ of the first fully connected layer</b>`</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习基础知识</title>
    <url>/2020/10/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1>机器学习（Machine Learning,ML）</h1>
<h2>机器是如何学习的？</h2>
<h3>1.什么是机器学习？</h3>
通过输入海量训练数据对模型进行训练，使模型掌握数据所蕴含的潜在规律，进而对新输入的数据进行准确的分类和预测。
Note:
1)计算机程序能够处理的只有数值和运算
2）要让一段程序了解客观世界变化万千的实物，则必须将这些实物数值化，将事物的变化和不同事物之间的关联转化为运算。
3）现实世界和计算机之间，概念<-->数值，关系<-->运算的映射，造就了机器可以自主学习实物规律的可能
<span id="more"></span>
<h3>2.机器学习的分类</h3>
有监督学习 通过标注进行学习（用于学习的数据包含样本和标签）
无监督学习 用于学习的数据只有样本没有标签


<h2>机器学习三要素</h2> 
数据、模型、算法（算法通过在数据上进行运算产生模型）
<h3>1.数据</h3>  <h3></h3>
原数据（图片/文字/声音（计算机能够处理的是数值））---->特征工程（1.确定用哪些特征来表示数据 2.确定用什么方式表达这些特征）--VSM(向量空间模型)--> vector ---->算法--算运-->模型
有标注数据（数据样本有标签）
无标注数据（数据样本无标签）
<h3>2.模型</h3>
模型是机器学习的结果，学习的过程称为训练
机器学习的两类问题
    回归（输出结果是一个数值）
    分类（输出结果是一个标签）
<h3>3.算法</h3>
损失函数 描述预测值与真实值之间的差别（针对一个训练数据）
代价函数 （针对所有的训练数据）
目标函数 最小化的代价函数
如何找到最小的参数？---->优化算法
优化算法
    梯度下降法（最常用）
    共轭梯度法
    牛顿法
    拟牛顿法
    模拟退火法
    ...

<h2>模型的获取和改进</h2>
<h3>1.获取模型的过程（-训练-将算法应用到数据上进行运算的过程）</h3>
数据+算法=模型
模型构建步骤
    Step1 数据准备
        Step1.1数据预处理 收集数据、清洗数据、标注数据
        Step1.2构建数据的VSM(将文本、图片、音频、视频等格式的数据转换为向量)
        Step1.3将构件号的VSM的数据分为训练集、验证集和测试集
    Step2 训练--将训练集输入给训练程序进行运算。训练程序的核心是算法，所有输入的向量化数据都会按该训练程序所以及的算法进行运算。训练程序输出的结果就是模型
        Step2.1编写训练程序
            Step2.1.1选择模型类型
            Step2.1.2选择优化算法
            Step2.1.3根据模型类型和算法编写程序
        Step2.2训练-->获得临时模型
        Step2.3在训练集上运行临时模型，获得训练集预测结果
        Step2.4在验证集上运行临时模型，获得验证集预测结果
        Step2.5综合参照Step2.3和step2.4的预测结果，改进模型
        Step2.6 Step2.2到Step2.5反复迭代，直至获得让我们满意，或者已经无法继续优化的模型
    Step3 测试--将测试机数据输入给训练获得的模型，得到预测结果；再将预测结果与这些数据原本预期的结果进行比较
Note:
    训练集：用来做训练的数据的集合
    验证集：用来在训练的过程中每个训练轮次结束后验证当前模型性能，为进一步优化模型提供参考的数据的集合
    测试集：用来做测试的数据的集合，用于检验最终得出的模型的性能
    每个集合都应当是独立的，和另外两个没有重叠
    训练集市训练过程的基础，而验证和测试集则是在不同阶段用来评价训练结果的
<h3>2.改进模型</h3>
数据
    大量的高质量训练数据，是提高模型质量的有效手段，但通常我们可以用来训练的数据量相当有限
    有限的数据---->归一化（Normalization）、正则化(Regularization)、Bootstrap、根据业务进行特征选取（从业务角度区分输入数据包含的特征，并理解这些特征对结果的贡献）
调参
    超参数需要模型训练者自己来设置和调整
选择合适的模型

<p>模型的质量和评判指标<br>分类模型评判指标<br>    精确率（Precision)<br>    召回率（Recall）<br>    F1Score(综合Precision和Recall)<br>一个机器学习模型的质量问题，从对训练集样本拟合程度的角度，可以分为两类：<br>欠拟合（Underfitting）模型在训练集上的预测结果不佳，指标偏低<br>    解决方法：选择更复杂的模型，增加特征<br>过拟合（Overfitting）模型在训练集上指标很好，而在验证或测绘集上指标偏低<br>    解决方法：选择更简单的模型，减少特征</p>
<p>模型<br>    线性回归 LinearRegression,LR<br>    逻辑回归 LogisticRegression<br>    朴素贝叶斯分类器 Naive Bayes Classifier,NB<br>    决策树 DecisionTree,DT<br>    支持向量机 Supporting Vector Machine,SVM<br>    支持向量回归机器 Support Vector Regressioon,SVR<br>    隐马尔科夫模型 Hiden Marcov Model,HMM<br>    条件随机场 Conditional Random Field,CRF<br>    K邻近 K Nearest Neighbor,KNN<br>    K均值 K Means</p>
</--></-->]]></content>
      <categories>
        <category>机器学习</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>脑电分类 | 机器学习实现脑电分类</title>
    <url>/2021/02/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E7%8E%B0%E8%84%91%E7%94%B5%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="机器学习实现脑电分类"><a href="#机器学习实现脑电分类" class="headerlink" title="机器学习实现脑电分类"></a>机器学习实现脑电分类</h1><p><img src="/2021/02/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E7%8E%B0%E8%84%91%E7%94%B5%E5%88%86%E7%B1%BB/1.jpg"></p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>脑电分类</category>
      </categories>
      <tags>
        <tag>脑电分类</tag>
        <tag>机器学习</tag>
        <tag>EEG</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习 | 机器学习常用的两种验证方法</title>
    <url>/2021/05/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E9%AA%8C%E8%AF%81%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="机器学习常用的两种验证方法"><a href="#机器学习常用的两种验证方法" class="headerlink" title="机器学习常用的两种验证方法"></a>机器学习常用的两种验证方法</h1><p>1.Leave One Subject Out<br>2.K Fold Cross Validation</p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>验证方法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 权重初始化</title>
    <url>/2021/06/22/%E6%9D%83%E9%87%8D%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<h1 id="权重初始化"><a href="#权重初始化" class="headerlink" title="权重初始化"></a>权重初始化</h1><p>在训练神经网络时，权重随机初始化是很重要的。</p>
<p>对于<strong>逻辑回归</strong>，把<strong>权重初始化为0</strong>当然也是可以的。但是对于一个<strong>神经网络</strong>，如果你把权重<br>或者参数都初始化为 0，那么<strong>梯度下降将不会起作用</strong>。</p>
<p>如果你<strong>把权重都初始化为 0，那么由于隐含单元开始计算同一个函数</strong>，所有的隐含单元就会对输出单元有同样的影响。<br>一次迭代后同样的表达式结果仍然是相同的，即<strong>隐含单元仍是对称的</strong>。通过推导，两次、三次、无论多少次迭代，不管你训练网络多长时间，<br>隐含单元仍然计算的是同样的函数。因此这种情况下超过 1 个隐含单元也没什么意义，因为他们计算同样的东西。如果你要初始化成 0，<br>由于所有的隐含单元都是对称的，无论你运行梯度下降多久，他们一直计算同样的函数。这没有任何帮助，因为你想要两个不同<br>的隐含单元计算不同的函数，这个问题的解决方法就是<b>随机初始化参数</b>。</p>
<p><a href="https://www.bilibili.com/video/BV1FT4y1E74V?p=35&spm_id_from=pageDriver">参考吴恩达深度学习视频</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Research and Paper | 查找论文代码的两个网站</title>
    <url>/2021/07/03/%E6%9F%A5%E6%89%BE%E8%AE%BA%E6%96%87%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h1 id="查找论文代码的两个网站"><a href="#查找论文代码的两个网站" class="headerlink" title="查找论文代码的两个网站"></a>查找论文代码的两个网站</h1><p><a href="https://www.paperswithcode.com/">网址1</a></p>
<p><a href="https://researchcode.com/">网址2</a></p>
]]></content>
      <categories>
        <category>Research and Paper</category>
      </categories>
      <tags>
        <tag>论文代码</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 检测大写字母</title>
    <url>/2021/09/01/%E6%A3%80%E6%B5%8B%E5%A4%A7%E5%86%99%E5%AD%97%E6%AF%8D/</url>
    <content><![CDATA[<h1 id="520-检测大写字母"><a href="#520-检测大写字母" class="headerlink" title="520.检测大写字母"></a>520.检测大写字母</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个单词，你需要判断单词的大写使用是否正确。<br>我们定义，在以下情况时，单词的大写用法是正确的：<br>    全部字母都是大写，比如”USA”。<br>    单词中所有字母都不是大写，比如”leetcode”。<br>    如果单词不只含有一个字母，只有首字母大写， 比如 “Google”。<br>否则，我们定义这个单词没有正确使用大写字母。</p>
<span id="more"></span>
<p>示例 1:<br>输入: “USA”<br>输出: True<br>示例 2:<br>输入: “FlaG”<br>输出: False<br>注意: 输入是由大写和小写拉丁字母组成的非空单词。</p>
<p><a href="https://leetcode-cn.com/problems/detect-capital/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>按照单词大写用法进行判断，满足返回True，不满足返回False</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def detectCapitalUse(self, word: str) -&gt; bool:
        if word.islower() or word.isupper():
            return True
        elif word[0].isupper() and word[1:].islower():
            return True
        else:
            return False


if __name__ == &quot;__main__&quot;:
    slt = Solution()
    # word = &quot;USA&quot;
    # word = &quot;leetcode&quot;
    # word = &quot;Google&quot;
    word = &quot;flaG&quot;
    res = slt.detectCapitalUse(word)
    print(res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>pygame | 植物大战僵尸</title>
    <url>/2021/10/25/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8/</url>
    <content><![CDATA[<h1 id="植物大战僵尸"><a href="#植物大战僵尸" class="headerlink" title="植物大战僵尸"></a>植物大战僵尸</h1><p>python pygame 实现植物大战僵尸.<br><a href="https://blog.csdn.net/Gtieguo/article/details/112093640">植物大战僵尸</a></p>
<span id="more"></span>
<p>实现代码：</p>
<pre><code># 引入需要的模块
import pygame
import random

# 配置图片地址
IMAGE_PATH = &#39;imgs/&#39;

# 设置页面宽高
scrrr_width = 800
scrrr_height = 560

# 创建控制游戏结束的状态
GAMEOVER = False

# 图片加载报错处理
LOG = &#39;文件:&#123;&#125;中的方法:&#123;&#125;出错&#39;.format(__file__, __name__)

# 创建地图类
class Map():
    map_names_list = [IMAGE_PATH + &#39;map1.png&#39;, IMAGE_PATH + &#39;map2.png&#39;]

    # 初始化地图
    def __init__(self, x, y, img_index):
        self.image = pygame.image.load(Map.map_names_list[img_index])
        self.position = (x, y)

        # 是否能够种植
        self.can_grow = True

    # 加载地图
    def load_map(self):
        MainGame.window.blit(self.image, self.position)


# 植物类
class Plant(pygame.sprite.Sprite):
    def __init__(self):
        super(Plant, self).__init__()
        self.live = True

    def load_image(self):
        if hasattr(self, &#39;image&#39;) and hasattr(self, &#39;rect&#39;):
            MainGame.window.blit(self.image, self.rect)
        else:
            print(LOG)


# 向日葵类
class Sunflower(Plant):
    def __init__(self, x, y):
        super(Sunflower, self).__init__()
        self.image = pygame.image.load(&#39;imgs/sunflower.png&#39;)
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.price = 50
        self.hp = 100
        # 5 时间计数器
        self.time_count = 0

    # 新增功能：生成阳光

    def produce_money(self):
        self.time_count += 1
        if self.time_count == 25:
            MainGame.money += 5
            self.time_count = 0

    # 向日葵加入到窗口中
    def display_sunflower(self):
        MainGame.window.blit(self.image, self.rect)

# 豌豆射手类
class PeaShooter(Plant):
    def __init__(self, x, y):
        super(PeaShooter, self).__init__()
        # self.image 为一个 surface
        self.image = pygame.image.load(&#39;imgs/peashooter.png&#39;)
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.price = 50
        self.hp = 200
        # 6 发射计数器
        self.shot_count = 0

    # 增加射击方法
    def shot(self):
        # 6 记录是否应该射击
        should_fire = False
        for zombie in MainGame.zombie_list:
            if zombie.rect.y == self.rect.y and zombie.rect.x &lt; 800 and zombie.rect.x &gt; self.rect.x:
                should_fire = True
        # 6 如果活着
        if self.live and should_fire:
            self.shot_count += 1
            # 6 计数器到25发射一次
            if self.shot_count == 25:
                # 6 基于当前豌豆射手的位置，创建子弹
                peabullet = PeaBullet(self)
                # 6 将子弹存储到子弹列表中
                MainGame.peabullet_list.append(peabullet)
                self.shot_count = 0

    # 将豌豆射手加入到窗口中的方法
    def display_peashooter(self):
        MainGame.window.blit(self.image, self.rect)


# 豌豆子弹类
class PeaBullet(pygame.sprite.Sprite):
    def __init__(self, peashooter):
        self.live = True
        self.image = pygame.image.load(&#39;imgs/peabullet.png&#39;)
        self.damage = 50
        self.speed = 10
        self.rect = self.image.get_rect()
        self.rect.x = peashooter.rect.x + 60
        self.rect.y = peashooter.rect.y + 15

    def move_bullet(self):
        # 7 在屏幕范围内，实现往右移动
        if self.rect.x &lt; scrrr_width:
            self.rect.x += self.speed
        else:
            self.live = False

    # 7 新增，子弹与僵尸的碰撞
    def hit_zombie(self):
        for zombie in MainGame.zombie_list:
            if pygame.sprite.collide_rect(self, zombie):
                # 打中僵尸之后，修改子弹的状态，
                self.live = False
                # 僵尸掉血
                zombie.hp -= self.damage
                if zombie.hp &lt;= 0:
                    zombie.live = False
                    self.nextLevel()
    # 7闯关方法

    def nextLevel(self):
        MainGame.score += 20
        MainGame.remnant_score -= 20
        for i in range(1, 100):
            if MainGame.score == 100 * i and MainGame.remnant_score == 0:
                MainGame.remnant_score = 100 * i
                MainGame.shaoguan += 1
                MainGame.produce_zombie += 50

    def display_peabullet(self):
        MainGame.window.blit(self.image, self.rect)


# 僵尸类
class Zombie(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super(Zombie, self).__init__()
        self.image = pygame.image.load(&#39;imgs/zombie.png&#39;)
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.hp = 1000
        self.damage = 2
        self.speed = 1
        self.live = True
        self.stop = False
    # 9 僵尸的移动

    def move_zombie(self):
        if self.live and not self.stop:
            self.rect.x -= self.speed
            if self.rect.x &lt; -80:
                # 8 调用游戏结束方法
                MainGame().gameOver()

    # 9 判断僵尸是否碰撞到植物，如果碰撞，调用攻击植物的方法
    def hit_plant(self):
        for plant in MainGame.plants_list:
            if pygame.sprite.collide_rect(self, plant):
                # 8  僵尸移动状态的修改
                self.stop = True
                self.eat_plant(plant)
    # 9 僵尸攻击植物

    def eat_plant(self, plant):
        # 9 植物生命值减少
        plant.hp -= self.damage
        # 9 植物死亡后的状态修改，以及地图状态的修改
        if plant.hp &lt;= 0:
            a = plant.rect.y // 80 - 1
            b = plant.rect.x // 80
            map = MainGame.map_list[a][b]
            map.can_grow = True
            plant.live = False
            # 8 修改僵尸的移动状态
            self.stop = False

    # 9 将僵尸加载到地图中

    def display_zombie(self):
        MainGame.window.blit(self.image, self.rect)


# 主程序
class MainGame():
    # 2 创建关数，得分，剩余分数，钱数
    shaoguan = 1
    score = 0
    remnant_score = 100
    money = 200
    # 3 存储所有地图坐标点
    map_points_list = []
    # 3 存储所有的地图块
    map_list = []
    # 4 存储所有植物的列表
    plants_list = []
    # 7 存储所有豌豆子弹的列表
    peabullet_list = []
    # 9 新增存储所有僵尸的列表
    zombie_list = []
    count_zombie = 0
    produce_zombie = 100
    # 1 加载游戏窗口

    def init_window(self):
        # 1 调用显示模块的初始化
        pygame.display.init()
        # 1 创建窗口
        MainGame.window = pygame.display.set_mode([scrrr_width, scrrr_height])

    # 2 文本绘制
    def draw_text(self, content, size, color):
        pygame.font.init()
        font = pygame.font.SysFont(&#39;kaiti&#39;, size)
        text = font.render(content, True, color)
        return text

    # 2 加载帮助提示
    def load_help_text(self):
        text1 = self.draw_text(&#39;1.按左键创建向日葵 2.按右键创建豌豆射手&#39;, 26, (255, 0, 0))
        MainGame.window.blit(text1, (5, 5))

    # 3 初始化坐标点
    def init_plant_points(self):
        for y in range(1, 7):
            points = []
            for x in range(10):
                point = (x, y)
                points.append(point)
            MainGame.map_points_list.append(points)
            print(&quot;MainGame.map_points_list&quot;, MainGame.map_points_list)

    # 3 初始化地图
    def init_map(self):
        for points in MainGame.map_points_list:
            temp_map_list = list()
            for point in points:
                # map = None
                if (point[0] + point[1]) % 2 == 0:
                    map = Map(point[0] * 80, point[1] * 80, 0)
                else:
                    map = Map(point[0] * 80, point[1] * 80, 1)
                # 将地图块加入到窗口中
                temp_map_list.append(map)
                print(&quot;temp_map_list&quot;, temp_map_list)
            MainGame.map_list.append(temp_map_list)
        print(&quot;MainGame.map_list&quot;, MainGame.map_list)

    # 3 将地图加载到窗口中
    def load_map(self):
        for temp_map_list in MainGame.map_list:
            for map in temp_map_list:
                map.load_map()

    # 6 增加豌豆射手发射处理
    def load_plants(self):
        for plant in MainGame.plants_list:
            # 6 优化加载植物的处理逻辑
            if plant.live:
                if isinstance(plant, Sunflower):
                    plant.display_sunflower()
                    plant.produce_money()
                elif isinstance(plant, PeaShooter):
                    plant.display_peashooter()
                    plant.shot()
            else:
                MainGame.plants_list.remove(plant)

    # 7 加载所有子弹的方法
    def load_peabullets(self):
        for b in MainGame.peabullet_list:
            if b.live:
                b.display_peabullet()
                b.move_bullet()
                # v1.9 调用子弹是否打中僵尸的方法
                b.hit_zombie()
            else:
                MainGame.peabullet_list.remove(b)

    # 8事件处理

    def deal_events(self):
        # 8 获取所有事件
        eventList = pygame.event.get()
        # 8 遍历事件列表，判断
        for e in eventList:
            if e.type == pygame.QUIT:
                self.gameOver()
            elif e.type == pygame.MOUSEBUTTONDOWN:
                # print(&#39;按下鼠标按键&#39;)
                print(e.pos)
                # print(e.button)#左键1  按下滚轮2 上转滚轮为4 下转滚轮为5  右键 3

                x = e.pos[0] // 80
                y = e.pos[1] // 80
                print(x, y)
                map = MainGame.map_list[y - 1][x]
                print(map.position)
                # 8 增加创建时候的地图装填判断以及金钱判断
                if e.button == 1:
                    if map.can_grow and MainGame.money &gt;= 50:
                        sunflower = Sunflower(map.position[0], map.position[1])
                        MainGame.plants_list.append(sunflower)
                        print(&#39;当前植物列表长度:&#123;&#125;&#39;.format(len(MainGame.plants_list)))
                        map.can_grow = False
                        MainGame.money -= 50
                elif e.button == 3:
                    if map.can_grow and MainGame.money &gt;= 50:
                        peashooter = PeaShooter(
                            map.position[0], map.position[1])
                        MainGame.plants_list.append(peashooter)
                        print(&#39;当前植物列表长度:&#123;&#125;&#39;.format(len(MainGame.plants_list)))
                        map.can_grow = False
                        MainGame.money -= 50

    # 9 新增初始化僵尸的方法
    def init_zombies(self):
        for i in range(1, 7):
            dis = random.randint(1, 5) * 200
            zombie = Zombie(800 + dis, i * 80)
            MainGame.zombie_list.append(zombie)

    # 9将所有僵尸加载到地图中
    def load_zombies(self):
        for zombie in MainGame.zombie_list:
            if zombie.live:
                zombie.display_zombie()
                zombie.move_zombie()
                # v2.0 调用是否碰撞到植物的方法
                zombie.hit_plant()
            else:
                MainGame.zombie_list.remove(zombie)
    # 1 开始游戏

    def start_game(self):
        # 1 初始化窗口
        self.init_window()
        # 3 初始化坐标和地图
        self.init_plant_points()
        self.init_map()
        # 9 调用初始化僵尸的方法
        self.init_zombies()
        # 1 只要游戏没结束，就一直循环
        while not GAMEOVER:
            # 1 渲染白色背景
            MainGame.window.fill((255, 255, 255))
            # 2 渲染的文字和坐标位置
            MainGame.window.blit(
                self.draw_text(
                    &#39;当前钱数$: &#123;&#125;&#39;.format(
                        MainGame.money), 26, (255, 0, 0)), (500, 40))
            MainGame.window.blit(
                self.draw_text(
                    &#39;当前关数&#123;&#125;，得分&#123;&#125;,距离下关还差&#123;&#125;分&#39;.format(
                        MainGame.shaoguan,
                        MainGame.score,
                        MainGame.remnant_score),
                    26,
                    (255,
                     0,
                     0)),
                (5,
                 40))
            self.load_help_text()

            # 3 需要反复加载地图
            self.load_map()
            # 6 调用加载植物的方法
            self.load_plants()
            # 7  调用加载所有子弹的方法
            self.load_peabullets()
            # 8 调用事件处理的方法
            self.deal_events()
            # 9 调用展示僵尸的方法
            self.load_zombies()
            # 9 计数器增长，每数到100，调用初始化僵尸的方法
            MainGame.count_zombie += 1
            if MainGame.count_zombie == MainGame.produce_zombie:
                self.init_zombies()
                MainGame.count_zombie = 0
            pygame.time.wait(10)
            pygame.display.update()

    def gameOver(self):
        MainGame.window.blit(
            self.draw_text(
                &#39;游戏结束&#39;, 50, (255, 0, 0)), (300, 200))
        print(&#39;游戏结束&#39;)
        pygame.time.wait(400)
        global GAMEOVER
        GAMEOVER = True


if __name__ == &#39;__main__&#39;:
    game = MainGame()
    game.start_game()
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>pygame</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pygame</tag>
        <tag>植物大战僵尸</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 模型存储的5种方法</title>
    <url>/2021/11/15/%E6%A8%A1%E5%9E%8B%E5%AD%98%E5%82%A8%E7%9A%845%E4%B8%AD%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="模型存储的5种方法"><a href="#模型存储的5种方法" class="headerlink" title="模型存储的5种方法"></a>模型存储的5种方法</h1><p><strong>方法1：csv/txt</strong><br>存储为csv、text或者json是最为简单的存储格式，阅读和解析起来非常方便。<br>如果使用Pandas则可以在存储的过程中设置压缩方法，对磁盘比较友好。</p>
<p><strong>·</strong> 场景：通用<br><strong>·</strong> 数据：表格、文本<br><strong>·</strong> 文件大小：压缩后较少<br><strong>·</strong> 读取速度：较慢</p>
<pre><code>compression_opts = dict(method=&#39;zip&#39;,
                        archive_name=&#39;out.csv&#39;)  
df.to_csv(&#39;out.zip&#39;, index=False,
          compression=compression_opts) 
</code></pre>
<p><strong>方法2：hdf</strong><br>HDF(Hierarchical Data File)是能满足各种领域研究需求而研制的一种能高效存储和分发科学数据的新型数据格式。<br>HDF格式支持分层存储，可以将多个变量同时存在一个HDF文件中，同时在读取速度上也比较快。</p>
<p><strong>·</strong> 场景：通用<br><strong>·</strong> 数据：表格、文本<br><strong>·</strong> 文件大小：较大<br><strong>·</strong> 读取速度：较快</p>
<pre><code>df = pd.DataFrame(&#123;&#39;A&#39;: [1, 2, 3], &#39;B&#39;: [4, 5, 6]&#125;,
                  index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])
df.to_hdf(&#39;data.h5&#39;, key=&#39;df&#39;, mode=&#39;w&#39;)
</code></pre>
<p><strong>方法3：npy</strong><br>如果将特征和数据处理为Numpy格式，则可以考虑存储为Numpy中的npy或npz格式。</p>
<p><strong>·</strong> 场景：文件存储<br><strong>·</strong> 数据：矩阵<br><strong>·</strong> 文件大小：适中<br><strong>·</strong> 读取速度：较快</p>
<ol>
<li>npy文件：二进制格式<br>np.load()和np.save()是读写磁盘数组数据的两个重要函数。使用时数组会以未压缩的原始二进制格式保存在扩展名为.npy的文件中。</li>
</ol>
<pre><code>import numpy as np
arr=np.arange(5)
np.save(&#39;test&#39;,arr)
print(np.load(&#39;test.npy&#39;))
</code></pre>
<p>2.npz文件：压缩文件<br>使用np.savez()函数可以将多个数组保存到同一个文件中。读取.npz文件时使用np.load()函数，返回的是一个类似于字典的对象，因此可以通过数组名作为关键字对多个数组进行访问。</p>
<pre><code>import numpy as np

a = np.arange(5)
b = np.arange(6)
c = np.arange(7)
np.savez(&#39;test&#39;, a, b, c_array=c)  # c_array是数组c的命名

data = np.load(&#39;test.npz&#39;)
print(&#39;arr_0 : &#39;, data[&#39;arr_0&#39;])
print(&#39;arr_1 : &#39;, data[&#39;arr_1&#39;])
print(&#39;c_array : &#39;, data[&#39;c_array&#39;])
</code></pre>
<p><strong>方法4：memmap</strong><br>NumPy实现了一个类似于ndarray的memmap对象，它允许将大文件分成小段进行读写，而不是一次性将整个数组读入内存。</p>
<p>如果需要存储的对象大于内存，则可以选择memmap进行存储。</p>
<p><strong>·</strong> 场景：大文件存储<br><strong>·</strong> 数据：矩阵<br><strong>·</strong> 文件大小：较大、特别大<br><strong>·</strong> 读取速度：适中</p>
<pre><code>newfp = np.memmap(filename, dtype=&#39;float32&#39;, mode=&#39;r&#39;, shape=(3,4))
fpc[0,:] = 0
</code></pre>
<p><strong>方法5：joblib</strong><br>类似于pkl存储，joblib.dump可以将任意的Python对象持久化到一个文件中，并使用joblib.load进行读取。</p>
<p><strong>·</strong> 场景：任意<br><strong>·</strong> 数据：任意<br><strong>·</strong> 文件大小：适中<br><strong>·</strong> 读取速度：适中</p>
<pre><code>from joblib import load, dump

X = [[0, 0], [1, 1]]
Y = [1, 0]

dump((X, Y), &quot;data.pkl&quot;)
X, Y = load(&quot;data.pkl&quot;)
</code></pre>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>模型存储</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>模型存储</tag>
      </tags>
  </entry>
  <entry>
    <title>win32com | 汇总excel表</title>
    <url>/2021/11/04/%E6%B1%87%E6%80%BBexcel%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="汇总excel表"><a href="#汇总excel表" class="headerlink" title="汇总excel表"></a>汇总excel表</h1><p>程序实现汇总多个excel表格并生成目录。</p>
<span id="more"></span>
<p>代码：</p>
<pre><code>import os  # 用于获取目标文件所在路径
import win32com
import win32com

path = os.getcwd() + &quot;\\文件\\&quot;  # 文件夹绝对路径
files = []
for file in os.listdir(path):
    if file.endswith(&quot;.xls&quot;) or file.endswith(&quot;.xlsx&quot;):  # 只获取&quot;.xls&quot;后缀的文件
        files.append(path + file)
# print(files)
excel_app = win32com.client.Dispatch(&quot;Excel.Application&quot;)
excel_app.Visible = False  # 不显示Excel文件
excel_app.DisplayAlerts = False

# 新建excel工作簿
wb = excel_app.Workbooks.Add()
wb.SaveAs(os.getcwd() + &quot;\\汇总.xlsx&quot;)
ws = wb.Worksheets(1)
ws.Name = &quot;目录&quot;
for i in range(len(files)):
    file_name = files[i].split(&quot;\\&quot;)[-1].split(&quot;.&quot;)[0]
    ws.Range(&quot;A&quot; + str(i + 1)).Value = file_name
    # 读取子文件
    wb_sub = excel_app.Workbooks.Open(files[i])
    ws_sub = wb_sub.ActiveSheet  # #获取活动工作表

    ws_sub.Copy(ws)  # 复制工作表到汇总表
    wb.ActiveSheet.Name = file_name  # 更改工作表名
    wb_sub.Close()
    print(f&quot;已复制文件 &#123;file_name&#125;&quot;)

# 将“目录”工作表移动到最前面
first_sheet = files[0].split(&quot;\\&quot;)[-1].split(&quot;.&quot;)[0]
wb.Worksheets(&quot;目录&quot;).Move(wb.Worksheets(first_sheet))

wb.Save()
wb.Close()
excel_app.Quit()
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>win32com</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>win32com</tag>
      </tags>
  </entry>
  <entry>
    <title>spring | 注入方式</title>
    <url>/2022/03/05/%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="依赖注入的两种方式"><a href="#依赖注入的两种方式" class="headerlink" title="依赖注入的两种方式"></a>依赖注入的两种方式</h1><ol>
<li>通过bean的setXxx()方法赋值</li>
<li>通过bean的构造器赋值<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2></li>
<li>项目目录<br><img src="/2022/03/05/%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/1.PNG"></li>
</ol>
<p>2.创建Student.java</p>
<pre><code>package com.atguigu.spring.di;

public class Student &#123;
    private Integer id;
    private String name;
    private Integer age;
    private String sex;
    private Double score;
    public Double getScore() &#123;
        return score;
    &#125;
    public void setScore(Double score) &#123;
        this.score = score;
    &#125;
    public Integer getId() &#123;
        return id;
    &#125;
    public void setId(Integer id) &#123;
        this.id = id;
    &#125;
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    public Integer getAge() &#123;
        return age;
    &#125;
    public void setAge(Integer age) &#123;
        this.age = age;
    &#125;
    public String getSex() &#123;
        return sex;
    &#125;
    public void setSex(String sex) &#123;
        this.sex = sex;
    &#125;
    
    @Override
    public String toString() &#123;
        return &quot;Student [id=&quot; + id + &quot;, name=&quot; + name + &quot;, age=&quot; + age + &quot;, sex=&quot; + sex + &quot;, score=&quot; + score + &quot;]&quot;;
    &#125;
    public Student() &#123;
        super();
        // TODO Auto-generated constructor stub
    &#125;
    public Student(Integer id, String name, Integer age, String sex) &#123;
        super();
        this.id = id;
        this.name = name;
        this.age = age;
        this.sex = sex;
    &#125;
    
    public Student(Integer id, String name, Double score, String sex)&#123;
        this.id = id;
        this.name = name;
        this.score = score;
        this.sex = sex;
    &#125;
&#125;
</code></pre>
<p>3.创建beans-di.xml配置文件</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;s1&quot; class=&quot;com.atguigu.spring.di.Student&quot;&gt;
        &lt;!-- 通过set方法注入 --&gt;
        &lt;property name=&quot;id&quot; value=&quot;10010&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;sex&quot; value=&quot;男&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
        
    &lt;bean id=&quot;s2&quot; class=&quot;com.atguigu.spring.di.Student&quot;&gt;
        &lt;!-- 通过构造方法注入 --&gt;
        &lt;constructor-arg value=&quot;10086&quot;&gt;&lt;/constructor-arg&gt;
        &lt;constructor-arg value=&quot;李四&quot;&gt;&lt;/constructor-arg&gt;
        &lt;constructor-arg value=&quot;24&quot;&gt;&lt;/constructor-arg&gt;
        &lt;constructor-arg value=&quot;女&quot;&gt;&lt;/constructor-arg&gt;
    &lt;/bean&gt;
    
    &lt;bean id=&quot;s3&quot; class=&quot;com.atguigu.spring.di.Student&quot;&gt;
        &lt;!-- 通过构造方法注入 --&gt;
        &lt;constructor-arg value=&quot;10022&quot;&gt;&lt;/constructor-arg&gt;
        &lt;constructor-arg value=&quot;王五&quot;&gt;&lt;/constructor-arg&gt;
        &lt;constructor-arg value=&quot;90&quot; index=&quot;2&quot; type=&quot;java.lang.Double&quot;&gt;&lt;/constructor-arg&gt;
        &lt;constructor-arg value=&quot;女&quot;&gt;&lt;/constructor-arg&gt;
    &lt;/bean&gt;

    &lt;!-- Namespaces勾选p（beans标签会增加内容xmlns:p=&quot;http://www.springframework.org/schema/p&quot;） --&gt;
    &lt;bean id=&quot;s4&quot; class=&quot;com.atguigu.spring.di.Student&quot; p:id=&quot;10033&quot; p:name=&quot;赵六&quot; p:age=&quot;26&quot; p:sex=&quot;男&quot;&gt;&lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>4.编写测试类</p>
<pre><code>package com.atguigu.spring.di;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test &#123;

    public static void main(String[] args) &#123;
        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans-di.xml&quot;);
        
        Student s1 = ac.getBean(&quot;s1&quot;, Student.class);
        Student s2 = ac.getBean(&quot;s2&quot;, Student.class);
        Student s3 = ac.getBean(&quot;s3&quot;, Student.class);
        Student s4 = ac.getBean(&quot;s4&quot;, Student.class);
        System.out.println(s1);
        System.out.println(s2);
        System.out.println(s3);
        System.out.println(s4);
    &#125;

&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>spring</category>
        <category>依赖注入</category>
        <category>依赖注入的两种方式</category>
      </categories>
      <tags>
        <tag>p命名空间</tag>
        <tag>依赖注入的两种方式</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb项目开发 | 注册功能实现</title>
    <url>/2022/01/11/%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="注册功能实现"><a href="#注册功能实现" class="headerlink" title="注册功能实现"></a>注册功能实现</h1><ol>
<li>实现原理<br>当用户输入完注册信息，点击提交，浏览器向服务器发出请求，然后由服务器中的servlet来处理请求，将前台用户输入的信息保存到数据库当中。<br><img src="/2022/01/11/%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/1.PNG"></li>
<li>安装MySQL并创建需要的数据库和表(假设创建的数据库为test3，创建表user)，表结构如下图所示。<br><img src="/2022/01/11/%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/2.PNG"></li>
<li>在eclipse中导入数据库配置文件<br><img src="/2022/01/11/%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/3.PNG"></li>
<li>导入注册所需的jar包<br><img src="/2022/01/11/%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/4.PNG"></li>
<li>导入DataSourceUtils.java<br><img src="/2022/01/11/%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/6.PNG"><span id="more"></span></li>
<li>准备注册页面</li>
</ol>
<p><strong>页面效果：</strong><br><img src="/2022/01/11/%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/5.PNG"></p>
<p><strong>代码：</strong></p>
<pre><code>&lt;!doctype html&gt;
&lt;html&gt;
    &lt;head&gt;&lt;/head&gt;
        &lt;meta charset=&quot;utf-8&quot; /&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;
        &lt;title&gt;会员登录&lt;/title&gt;
        &lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap.min.css&quot; type=&quot;text/css&quot; /&gt;
        &lt;script src=&quot;js/jquery-1.11.3.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
        &lt;script src=&quot;js/bootstrap.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;!-- 引入自定义css文件 style.css --&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot; type=&quot;text/css&quot;/&gt;

&lt;style&gt;
  body&#123;
   margin-top:20px;
   margin:0 auto;
 &#125;
 .carousel-inner .item img&#123;
     width:100%;
     height:300px;
 &#125;
 .container .row div&#123; 
     /* position:relative;
     float:left; */
 &#125;
 
font &#123;
    color: #3164af;
    font-size: 18px;
    font-weight: normal;
    padding: 0 10px;
&#125;
 &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

            &lt;!--
                时间：2015-12-30
                描述：菜单栏
            --&gt;
            &lt;div class=&quot;container-fluid&quot;&gt;
                &lt;div class=&quot;col-md-4&quot;&gt;
                    &lt;img src=&quot;img/logo2.png&quot; height=&quot;50px&quot;/&gt;
                &lt;/div&gt;
                &lt;div class=&quot;col-md-5&quot;&gt;
                    &lt;img src=&quot;img/header.png&quot; /&gt;
                &lt;/div&gt;
                &lt;div class=&quot;col-md-3&quot; style=&quot;padding-top:20px&quot;&gt;
                    &lt;ol class=&quot;list-inline&quot;&gt;
                        &lt;li&gt;&lt;a href=&quot;login.htm&quot;&gt;登录&lt;/a&gt;&lt;/li&gt;
                        &lt;li&gt;&lt;a href=&quot;register.htm&quot;&gt;注册&lt;/a&gt;&lt;/li&gt;
                        &lt;li&gt;&lt;a href=&quot;cart.htm&quot;&gt;购物车&lt;/a&gt;&lt;/li&gt;
                    &lt;/ol&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;!--
                时间：2015-12-30
                描述：导航条
            --&gt;
            &lt;div class=&quot;container-fluid&quot;&gt;
                &lt;nav class=&quot;navbar navbar-inverse&quot;&gt;
                    &lt;div class=&quot;container-fluid&quot;&gt;
                        &lt;!-- Brand and toggle get grouped for better mobile display --&gt;
                        &lt;div class=&quot;navbar-header&quot;&gt;
                            &lt;button type=&quot;button&quot; class=&quot;navbar-toggle collapsed&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#bs-example-navbar-collapse-1&quot; aria-expanded=&quot;false&quot;&gt;
                                &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt;
                                &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;
                                &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;
                                &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;
                            &lt;/button&gt;
                            &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;首页&lt;/a&gt;
                        &lt;/div&gt;

                        &lt;!-- Collect the nav links, forms, and other content for toggling --&gt;
                        &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;bs-example-navbar-collapse-1&quot;&gt;
                            &lt;ul class=&quot;nav navbar-nav&quot;&gt;
                                &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;手机数码&lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
                                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;电脑办公&lt;/a&gt;&lt;/li&gt;
                                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;电脑办公&lt;/a&gt;&lt;/li&gt;
                                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;电脑办公&lt;/a&gt;&lt;/li&gt;
                            &lt;/ul&gt;
                            &lt;form class=&quot;navbar-form navbar-right&quot; role=&quot;search&quot;&gt;
                                &lt;div class=&quot;form-group&quot;&gt;
                                    &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Search&quot;&gt;
                                &lt;/div&gt;
                                &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Submit&lt;/button&gt;
                            &lt;/form&gt;

                        &lt;/div&gt;
                        &lt;!-- /.navbar-collapse --&gt;
                    &lt;/div&gt;
                    &lt;!-- /.container-fluid --&gt;
                &lt;/nav&gt;
            &lt;/div&gt;





&lt;div class=&quot;container&quot; style=&quot;width:100%;background:url(&#39;image/regist_bg.jpg&#39;);&quot;&gt;
&lt;div class=&quot;row&quot;&gt; 

    &lt;div class=&quot;col-md-2&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;col-md-8&quot; style=&quot;background:#fff;padding:40px 80px;margin:30px;border:7px solid #ccc;&quot;&gt;
        &lt;font&gt;会员注册&lt;/font&gt;USER REGISTER
        &lt;form class=&quot;form-horizontal&quot; style=&quot;margin-top:5px;&quot; action=&quot;/register/user&quot;&gt;
             &lt;div class=&quot;form-group&quot;&gt;
                &lt;label for=&quot;username&quot; class=&quot;col-sm-2 control-label&quot;&gt;用户名&lt;/label&gt;
                &lt;div class=&quot;col-sm-6&quot;&gt;
                  &lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;username&quot; id=&quot;username&quot; placeholder=&quot;请输入用户名&quot;&gt;
                &lt;/div&gt;
              &lt;/div&gt;
               &lt;div class=&quot;form-group&quot;&gt;
                &lt;label for=&quot;inputPassword3&quot; class=&quot;col-sm-2 control-label&quot;&gt;密码&lt;/label&gt;
                &lt;div class=&quot;col-sm-6&quot;&gt;
                  &lt;input type=&quot;password&quot; class=&quot;form-control&quot; name=&quot;password&quot; id=&quot;inputPassword3&quot; placeholder=&quot;请输入密码&quot;&gt;
                &lt;/div&gt;
              &lt;/div&gt;
               &lt;div class=&quot;form-group&quot;&gt;
                &lt;label for=&quot;confirmpwd&quot; class=&quot;col-sm-2 control-label&quot;&gt;确认密码&lt;/label&gt;
                &lt;div class=&quot;col-sm-6&quot;&gt;
                  &lt;input type=&quot;password&quot; class=&quot;form-control&quot; id=&quot;confirmpwd&quot; placeholder=&quot;请输入确认密码&quot;&gt;
                &lt;/div&gt;
              &lt;/div&gt;
              &lt;div class=&quot;form-group&quot;&gt;
                &lt;label for=&quot;inputEmail3&quot; class=&quot;col-sm-2 control-label&quot;&gt;Email&lt;/label&gt;
                &lt;div class=&quot;col-sm-6&quot;&gt;
                  &lt;input type=&quot;email&quot; class=&quot;form-control&quot; name=&quot;email&quot; id=&quot;inputEmail3&quot; placeholder=&quot;Email&quot;&gt;
                &lt;/div&gt;
              &lt;/div&gt;
             &lt;div class=&quot;form-group&quot;&gt;
                &lt;label for=&quot;usercaption&quot; class=&quot;col-sm-2 control-label&quot;&gt;姓名&lt;/label&gt;
                &lt;div class=&quot;col-sm-6&quot;&gt;
                  &lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;name&quot; id=&quot;usercaption&quot; placeholder=&quot;请输入姓名&quot;&gt;
                &lt;/div&gt;
              &lt;/div&gt;
              &lt;div class=&quot;form-group opt&quot;&gt;  
              &lt;label for=&quot;inlineRadio1&quot; class=&quot;col-sm-2 control-label&quot;&gt;性别&lt;/label&gt;  
              &lt;div class=&quot;col-sm-6&quot;&gt;
                &lt;label class=&quot;radio-inline&quot;&gt;
              &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;inlineRadio1&quot; value=&quot;1&quot;&gt; 男
            &lt;/label&gt;
            &lt;label class=&quot;radio-inline&quot;&gt;
              &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;inlineRadio2&quot; value=&quot;0&quot;&gt; 女
            &lt;/label&gt;
            &lt;/div&gt;
              &lt;/div&gt;        
              &lt;div class=&quot;form-group&quot;&gt;
                &lt;label for=&quot;date&quot; class=&quot;col-sm-2 control-label&quot;&gt;出生日期&lt;/label&gt;
                &lt;div class=&quot;col-sm-6&quot;&gt;
                  &lt;input type=&quot;date&quot; name=&quot;birthday&quot; class=&quot;form-control&quot;  &gt;              
                &lt;/div&gt;
              &lt;/div&gt;
              
              &lt;div class=&quot;form-group&quot;&gt;
                &lt;label for=&quot;date&quot; class=&quot;col-sm-2 control-label&quot;&gt;验证码&lt;/label&gt;
                &lt;div class=&quot;col-sm-3&quot;&gt;
                  &lt;input type=&quot;text&quot; class=&quot;form-control&quot;  &gt;
                  
                &lt;/div&gt;
                &lt;div class=&quot;col-sm-2&quot;&gt;
                &lt;img src=&quot;./image/captcha.jhtml&quot;/&gt;
                &lt;/div&gt;
                
              &lt;/div&gt;
             
              &lt;div class=&quot;form-group&quot;&gt;
                &lt;div class=&quot;col-sm-offset-2 col-sm-10&quot;&gt;
                  &lt;input type=&quot;submit&quot;  width=&quot;100&quot; value=&quot;注册&quot; name=&quot;submit&quot; border=&quot;0&quot;
                    style=&quot;background: url(&#39;./images/register.gif&#39;) no-repeat scroll 0 0 rgba(0, 0, 0, 0);
                    height:35px;width:100px;color:white;&quot;&gt;
                &lt;/div&gt;
              &lt;/div&gt;
            &lt;/form&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;col-md-2&quot;&gt;&lt;/div&gt;
  
&lt;/div&gt;
&lt;/div&gt;
    &lt;div style=&quot;margin-top:50px;&quot;&gt;
            &lt;img src=&quot;./image/footer.jpg&quot; width=&quot;100%&quot; height=&quot;78&quot; alt=&quot;我们的优势&quot; title=&quot;我们的优势&quot; /&gt;
        &lt;/div&gt;

        &lt;div style=&quot;text-align: center;margin-top: 5px;&quot;&gt;
            &lt;ul class=&quot;list-inline&quot;&gt;
                &lt;li&gt;&lt;a&gt;关于我们&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a&gt;联系我们&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a&gt;招贤纳士&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a&gt;法律声明&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a&gt;友情链接&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a target=&quot;_blank&quot;&gt;支付方式&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a target=&quot;_blank&quot;&gt;配送方式&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a&gt;服务声明&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a&gt;广告声明&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
        &lt;div style=&quot;text-align: center;margin-top: 5px;margin-bottom:20px;&quot;&gt;
            Copyright &amp;copy; 2005-2016 oracle商城 版权所有
        &lt;/div&gt;

&lt;/body&gt;&lt;/html&gt;
</code></pre>
<ol start="7">
<li>创建UserServlet</li>
</ol>
<pre><code>package com.oracle.servlet;

import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.util.Map;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.beanutils.BeanUtils;
import org.apache.commons.dbutils.QueryRunner;

import com.oracle.bean.User;
import com.oracle.utils.DataSourceUtils;

public class UserServlet extends HttpServlet &#123;
    private static final long serialVersionUID = 1L;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        try &#123;
            //接收请求数据
            Map&lt;String, String[]&gt; map = request.getParameterMap();
            //创建user
            User user = new User();
            //把map中的数据映射到user中
            BeanUtils.populate(user, map);
            System.out.println(user.getBirthday());
            //把当前user中的数据插入到数据库中
            //创建QueryRunner对象 
            QueryRunner qr = new QueryRunner(DataSourceUtils.getDataSource());
            //编写sql
            String sql = &quot;insert into user(id,username,password,email,name,sex,birthday)values(?,?,?,?,?,?,?)&quot;;
            //执行sql
            System.out.println(user.getUsername());
            qr.update(sql, user.getId(), user.getUsername(), user.getPassword(), user.getEmail(), user.getName(), user.getSex(), user.getBirthday());
            System.out.println(&quot;haahahahha&quot;);
            
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; 
    &#125;

    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        // TODO Auto-generated method stub
        doGet(request, response);
    &#125;
&#125;
</code></pre>
<ol start="8">
<li>创建数据库user表对应的JavaBean(user bean)</li>
</ol>
<pre><code>package com.oracle.bean;

public class User &#123;
    private int id;
    private String username;
    private String password;
    private String email;
    private String name;
    private String sex;
    private String birthday;
    
    public int getId() &#123;
        return id;
    &#125;
    public void setId(int id) &#123;
        this.id = id;
    &#125;
    public String getUsername() &#123;
        return username;
    &#125;
    public void setUsername(String username) &#123;
        this.username = username;
    &#125;
    public String getPassword() &#123;
        return password;
    &#125;
    public void setPassword(String password) &#123;
        this.password = password;
    &#125;
    public String getEmail() &#123;
        return email;
    &#125;
    public void setEmail(String email) &#123;
        this.email = email;
    &#125;
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    public String getSex() &#123;
        return sex;
    &#125;
    public void setSex(String sex) &#123;
        this.sex = sex;
    &#125;
    public String getBirthday() &#123;
        return birthday;
    &#125;
    public void setBirthday(String birthday) &#123;
        this.birthday = birthday;
    &#125;
    public User(int id, String username, String password, String email, String name, String sex, String birthday) &#123;
        super();
        this.id = id;
        this.username = username;
        this.password = password;
        this.email = email;
        this.name = name;
        this.sex = sex;
        this.birthday = birthday;
    &#125;
    public User() &#123;
        super();
        // TODO Auto-generated constructor stub
    &#125;
&#125;
</code></pre>
<ol start="9">
<li>访问页面输入用户信息进行登录</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb项目开发</category>
        <category>注册功能实现</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>注册</tag>
      </tags>
  </entry>
  <entry>
    <title>基于JavaWeb的网上购物商城 | 注册和登录</title>
    <url>/2022/01/13/%E6%B3%A8%E5%86%8C%E5%92%8C%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<h1 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h1><p>以下代码实现网上购物商城的用户注册和登录功能。</p>
<span id="more"></span>
<p><strong>register.jsp(在WebContent目录下创建)</strong></p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;
&lt;title&gt;会员注册&lt;/title&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap.min.css&quot; type=&quot;text/css&quot; /&gt;
&lt;script src=&quot;js/jquery-1.11.3.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;js/bootstrap.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;!-- 引入自定义css文件 style.css --&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot; type=&quot;text/css&quot; /&gt;

&lt;style&gt;
body &#123;
    margin-top: 20px;
    margin: 0 auto;
&#125;

.carousel-inner .item img &#123;
    width: 100%;
    height: 300px;
&#125;

font &#123;
    color: #3164af;
    font-size: 18px;
    font-weight: normal;
    padding: 0 10px;
&#125;
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

    &lt;!-- 引入header.jsp --&gt;
    &lt;jsp:include page=&quot;/header.jsp&quot;&gt;&lt;/jsp:include&gt;

    &lt;div class=&quot;container&quot;
        style=&quot;width: 100%; background: url(&#39;image/regist_bg.jpg&#39;);&quot;&gt;
        &lt;div class=&quot;row&quot;&gt;
            &lt;div class=&quot;col-md-2&quot;&gt;&lt;/div&gt;
            &lt;div class=&quot;col-md-8&quot;
                style=&quot;background: #fff; padding: 40px 80px; margin: 30px; border: 7px solid #ccc;&quot;&gt;
                &lt;font&gt;会员注册&lt;/font&gt;USER REGISTER
                &lt;form class=&quot;form-horizontal&quot; style=&quot;margin-top: 5px;&quot; method=&quot;post&quot; action=&quot;/shop2/user&quot;&gt;
                    &lt;input type=&quot;hidden&quot; name=&quot;method&quot; value=&quot;register&quot;&gt;
                    &lt;div class=&quot;form-group&quot;&gt;
                        &lt;label for=&quot;username&quot; class=&quot;col-sm-2 control-label&quot;&gt;用户名&lt;/label&gt;
                        &lt;div class=&quot;col-sm-6&quot;&gt;
                            &lt;input type=&quot;text&quot; name=&quot;username&quot; class=&quot;form-control&quot; id=&quot;username&quot;
                                placeholder=&quot;请输入用户名&quot;&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;form-group&quot;&gt;
                        &lt;label for=&quot;inputPassword3&quot; class=&quot;col-sm-2 control-label&quot;&gt;密码&lt;/label&gt;
                        &lt;div class=&quot;col-sm-6&quot;&gt;
                            &lt;input type=&quot;password&quot; name=&quot;password&quot; class=&quot;form-control&quot; id=&quot;inputPassword3&quot;
                                placeholder=&quot;请输入密码&quot;&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;form-group&quot;&gt;
                        &lt;label for=&quot;confirmpwd&quot; class=&quot;col-sm-2 control-label&quot;&gt;确认密码&lt;/label&gt;
                        &lt;div class=&quot;col-sm-6&quot;&gt;
                            &lt;input type=&quot;password&quot; class=&quot;form-control&quot; id=&quot;confirmpwd&quot;
                                placeholder=&quot;请输入确认密码&quot;&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;form-group&quot;&gt;
                        &lt;label for=&quot;inputEmail3&quot; class=&quot;col-sm-2 control-label&quot;&gt;Email&lt;/label&gt;
                        &lt;div class=&quot;col-sm-6&quot;&gt;
                            &lt;input type=&quot;email&quot; name=&quot;emial&quot; class=&quot;form-control&quot; id=&quot;inputEmail3&quot;
                                placeholder=&quot;Email&quot;&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;form-group&quot;&gt;
                        &lt;label for=&quot;usercaption&quot; class=&quot;col-sm-2 control-label&quot;&gt;姓名&lt;/label&gt;
                        &lt;div class=&quot;col-sm-6&quot;&gt;
                            &lt;input type=&quot;text&quot; name=&quot;name&quot; class=&quot;form-control&quot; id=&quot;usercaption&quot;
                                placeholder=&quot;请输入姓名&quot;&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;form-group opt&quot;&gt;
                        &lt;label for=&quot;inlineRadio1&quot; class=&quot;col-sm-2 control-label&quot;&gt;性别&lt;/label&gt;
                        &lt;div class=&quot;col-sm-6&quot;&gt;
                            &lt;label class=&quot;radio-inline&quot;&gt; &lt;input type=&quot;radio&quot;
                                name=&quot;sex&quot; id=&quot;inlineRadio1&quot; value=&quot;1&quot;&gt;
                                男
                            &lt;/label&gt; &lt;label class=&quot;radio-inline&quot;&gt; &lt;input type=&quot;radio&quot;
                                name=&quot;sex&quot; id=&quot;inlineRadio2&quot; value=&quot;0&quot;&gt;
                                女
                            &lt;/label&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;form-group&quot;&gt;
                        &lt;label for=&quot;date&quot; class=&quot;col-sm-2 control-label&quot;&gt;出生日期&lt;/label&gt;
                        &lt;div class=&quot;col-sm-6&quot;&gt;
                            &lt;input type=&quot;date&quot; name=&quot;birthday&quot; class=&quot;form-control&quot;&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;

                    &lt;div class=&quot;form-group&quot;&gt;
                        &lt;label for=&quot;date&quot; class=&quot;col-sm-2 control-label&quot;&gt;验证码&lt;/label&gt;
                        &lt;div class=&quot;col-sm-3&quot;&gt;
                            &lt;input type=&quot;text&quot; class=&quot;form-control&quot;&gt;

                        &lt;/div&gt;
                        &lt;div class=&quot;col-sm-2&quot;&gt;
                            &lt;img src=&quot;./image/captcha.jhtml&quot; /&gt;
                        &lt;/div&gt;

                    &lt;/div&gt;

                    &lt;div class=&quot;form-group&quot;&gt;
                        &lt;div class=&quot;col-sm-offset-2 col-sm-10&quot;&gt;
                            &lt;input type=&quot;submit&quot; width=&quot;100&quot; value=&quot;注册&quot; name=&quot;submit&quot;
                                style=&quot;background: url(&#39;./images/register.gif&#39;) no-repeat scroll 0 0 rgba(0, 0, 0, 0); height: 35px; width: 100px; color: white;&quot;&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                &lt;/form&gt;
            &lt;/div&gt;

            &lt;div class=&quot;col-md-2&quot;&gt;&lt;/div&gt;

        &lt;/div&gt;
    &lt;/div&gt;

    &lt;!-- 引入footer.jsp --&gt;
    &lt;jsp:include page=&quot;/footer.jsp&quot;&gt;&lt;/jsp:include&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>login.jsp(在WebContent目录下创建)</strong></p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;

    &lt;head&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;
        &lt;title&gt;oracle商城信息展示&lt;/title&gt;
        &lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap.min.css&quot; type=&quot;text/css&quot; /&gt;
        &lt;script src=&quot;js/jquery-1.11.3.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
        &lt;script src=&quot;js/bootstrap.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;div class=&quot;container-fluid&quot;&gt;

            &lt;!-- 引入header.jsp --&gt;
            &lt;jsp:include page=&quot;/header.jsp&quot;&gt;&lt;/jsp:include&gt;

            &lt;div class=&quot;container-fluid&quot;&gt;
                &lt;div class=&quot;main_con&quot;&gt;
                    &lt;h2&gt;公司简介&lt;/h2&gt;
                    &lt;hr/&gt;
                    &lt;div&gt;
                        &lt;p&gt;中公教育集团创建于1999年，经过十余年潜心发展.&lt;/p&gt;
                        &lt;p&gt;中公教育已由一家北大毕业生自主创业的信息技术与教育服务机构.&lt;/p&gt;
                        &lt;p&gt;发展为教育服务业的综合性企业集团，&lt;/p&gt;
                        &lt;p&gt;成为集合面授教学培训、网校远程教育、图书教材及音像制品的出版发行于一体的大型知识产业实体.&lt;/p&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;!-- 引入footer.jsp --&gt;
        &lt;jsp:include page=&quot;/footer.jsp&quot;&gt;&lt;/jsp:include&gt;

    &lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p><strong>User.java(JavaBean 在src/com.oracle.bean目录下创建)</strong></p>
<pre><code>package com.oracle.bean;

public class User &#123;
    private String uid;
    private String username;
    private String password;
    private String name;
    private String email;
    private String telephone;
    private String birthday;
    private String sex;
    private int state;
    public String getUid() &#123;
        return uid;
    &#125;
    public void setUid(String uid) &#123;
        this.uid = uid;
    &#125;
    public String getUsername() &#123;
        return username;
    &#125;
    public void setUsername(String username) &#123;
        this.username = username;
    &#125;
    public String getPassword() &#123;
        return password;
    &#125;
    public void setPassword(String password) &#123;
        this.password = password;
    &#125;
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    public String getEmail() &#123;
        return email;
    &#125;
    public void setEmail(String email) &#123;
        this.email = email;
    &#125;
    public String getTelephone() &#123;
        return telephone;
    &#125;
    public void setTelephone(String telephone) &#123;
        this.telephone = telephone;
    &#125;
    public String getBirthday() &#123;
        return birthday;
    &#125;
    public void setBirthday(String birthday) &#123;
        this.birthday = birthday;
    &#125;
    public String getSex() &#123;
        return sex;
    &#125;
    public void setSex(String sex) &#123;
        this.sex = sex;
    &#125;
    public int getState() &#123;
        return state;
    &#125;
    public void setState(int state) &#123;
        this.state = state;
    &#125;
    public User(String uid, String username, String password, String name, String email, String telephone,
            String birthday, String sex, int state) &#123;
        super();
        this.uid = uid;
        this.username = username;
        this.password = password;
        this.name = name;
        this.email = email;
        this.telephone = telephone;
        this.birthday = birthday;
        this.sex = sex;
        this.state = state;
    &#125;
    public User() &#123;
        super();
        // TODO Auto-generated constructor stub
    &#125;
    
&#125;
</code></pre>
<p><strong>UserServlet.java(在src/com.oracle.servlet目录下创建)</strong></p>
<pre><code>package com.oracle.servlet;

import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.sql.SQLException;
import java.util.Map;
import java.util.UUID;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.beanutils.BeanUtils;

import com.oracle.bean.User;
import com.oracle.service.UserService;

public class UserServlet extends HttpServlet &#123;
    private static final long serialVersionUID = 1L;

    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        String method = request.getParameter(&quot;method&quot;);
        if(&quot;register&quot;.equals(method)) &#123;
            register(request, response);
        &#125;else if(&quot;login&quot;.equals(method)) &#123;
            login(request, response);
        &#125;
    &#125;

    public void login(HttpServletRequest request, HttpServletResponse response) &#123;
        // TODO Auto-generated method stub
        try &#123;
            String username = request.getParameter(&quot;username&quot;);
            String password = request.getParameter(&quot;password&quot;);
            
            UserService us = new UserService();
            User user = us.login(username, password);
            
            if(user!=null) &#123;
                //request.getRequestDispatcher(&quot;/index.jsp&quot;).forward(request, response);
            
                response.sendRedirect(&quot;/shop/index.jsp&quot;);
            &#125;else &#123;
                request.setAttribute(&quot;msg&quot;, &quot;用户名或密码错误&quot;);
                request.getRequestDispatcher(&quot;/login.jsp&quot;).forward(request, response);
            &#125;
        &#125; catch (Exception e) &#123;
            // TODO Auto-generated catch block
            try &#123;
                request.getRequestDispatcher(&quot;/error.jsp&quot;).forward(request, response);
            &#125; catch (Exception e1) &#123;
                // TODO Auto-generated catch block
                e1.printStackTrace();
            &#125; 
        &#125;
    &#125;

    public void register(HttpServletRequest request, HttpServletResponse response) &#123;
        // TODO Auto-generated method stub
        try &#123;
            Map&lt;String, String[]&gt; map = request.getParameterMap();
            
            User user = new User();
            BeanUtils.populate(user, map);
            
            UUID uid = UUID.randomUUID();
            user.setUid(uid.toString());
            user.setState(0);
            
            UserService us = new UserService();
            us.register(user);
            
            request.getRequestDispatcher(&quot;/login.jsp&quot;).forward(request, response);
        &#125; catch (Exception e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125;
    &#125;

    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        doGet(request, response);
    &#125;
&#125;
</code></pre>
<p><strong>UserService.java(在src/com.oracle.service目录下创建)</strong></p>
<pre><code>package com.oracle.service;

import java.sql.SQLException;

import com.oracle.bean.User;
import com.oracle.dao.UserDao;

public class UserService &#123;

    public void register(User user) throws SQLException &#123;
        // TODO Auto-generated method stub
        UserDao ud = new UserDao();
        ud.register(user);
    &#125;

    public User login(String username, String password) throws SQLException &#123;
        // TODO Auto-generated method stub
        UserDao ud = new UserDao();
        User user = ud.login(username, password);
        return user;
    &#125;

&#125;
</code></pre>
<p><strong>UserDao.java(在src/com.oracle.dao目录下创建)</strong></p>
<pre><code>package com.oracle.dao;

import java.sql.SQLException;

import org.apache.commons.dbutils.QueryRunner;
import org.apache.commons.dbutils.handlers.BeanHandler;

import com.oracle.bean.User;
import com.oracle.utils.DataSourceUtils;

public class UserDao &#123;

    public void register(User user) throws SQLException &#123;
        // TODO Auto-generated method stub
        QueryRunner qr = new QueryRunner(DataSourceUtils.getDataSource());
        
        //编写sql 
        String sql = &quot;insert into user values(?,?,?,?,?,?,?,?,?)&quot;;
        
        //执行sql
        qr.update(sql, user.getUid(), user.getUsername(), user.getPassword(), user.getName(), user.getEmail(), user.getTelephone(), user.getBirthday(), user.getSex(), user.getState());
    &#125;

    public User login(String username, String password) throws SQLException &#123;
        // TODO Auto-generated method stub
        QueryRunner qr = new QueryRunner(DataSourceUtils.getDataSource());
        
        //编写sql 
        String sql = &quot;select * from user where username=? and password=? and state=?&quot;;
        
        //执行sql
        User user = qr.query(sql, new BeanHandler&lt;&gt;(User.class), username, password, 0);
        return user;
    &#125;

&#125;
</code></pre>
]]></content>
      <categories>
        <category>项目经历</category>
        <category>JavaWeb</category>
        <category>基于JavaWeb的网上购物商城</category>
        <category>注册和登录</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
        <tag>基于JavaWeb的网上购物商城</tag>
      </tags>
  </entry>
  <entry>
    <title>励志 | 活法</title>
    <url>/2021/07/22/%E6%B4%BB%E6%B3%95/</url>
    <content><![CDATA[<h1 id="活法"><a href="#活法" class="headerlink" title="活法"></a>活法</h1><p>读了稻盛和夫的活法，书中的每一字每一句都可以作为人生哲学和信条，下面记录了自己应该首先去学习、去执行的一些人生哲学：</p>
<span id="more"></span>

<h2 id="只有主动追求的东西才可能到手"><a href="#只有主动追求的东西才可能到手" class="headerlink" title="只有主动追求的东西才可能到手"></a>只有主动追求的东西才可能到手</h2><p>“心不唤物，物不至”，只有自己内心渴望的事情，才能将它呼唤到可能事先的射程之内。</p>
<h2 id="只要思考达到每个细节，目标就一定能实现"><a href="#只要思考达到每个细节，目标就一定能实现" class="headerlink" title="只要思考达到每个细节，目标就一定能实现"></a>只要思考达到每个细节，目标就一定能实现</h2><p>在我们的人生中，想要做成某件事，我们首先要描画它的理想状态，然后把实现它的过程在头脑中模拟演练，<br>一直到“看见”它的结果为止。你事先能“看见”的东西就能做成，“看不见”的东西就做不成。</p>
<h2 id="心态决定命运"><a href="#心态决定命运" class="headerlink" title="心态决定命运"></a>心态决定命运</h2><p>人的命运绝不是天定的，它不是在事先铺设好的轨道上运行的，根据我们的意志，命运既可以变好，也可以变坏。</p>
<h2 id="原理原则"><a href="#原理原则" class="headerlink" title="原理原则"></a>原理原则</h2><p>作为人，何为正确？</p>
<h2 id="人生方程式"><a href="#人生方程式" class="headerlink" title="人生方程式"></a>人生方程式</h2><p>人生·工作的结果 = 思维方式 x 热情 x 能力</p>
<h2 id="自己的人生之戏如何编演"><a href="#自己的人生之戏如何编演" class="headerlink" title="自己的人生之戏如何编演"></a>自己的人生之戏如何编演</h2><p>人生是一出戏，我们每个人都是戏里的主角。不仅如此，而且这戏剧的导演、编剧、主演都可由自己单肩独挑。其实这出戏也<br>只能自编自演，这就是我们的人生。</p>
<h2 id="不在现场流汗什么也学不到"><a href="#不在现场流汗什么也学不到" class="headerlink" title="不在现场流汗什么也学不到"></a>不在现场流汗什么也学不到</h2><p>体验重于知识，“知”未必等于“会”。进入信息社会，进入偏重知识的时代，认为“只要知道自然就会了”的人越来越多了。这种<br>看法大错特错。“会”和“知”中间有一条鸿沟，只有靠现场的经验才能填补。</p>
<h2 id="成为自我燃烧型的人"><a href="#成为自我燃烧型的人" class="headerlink" title="成为自我燃烧型的人"></a>成为自我燃烧型的人</h2><p>要成为自燃型的人，最好最有效的办法是“喜欢自己的工作”，能做成事情的人，他们不仅自我燃烧而且其能量还可与周围人分享。</p>
<h2 id="我正在干一件了不起的工作"><a href="#我正在干一件了不起的工作" class="headerlink" title="我正在干一件了不起的工作"></a>我正在干一件了不起的工作</h2><p>在你讨厌工作，觉得难以忍受时，你还是要多加忍耐，要决心朝前走，要发奋努力，这将改变你的人生。</p>
<h2 id="喜欢与投入"><a href="#喜欢与投入" class="headerlink" title="喜欢与投入"></a>喜欢与投入</h2><p>“喜欢”和“投入”是硬币的正反两面，两者之间是因果循环的关系：因为喜欢就会投入工作；在投入工作的过程中就会产生喜欢。</p>
<h2 id="看似复杂的现象，其实不过是简单事物的投影而已"><a href="#看似复杂的现象，其实不过是简单事物的投影而已" class="headerlink" title="看似复杂的现象，其实不过是简单事物的投影而已"></a>看似复杂的现象，其实不过是简单事物的投影而已</h2><h2 id="生存的意义和目的"><a href="#生存的意义和目的" class="headerlink" title="生存的意义和目的"></a>生存的意义和目的</h2><p>相对于浩瀚宇宙的历史长河，我们的人生不过是一闪而过。但正因为如此，在我们稍纵即逝的人生中，我们的灵魂在终结时的价值<br>必须高于降生时的价值，这才是我们生存的意义和目的。</p>
<h2 id="“六项精进”-磨炼心志的指针"><a href="#“六项精进”-磨炼心志的指针" class="headerlink" title="“六项精进”-磨炼心志的指针"></a>“六项精进”-磨炼心志的指针</h2><p>1.付出不亚于任何人的努力<br>2.谦虚戒骄<br>3.天天反省<br>4.活着就要感谢<br>5.积善行、思利他<br>6.不要有感性的烦恼</p>
<h2 id="率直之心"><a href="#率直之心" class="headerlink" title="率直之心"></a>率直之心</h2><p>所谓率直之心并不是别人要你向右转你就向右转，并不是盲目顺从，而是抱着谦虚的态度，如实承认自己的弱点和不足，然后不惜一切<br>努力奋斗。具备一对虚心聆听他人意见的大耳朵，具备一双真诚审视自己的大眼睛，耳聪目明，充分发挥耳朵、眼睛的作用。</p>
<p>把发自内心的喜悦之情、感恩之心直率地表达出来，可以成为一种动力，激励我们持续这种枯燥的研究和单调的工作。不管什么小事，<br>只要开心，只要赶集，就要率直地表达出来，不绕圈子，不装深沉。</p>
<h2 id="在做出结论之前，先设置一个“理性的缓冲器”"><a href="#在做出结论之前，先设置一个“理性的缓冲器”" class="headerlink" title="在做出结论之前，先设置一个“理性的缓冲器”"></a>在做出结论之前，先设置一个“理性的缓冲器”</h2><h2 id="喜悦从苦劳与艰辛中渗出，工作的乐趣潜藏在超越困难的过程之中"><a href="#喜悦从苦劳与艰辛中渗出，工作的乐趣潜藏在超越困难的过程之中" class="headerlink" title="喜悦从苦劳与艰辛中渗出，工作的乐趣潜藏在超越困难的过程之中"></a>喜悦从苦劳与艰辛中渗出，工作的乐趣潜藏在超越困难的过程之中</h2><h2 id="踏上社会，要转变角色，要为周围的人服务，要为团队、为企业做贡献"><a href="#踏上社会，要转变角色，要为周围的人服务，要为团队、为企业做贡献" class="headerlink" title="踏上社会，要转变角色，要为周围的人服务，要为团队、为企业做贡献"></a>踏上社会，要转变角色，要为周围的人服务，要为团队、为企业做贡献</h2><h2 id="养成在更大视野内观察事物的眼光，从更大的视角、以相对的观点来审视自己的行为"><a href="#养成在更大视野内观察事物的眼光，从更大的视角、以相对的观点来审视自己的行为" class="headerlink" title="养成在更大视野内观察事物的眼光，从更大的视角、以相对的观点来审视自己的行为"></a>养成在更大视野内观察事物的眼光，从更大的视角、以相对的观点来审视自己的行为</h2><h2 id="主宰人生的两只看不见的手"><a href="#主宰人生的两只看不见的手" class="headerlink" title="主宰人生的两只看不见的手"></a>主宰人生的两只看不见的手</h2><p>主宰人生的两只看不见的手，一只叫命运，一只叫因果报应法则。<br>我们身上发生的各种事情，都有其产生的原因。这原因不是别的，就是我们自己的思想和行为。你在想什么做什么，都成为因，而<br>必生其果，你对所生结果如何应对，又成为因，有必有所果。<br>人生超脱命运的轨迹，那是因为因果法则这个力量在发挥作用；而另一方面，善行有时并不立即产生善果，那是因为命运的力量在干扰。<br>在这里，因果报应法则要强于命运的法则。因此，由上苍决定的命运也可以用自己的力量加以改变。</p>
<h2 id="为善不见其益，如草里冬瓜自暗应长"><a href="#为善不见其益，如草里冬瓜自暗应长" class="headerlink" title="为善不见其益，如草里冬瓜自暗应长"></a>为善不见其益，如草里冬瓜自暗应长</h2><p>我们人生的意义是什么？人生的目的在哪里？<br>要带着一颗比降生是稍稍善良、稍稍美丽的心灵离开人世，从生至死都要尽力去思善行善，陶冶人格，使人生终点时灵魂的品格比起点时有所提升。</p>
<p>在此我定下一个目标，一定要在n年后重读此书，看看自己的感悟与此时此刻有何不同，自己有没有按照书中的“活法”去生活、工作、学习！</p>
]]></content>
      <categories>
        <category>书籍</category>
        <category>励志类</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>活法</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 深度学习pytorch训练代码模板</title>
    <url>/2021/11/21/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0pytorch%E8%AE%AD%E7%BB%83%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="深度学习pytorch训练代码模板"><a href="#深度学习pytorch训练代码模板" class="headerlink" title="深度学习pytorch训练代码模板"></a>深度学习pytorch训练代码模板</h1><p><a href="https://zhuanlan.zhihu.com/p/396666255?utm_source=wechat_session&utm_medium=social&utm_oi=1006101315038175232&utm_campaign=shareopn">查看模板！</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 深度学习中常用的几种激活函数</title>
    <url>/2021/06/22/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="深度学习中常用的几种激活函数"><a href="#深度学习中常用的几种激活函数" class="headerlink" title="深度学习中常用的几种激活函数"></a>深度学习中常用的几种激活函数</h1><p>使用一个神经网络时，需要决定使用哪种激活函数用隐藏层上，哪种用在输出节点上。<br><b style="color:red">在不同的神经网络层中，激活函数可以不同</b><br><b>几种常用的激活函数：</b><br><img src="/2021/06/22/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/1.png"></p>
<p><b>note:</b><br>1.tanh函数总体上优于sigmoid函数(因为tanh函数值值域在-1,1之间，其均值更接近0)</p>
<p>2.例外：在二分类的问题中，对于输出层，因为𝑦的值是 0 或 1，所以想让𝑦^的数<br>值介于 0 和 1 之间，而不是在-1 和+1 之间。所以需要使用 sigmoid 激活函数。</p>
<p>如果输出是 0、1 值（二分类问题），则输出层选择 sigmoid 函数，然后其它的所有单<br>元都选择 Relu 函数。</p>
<p>3.sigmoid 函数和 tanh 函数两者共同的缺点是，在𝑧特别大或者特别小的情况下，导数的<br>梯度或者函数的斜率会变得特别小，最后就会接近于 0，导致降低梯度下降的速度。</p>
<p><b>总结：</b><br>sigmoid 激活函数：除了输出层是一个二分类问题基本不会用它。<br>tanh 激活函数：tanh 是非常优秀的，几乎适合所有场合。<br>ReLu 激活函数：最常用的默认函数，，如果不确定用哪个激活函数，就使用 ReLu 或者<br>Leaky Relu</p>
<p><a href="https://mp.weixin.qq.com/s/9N-d8_D5rniJylDMLXdTPQ">点这里查看更多的激活函数，有更加详细的解释！</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>激活函数</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 深度学习基础问题</title>
    <url>/2021/11/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="深度学习基础问题"><a href="#深度学习基础问题" class="headerlink" title="深度学习基础问题"></a>深度学习基础问题</h1><p><a href="https://mp.weixin.qq.com/s/KcIlkLyNROxC_TUbCDhEmg">深度学习基础问题</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>基于JavaWeb的网上购物商城 | 清空购物车</title>
    <url>/2022/01/15/%E6%B8%85%E7%A9%BA%E8%B4%AD%E7%89%A9%E8%BD%A6/</url>
    <content><![CDATA[<h1 id="清空购物车"><a href="#清空购物车" class="headerlink" title="清空购物车"></a>清空购物车</h1><p><strong>实现功能：</strong><br>用户点击购物车中的清空购物车链接时，删除所有购物项，总金额清零。<br><img src="/2022/01/15/%E6%B8%85%E7%A9%BA%E8%B4%AD%E7%89%A9%E8%BD%A6/1.PNG"></p>
<span id="more"></span>
<p><strong>cart.jsp</strong><br>为清空购物车链接增加onclick属性，并使用js实现clearCart方法。</p>
<pre><code>&lt;a href=&quot;#&quot; id=&quot;clear&quot; class=&quot;clear&quot; onclick=&quot;clearCart()&quot;&gt;清空购物车&lt;/a&gt;
......
&lt;script type=&quot;text/javascript&quot;&gt;
    function clearCart()&#123;
        location.href=&quot;$&#123;pageContext.request.contextPath&#125;/product?method=clearCart&quot;;
    &#125;
&lt;/script&gt;
</code></pre>
<p><strong>ProductServlet.java</strong><br>在ProductServlet.java的doGet方法中添加clearCart的判断，并完成clearCart方法。</p>
<pre><code>public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
    String method = request.getParameter(&quot;method&quot;);
    if(&quot;getProById&quot;.equals(method)) &#123;
        getProById(request, response);
    &#125;else if(&quot;findListByCate&quot;.equals(method)) &#123;
        findListByCate(request, response);
    &#125;else if(&quot;cart&quot;.equals(method)) &#123;
        cart(request, response);
    &#125;else if(&quot;delCart&quot;.equals(method)) &#123;
        delCart(request, response);
    &#125;else if(&quot;clearCart&quot;.equals(method)) &#123;
        clearCart(request, response);
    &#125;
&#125;

public void clearCart(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
    //获取购物车
    HttpSession session = request.getSession();
    Cart cart = (Cart) session.getAttribute(&quot;cart&quot;);
    
    cart.setMap(new HashMap&lt;&gt;());//删除所有购物项
    cart.setSubMoney(0.0);//总金额清零
    
    //返回购物车页面
    request.getRequestDispatcher(&quot;/cart.jsp&quot;).forward(request, response);
&#125;
</code></pre>
]]></content>
      <categories>
        <category>项目经历</category>
        <category>JavaWeb</category>
        <category>基于JavaWeb的网上购物商城</category>
        <category>清空购物车</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
        <tag>基于JavaWeb的网上购物商城</tag>
        <tag>清空购物车</tag>
      </tags>
  </entry>
  <entry>
    <title>requests | 爬取精美壁纸</title>
    <url>/2021/11/06/%E7%88%AC%E5%8F%96%E7%B2%BE%E7%BE%8E%E5%A3%81%E7%BA%B8/</url>
    <content><![CDATA[<h1 id="爬取精美壁纸"><a href="#爬取精美壁纸" class="headerlink" title="爬取精美壁纸"></a>爬取精美壁纸</h1><p><strong>爬取目标：</strong> Wallhaven网站中Toplist标签下前50页共1196张精美壁纸。<br><a href="https://mp.weixin.qq.com/s/BiJKm4SnL6qCLEK91xcDIQ">参考资料</a></p>
<p><strong>代码：</strong></p>
<pre><code># -*- coding:utf-8 -*-
import os
import requests
from lxml import etree


# 1.获取每页的html信息
headers = &#123;
    &#39;user-agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) &#39;
                  &#39;Chrome/95.0.4638.54 Safari/537.36 &#39;
&#125;


# 定义获取每页html信息的函数
def get_html_info(page):
    url = f&#39;https://wallhaven.cc/toplist?page=&#123;page&#125;&#39;
    resp = requests.get(url, headers=headers)
    print(resp.text)
    resp_html = etree.HTML(resp.text)
    return resp_html


# 2.解析url信息+下载图片
def get_pic(resp_html):
    pic_url_list = []
    lis = resp_html.xpath(&#39;//*[@id=&quot;thumbs&quot;]/section[1]/ul/li&#39;)  # 获取该页所有缩略图包含的信息
    for li in lis:
        pic_url = li.xpath(&#39;./figure/a/@href&#39;)[0]  # 获取存放在缩略图信息中的缩略图原图网址
        pic_url_list.append(pic_url)
    for pic_url in pic_url_list:
        resp2 = requests.get(pic_url, headers=headers)
        r_html2 = etree.HTML(resp2.text)
        pic_size = r_html2.xpath(&#39;//*[@id=&quot;showcase-sidebar&quot;]/div/div[1]/h3/text()&#39;)[0]  # 用照片分辨率作为名称一部分
        final_url = r_html2.xpath(&#39;//*[@id=&quot;wallpaper&quot;]/@src&#39;)[0]  # 获取原图下载地址
        pic = requests.get(url=final_url, headers=headers).content
        if not os.path.exists(&#39;Wallhaven&#39;):
            os.mkdir(&#39;Wallhaven&#39;)
        with open(&#39;Wallhaven\\&#39; + pic_size + final_url[-10:], mode=&#39;wb&#39;) as f:
            f.write(pic)  # 保存图片
            print(pic_size + final_url[-10:] + &#39;，下载完毕，已下载&#123;&#125;张壁纸&#39;.format(len(os.listdir(&#39;Wallhaven&#39;))))


# 3.构建main()函数运行程序
def main():
    page_range = range(1,51) # 爬取1-50页的壁纸
    for i in page_range:
        r = get_html_info(i)
        get_pic(r)
        print(f&#39;===============第&#123;i&#125;页下载完毕=============&#39;)


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>requests</category>
      </categories>
      <tags>
        <tag>requests</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 70.爬楼梯</title>
    <url>/2022/07/09/%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    <content><![CDATA[<h1 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br><a href="https://leetcode.cn/problems/climbing-stairs/">题目链接</a></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>f(n) = f(n-1) + f(n-2)</strong></p>
<ol>
<li><p>递归法<br>由f(1)=1,f(2)=2,f(3)=3,…,以此类推,f(n)=f(n-1)+f(n-2),使用递归法实现该问题，递归方程为f(n)=f(n-1)+f(n-2),<br>递归出口为f(1)=1,f(2)=2。</p>
</li>
<li><p>记忆化递归法<br>使用数组记录了每次计算的结果，避免递归法中的重复计算。</p>
</li>
<li><p>动态规划<br>动态规划转移方程：f(n)=f(n-1)+f(n-2)<br>边界条件：f(1)=1,f(2)=2</p>
</li>
<li><p>滚动数组<br>使用长度为3的数组实现爬楼梯问题，问题中涉及三个状态:状态1、状态2、状态3，每次更新状态时，先将状态2移动到状态1<br>的位置，再把状态3移动到状态2的位置，即将状态数组整体向前滚动一位。<br>例：<br>|1|2|3|—&gt;|2|3|5|</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p> class Solution(object):</p>
<pre><code> def climbStairs(self, n):
     &quot;&quot;&quot;
     递归法
     :type n: int
     :rtype: int
     &quot;&quot;&quot;
     if n == 1:
         return 1
     if n == 2:
         return 2
     return self.climbStairs(n - 1) + self.climbStairs(n - 2)
 
 def climbStairs2(self, n):
     &quot;&quot;&quot;
     记忆化递归法
     :type n: int
     :rtype: int
     &quot;&quot;&quot;
     memo = []
     return self.climbStairsMemo(n, memo)
 
 def climbStairsMemo(self, n, memo):
     if memo[n] &gt; 0:
         return memo[n]
     if n == 1:
         memo[n] = 1
     elif n == 2:
         memo[n] = 2
     else:
         memo[n] = self.climbStairsMemo(n - 1, memo) + self.climbStairsMemo(n - 2, memo)
     return memo[n]
 
 def climbStairs3(self, n):
     &quot;&quot;&quot;
     动态规划
     :type n: int
     :rtype: int
     &quot;&quot;&quot;
     if n == 1:
         return 1
     dp = [1, 2]
     for i in range(2, n):
         dp.append(dp[i-1]+dp[i-2])  # dp[i] = dp[i-1] + dp[i-2]
     return dp[n-1]
 
 def climbStairs4(self, n):
     &quot;&quot;&quot;
     滚动数组（斐波那契数列）
     :type n: int
     :rtype: int
     &quot;&quot;&quot;
     if n == 1:
         return 1
     first = 1
     second = 2
     for i in range(2, n):
         third = first + second
         first = second
         second = third
     return second
     
</code></pre>
<p> if <strong>name</strong> == “<strong>main</strong>“:</p>
<pre><code> slt = Solution()
 # numberOfSolutions = slt.climbStairs(2)
 # numberOfSolutions = slt.climbStairs2(2)
 # numberOfSolutions = slt.climbStairs3(2)
 numberOfSolutions = slt.climbStairs4(4)
 print(numberOfSolutions)
</code></pre>
</li>
</ol>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>动态规划</category>
        <category>70.爬楼梯</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 环形链表</title>
    <url>/2021/08/27/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141.环形链表"></a>141.环形链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个链表，判断链表中是否有环。<br>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。<br>如果链表中存在环，则返回 true 。 否则，返回 false 。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/linked-list-cycle/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.哈希表<br>最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。<br>具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。<br>2.快慢指针<br>定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution:
    def hasCycle(self, head: ListNode) -&gt; bool:
        &quot;&quot;&quot;
        哈希表

        :param head:单链表头节点
        :return:True-linked list has cycle/False-linked list has not cycle
        &quot;&quot;&quot;
        seen = set()
        while head:
            if head in seen:
                return True
            seen.add(head)
            head = head.next
        return False

    def hasCycle1(self, head: ListNode) -&gt; bool:
        &quot;&quot;&quot;
        快慢指针

        :param head:单链表头节点
        :return:True-linked list has cycle/False-linked list has not cycle
        &quot;&quot;&quot;
        if not head or not head.next:  # 如果头节点为空，或者链表第一个节点为空，则链表没有环
            return False

        slow = head
        fast = head.next

        while slow != fast:
            if not fast or not fast.next:
                return False

            slow = slow.next
            fast = fast.next.next
        return True

    def create_linked_list(self):
        node4 = ListNode(-4)
        node3 = ListNode(0)
        node2 = ListNode(2)
        node1 = ListNode(3)
        node1.next = node2
        node2.next = node3
        node3.next = node4
        node4.next = node2

        return node1

    def print_linked_list(self, linked_list) -&gt; None:
        &quot;&quot;&quot;
        打印单链表中的所有元素

        :param linked_list: 单链表
        :return: 无
        &quot;&quot;&quot;
        print(&quot;----------------------------------------&quot;)
        pointer = linked_list
        while pointer is not None:
            print(pointer.val)
            pointer = pointer.next


if __name__ == &quot;__main__&quot;:
    slt = Solution()

    linked_list = slt.create_linked_list()

    print(slt.hasCycle1(linked_list))
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>pyqrcode | 生成二维码</title>
    <url>/2022/07/09/%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81/</url>
    <content><![CDATA[<h1 id="生成二维码"><a href="#生成二维码" class="headerlink" title="生成二维码"></a>生成二维码</h1><p><strong>代码：</strong></p>
<pre><code>import pyqrcode  # pip install pyqrcode
import png  # pip install pypng
link = &quot;https://victory-liao.github.io/&quot;
qrCode = pyqrcode.create(link)
qrCode.png(&quot;my blog.png&quot;, scale=10)
</code></pre>
<p><strong>结果：</strong><br><img src="/2022/07/09/%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81/my%20blog.png"><br><strong>注：如果要生成其他链接的二维码，只需要替换link变量中的值！</strong></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>pyqrcode</category>
      </categories>
      <tags>
        <tag>二维码</tag>
        <tag>pyqrcode</tag>
      </tags>
  </entry>
  <entry>
    <title>生成器 | 生成器输出fibonacci数列</title>
    <url>/2021/11/01/%E7%94%9F%E6%88%90%E5%99%A8%E8%BE%93%E5%87%BAfibonacci%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<h1 id="生成器输出小于max-num的fibonacci数列"><a href="#生成器输出小于max-num的fibonacci数列" class="headerlink" title="生成器输出小于max_num的fibonacci数列"></a>生成器输出小于max_num的fibonacci数列</h1><p>代码：</p>
<pre><code>def feb(max_num):
    n_1 = 1
    n_2 = 1
    n = 0
    while n &lt; max_num:
        if n == 0 or n == 1:
            yield 1
            n += 1
        else:
            yield n_1 + n_2
            new_n_2 = n_1
            n_1 = n_1 + n_2
            n_2 = new_n_2
            n += 1

g = feb(5)
for n in g:
    print(n)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
        <category>生成器</category>
      </categories>
      <tags>
        <tag>生成器</tag>
      </tags>
  </entry>
  <entry>
    <title>生成器 | 生成器输出小于maxnum的偶数或奇数</title>
    <url>/2021/11/01/%E7%94%9F%E6%88%90%E5%99%A8%E8%BE%93%E5%87%BA%E5%B0%8F%E4%BA%8Emaxnum%E7%9A%84%E5%81%B6%E6%95%B0%E6%88%96%E5%A5%87%E6%95%B0/</url>
    <content><![CDATA[<h1 id="生成器输出小于max-num的偶数或奇数"><a href="#生成器输出小于max-num的偶数或奇数" class="headerlink" title="生成器输出小于max_num的偶数或奇数"></a>生成器输出小于max_num的偶数或奇数</h1><p>代码：</p>
<pre><code># 1.输出小于max_num的偶数或奇数
def odd(max_num):
    
    i = 1
    while i &lt; max_num:
        if i % 2 == 0:  # if % 2 == 1可生成奇数
            yield i
        i += 1

g = odd(10)
for n in g:
    print(n)

# 2.输出任意个偶数或奇数
def odd():
i = 2
while i:
    if i % 2 == 0:  # if % 2 == 1可生成奇数
        yield i
    i += 1
g = odd()
for i in range(100):
    print(next(g))
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
        <category>生成器</category>
      </categories>
      <tags>
        <tag>生成器</tag>
      </tags>
  </entry>
  <entry>
    <title>生成器 | 生成器输出质数</title>
    <url>/2021/11/01/%E7%94%9F%E6%88%90%E5%99%A8%E8%BE%93%E5%87%BA%E8%B4%A8%E6%95%B0/</url>
    <content><![CDATA[<h1 id="生成器输出小于max-num的质数"><a href="#生成器输出小于max-num的质数" class="headerlink" title="生成器输出小于max_num的质数"></a>生成器输出小于max_num的质数</h1><p>通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。<br>而且，创建一个包含成百上千完个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前<br>面几个元素，那后面绝大多数元素占用的空间都白白浪费了。生成器有效的解决了这个问题。</p>
<span id="more"></span>
<p>代码：</p>
<pre><code>def factor(max_num):
    # 这是一个函数  用于输出所有小于max_num的质数
    factor_list = []
    n = 2
    while n &lt; max_num:
        find = False
        for f in factor_list:
            # 先看看列表里面有没有能整除它的
            if n % f == 0:
                find = True
                break
        if not find:
            factor_list.append(n)
            yield n

        n += 1

g = factor(10)

for n in g:
    print(n)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
        <category>生成器</category>
      </categories>
      <tags>
        <tag>生成器</tag>
      </tags>
  </entry>
  <entry>
    <title>openpyxl | 用Python在Excel中查找并替换数据</title>
    <url>/2021/10/25/%E7%94%A8Python%E5%9C%A8Excel%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%B9%B6%E6%9B%BF%E6%8D%A2%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="用Python在Excel中查找并替换数据"><a href="#用Python在Excel中查找并替换数据" class="headerlink" title="用Python在Excel中查找并替换数据"></a>用Python在Excel中查找并替换数据</h1><p>实现代码：</p>
<pre><code>from openpyxl import load_workbook  # 用于读取Excel中的信息

# 获取Excel表格中的数据
wb = load_workbook(&#39;查找替换.xlsx&#39;)  # 读取工作簿
ws = wb.active  # 读取活动工作表
data = &#123;&#125;  # 新建字典，用于储存数据

for row in range(2, ws.max_row + 1):
    chazhao = str(ws[&#39;A&#39; + str(row)].value)  # 转换成字符串，以免后续比对时出现数据类型冲突
    tihuan = str(ws[&#39;B&#39; + str(row)].value)  # 转换成字符串，以免后续比对时出现数据类型冲突
    data[chazhao] = tihuan  # 键值对应存入字典

wb = load_workbook(&#39;原表.xlsx&#39;)  # 读取目标工作簿
ws = wb.active
ID_list = []  # 新建一个列表，用于储存原表D列的信息
for row in range(2, ws.max_row + 1):
    ID = ws[&#39;D&#39; + str(row)].value  # 遍历整个工作表，将D列的数据逐个存入ID变量
    ID_list.append(ID)  # 将读取到的结果存入列表

code = []
for i in ID_list:
    if i is None:  # 如果是None，则放入None占位，以保持列表的值的顺序与原表一致
        code.append(None)
    else:
        code.append(i.split(&quot;：&quot;)[-1])  # 不是None,则按&quot;：&quot;符号分割，并放分割后的最后一个值进入新列表code

for i in range(len(code)):
    if code[i] in data:
        ws.cell(row=i + 2, column=4).value = ID_list[i].split(&quot;：&quot;)[0] + &quot;：&quot; + data[code[i]]
wb.save(&#39;原表-替换.xlsx&#39;)
</code></pre>
<p><a href="查找替换.xlsx">查找替换.xlsx</a><br><a href="原表.xlsx">原表.xlsx</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>openpyxl</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>openpyxl</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 用两个队列实现栈</title>
    <url>/2021/08/27/%E7%94%A8%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
    <content><![CDATA[<h1 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225.用队列实现栈"></a>225.用队列实现栈</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。<br>实现 MyStack 类：<br>    void push(int x) 将元素 x 压入栈顶。<br>    int pop() 移除并返回栈顶元素。<br>    int top() 返回栈顶元素。<br>    boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。</p>
<p>注意：<br>    你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。<br>    你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>1.使用两个队列实现栈</strong><br>使用两个队列实现栈的操作，其中 queue1 用于存储栈内的元素，queue2 作为入栈操作的辅助队列。<br>入栈操作时，首先将元素入队到 queue2，然后将 queue1 的全部元素依次出队并入队到 queue2，此时 queue2 的前端的元素即为新入栈的元素，再将 queue1 和 queue2 互换，则 queue1 的元素即为栈内的元素，queue1 的前端和后端分别对应栈顶和栈底。<br>由于每次入栈操作都确保 queue1 的前端元素为栈顶元素，因此出栈操作和获得栈顶元素操作都可以简单实现。出栈操作只需要移除 queue1 的前端元素并返回即可，获得栈顶元素操作只需要获得 queue1 的前端元素并返回即可（不移除元素）。<br>由于 queue1 用于存储栈内的元素，判断栈是否为空时，只需要判断 queue1 是否为空即可。<br><strong>2.使用一个队列实现栈</strong><br>使用一个队列时，为了满足栈的特性，即最后入栈的元素最先出栈，同样需要满足队列前端的元素是最后入栈的元素。<br>入栈操作时，首先获得入栈前的元素个数 n，然后将元素入队到队列，再将队列中的前 n 个元素（即除了新入栈的元素之外的全部元素）依次出队并入队到队列，此时队列的前端的元素即为新入栈的元素，且队列的前端和后端分别对应栈顶和栈底。<br>由于每次入栈操作都确保队列的前端元素为栈顶元素，因此出栈操作和获得栈顶元素操作都可以简单实现。出栈操作只需要移除队列的前端元素并返回即可，获得栈顶元素操作只需要获得队列的前端元素并返回即可（不移除元素）。<br>由于队列用于存储栈内的元素，判断栈是否为空时，只需要判断队列是否为空即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>import collections


class MyStack(object):
    &quot;&quot;&quot;使用两个队列实现栈&quot;&quot;&quot;
    def __init__(self):
        &quot;&quot;&quot;
        Initialize your data structure here.
        &quot;&quot;&quot;
        self.queue1 = collections.deque()
        self.queue2 = collections.deque()

    def push(self, x):
        &quot;&quot;&quot;
        Push element x onto stack.
        :type x: int
        :rtype: None
        &quot;&quot;&quot;
        self.queue2.append(x)
        while self.queue1:
            self.queue2.append(self.queue1.popleft())
        self.queue1, self.queue2 = self.queue2, self.queue1

    def pop(self):
        &quot;&quot;&quot;
        Removes the element on top of the stack and returns that element.
        :rtype: int
        &quot;&quot;&quot;
        return self.queue1.popleft()

    def top(self):
        &quot;&quot;&quot;
        Get the top element.
        :rtype: int
        &quot;&quot;&quot;
        return self.queue1[0]

    def empty(self):
        &quot;&quot;&quot;
        Returns whether the stack is empty.
        :rtype: bool
        &quot;&quot;&quot;
        return not self.queue1


class MyStack1(object):
    &quot;&quot;&quot;使用1个队列实现栈&quot;&quot;&quot;
    def __init__(self):
        &quot;&quot;&quot;
        Initialize your data structure here.
        &quot;&quot;&quot;
        self.queue = collections.deque()

    def push(self, x):
        &quot;&quot;&quot;
        Push element x onto stack.
        :type x: int
        :rtype: None
        &quot;&quot;&quot;
        n = len(self.queue)
        self.queue.append(x)
        for _ in range(n):
            self.queue.append(self.queue.popleft())

    def pop(self):
        &quot;&quot;&quot;
        Removes the element on top of the stack and returns that element.
        :rtype: int
        &quot;&quot;&quot;
        return self.queue.popleft()

    def top(self):
        &quot;&quot;&quot;
        Get the top element.
        :rtype: int
        &quot;&quot;&quot;
        return self.queue[0]

    def empty(self):
        &quot;&quot;&quot;
        Returns whether the stack is empty.
        :rtype: bool
        &quot;&quot;&quot;
        return not self.queue
# Your MyStack object will be instantiated and called as such:
# obj = MyStack()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.top()
# param_4 = obj.empty()


if __name__ == &quot;__main__&quot;:
    my_stack = MyStack()
    my_stack = MyStack1()
    my_stack.push(1)
    my_stack.push(2)
    print(&quot;当前栈顶元素为: &#123;&#125;&quot;.format(my_stack.top()))
    print(&quot;当前弹出的元素为: &#123;&#125;&quot;.format(my_stack.pop()))
    print(&quot;当前栈空：&#123;&#125;&quot;.format(&quot;yes&quot; if my_stack.empty() is True else &quot;no&quot;))
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 用栈实现队列</title>
    <url>/2021/08/27/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232.用栈实现队列"></a>232.用栈实现队列</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：<br>实现 MyQueue 类：<br>    void push(int x) 将元素 x 推到队列的末尾<br>    int pop() 从队列的开头移除并返回元素<br>    int peek() 返回队列开头的元素<br>    boolean empty() 如果队列为空，返回 true ；否则，返回 false<br>说明：<br>    你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。<br>    你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</p>
<span id="more"></span>

<p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用两个栈实现队列，一个栈作为输入栈（入队），一个对作为输出栈（出队/取队头元素）。<br>入队操作的实现：将元素压入输入栈<br>出队操作的实现：弹出输出栈栈顶元素，若输出栈为空，输入栈不为空，则将输入栈所有元素出栈并压入输出栈，接着再弹出输出栈栈顶元素。<br>队列判空：输入栈和输出栈同时为空时队列为空。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class MyQueue(object):
    &quot;&quot;&quot;用2个栈实现队列&quot;&quot;&quot;
    def __init__(self):
        &quot;&quot;&quot;
        Initialize your data structure here.
        &quot;&quot;&quot;
        self.stack1 = list()
        self.stack2 = list()

    def push(self, x):
        &quot;&quot;&quot;
        Push element x to the back of queue.
        :type x: int
        :rtype: None
        &quot;&quot;&quot;
        self.stack1.append(x)

    def pop(self):
        &quot;&quot;&quot;
        Removes the element from in front of queue and returns that element.
        :rtype: int
        &quot;&quot;&quot;
        if len(self.stack2) != 0:
            return self.stack2.pop()
        else:
            for _ in range(len(self.stack1)):
                self.stack2.append(self.stack1.pop())
            return self.stack2.pop()

    def peek(self):
        &quot;&quot;&quot;
        Get the front element.
        :rtype: int
        &quot;&quot;&quot;
        if len(self.stack2) != 0:
            return self.stack2[-1]
        else:
            for _ in range(len(self.stack1)):
                self.stack2.append(self.stack1.pop())
            return self.stack2[-1]


    def empty(self):
        &quot;&quot;&quot;
        Returns whether the queue is empty.
        :rtype: bool
        &quot;&quot;&quot;
        return not self.stack1 and not self.stack2


# Your MyQueue object will be instantiated and called as such:
# obj = MyQueue()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.peek()
# param_4 = obj.empty()


if __name__ == &quot;__main__&quot;:
    my_queue = MyQueue()
    my_queue.push(1)
    my_queue.push(2)
    print(&quot;当前队头元素为：&#123;&#125;&quot;.format(my_queue.peek()))
    print(&quot;当前出队元素为：&#123;&#125;&quot;.format(my_queue.pop()))
    print(&quot;当前队列空：&#123;&#125;&quot;.format(&quot;yes&quot; if my_queue.empty() is True else &quot;no&quot;))
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 电话号码的字母组合</title>
    <url>/2021/09/04/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h1 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17.电话号码的字母组合"></a>17.电话号码的字母组合</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。<br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.遍历并组合每一个数字对应的字母列表 –&gt; letterCombinations()<br><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/zhi-xing-yong-shi-ji-bai-9954nei-cun-xia-gwkb/">点击这里查看完整解题思路！！！</a><br>2.使用内置库 –&gt; letterCombinations1()<br><strong>3.回溯</strong> –&gt; letterCombinations2()<br><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/dian-hua-hao-ma-de-zi-mu-zu-he-by-leetcode-solutio/">回溯法和使用内置库思路见leetcode题解</a></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    num2ch = &#123;
        &#39;2&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],
        &#39;3&#39;: [&#39;d&#39;, &#39;e&#39;, &#39;f&#39;],
        &#39;4&#39;: [&#39;g&#39;, &#39;h&#39;, &#39;i&#39;],
        &#39;5&#39;: [&#39;j&#39;, &#39;k&#39;, &#39;l&#39;],
        &#39;6&#39;: [&#39;m&#39;, &#39;n&#39;, &#39;o&#39;],
        &#39;7&#39;: [&#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;],
        &#39;8&#39;: [&#39;t&#39;, &#39;u&#39;, &#39;v&#39;],
        &#39;9&#39;: [&#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;]
    &#125;

    def letterCombinations(self, digits: str) -&gt; list:
        if len(digits) == 0:
            return []

        list1 = []  # 用于存储digits数组中每个字符对应的字母列表
        for d in digits:
            list1.append(self.num2ch[d])

        i = 0
        j = 1
        while j &lt; len(list1):
            list1[j] = self.concat(list1[i], list1[j])
            i = j
            j += 1

        return list1[-1]

    def concat(self, list1, list2):
        res = []
        for e1 in list1:
            for e2 in list2:
                res.append(e1 + e2)
        return res

    def letterCombinations1(self, digits: str):
        if not digits:
            return list()

        phoneMap = &#123;
            &quot;2&quot;: &quot;abc&quot;,
            &quot;3&quot;: &quot;def&quot;,
            &quot;4&quot;: &quot;ghi&quot;,
            &quot;5&quot;: &quot;jkl&quot;,
            &quot;6&quot;: &quot;mno&quot;,
            &quot;7&quot;: &quot;pqrs&quot;,
            &quot;8&quot;: &quot;tuv&quot;,
            &quot;9&quot;: &quot;wxyz&quot;,
        &#125;

        groups = (phoneMap[digit] for digit in digits)

        import itertools
        return [&quot;&quot;.join(combination) for combination in itertools.product(*groups)]

    def letterCombinations2(self, digits: str):
        if not digits:
            return list()

        phoneMap = &#123;
            &quot;2&quot;: &quot;abc&quot;,
            &quot;3&quot;: &quot;def&quot;,
            &quot;4&quot;: &quot;ghi&quot;,
            &quot;5&quot;: &quot;jkl&quot;,
            &quot;6&quot;: &quot;mno&quot;,
            &quot;7&quot;: &quot;pqrs&quot;,
            &quot;8&quot;: &quot;tuv&quot;,
            &quot;9&quot;: &quot;wxyz&quot;,
        &#125;

        def backtrack(index: int):
            if index == len(digits):
                combinations.append(&#39;&#39;.join(combination))
            else:
                digit = digits[index]
                for letter in phoneMap[digit]:
                    combination.append(letter)
                    backtrack(index + 1)
                    combination.pop()

        combination = list()
        combinations = list()
        backtrack(0)
        return combinations


if __name__ == &#39;__main__&#39;:
    slt = Solution()
    digits = &quot;23&quot;
    res = slt.letterCombinations2(digits)
    print(res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>基于JavaWeb的网上购物商城 | 登录成功后网页头部显示用户名</title>
    <url>/2022/01/13/%E7%99%BB%E5%BD%95%E6%88%90%E5%8A%9F%E5%90%8E%E7%BD%91%E9%A1%B5%E5%A4%B4%E9%83%A8%E6%98%BE%E7%A4%BA%E7%94%A8%E6%88%B7%E5%90%8D/</url>
    <content><![CDATA[<h1 id="登录成功后网页头部显示用户名"><a href="#登录成功后网页头部显示用户名" class="headerlink" title="登录成功后网页头部显示用户名"></a>登录成功后网页头部显示用户名</h1><p>要实现登录成功后在网页头部显示用户名，只需在登录成功后将当前用户存入session,然后在登录页面使用jstl语法判断用户状态，<br>登录成功则显示用户名。</p>
<ol>
<li>在UserServlet.java中添加将当前用户加入session中的代码<br>public void login(HttpServletRequest request, HttpServletResponse response) {<pre><code> ......
 if(user!=null) &#123;
     HttpSession session = request.getSession();
     session.setAttribute(&quot;user&quot;, user);//将当前用户(User)加入session
     
     request.getRequestDispatcher(&quot;/index.jsp&quot;).forward(request, response);
 &#125;
 ......
</code></pre>
 }</li>
<li>修改header.jsp代码<br>使用jstl代码判断当前用户是否为空，若为空，显示登录注册链接，若不为空显示用户名等信息。</li>
</ol>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;
&lt;!DOCTYPE html&gt;
&lt;!-- 登录 注册 购物车... --&gt;
&lt;div class=&quot;container-fluid&quot;&gt;
    &lt;div class=&quot;col-md-4&quot;&gt;
        &lt;img src=&quot;img/logo2.png&quot; /&gt;
    &lt;/div&gt;
    &lt;div class=&quot;col-md-5&quot;&gt;
        &lt;img src=&quot;img/header.png&quot; /&gt;
    &lt;/div&gt;
    &lt;div class=&quot;col-md-3&quot; style=&quot;padding-top:20px&quot;&gt;
        &lt;ol class=&quot;list-inline&quot;&gt;
            &lt;c:if test=&quot;$&#123;empty user&#125;&quot;&gt;
                &lt;li&gt;&lt;a href=&quot;login.jsp&quot;&gt;登录&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href=&quot;register.jsp&quot;&gt;注册&lt;/a&gt;&lt;/li&gt;
            &lt;/c:if&gt;
            &lt;c:if test=&quot;$&#123;not empty user&#125;&quot;&gt;
                &lt;li&gt;$&#123;user.username&#125;&lt;/li&gt;
                &lt;li&gt;&lt;a href=&quot;cart.jsp&quot;&gt;购物车&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href=&quot;order_list.jsp&quot;&gt;我的订单&lt;/a&gt;&lt;/li&gt;
            &lt;/c:if&gt;
        &lt;/ol&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;!-- 导航条 --&gt;
&lt;div class=&quot;container-fluid&quot;&gt;
    &lt;nav class=&quot;navbar navbar-inverse&quot;&gt;
        &lt;div class=&quot;container-fluid&quot;&gt;
            &lt;!-- Brand and toggle get grouped for better mobile display --&gt;
            &lt;div class=&quot;navbar-header&quot;&gt;
                &lt;button type=&quot;button&quot; class=&quot;navbar-toggle collapsed&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#bs-example-navbar-collapse-1&quot; aria-expanded=&quot;false&quot;&gt;
                    &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt;
                    &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;
                    &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;
                    &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;
                &lt;/button&gt;
                &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;首页&lt;/a&gt;
            &lt;/div&gt;

            &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;bs-example-navbar-collapse-1&quot;&gt;
                &lt;ul class=&quot;nav navbar-nav&quot;&gt;
                    &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;product_list.htm&quot;&gt;手机数码&lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;电脑办公&lt;/a&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;电脑办公&lt;/a&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;电脑办公&lt;/a&gt;&lt;/li&gt;
                &lt;/ul&gt;
                &lt;form class=&quot;navbar-form navbar-right&quot; role=&quot;search&quot;&gt;
                    &lt;div class=&quot;form-group&quot;&gt;
                        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Search&quot;&gt;
                    &lt;/div&gt;
                    &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Submit&lt;/button&gt;
                &lt;/form&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/nav&gt;
&lt;/div&gt;
</code></pre>
<ol start="3">
<li>效果<br><img src="/2022/01/13/%E7%99%BB%E5%BD%95%E6%88%90%E5%8A%9F%E5%90%8E%E7%BD%91%E9%A1%B5%E5%A4%B4%E9%83%A8%E6%98%BE%E7%A4%BA%E7%94%A8%E6%88%B7%E5%90%8D/1.PNG"></li>
</ol>
]]></content>
      <categories>
        <category>项目经历</category>
        <category>JavaWeb</category>
        <category>基于JavaWeb的网上购物商城</category>
        <category>登录成功后网页头部显示用户名</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
        <tag>基于JavaWeb的网上购物商城</tag>
      </tags>
  </entry>
  <entry>
    <title>wxPython | 盒子布局管理器</title>
    <url>/2021/08/03/%E7%9B%92%E5%AD%90%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<h1 id="盒子布局管理器"><a href="#盒子布局管理器" class="headerlink" title="盒子布局管理器"></a>盒子布局管理器</h1><p>wxPython提供了布局管理器类帮助实现界面布局，主要分为两大类：盒子布局管理器（类似于CSS中的弹性布局）和网格布局管理器。</p>
<p>下面我们做一个盒子布局管理器（垂直方向布局）的例子：<br>1.代码</p>
<pre><code># coding=utf-8
import wx
class MyFrame(wx.Frame):
    def __init__(self):
        super().__init__(None, title=&quot;事件处理&quot;, size=(300, 180))
        panel = wx.Panel(parent=self)
        self.statictext = wx.StaticText(parent=panel, label=&quot;请单击OK按钮&quot;)
        b = wx.Button(parent=panel, label=&quot;OK&quot;)
        self.Bind(wx.EVT_BUTTON, self.on_click, b)

        # 创建垂直方向的盒子布局管理器对象vbox
        vbox = wx.BoxSizer(wx.VERTICAL)
        # 添加静态文本到vbox布局管理器
        vbox.Add(self.statictext, proportion=1, flag=wx.ALIGN_CENTER_HORIZONTAL | wx.FIXED_MINSIZE | wx.TOP, border=30)
        # 添加按钮b到vbox布局管理器
        vbox.Add(b, proportion=1, flag=wx.EXPAND | wx.BOTTOM, border=10)
        panel.SetSizer(vbox)

    def on_click(self, event):
        self.statictext.SetLabelText(&#39;Hello, World.&#39;)


app = wx.App()  # 创建应用程序对象
frm = MyFrame()  # 创建窗口对象
frm.Show()  # 显示窗口
app.MainLoop()  # 进入主事件循环
</code></pre>
<p>2.界面<br><img src="/2021/08/03/%E7%9B%92%E5%AD%90%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8/1.png"></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>wxPython</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>wxPython</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 盛最多水的容器</title>
    <url>/2021/08/27/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11.盛最多水的容器"></a>11.盛最多水的容器</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>说明：你不能倾斜容器。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/container-with-most-water/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>双指针法<br>height=[a1,a2,…,an]<br>起始两个指针l、r分别指向n个非负整数的两端，接着计算容器容积area = min(height[l], height[r]) * (r - l),然后移动l、r指针中指针指向元素较小的那个指针（向另一个指针所在的方向移动），再计算area,…,以此类推，然会最大的area</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):
    def maxArea(self, height):
        &quot;&quot;&quot;
        :type height: List[int]
        :rtype: int
        &quot;&quot;&quot;
        # 容器的高为height中每一对值中较小的
        # 容器的宽为每一对值的下标相减，后者下标减去前者下标
        # Area = H x W

        n = len(height)  # 输入数组的长度
        max = 0  # 最大容器容量
        for i in range(n):
            for j in range(i+1, n):
                h = min(height[i], height[j])
                w = j - i
                if h * w &gt; max:
                    max = h * w

        return max

    def maxArea1(self, height):
        l, r = 0, len(height) - 1
        ans = 0

        while l &lt; r:
            area = min(height[l], height[r]) * (r - l)
            ans = max(ans, area)
            if height[l] &lt;= height[r]:
                l += 1
            else:  # height[l] &gt;= height[r]
                r -= 1
        return ans


if __name__ == &quot;__main__&quot;:
    slt = Solution()
    height = [1, 8, 6, 2, 5, 4, 8, 3, 7]
    max_area = slt.maxArea(height)
    print(max_area)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>伪迹移除 | 盲源分离和独立成分分析</title>
    <url>/2021/02/21/%E7%9B%B2%E6%BA%90%E5%88%86%E7%A6%BB%E5%92%8C%E7%8B%AC%E7%AB%8B%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="盲源分离-BSS-和独立成分分析-ICA"><a href="#盲源分离-BSS-和独立成分分析-ICA" class="headerlink" title="盲源分离(BSS)和独立成分分析(ICA)"></a>盲源分离(BSS)和独立成分分析(ICA)</h1><h2 id="BSS"><a href="#BSS" class="headerlink" title="BSS"></a>BSS</h2><p>盲源分离是最流行的伪迹检测/移除方法之一，其目的是提取混合信号中独立的未知的源信号；同时尽可能在对源信号和混合通道没有或者有非常有限的了解下尽可能仅通过在每一个通道的输出观测到的混合信号来估计未知的混合通道。盲源分离包括ICA(独立成分分析)、CCA(典型成分分析)、MCA(形态成分分析)三种方法。</p>
<h3 id="数学表示式："><a href="#数学表示式：" class="headerlink" title="数学表示式："></a>数学表示式：</h3><p><b>X = AS + N</b><br><b>S’ = WX</b><br>其中,X表示观测到的信号(假设X为若干源信号和噪声信号的混合),N代表噪声信号，A为系数矩阵，W也为系数矩阵（需要对W矩阵进行估计），S’为S的估计<br><img src="/2021/02/21/%E7%9B%B2%E6%BA%90%E5%88%86%E7%A6%BB%E5%92%8C%E7%8B%AC%E7%AB%8B%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/bss.png"></p>
<h2 id="ICA"><a href="#ICA" class="headerlink" title="ICA"></a>ICA</h2><p>独立成分分析是盲源分离的一个特例，它假设组成观测信号的若干源信号是线性独立的。</p>
<h3 id="基于ICA的伪迹检测和去除方法存在的问题"><a href="#基于ICA的伪迹检测和去除方法存在的问题" class="headerlink" title="基于ICA的伪迹检测和去除方法存在的问题"></a>基于ICA的伪迹检测和去除方法存在的问题</h3><p>1.非自动的<br>2.需要人为介入去除观察到的伪迹</p>
<h3 id="基于ICA的伪迹检测和去除方法的自动化"><a href="#基于ICA的伪迹检测和去除方法的自动化" class="headerlink" title="基于ICA的伪迹检测和去除方法的自动化"></a>基于ICA的伪迹检测和去除方法的自动化</h3><p><b style="color:red">1.ICA+WT(Wavelet Transform,小波变换)<br>2.ICA+EMD(Empirical Mode Decomposition,经验模态分解)<br>3.使用分类器，例如SVM(Support Vector Machine,支持向量机-一种机器学习算法)<br>4.参考信号辅助</b></p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>1.伪迹独立成分仍然可能包含残余的神经信号导致神经信号的失真<br>2.不能用于单通道数据<br>3.不适合实时应用</p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>伪迹移除</category>
      </categories>
      <tags>
        <tag>ICA</tag>
        <tag>BSS</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 相交链表</title>
    <url>/2021/08/27/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="160-环形链表"><a href="#160-环形链表" class="headerlink" title="160.环形链表"></a>160.环形链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.哈希表<br>判断两个链表是否相交，可以使用哈希集合存储链表节点。<br>首先遍历链表 headA，并将链表 headA 中的每个节点加入哈希集合中。然后遍历链表 headB，对于遍历到的每个节点，判断该节点是否在哈希集合中：<br>    如果当前节点不在哈希集合中，则继续遍历下一个节点；<br>    如果当前节点在哈希集合中，则后面的节点都在哈希集合中，即从当前节点开始的所有节点都在两个链表的相交部分，因此在链表 headB 中遍历到的第一个在哈希集合中的节点就是两个链表相交的节点，返回该节点。<br>如果链表 headB 中的所有节点都不在哈希集合中，则两个链表不相交，返回 null。<br>2.双指针<br>只有当链表 headA 和 headB 都不为空时，两个链表才可能相交。因此首先判断链表 headA 和 headB 是否为空，如果其中至少有一个链表为空，则两个链表一定不相交，返回 null。<br>当链表 headA 和 headB 都不为空时，创建两个指针 pA 和 pB，初始时分别指向两个链表的头节点 headA 和 headB，然后将两个指针依次遍历两个链表的每个节点。具体做法如下：<br>    每步操作需要同时更新指针 pA 和 pB。<br>    如果指针 pA 不为空，则将指针 pA 移到下一个节点；如果指针 pB 不为空，则将指针 pB 移到下一个节点。<br>    如果指针 pA 为空，则将指针 pA 移到链表 headB 的头节点；如果指针 pB 为空，则将指针 pB 移到链表 headA 的头节点。<br>    当指针 pA 和 pB 指向同一个节点或者都为空时，返回它们指向的节点或者 null。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># Definition for singly-linked list.
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):
    def getIntersectionNode(self, headA, headB):
        &quot;&quot;&quot;
        哈希表

        :type head1, head1: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        if not headA or not headB:
            return None
        seen = set()
        p1 = headA
        p2 = headB
        while p1 is not None:
            seen.add(p1)
            p1 = p1.next

        while p2 is not None:
            if p2 in seen:
                return p2.val
            p2 = p2.next

        return None

    def getIntersectionNode1(self, headA, headB):
        &quot;&quot;&quot;
        双指针

        :param headA:
        :param headB:
        :return:
        &quot;&quot;&quot;
        if not headA or not headB:
            return None

        p_A = headA
        p_B = headB

        while p_A != p_B:
            p_A = headB if p_A is None else p_A.next
            p_B = headA if p_B is None else p_B.next

        return p_A


    def create_linked_list(self):
        &quot;&quot;&quot;
        创建两个相交的单链表
        :return:两个相交但表表的头指针
        &quot;&quot;&quot;
        a_node1 = ListNode(4)
        a_node2 = ListNode(1)

        b_node1 = ListNode(5)
        b_node2 = ListNode(0)
        b_node3 = ListNode(1)

        common_node1 = ListNode(8)
        common_node2 = ListNode(4)
        common_node3 = ListNode(5)

        a_node1.next = a_node2
        a_node2.next = common_node1
        common_node1.next = common_node2
        common_node2.next = common_node3

        b_node1.next = b_node2
        b_node2.next = b_node3
        b_node3.next = common_node1
        common_node1.next = common_node2
        common_node2.next = common_node3

        return a_node1, b_node2


if __name__ ==&quot;__main__&quot;:
    slt = Solution()

    head_a, head_b = slt.create_linked_list()

    intersected_node = slt.getIntersectionNode1(head_a, head_b)
    print(intersected_node.val)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>基于JavaWeb的网上购物商城 | 确认订单</title>
    <url>/2022/01/17/%E7%A1%AE%E8%AE%A4%E8%AE%A2%E5%8D%95/</url>
    <content><![CDATA[<h1 id="确认订单"><a href="#确认订单" class="headerlink" title="确认订单"></a>确认订单</h1><p><strong>实现功能：</strong><br>用户在购物车页面点击“确认订单”，在数据库将之前提交的订单的状态改为已支付，并向数据库写入收货人、收获地址、电话等信息;<br>确认订单后跳转到我的订单页面。<br><img src="/2022/01/17/%E7%A1%AE%E8%AE%A4%E8%AE%A2%E5%8D%95/1.PNG"></p>
<span id="more"></span>
<p><strong>order_info.jsp</strong><br>修改order_info.jsp中的以下代码，当点击”确认订单“时将表单信息提交。</p>
<pre><code>&lt;form class=&quot;form-horizontal&quot; id=&quot;form&quot; method=&quot;post&quot; action=&quot;$&#123;pageContext.request.contextPath&#125;/product&quot;
    style=&quot;margin-top: 5px; margin-left: 150px;&quot;&gt;
    &lt;input type=&quot;hidden&quot; name=&quot;method&quot; value=&quot;submitOrder&quot;&gt;
    &lt;input type=&quot;hidden&quot; name=&quot;oid&quot; value=&quot;$&#123;order.oid&#125;&quot;&gt;
    &lt;div class=&quot;form-group&quot;&gt;
        &lt;label for=&quot;username&quot; class=&quot;col-sm-1 control-label&quot;&gt;地址&lt;/label&gt;
        &lt;div class=&quot;col-sm-5&quot;&gt;
            &lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;address&quot; id=&quot;username&quot;
                placeholder=&quot;请输入收货地址&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;form-group&quot;&gt;
        &lt;label for=&quot;inputPassword3&quot; class=&quot;col-sm-1 control-label&quot;&gt;收货人&lt;/label&gt;
        &lt;div class=&quot;col-sm-5&quot;&gt;
            &lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;username&quot; id=&quot;inputPassword3&quot;
                placeholder=&quot;请输收货人&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;form-group&quot;&gt;
        &lt;label for=&quot;confirmpwd&quot; class=&quot;col-sm-1 control-label&quot;&gt;电话&lt;/label&gt;
        &lt;div class=&quot;col-sm-5&quot;&gt;
            &lt;input type=&quot;text&quot; name=&quot;phone&quot; class=&quot;form-control&quot; id=&quot;confirmpwd&quot;
                placeholder=&quot;请输入联系方式&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/form&gt;


&lt;hr /&gt;

&lt;div style=&quot;margin-top: 5px; margin-left: 150px;&quot;&gt;
    
    
    &lt;hr /&gt;
    &lt;p style=&quot;text-align: right; margin-right: 100px;&quot;&gt;
        &lt;a href=&quot;#&quot; onclick=&quot;submitOrder()&quot;&gt;
            &lt;img src=&quot;./images/finalbutton.gif&quot; width=&quot;204&quot; height=&quot;51&quot;
            border=&quot;0&quot; /&gt;
        &lt;/a&gt;
    &lt;/p&gt;
    &lt;hr /&gt;

&lt;/div&gt;
</code></pre>
<p><strong>ProductServlet.java</strong><br>在ProductServlet的doGet方法中添加submitOrder的判断并完成submitOrder方法。</p>
<pre><code>public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
    String method = request.getParameter(&quot;method&quot;);
    if(&quot;getProById&quot;.equals(method)) &#123;
        getProById(request, response);
    &#125;else if(&quot;findListByCate&quot;.equals(method)) &#123;
        findListByCate(request, response);
    &#125;else if(&quot;cart&quot;.equals(method)) &#123;
        cart(request, response);
    &#125;else if(&quot;delCart&quot;.equals(method)) &#123;
        delCart(request, response);
    &#125;else if(&quot;clearCart&quot;.equals(method)) &#123;
        clearCart(request, response);
    &#125;else if(&quot;showOrder&quot;.equals(method)) &#123;
        showOrder(request, response);
    &#125;else if(&quot;submitOrder&quot;.equals(method)) &#123;
        submitOrder(request, response);
    &#125;
&#125;

public void submitOrder(HttpServletRequest request, HttpServletResponse response) &#123;
    // TODO Auto-generated method stub
    try &#123;
        String oid = request.getParameter(&quot;oid&quot;);
        System.out.println(&quot;oid&quot; + oid);
        String username = request.getParameter(&quot;username&quot;);
        String address = request.getParameter(&quot;address&quot;);
        String phone = request.getParameter(&quot;phone&quot;);
        
        Order order = new Order();
        
        order.setAddress(address);
        order.setName(username);
        order.setTelephone(phone);
        order.setOid(oid);
        
        ProductService ps = new ProductService();
        ps.updateOrder(order);
        
        HttpSession session = request.getSession();
        session.removeAttribute(&quot;cart&quot;);
        session.removeAttribute(&quot;orders&quot;);
        
        response.sendRedirect(request.getContextPath() + &quot;/product?method=myOrder&quot;);
    &#125; catch (Exception e) &#123;
        // TODO Auto-generated catch block
        e.printStackTrace();
    &#125;
&#125;
</code></pre>
<p><strong>ProductService.java</strong><br>在ProductService中添加updateOrder方法。</p>
<pre><code>public void updateOrder(Order order) throws SQLException &#123;
    // TODO Auto-generated method stub
    ProductDao pd = new ProductDao();
    pd.updateOrder(order);
&#125;
</code></pre>
<p><strong>ProductDao.java</strong><br>在ProductDao中添加updateOrder方法。</p>
<pre><code>public void updateOrder(Order order) throws SQLException &#123;
    // TODO Auto-generated method stub
    QueryRunner qr = new QueryRunner(DataSourceUtils.getDataSource());
    
    String sql = &quot;update orders set address=?,name=?,telephone=?,state=1 where oid=?&quot;;
    
    System.out.println(order.getOid());
    
    qr.update(sql, order.getAddress(), order.getName(), order.getTelephone(), order.getOid());
&#125;
</code></pre>
]]></content>
      <categories>
        <category>项目经历</category>
        <category>JavaWeb</category>
        <category>基于JavaWeb的网上购物商城</category>
        <category>确认订单</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
        <tag>基于JavaWeb的网上购物商城</tag>
        <tag>确认订单</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 神经网络中的超参数</title>
    <url>/2021/06/30/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E8%B6%85%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h1 id="神经网络中的超参数"><a href="#神经网络中的超参数" class="headerlink" title="神经网络中的超参数"></a>神经网络中的超参数</h1><p><b>神经网络中常见的超参数：</b><br>1.隐藏层的大小n^[l](size of hidden layers)<br>2.学习率 alpha(learning rate)<br>3.迭代次数(number of iterations)<br>4.神经网络中的层数L(number of layers L in the neral network)</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>超参数</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习基础 | 神经网络模型概览</title>
    <url>/2021/11/05/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%A7%88/</url>
    <content><![CDATA[<p><a href="https://mp.weixin.qq.com/s/ds5YWmyIZTHW55Tkdf3pww">一文概览神经网络模型</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>神经网络模型</tag>
      </tags>
  </entry>
  <entry>
    <title>研究 | 科研方法分享</title>
    <url>/2021/11/05/%E7%A7%91%E7%A0%94%E6%96%B9%E6%B3%95%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<h1 id="科研方法分享"><a href="#科研方法分享" class="headerlink" title="科研方法分享"></a>科研方法分享</h1><h2 id="科研基本流程"><a href="#科研基本流程" class="headerlink" title="科研基本流程"></a>科研基本流程</h2><p><strong>选题 –&gt; 模型/算法设计 –&gt; 实验验证 –&gt; 论文写作</strong></p>
<p>论文=50% technique + 50% paper writing</p>
<p>关注技术、工作的价值、insight.</p>
<p><a href="https://mp.weixin.qq.com/s/n0Tl6dM7QCM07Ae01Edl4A">上海交大吴齐天的科研思考！</a></p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>科研方法</category>
      </categories>
      <tags>
        <tag>科研方法</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis | 秒杀</title>
    <url>/2022/05/07/%E7%A7%92%E6%9D%80/</url>
    <content><![CDATA[<h1 id="秒杀"><a href="#秒杀" class="headerlink" title="秒杀"></a>秒杀</h1><h2 id="秒杀需要解决的问题"><a href="#秒杀需要解决的问题" class="headerlink" title="秒杀需要解决的问题"></a>秒杀需要解决的问题</h2><p>解决商品库存计数器和秒杀成功的用户记录的事务操作</p>
<h2 id="秒杀遇到的三个问题"><a href="#秒杀遇到的三个问题" class="headerlink" title="秒杀遇到的三个问题"></a>秒杀遇到的三个问题</h2><p>1.连接超时问题 —&gt; 使用Redis连接池<br>2.超卖（卖出的商品数量超过商品库存数量） —&gt; 使用事务<br>3.库存遗留问题（并发的请求中只有一个请求能够秒杀成功造成库存遗留） —&gt; 使用lua脚本</p>
<span id="more"></span>
<p>1.index.jsp</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;iPhoneXsMAX !!!  1元秒杀！！！
&lt;/h1&gt;


&lt;form id=&quot;msform&quot; action=&quot;$&#123;pageContext.request.contextPath&#125;/doseckill&quot; enctype=&quot;application/x-www-form-urlencoded&quot;&gt;
    &lt;input type=&quot;hidden&quot; id=&quot;prodid&quot; name=&quot;prodid&quot; value=&quot;0101&quot;&gt;
    &lt;input type=&quot;button&quot;  id=&quot;miaosha_btn&quot; name=&quot;seckill_btn&quot; value=&quot;秒杀点我&quot;/&gt;
&lt;/form&gt;

&lt;/body&gt;
&lt;script  type=&quot;text/javascript&quot; src=&quot;$&#123;pageContext.request.contextPath&#125;/script/jquery/jquery-3.1.0.js&quot;&gt;&lt;/script&gt;
&lt;script  type=&quot;text/javascript&quot;&gt;
$(function()&#123;
    $(&quot;#miaosha_btn&quot;).click(function()&#123;     
        var url=$(&quot;#msform&quot;).attr(&quot;action&quot;);
         $.post(url,$(&quot;#msform&quot;).serialize(),function(data)&#123;
            if(data==&quot;false&quot;)&#123;
                alert(&quot;抢光了&quot; );
                $(&quot;#miaosha_btn&quot;).attr(&quot;disabled&quot;,true);
            &#125;
        &#125; );    
    &#125;)
&#125;)
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p>2.SeckillServlet.java</p>
<pre><code>public class SecKillServlet extends HttpServlet &#123;
    private static final long serialVersionUID = 1L;
       
    /**
     * @see HttpServlet#HttpServlet()
     */
    public SecKillServlet() &#123;
        super();
        // TODO Auto-generated constructor stub
    &#125;

    /**
     * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)
     */
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        // TODO Auto-generated method stub
 
        String userid = new Random().nextInt(50000) +&quot;&quot; ; 

        String prodid =request.getParameter(&quot;prodid&quot;);
        
        boolean if_success=SecKill_redisByScript.doSecKill(userid,prodid);
 
        response.getWriter().print(if_success);
    &#125;
&#125;
</code></pre>
<p>3.JedisPoolUtil.java</p>
<pre><code>package com.atguigu;

import redis.clients.jedis.Jedis;
import redis.clients.jedis.JedisPool;
import redis.clients.jedis.JedisPoolConfig;

public class JedisPoolUtil &#123;
    private static volatile JedisPool jedisPool = null;
 

    private JedisPoolUtil() &#123;
    &#125;

    public static JedisPool getJedisPoolInstance() &#123;
        if (null == jedisPool) &#123;
            synchronized (JedisPoolUtil.class) &#123;
                if (null == jedisPool) &#123;
                    JedisPoolConfig poolConfig = new JedisPoolConfig();
                    poolConfig.setMaxTotal(200);
                    poolConfig.setMaxIdle(32);
                    poolConfig.setMaxWaitMillis(100*1000);
                    poolConfig.setBlockWhenExhausted(true);
                    poolConfig.setTestOnBorrow(true);  // ping  PONG
                 
                    jedisPool = new JedisPool(poolConfig, &quot;192.168.223.132&quot;, 6379, 60000 );
             
                &#125;
            &#125;
        &#125;
        return jedisPool;
    &#125;

    public static void release(JedisPool jedisPool, Jedis jedis) &#123;
        if (null != jedis) &#123;
            jedisPool.returnResource(jedis);
        &#125;
    &#125;

&#125;
</code></pre>
<p>4.Seckill_redisByScript.java</p>
<pre><code>public class SecKill_redisByScript &#123;
    
    private static final  org.slf4j.Logger logger =LoggerFactory.getLogger(SecKill_redisByScript.class) ;

    public static void main(String[] args) &#123;
 
 
        JedisPool jedispool =  JedisPoolUtil.getJedisPoolInstance();
 
        Jedis jedis=jedispool.getResource();
        System.out.println(jedis.ping());
        
        Set&lt;HostAndPort&gt; set=new HashSet&lt;HostAndPort&gt;();
        
    //    doSecKill(&quot;201&quot;,&quot;sk:0101&quot;);
    &#125;
    
    static String secKillScript =&quot;local userid=KEYS[1];\r\n&quot; + 
            &quot;local prodid=KEYS[2];\r\n&quot; + 
            &quot;local qtkey=&#39;Seckill:&#39;..prodid..\&quot;:kc\&quot;;\r\n&quot; + 
            &quot;local usersKey=&#39;Seckill:&#39;..prodid..\&quot;:user\&quot;;\r\n&quot; + 
            &quot;local userExists=redis.call(\&quot;sismember\&quot;,usersKey,userid);\r\n&quot; + 
            &quot;if tonumber(userExists)==1 then \r\n&quot; + 
            &quot;   return 2;\r\n&quot; + 
            &quot;end\r\n&quot; + 
            &quot;local num= redis.call(\&quot;get\&quot; ,qtkey);\r\n&quot; + 
            &quot;if tonumber(num)&lt;=0 then \r\n&quot; + 
            &quot;   return 0;\r\n&quot; + 
            &quot;else \r\n&quot; + 
            &quot;   redis.call(\&quot;decr\&quot;,qtkey);\r\n&quot; + 
            &quot;   redis.call(\&quot;sadd\&quot;,usersKey,userid);\r\n&quot; + 
            &quot;end\r\n&quot; + 
            &quot;return 1&quot; ;
             
    static String secKillScript2 = 
            &quot;local userExists=redis.call(\&quot;sismember\&quot;,\&quot;&#123;sk&#125;:0101:usr\&quot;,userid);\r\n&quot; +
            &quot; return 1&quot;;
 
    
    public static boolean doSecKill(String uid,String prodid) throws IOException &#123;

                JedisPool jedisPool = JedisPoolUtil.getJedisPoolInstance();
                
                Jedis jedis = jedisPool.getResource();
                
                String sha1=  jedis.scriptLoad(secKillScript);
                 
                Object result= jedis.evalsha(sha1, 2, uid,prodid);  
 
 
                String reString=String.valueOf(result);
                if (&quot;0&quot;.equals( reString )  ) &#123;
                    System.err.println(&quot;已抢空！！&quot;);
                &#125;else if(&quot;1&quot;.equals( reString )  )  &#123;
                    System.out.println(&quot;抢购成功！！！！&quot;);
                &#125;else if(&quot;2&quot;.equals( reString )  )  &#123;
                    System.err.println(&quot;该用户已抢过！！&quot;);
                &#125;else&#123;
                    System.err.println(&quot;抢购异常！！&quot;);
                &#125;
                jedis.close();
        return true;         
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Redis</category>
        <category>秒杀</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>秒杀</tag>
      </tags>
  </entry>
  <entry>
    <title>入门指南 | 程序员必备的8大学习网站</title>
    <url>/2021/02/20/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%E7%9A%848%E5%A4%A7%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h1 id="程序员必备的8大学习网站"><a href="#程序员必备的8大学习网站" class="headerlink" title="程序员必备的8大学习网站"></a>程序员必备的8大学习网站</h1><table>
<thead>
<tr>
<th>网站</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>github</td>
<td>代码托管平台</td>
</tr>
<tr>
<td>stackoverflow</td>
<td>技术问答</td>
</tr>
<tr>
<td>leetcode</td>
<td>刷题讨论 码不停题</td>
</tr>
<tr>
<td>bilibili</td>
<td>学习</td>
</tr>
<tr>
<td>牛客网</td>
<td>应届毕业生找工作的天堂</td>
</tr>
<tr>
<td>papers with code</td>
<td>论文+代码</td>
</tr>
<tr>
<td>菜鸟教程</td>
<td>技术手册</td>
</tr>
<tr>
<td>W3School</td>
<td>技术手册</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>入门指南</category>
      </categories>
      <tags>
        <tag>程序员必备的8大学习网站</tag>
      </tags>
  </entry>
  <entry>
    <title>小说 | 研究生第一本书-恶意</title>
    <url>/2020/10/08/%E7%AC%AC%E4%B8%80%E6%9C%AC%E4%B9%A6/</url>
    <content><![CDATA[<h1>研究生第一本书-恶意</h1>
“<strong style="color:red">这个世界上有两个东西不能直视，一个是太阳，一个是人心。</strong>”
<span id="more"></span>
晓燕老师在微博视频中提到一本书-恶意，开头这句活是这本书中一句特别经典的话：正是冲着这句话，我读完了恶意这本书。

<p>这本书是由日本著名作家-东野圭吾写的，书中主要说了一个人由于嫉妒一位朋友（这位朋友是他小时候的好朋友）的文学才华，<br>这恶意深不见底，于是最后杀害了自己的这位朋友；然而朋友的死亡任然不能了却他心中的仇恨、恶意，他精心谋划杀害并企图<br>让这位朋友身败名裂；</p>
<p>这本书中有这样一句话：“<strong style="color:red">在你的心中深藏着对他的恶意，这仇恨深的连你自己都无法解释<br></strong>”</p>
<p>别人对你的恶意是没有理由、没有原因的，因此我们能做的只有做自己。</p>
<p>因为“这个世界上有两个东西不能直视，一个是太阳，一个是人心。”这句话读这本书，从始至终我也试图在书中遇到这么一句话，<br>然我翻到书最后一页也没有见到这句话。后来在网上得知，这句话藏在东野圭吾写的另一个优秀作品-《白夜行》里面。</p>
<p><img src="/2020/10/08/%E7%AC%AC%E4%B8%80%E6%9C%AC%E4%B9%A6/%E6%81%B6%E6%84%8F.jpg" alt="恶意"></p>
]]></content>
      <categories>
        <category>书籍</category>
        <category>小说类</category>
      </categories>
      <tags>
        <tag>恶意</tag>
      </tags>
  </entry>
  <entry>
    <title>人生经历 | 第一次工作面试</title>
    <url>/2021/07/07/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="f14616c556d44103c9ff2b86aa1ee0f52f97227630385289e35a7db8f991ddee">5fa8d7dd4aaa9bde3945cea575f036350644f9a4f5c0b32d0d2de067b73e8ac8bf4e611e865e7ed9b29692f3df8d4b6a978e485acefe710776ac7f50bf5f51f7a4a99a71a01878e93d058395d5d93a2b9cc22097e99ae920538312efdd5e286a81da9d1b736a71d9a123f9d6ea25c731067e47d6f160862fa960c95bfdf6175be9186f5aaa2d2c5c897afbcb2b94c610c5512f72bf7617c6701cdca762cc3e7e837e37e4a1566f9780c15d0a8fa6d7bd65c49c7a981d3f38c3d20d8758aa6a4b8a1478761d32b4b5ae7de43a0a490b5a2c94ecf372831a19b4154eaa2711a71b3f0fec9d024b30616a94e4bf991657c3b4fd4482a97bd7478f591a0f30b9336aeede5ead853486506ad22a9c79140833e2390da1c4e4edc6834e3b14ce2c83277c21930fdf394ed5c39da49d30f37fee48548f5b0733d7527a9b8b9893617eee2090d644a477d0ec91f27c913af1d3000517258e15ef02b32fa87a40ae0d30cb58004073b3ca2f4f750f0438527390c2102cd4ea275d7d1a15cfec872e6c537efbfd6933a029493422463fde13170d18e7d42ac1b6cbfd9490883cc7c7701531c0623fea48fef6e6e5111aa1954f7117a3cbb1c8d856d8918d29083c4efd819e18db923205a73c27ab7a5f5dd635ff805bdd20f4170cef0d9e4cb38469d791b0728d4ecb84cbcad6ae4d92121d673a3e5ee8b12d1747aa94827da11c050dc938ccd35015545a3cdde889afd7a39515544219b7155b6b1108bd5bb882f40f319fd9d29584556ee7abb7ec7d88a76e4b0c3b63e9c96031b2e11724202acc9c3bc19e94023d8567f7bd82ffac553e52b25bbe489c2e31a91df601a6ef3191aef1053226c63ae66523dc5feec275a15baf05b553459c88410a6b10b61eb274d4e2756d1ff9e2e00e44214f597e6afc2c46cdf6b467b0464c70d534c285a2cd163cc534da9f600d56f5e6f5f1b85b148126f95bc3758acc01848f6f183788210c41559e055514df93a6e4271d5952cddf91fdbe7a9ab3752a7452ceb2b1907f5794fc92cb900dbbf392bd9b84b92627dc030d9995a4eafba8b8a7d0756760d6dc016c3697d619a906833e7128b0873dd0fee83eb49c2f21720faa8f1667766db7cb5efe92ceda0feaa256dc2ab09521d3d988173f8787bafe67fb36294ae9ac79f808d6cdf0467eabb97fedaaa0fa3007b322cdcf6190280dfed2392677b191a3db99cedc37550f5e7cd9d5cd2e196ce175ebce80c23b22b6b467290c8a8204b4d6eb4996a389ba7ebe20256bf80a1551ffdb51b490e62cac8534d2a237cbd65617601f8d2680cd9f90bd139c4325e15a151921c6022bb768fbb4e3a44b34056649b7edb2119e5dccc1804f29f32000cbc9a423ce92a11ef7599594af177e0c6f5c934e99b7098cd4a3e99ab9f59fe1958e676cba2626b63adbbdaf7d4c24e5bfe630ef64d56bc53109a5ced9a159ecefba9ef1f96952e6675bc39a24a773bb60ad4bb2f43ea7da2b6547665e110c260ab908f2c1cca89bd55143f4c60af93acaf42d6aaffdc087e491e75f976dce57670e07ca54e77eb62121386597978e80946c9d2ac381140526f8cc13bf2c8b4ce6d9e8a70552181a001a70e87f0ed20a3220c5263b5f440df845e771eae54b49fa433a5467a6a0d17d96131d21dee9695b0eb02455a94269d1d0c012ae2e8eb1a37fc1be0c53cc0532e1d4c7f3e070cfcc89b2037b2dce453c3c7e2b243d18ce10122d1aa4ec87a28a4917f870fef44c1c2a9befef260b684ddf9e430258e397a81c60756995567cf6d3fc3cb705f21078636f2b32a909f9afead9f0cd08cc0316c39231594546a7be17f3399fc6bdd643c1a6e38a36d7f69565d9df0e0fb5e43a88b6775f39cdc658b52e5810062ad1be66b4460059e32a376a33409caa4f94a9ac2edeb27dd855a886d5de400e40edcffaca468c906d8fbf180d43111956c13dff1ddbe4f4b8bdb2eba1a4e429efd7010f65c433d5481196a24b124fac4ebd75156e402ffc312cd5e65b94e8c225754d2841b31e2eae44524d7e7c1155b4ae502bd5311676a80b168ee125b8ee695d51d3600370205bf8bb82137740df4cdc526b634d97f6b41105580ddf0fed974101a65e570e3c2cc699e51cde9c3dd921b3466bc2d5a2928c0bdce3d4e462a47e8ed421d4a39981e9c5f18bdf2903d2c64a243d72ffc3745c74efe16b35417845de495d3bb5e09f9ccede446fa201967c58c9c82a99643e06f63841369903bcc9d5e98d0cc025e09b7b8ed0ce9960a80e0a34432a82992a9a5c863990561c0781c1a2e64999127f8507d3e315a047f42a57294f8723ae0e36f9a213bed96e0dc7272c1bcd944c45313a212e3d16d9b738006aac517e9364c4ad6f25cff848996ba28d94812e85509680dfdd3cc513ab7a971d1f00a486ca98f3b311c413d0bbc58cf6908eaef31ae5ca66d93b643322080918a11da928ad77e31bb8c9c6390ac3b7ca97c1f2bbce3a88b7cda4cdf2741068a22315ee7d4890d429759ef49df2f79526695f8d659e49aae30330027f15d73d19d70681343495908d97075dc74cafb0b2c700a4c0b835939d6a06eff598c601896992e7bb5a6a3dca92fb5c6fa7257287d11ffdbbd60ac640b4a54e9630507c2bc71a5bfd9d7a8254543efd696576e81446ba6a93b5126350d28f8eee8c42ebadb22ff1dd85949f37df5c848bf69b667f2f4d18139d022860a41bc03b03be947bed1c1fec906527588921c83228ffaca5ebe297294b8e9dd4570eba26d74c652889f75936616b6ae6c1707e72a2b29f254b62147577bbbf585e1db1462782844905b173eafcedb8319861daf37c3de30b89e2b9c146827b18ebcf41c3cf4824d00fa69fe86e060b994d7480c5e8dba591a12c97dd50ab8380edd716c6eb7a34c2d889cc712bb7e46215c4029e2446a7d124a2bf7ddd5b175c40029213348a0f8e8bbbec537cb1f50a06c73acc4559a5b1f13d22832d9c7437d5e44b4e948bba1730844abe0eb5f0ce1d8b3354375eaade88154089148d278b0cf9294c8a55e65ec619a1066284b5c46edbda77a6695eab1987ee9d482f2ec7e2a7a7d46a1e677b3ddc244fba2361d68a2f875aaa4ba5b6504a7d9c03925c0b7af814c1a127e2ac07c2458bea892d5c277f078f9c7717024aced6b2e3629286ecca0144632e73bd6f03a765396425b3fd8b8c043edb1f234bd40c6752ffedbaf8dbc2b1e587617053fb3da887679829e25c6cf7c82900d3aba440190090a5735ed0348cef10d25a2e0d5f7dea154e0aa2780f19c2d9282c8bed4d90e6072827d03404ab11f4be57be94cfc408a98f84c45716c3cd3f66835d8981f8601994289ee62b7f0f9dbbc2d64517aa4733b5d01c0eaa95c395476b884ebc1336a1dd7be1d5cef0b1909a07aa7e16b92d57a2ca8bf448784181123e4e546d5d95bc365698ca573d33945b3bd5bfeb8182cd9b62f5645a63a47c0e6f412ddbe5b99ba9a14c9ca17cb51ae7c2b46e85760e5e154321c205f212dee929ee0bc8d59389c306304f7987fe92d6fd41d09920782c31c189f86db261bdf1fed28cf8dc27354ca33ed1705c5ddae446388910199207b20787a439ab09b7c7d2c02ce323332bf9f3d5e8dce840cd2bdcca073f2d9d221b29436839514015983228ff2d0df2c5eaeaea601d66bc967659222cde4ca70157ece8c5987b687cd3e6555c9b095f0ac03a1a3185733bfae1f8bab7f1642d85b717ed4bad58757bf7289afe18ab6871a4aee9c6682d7514dfb1252bb84bb5532b998b99b8c561e69ef5955af46f0b9b14542fca37b65f093004be0cf329cc5325682f0431dccb512a1961303151a81d206ea7e8a9f2b24c8d3f0054af9d6033e315222d62d4689016dc4d5dd8e8515628ca5f8b691c52fcc3638da76bbd06ed3c544c0826656193894733114f0db965d0e9cecaec42c1272fcf92850aacd9e85607410dae688f61bc9bd48db6e968a376449336752a18635c4aaef648cd6204d43180491f8d1ca14ae65574294cc1d36dd39c41e5a74c5a55315e5cdd2ef517d9f39bdbe6b28ca29e5f1a137b3b0663b29c201a5b942d0d063c8f782f3891794c956ab6861aa9b1888acfda8fc4d5ef80849faa31ad44efdb258947fe595686a7c0e1c90d25192d007b3adcb4abd638d6c93f40ea26277382096110574c0f8c0dfb570799675e76e232e7424f8710919524b3e0cc552b5779512b55621eafe1d24009caf6ebac0b0943a758743972070743826c28bc61587b8ddb6d930c3e1ddce11ed6932b755e01cff4f32533af10f68cd78d559fdcd5668365732d0e6a59648dfe5a7c383597beb7061a16b1206df301389c2ecf3a0f820489cec622e50371e5f5e7f91c15f535dc67f7816407d2cbc25f135e8cefb40e247f8b59a246999c32253c8fbbb376dd4c293ff15591b538ec9591b8fc2c64018e17d2d47648e2434c8c1e6c9b98f4fefd180809f6681b6839ec608bcf3851d7ad1df7d92356ae71295aac44d930120108b5a069ca0482c0486d4ced50e24e0e73f89cc539ea5cf09a69e8852943171b713cb8549fa44a300fad9d610e07bcd21748711eb343f256c0d1364a4f819650451274921d5e2d603dd6f7de983383907104d4f795bee4f151c1a24cfa1c39817bd6072b8675e5922bb662c7f096e3f7b5d25148d1e40569d219b09c773e8871348f2221f53e3c932a21930af820398148f70485d3bb08c92c13a2bb298b690b260d22cb2999e7086e241f9c3f1b29ed3e83e31c4bc562d707c07a6ebd1067ea66289e16a2c784a8637ea203bd64e3bb08315bc9d597f2131602df234cf5bf7af8938d79ebfda8473897c1cde5e3739ba68198b81b0a20337aa78ada19dcf70c9f6830d2a20bad263eb440c3883710849673f3e9c733b06d0e9641ddc5a2f8454580e5af74fb24ed7c9937d90d4128e4bdaa3862f5c433130a0aaf3c0194dc45cc3500cb5be5968b0ffef55d9840991ababd9b92ecb1a26a7076cb3a7f78c293b60e27850ae7b42f556e8989ad1e4fbe1583489970fe0b111a43cf8a0077593d5a8cc24f886d06fd9056aee01c413ba5dd848e25a6eb08e59d7de5c19fdfe8d7e01d4e848fb7c6c254df14296ea5fdf799cb6a287d857d5f9f7d700bae210c24dc634cfdb522ee0d5cc260752b68c72f7f7d06fa96442156599ca72a4c5d271ce713eccb29b65d81b79d20593f65bcd7e16e946c16a85aba9adccac1c9ede154d372b9a334a6f7aea78bb1adb1c3c0a23e263e8c8cabf71190e29d91d5283d8a1d8173820bd5f8ac288174ed24484fa2996e4adef142c5f26f77477003037885b5b77ca31657132089d859416a06998f3ff3b3a6eec9289cfe183e806aed3f1c9642236029373ed5e3f39c9f19eac9769f5594b1517bee0f195f7a0a60dd5246e46d4d4cec7f47c81cd0ae8d5dd60d1f5ee580dae0577e6231e31a924009ee6405227f0f76e41a07c68263425d7537bcda044d5ea7cdfe04b5464cbbca064bb3d5c20ad0592bbaee16f4a08141ad269544f82703120744e5420c871306790d73b5f7c56fd9d323914e854d6afa80d86baba4606d223f1160545275372ad75716090ba94dedae83300bdb63036e12e2e40ee9b3205d60e239e51ad3873694769ea36007a4030fcbeb3af9808c516e360153a8d3c8b076f274e621c7e816d93f4fc49cca6a09f1e9b519f15d559af05d5bc4ae26fa673d482396b64ce79be4de5a3e77768d7c439493bc0b2d4a9cef624d8c0d61d066425df1283ec3adb6d46119f33348cc061922cb2182ee42841929438411c01f63c30976f2b6dc289a67ed5d5be6594a9f05b9ba7f52278a530709aa63eafeea0a90effe12f23bbce3f6250f25dc272f9a7f3c586d9b92f7a6cc92a7baa56ce491c16ede99e26295c839374fc9660dd00de279c86d4689b36ae569bb4fc14cac86e6532d8fd2e5b0e0cd37e860a09ec2b135e3ad2f0a042e08bb7e70d3f615555c70eba08d4c4ef948922a93d982f47fbaf237dfd71b5fc4cf14863cb5d365e310960cf1e63f751baca49697c383750ac3553f13f28f4ae81b6dd67b1a0c71ceffc99b3933e4505564ff1d70ddd834dc8c43c74ef4cf7dced6a87083ec0964e668e7383815c06df990b7f488ad0714348b7af4071ab78b97c73521ecf9015aa66e4a89c7ad42f121fafdb1f408718b05589a513cc0bcabc7d1bb837b2fcfa6e2d0a9f187743b7f8b3c61014ef4a0f83669bcd437db69283e4700bc3714728972b5f195ca5b7e0febc331aed2b6d8e4316b9c40c867ca166b69c3e5966378e4f59dfec81f39a9040beea458ba07ed1224ac616c223614327c44ad1b832842303e5eee0aca2036198a685cf7ae07f480a20047f421b4dd99e61953ea7c6ed05f58367776f33138a21db6c6dffa66c0bfd6d0c4cd5b3c272c33aa49f8a4595bbdafc5824deb2bd1846c8d0277653294911f3f483397fee7ff7617ea8c3ab3e300566b77d8cadad260703ed2d038cdf03d1482dbda9b03489b9c15c373da8f813021193440aa84c5a8d42df6eb9e0cb7649dfc00250dbe67df126d575b3123b5aa761a0762ea8d6c709260b4f1def3a8596339c2c19778fefcb448d8143485bf9f00f1e8c6ea7896c046489b9b95806c0f5eb0c1ef7ac9d0cd6a0a51cc3fcc1f0d0330725f94d2eaf63eeb0bc52f3c1ea92b77f916a26e9acb3df6cc5cfb3a7c035cfb660fe46dca4f254e80c9cf00eaafc7b7e6207636a5c6238b721c14ae319ca092bbffb8a23f661a1fb3e557e98c811a891ff7cac213b41ccb6ec7c998ce907c7610dd180e838947741993bc477dc384f33340d70872375d255a4ee3e324e96d6438ec5b2c12ff4739a12c3a7c6a3665411c74661f8e90b3ebbfbb18ef2a71ceed01b8b396084760ec7420ee3e0da2669d31abd36916257859481301c23cd7c357a889fd0e9bddc85b762640faa6caf8a222bcab326578b01ff14d9d8493682d3f3c8dc15ef26fdfd355019765f7fc55522a76be92b3e110f6dfd9a453cb43c3489b2bed2697b9b234aa2be55b76e2913611179c60e17094784af977dc3aa8b6e899e7fc72d4ea1955af0b8c3cc60200273465c4ef8b6a45639fc36c6101d751d0ac224f0f36f604c86cea28a647b35e165210ea2425615c739473c7cf8e5db1ad22fea646c2602b18a11faf5f18775eba48273048903e2d35382ea6095070879901992336dc6f392fcfe28ad5ac45a28ff64185aa780f287a3ca2f38afdd269098806dcf27d08f932f34d223e65c91f77460ff700eb372ba55ed9e78abbfa5e4898b3f6bb85420053589d8e141e374ec1d9c682f8c2e46ab5c4f599606ee7d90e045cd82f8087e0c467cfebe24d138aecdc08a2f70ed2e8628cee653c8be507e021b9f136a5152637bab5daadbe</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>人生经历</category>
        <category>工作</category>
      </categories>
      <tags>
        <tag>人生经历</tag>
      </tags>
  </entry>
  <entry>
    <title>并发 | 等待/通知机制</title>
    <url>/2022/05/28/%E7%AD%89%E5%BE%85-%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h1><p>等待通知机制，是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或着notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。<br><strong>示例代码</strong></p>
<pre><code>package concurrency;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.TimeUnit;

public class WaitNotify &#123;
    static boolean flag = true;
    static Object lock = new Object();
    
    public static void main(String[] args) throws InterruptedException &#123;
        Thread waitThread = new Thread(new Wait(), &quot;WaitThread&quot;);
        waitThread.start();
        TimeUnit.SECONDS.sleep(1);
        Thread notifyThread = new Thread(new Notify(), &quot;NotifyThread&quot;);
        notifyThread.start();
    &#125;
    
    static class Wait implements Runnable&#123;
        @Override
        public void run()&#123;
            //加锁，用于lock的Monitor
            synchronized(lock)&#123;
                //当条件不满足时，继续wait，同时释放了lock的锁
                while(flag)&#123;
                    try &#123;
                        System.out.println(Thread.currentThread()+&quot; flag is true. wait@ &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));
                        lock.wait();
                    &#125; catch (InterruptedException e) &#123;
                    &#125;
                &#125;
                //条件满足时，完成工作
                System.out.println(Thread.currentThread() + &quot;flag is false. running@ &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));
            &#125;
        &#125;
    &#125;
    
    static class Notify implements Runnable&#123;
        @Override
        public void run() &#123;
            synchronized(lock)&#123;
                //获取lock的锁，然后进行通知，通知时不会释放lock的锁
                //直到当前线程释放了lock后，WaitThread才能从wait方法中返回
                System.out.println(Thread.currentThread() + &quot; hold lock. notify @ &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));
                lock.notifyAll();
                flag = false;
                SleepUtils.second(5);
            &#125;
            
            //再次加锁
            synchronized(lock)&#123;
                System.out.println(Thread.currentThread()+ &quot;hold lock again. sleep@ &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));
                SleepUtils.second(5);
            &#125;
            
        &#125;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
        <category>等待/通知机制</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>等待/通知机制</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程 | 等待线程结束</title>
    <url>/2021/08/05/%E7%AD%89%E5%BE%85%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9D%9F/</url>
    <content><![CDATA[<h1 id="等待线程结束"><a href="#等待线程结束" class="headerlink" title="等待线程结束"></a>等待线程结束</h1><p><strong>等待线程结束：</strong> 一个线程（假设是主线程）需要等待另外一个线程（假设是t1子线程）执行结束才能继续执行。<br><strong>实现：</strong> 通过调用join(timeout=None)方法<br>参数timeout用来设置超时时间，单位为秒。如果没有设置timeout，则可以一直等待，知道结束。</p>
<span id="more"></span>
<p><strong>实例代码：</strong></p>
<pre><code># coding=utf-8

import time
import threading

# 共享变量
value = []  # 多个线程都可以访问的变量


# 线程体函数
def thread_body():
    # 当前线程对象
    print(&#39;t1子线程开始...&#39;)

    for n in range(2):
        print(&#39;t1子线程执行...&#39;)
        value.append(n)
        # 线程休眠
        time.sleep(2)

    print(&#39;t1子线程结束。&#39;)


# 主线程
print(&#39;主线程开始执行...&#39;)
# 创建线程对象t1
t1 = threading.Thread(target=thread_body)
# 启动线程t1
t1.start()
# 主线程阻塞，等待t1线程结束
t1.join()
print(&#39;value = &#123;0&#125;&#39;.format(value))
print(&#39;主线程继续执行...&#39;)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>内置模块</category>
        <category>threading</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>多线程</tag>
        <tag>threading</tag>
      </tags>
  </entry>
  <entry>
    <title>并发 | 等待超时模式构造简单的数据库连接池</title>
    <url>/2022/05/28/%E7%AD%89%E5%BE%85%E8%B6%85%E6%97%B6%E6%A8%A1%E5%BC%8F%E6%9E%84%E9%80%A0%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="等待超时模式构造简单的数据库连接池"><a href="#等待超时模式构造简单的数据库连接池" class="headerlink" title="等待超时模式构造简单的数据库连接池"></a>等待超时模式构造简单的数据库连接池</h1><p><strong>ConnectionPool.java</strong></p>
<pre><code>package concurrency.connetionPool;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.sql.Connection;
import java.util.LinkedList;
import java.util.concurrent.TimeUnit;

class ConnectionDriver&#123;
    static class ConnectionHandler implements InvocationHandler&#123;
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
            if(method.getName().equals(&quot;commit&quot;))&#123;
                TimeUnit.MILLISECONDS.sleep(100);
            &#125;
            return null;
        &#125;
    &#125;
    
    //创建一个Connection的代理，在commit时休眠100毫秒
    public static final Connection createConnection()&#123;
        return (Connection) Proxy.newProxyInstance(ConnectionDriver.class.getClassLoader(), new Class&lt;?&gt;[] &#123; Connection.class &#125;, new ConnectionHandler());
    &#125;
&#125;

public class ConnectionPool &#123;
    private LinkedList&lt;Connection&gt; pool = new LinkedList&lt;Connection&gt;();
    
    public ConnectionPool(int initialSize)&#123;
        if(initialSize &gt; 0)&#123;
            for(int i = 0; i &lt; initialSize; i++)&#123;
                pool.addLast(ConnectionDriver.createConnection());
            &#125;
        &#125;
    &#125;
    
    public void releaseConnection(Connection connection)&#123;
        if(connection != null)&#123;
            synchronized(pool)&#123;
                //连接释放后需要进行通知，这样其他消费者能够感知到连接池中已经归还了一个连接
                pool.addLast(connection);
                pool.notifyAll();
            &#125;
        &#125;
    &#125;
    
    //在mills内无法获取到连接，将会返回null
    public Connection fetchConnection(long mills) throws InterruptedException&#123;
        synchronized(pool)&#123;
            //完全超时
            if(mills &lt; 0)&#123;
                while(pool.isEmpty())&#123;
                    pool.wait();
                &#125;
                return pool.removeFirst();//Removes and returns the first element from this list.
            &#125;else&#123;
                long future = System.currentTimeMillis() + mills;
                long remaining = mills;
                while(pool.isEmpty() &amp;&amp; remaining &gt; 0)&#123;
                    pool.wait(remaining);
                    remaining = future - System.currentTimeMillis();
                &#125;
                Connection result = null;
                if(!pool.isEmpty())&#123;
                    result = pool.removeFirst();
                &#125;
                return result;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>ConnectionPoolTest.java</strong></p>
<pre><code>package concurrency.connetionPool;

import java.sql.Connection;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicInteger;

public class ConnectionPoolTest &#123;
    static ConnectionPool pool = new ConnectionPool(10);
    
    //保证所有ConnectionRunner能够同时开始
    static CountDownLatch start = new CountDownLatch(1);
    
    //main线程将会等待所有ConnectionRunner结束后才能继续执行
    static CountDownLatch end;
    
    public static void main(String[] args) throws InterruptedException&#123;
        //线程数量，可以修改线程数量进行观察
        int threadCount = 50;
        end = new CountDownLatch(threadCount);
        int count = 20;
        AtomicInteger got = new AtomicInteger();
        AtomicInteger notGot = new AtomicInteger();
        for(int i = 0; i &lt; threadCount; i++)&#123;
            Thread thread = new Thread(new ConnectionRunner(count, got, notGot), &quot;ConnectionRunnerThread&quot;);
            thread.start();
        &#125;
        start.countDown();//使latch的值减1，如果减到了0，则会唤醒所有等待在这个latch上的线程。
        end.await();//使当前线程进入同步队列进行等待，直到latch的值被减到0或者当前线程被中断，当前线程就会被唤醒。
        System.out.println(&quot;total invoke: &quot; + (threadCount * count));
        System.out.println(&quot;got connection: &quot; + got);
        System.out.println(&quot;not got connection: &quot; + notGot);
    &#125;
    static class ConnectionRunner implements Runnable&#123;
        int count;
        AtomicInteger got;
        AtomicInteger notGot;
        
        public ConnectionRunner(int count, AtomicInteger got, AtomicInteger notGot)&#123;
            this.count = count;
            this.got = got;
            this.notGot = notGot;
        &#125;
        
        public void run()&#123;
            try&#123;
                start.await();
            &#125;catch(Exception ex)&#123;
                
            &#125;
            while(count &gt; 0)&#123;
                try&#123;
                    //从线程池中获取连接，如果1000ms内无法获取到，将会返回null
                    //分别统计连接获取的数量got和未获取到的数量notGot
                    Connection connection = pool.fetchConnection(1000);
                    if(connection != null)&#123;
                        try&#123;
                            connection.createStatement();
                            connection.commit();
                        &#125;finally&#123;
                            pool.releaseConnection(connection);
                            got.incrementAndGet();
                        &#125;
                    &#125;else&#123;
                        notGot.incrementAndGet();
                    &#125;
                &#125;catch(Exception ex)&#123;
                    
                &#125;finally&#123;
                    count--;
                &#125;
                
            &#125;
            end.countDown();
        &#125;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
        <category>等待超时模式构造简单的数据库连接池</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 | 简单工厂模式</title>
    <url>/2022/03/21/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p>工厂：用一个单独的类来完成创造实例的过程。<br><strong>案例</strong><br>类图：<br><img src="/2022/03/21/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/1.jpg"></p>
<pre><code>class Operation&#123;
    private double numberA = 0;
    private double numberB = 0;
    public double getNumberA() &#123;
        return numberA;
    &#125;
    public void setNumberA(double numberA) &#123;
        this.numberA = numberA;
    &#125;
    public double getNumberB() &#123;
        return numberB;
    &#125;
    public void setNumberB(double numberB) &#123;
        this.numberB = numberB;
    &#125;
    public double getResult() throws Exception&#123;
        double result = 0;
        return result;
    &#125;
&#125;

class Add extends Operation&#123;
    public double getResult()
    &#123;
        double result = 0;
        result = getNumberA() + getNumberB();
        return result;
    &#125;
&#125;

class Sub extends Operation&#123;
    public double getResult()
    &#123;
        double result = 0;
        result = getNumberA() - getNumberB();
        return result;
    &#125;
&#125;

class Mul extends Operation&#123;
    public double getResult()
    &#123;
        double result = 0;
        result = getNumberA() * getNumberB();
        return result;
    &#125;
&#125;

class Div extends Operation&#123;
    public double getResult() throws Exception
    &#123;
        double result = 0;
        if (getNumberB() == 0)&#123;
            throw new Exception(&quot;除数不能为0&quot;);
        &#125;
        result = getNumberA() / getNumberB();
        return result;
    &#125;
&#125;

//工厂：用一个单独的类来做这个创造实例的过程
class OperationFactory&#123;
    public static Operation createOperate(String operate)&#123;
        Operation oper = null;
        
        if(operate.equals(&quot;+&quot;))&#123;
            oper = new Add();
        &#125;else if(operate.equals(&quot;-&quot;))&#123;
            oper = new Sub();
        &#125;else if(operate.equals(&quot;*&quot;))&#123;
            oper = new Mul();
        &#125;else if(operate.equals(&quot;/&quot;))&#123;
            oper = new Div();
        &#125;
        return oper;
    &#125;
&#125;

public class SimpleFactoryTest &#123;
    public static void main(String[] args) throws Exception &#123;
        Operation oper = OperationFactory.createOperate(&quot;+&quot;);
        oper.setNumberA(1);
        oper.setNumberB(2);
        double result = oper.getResult();
        System.out.println(result);
    &#125;
&#125;
</code></pre>
<p>在使用简单工厂模式的情况下，如果我们要增加新的功能，比如说现在要增加一个求余操作，<br>我们需要增加一个用于求余运算的类，然后在OperationFactory中增加对于求余运算的逻辑判断，这样的做法违背了<br>开放封闭原则，即在开放拓展的同时也开放了修改。</p>
<pre><code>class Mod extends Operation&#123;
    public double getResult()&#123;
        double result = 0;
        result = getNumberA() % getNumberB();
        return result;
    &#125;
&#125;

class OperationFactory&#123;
    public static Operation createOperate(String operate)&#123;
        ......
        else if(operate.equals(&quot;%&quot;))&#123;
            oper = new Div();
        &#125;
        ......
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>简单工厂模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>简单工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程 | 线程停止</title>
    <url>/2021/08/05/%E7%BA%BF%E7%A8%8B%E5%81%9C%E6%AD%A2/</url>
    <content><![CDATA[<h1 id="线程停止"><a href="#线程停止" class="headerlink" title="线程停止"></a>线程停止</h1><p>在线程体结束时，线程就停止了。但在某些业务比较复杂时，会在线程体重执行一个“死循环”。线程体是够执行“死循环”是通过<br><strong>判断停止变量</strong>实现的，“死循环”结束则线程体结束，线程也就结束了。</p>
<p><strong>示例代码：</strong></p>
<pre><code># coding=utf-8

import time
import threading

# 线程停止变量
isrunning = True


# 工作线程体函数
def workthread_body():
    while isrunning:
        # 线程开始工作
        print(&#39;工作线程执行中...&#39;)
        # 线程休眠
        time.sleep(5)
    print(&#39;工作线程结束。&#39;)


# 控制线程体函数
def controlthread_body():
    global isrunning
    while isrunning:
        # 从键盘输入停止指令exit
        command = input(&#39;请输入停止指令：&#39;)
        if command == &#39;exit&#39;:
            isrunning = False
            print(&#39;控制线程结束&#39;)


# 主线程
# 创建工作线程对象workthread
workthread = threading.Thread(target=workthread_body)
# 启动线程workthread
workthread.start()

# 创建控制线程对象controlthread
controlthread = threading.Thread(target=controlthread_body)
# 启动线程controlthread
controlthread.start()
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>内置模块</category>
        <category>threading</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>多线程</tag>
        <tag>threading</tag>
      </tags>
  </entry>
  <entry>
    <title>并发 | 线程池</title>
    <url>/2022/06/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0-1/</url>
    <content><![CDATA[<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p><strong>线程池的实现原理</strong><br><img src="/2022/06/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0-1/1.jpg"><br><strong>线程池的使用</strong><br>（1）线程池的创建</p>
<pre><code>new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime,unit,workQueue, handler)

Parameters:
    corePoolSize: the number of threads to keep in the pool, even if they are idle, unless allowCoreThreadTimeOut is set
    maximumPoolSize: the maximum number of threads to allow in the pool
    keepAliveTime: when the number of threads is greater than the core, this is the maximum time that excess idle threads will wait for new tasks before terminating.
    unit the time: unit for the keepAliveTime argument
    workQueue：the queue to use for holding tasks before they are executed. This queue will hold only the Runnable tasks submitted by the execute method.
    threadFactory: set thread factory
    handler: the handler to use when execution is blocked because the thread bounds and queue capacities are reached
    
workQueue:
    ArrayBlockingQueue：基于数组结构的有界阻塞队列
    LinkedBlockingQueue：基于链表结果的阻塞队列
    SynchronousQueue：不存储元素的阻塞队列
    PriorityBlockingQueue:具有优先级的无限阻塞队列

handler:
    AbortPolicy:直接抛出RejectedExecutionException异常
    CallerRunsPolicy:使用调用者所在线程来执行任务
    DiscardOldestPolicy：丢弃掉在队列中存在时间最久的任务
    DiscardPolicy:默认丢弃任务，不进行任何通知
</code></pre>
<p><a href="https://victory-liao.github.io/2022/04/24/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%847%E4%B8%AD%E6%96%B9%E5%BC%8F/">创建线程池的7种方式</a><br><a href="https://blog.csdn.net/qq_45404693/article/details/121020639">Executor框架</a></p>
<span id="more"></span>
<p>（2）向线程池提交任务<br>    execute():用于提交不需要返回值的任务。<br>    submit():用于提交需要返回值的任务。<br>（3）关闭线程池<br>    shutdown()<br>    shutdownNow()<br><strong>线程池的配置</strong><br>（1）<br>CPU密集型任务：配置 CPU数量+1 个线程的线程池；<br>IO密集型任务：配置 2*CPU数量 个线程的线程池；<br>混合型任务：两个事务执行时间相差不大，如果可以拆分，将其分解成一个CPU密集型任务和一个IO密集型任务，如果两个任务的执行时间相差太大，则没有必要拆分。<br>（2）优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理，让优先级高的任务先执行。<br>（3）执行时间不同的任务可以交给不同规模的线程池来处理，或者可以使用优先级队列，让执行时间段的任务先执行。<br>（4）依赖数据库连接池的任务，因为线程提交SQL后选哟等待数据库返回结果，等待的时间越长，则CPU空闲时间越长，应该设置较大的线程数。<br>（5）建议使用有界队列。</p>
]]></content>
      <categories>
        <category>并发</category>
        <category>线程池</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>线程池</tag>
        <tag>Executor</tag>
        <tag>Executors</tag>
        <tag>ThreadPoolExecutor</tag>
        <tag>ScheduledThreadPoolExecutor</tag>
      </tags>
  </entry>
  <entry>
    <title>并发 | 线程池</title>
    <url>/2022/05/29/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>1.线程池的作用<br>对于服务器端的程序，如果服务端每接收到一个任务，创建一个线程，然后进行执行；这样的做法在面对成千上万的任务递交进服务器时，<br>那么会创建数以万记的线程，这样会时操作系统频繁的进行上下文切换，无故增加系统的负载，而线程的创建和小王都是需要好耗费<br>系统资源的，也无疑浪费了系统资源。线程池技术（通过使用固定或较为固定数目的线程来完成任务的执行）能够很好地解决这个问题，<br>消除频繁创建和消亡线程的系统资源开销。<br>2.线程池的本质<br>使用了一个线程安全的工作队列连接工作者线程和客户端线程，客户端线程将任务放入工作队列后便返回，而工作者线程则不断地从工作<br>队列取出工作并执行。当工作队列为空时，所有的工作者线程均等待在工作队列上，当有客户端提交了一个任务之后会通知任意一个工作者<br>线程，随着大量任务被提交，更多的工作者线程会被唤醒。<br>3.线程池示例<br><strong>ThreadPool.java</strong></p>
<pre><code>package concurrency.threadPool;

public interface ThreadPool&lt;Job extends Runnable&gt; &#123;
    //执行一个Job，这个Job需要实现Runnable
    void execute(Job job);
    
    //关闭线程池
    void shutdown();
    
    //增加工作者线程
    void addWorkers(int num);
    
    //减少工作者线程
    void remvoeWorkers(int num);
    
    //得到正在等待执行的任务数量
    int getJobSize();
&#125;
</code></pre>
<p><strong>DefaultThreadPool.java</strong></p>
<pre><code>package concurrency.threadPool;

import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.atomic.AtomicLong;

public class DefaultThreadPool&lt;Job extends Runnable&gt; implements ThreadPool&lt;Job&gt; &#123;
    //线程池最大数量
    private static final int MAX_WORKER_NUMBERS = 10;
    
    //线程池默认数量
    private static final int DEFAULT_WORKER_NUMBERS = 5;
    
    //线程池最小的数量
    private static final int MIN_WORKER_NUMBERS = 1;
    
    //这是一个工作列表，将会向里面插入工作
    private final LinkedList&lt;Job&gt; jobs = new LinkedList&lt;Job&gt;();
    
    //工作者列表
    private final List&lt;Worker&gt; workers = Collections.synchronizedList(new ArrayList&lt;Worker&gt;());
    
    //工作者线程的数量
    private int workerNum = DEFAULT_WORKER_NUMBERS;
    
    //线程编号的生成
    private AtomicLong threadNum = new AtomicLong();
    
    //工作者，负责消费任务
    class Worker implements Runnable&#123;
        //是否工作
        private volatile boolean running = true;
        @Override
        public void run()&#123;
            while(running)&#123;
                Job job = null;
                synchronized(jobs)&#123;
                    //如果工作者列表是空的，那么就wait
                    while(jobs.isEmpty())&#123;
                        try&#123;
                            jobs.wait();
                        &#125;catch(InterruptedException ex)&#123;
                            //感知到外部对WorkerThread的中断操作，返回
                            Thread.currentThread().interrupt();
                            return;
                        &#125;
                    &#125;
                    //取出一个Job
                    job = jobs.removeFirst();
                &#125;
                if(job != null)&#123;
                    try&#123;
                        job.run();
                    &#125;catch(Exception ex)&#123;
                        //忽略Job执行中的Exception
                    &#125;
                &#125;
            &#125;
        &#125;
        
        public void shutdown()&#123;
            running = false;
        &#125;
    &#125;
    
    //初始化线程工作者
    private void initializeWorkers(int num)&#123;
        for(int i = 0; i &lt; num; i++)&#123;
            Worker worker = new Worker();
            workers.add(worker);
            Thread thread = new Thread(worker, &quot;ThreadPool-Worker-&quot; + threadNum.incrementAndGet());
            thread.start();
        &#125;
    &#125;
    
    public DefaultThreadPool()&#123;
        initializeWorkers(DEFAULT_WORKER_NUMBERS);
    &#125;
    
    public DefaultThreadPool(int num)&#123;
        workerNum = num &gt; MAX_WORKER_NUMBERS ? MAX_WORKER_NUMBERS : num &lt; MIN_WORKER_NUMBERS ? MIN_WORKER_NUMBERS : num;
        initializeWorkers(workerNum);
    &#125;
    
    @Override
    public void execute(Job job) &#123;
        if(job != null)&#123;
            //添加一个工作，然后进行通知
            synchronized(jobs)&#123;
                jobs.addLast(job);
                jobs.notify();
            &#125;
        &#125;
    &#125;

    @Override
    public void shutdown() &#123;
        for(Worker worker : workers)&#123;
            worker.shutdown();
        &#125;
    &#125;

    @Override
    public void addWorkers(int num) &#123;
        synchronized(jobs)&#123;
            //限制新增的Worker数量不能超过最大值
            if(num + this.workerNum &gt; MAX_WORKER_NUMBERS)&#123;
                num = MAX_WORKER_NUMBERS - this.workerNum;
            &#125;
            initializeWorkers(num);
            this.workerNum += num;
        &#125;
    &#125;

    @Override
    public void remvoeWorkers(int num) &#123;
        synchronized(jobs)&#123;
            if(num &gt;= this.workerNum)&#123;
                throw new IllegalArgumentException(&quot;beyond workNum&quot;);
            &#125;
            //按照给定的数量停止Worker
            int count = 0;
            while(count &lt; num)&#123;
                Worker worker = workers.get(count);
                if(workers.remove(worker))&#123;
                    worker.shutdown();
                    count++;
                &#125;
            &#125;
            this.workerNum -= count;
        &#125;
    &#125;

    @Override
    public int getJobSize() &#123;
        return jobs.size();
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
        <category>线程池</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>伪迹移除 | 经验模态分解</title>
    <url>/2021/02/23/%E7%BB%8F%E9%AA%8C%E6%A8%A1%E6%80%81%E5%88%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="EMD"><a href="#EMD" class="headerlink" title="EMD"></a>EMD</h1><p>EMD is an <b>empirical and data-driven method</b> developed to perform on <b>non-stationary</b>,<b>non-linear</b>, <b>stochastic</b> processes(it is ideally suitable for EEG signal analysis and processing)</p>
<h2 id="Disadvantages"><a href="#Disadvantages" class="headerlink" title="Disadvantages:"></a>Disadvantages:</h2><p>1.the <b>computational complexity</b> is quite heavy(not suitable for online application)<br>2.the <b>theory</b> behind EMD is still not complete and so far used in empirical studies(difficult to predict its robustness in all EEG recordings)</p>
<h2 id="EMD-Algorithm"><a href="#EMD-Algorithm" class="headerlink" title="EMD Algorithm"></a>EMD Algorithm</h2><p><b style="color: red">EMD algorithm decomposes a signal,s[n] into a sum of the band-limited components/functions,c[n] called intrinsic mode funciton(IMF) with well defined instantaneous frequencies.</b></p>
<h3 id="Two-Basic-Conditions-to-be-an-IMF"><a href="#Two-Basic-Conditions-to-be-an-IMF" class="headerlink" title="Two Basic Conditions to be an IMF"></a>Two Basic Conditions to be an IMF</h3><p>1.the numberof extrema must be equal(or at most may differ by one) to the number of zero crossings<br>2.any point,the mean value of the two envelopes defined by the local maxima and the local minima has to be zero</p>
<h3 id="The-General-Process-flow-of-EMD-Algorithm"><a href="#The-General-Process-flow-of-EMD-Algorithm" class="headerlink" title="The General Process flow of EMD Algorithm"></a>The General Process flow of EMD Algorithm</h3><p>Input: data sequence s[n]<br>1.Identify all the local extrema<br>2.Separately connect all the maxima and minima with natural cubic spline lines to form the upper,u[n],and lower,l[n],envelopes.<br>3.Find the mean of the envolopes as <b>z[n]=[u[n]+l[n]]/2</b><br>4.Take the difference between the data and the mean as the proto-IMF,<b>h[n]=s[n]-z[n]</b><br>5.Check the proto-IMF against the definition of IMF and the stoppage criterion to determine if it is an IMF<br>6.If the proto-IMF does not satisfy the definition,repeat step 1 to 5 on h[n] as many times as needed till it satisfies the definition<br>7.If the proto-IMF does satisfy the definition,assign the proto-IMF as an IMF component,c[n]<br>8.Repeat the operation step 1 to 7 on the residue,q[n]=s[n]-c[n],as the data<br>9.The operation ends when the residue contains no more than one extrema</p>
<h3 id="EEMD-enhanced-version-of-EMD"><a href="#EEMD-enhanced-version-of-EMD" class="headerlink" title="EEMD(enhanced version of EMD)"></a>EEMD(enhanced version of EMD)</h3><p>EEMD it inspired from the fact that <b>EMD is very sensitive to noise</b>,which often leads to mode mixing complication.<br>EEMD is proposed which uses an <b>average number of ensembles(IMFs) from EMD as the optimal IMFs</b> thus it provides a <b>noise-assisted data analysis method</b>.</p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>伪迹移除</category>
      </categories>
      <tags>
        <tag>EMD</tag>
        <tag>经验模态分解</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 结构化数据与非结构化数据</title>
    <url>/2021/06/21/%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE%E4%B8%8E%E9%9D%9E%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="结构化数据与非结构化数据"><a href="#结构化数据与非结构化数据" class="headerlink" title="结构化数据与非结构化数据"></a>结构化数据与非结构化数据</h1><p><img src="/2021/06/21/%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE%E4%B8%8E%E9%9D%9E%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE/1.png"></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>matplotlib | 绘制几个模型某性能指标在某个范围内的大小比较图</title>
    <url>/2021/10/12/%E7%BB%98%E5%88%B6%E5%87%A0%E4%B8%AA%E6%A8%A1%E5%9E%8B%E6%9F%90%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E5%9C%A8%E6%9F%90%E4%B8%AA%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%AF%94%E8%BE%83%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="绘制几个模型某性能指标在某个范围内的大小比较图"><a href="#绘制几个模型某性能指标在某个范围内的大小比较图" class="headerlink" title="绘制几个模型某性能指标在某个范围内的大小比较图"></a>绘制几个模型某性能指标在某个范围内的大小比较图</h1><p>我们在做深度学习实验时，很多时候会需要对几个模型的性能进行对比并进行可视化，从而清楚地展示模型性能的大小关系。</p>
<span id="more"></span>
<p>下面以几个模型的精确度大小比较为例：</p>
<p><strong>代码：</strong></p>
<pre><code>import matplotlib.pyplot as plt

CNNLSTM_valence_acc = [0.6885742, 0.690625, 0.69453126, 0.69277346, 0.69003904, 0.6965332, 0.6917969, 0.68652344, 0.6916992, 0.69140625, 0.6933594, 0.6972656, 0.69277346, 0.6941406, 0.69501954, 0.69257814, 0.6929687, 0.69208986, 0.6905273, 0.6930664, 0.69384766, 0.6856445, 0.6958984, 0.6929687, 0.693457, 0.69501954, 0.6893555, 0.7, 0.6904297, 0.69628906, 0.6921875, 0.6910156, 0.6988281, 0.69492185, 0.69541013, 0.69443357, 0.69257814, 0.6955078, 0.6942383, 0.69628906, 0.6933594, 0.6976563, 0.69267577, 0.6948242, 0.69277346, 0.6964844, 0.6923828, 0.6959961, 0.6993164, 0.6935547]
CNN3Conv_valence_acc = [0.53, 0.57, 0.52, 0.55, 0.57, 0.53, 0.54, 0.55, 0.5, 0.49, 0.53, 0.45, 0.55, 0.56, 0.54, 0.49, 0.54, 0.55, 0.57, 0.52, 0.49, 0.54, 0.5, 0.49, 0.56, 0.52, 0.52, 0.55, 0.55, 0.57, 0.5, 0.5, 0.52, 0.55, 0.54, 0.57, 0.53, 0.55, 0.51, 0.54, 0.54, 0.53, 0.56, 0.52, 0.53, 0.53, 0.54, 0.53, 0.5, 0.54]
CNN5Conv_valence_acc = [0.69, 0.6699999999999999, 0.6799999999999999, 0.66, 0.54, 0.57, 0.6699999999999999, 0.6699999999999999, 0.61, 0.61, 0.63, 0.62, 0.63, 0.62, 0.6699999999999999, 0.62, 0.66, 0.6699999999999999, 0.62, 0.58, 0.61, 0.66, 0.61, 0.65, 0.63, 0.62, 0.62, 0.59, 0.62, 0.63, 0.62, 0.63, 0.62, 0.62, 0.63, 0.61, 0.62, 0.62, 0.6699999999999999, 0.63, 0.64, 0.64, 0.65, 0.6699999999999999, 0.62, 0.69, 0.58, 0.59, 0.63, 0.61]

print(len(CNNLSTM_valence_acc))
print(len(CNN3Conv_valence_acc))
print(len(CNN5Conv_valence_acc))

x = range(len(CNN5Conv_valence_acc))
plt.plot(x, CNNLSTM_valence_acc, label=u&#39;CNN-LSTM&#39;)
plt.plot(x, CNN3Conv_valence_acc, label=u&#39;CNN3Conv&#39;)
plt.plot(x, CNN5Conv_valence_acc, label=u&#39;CNN5Conv&#39;)
plt.legend()
plt.xlabel(u&quot;epoch&quot;)
plt.ylabel(u&quot;accuracy&quot;)
plt.show()
</code></pre>
<p><strong>效果图：</strong><br><img src="/2021/10/12/%E7%BB%98%E5%88%B6%E5%87%A0%E4%B8%AA%E6%A8%A1%E5%9E%8B%E6%9F%90%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E5%9C%A8%E6%9F%90%E4%B8%AA%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%AF%94%E8%BE%83%E5%9B%BE/myplot.png"></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>matplotlib</category>
      </categories>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title>绝对路径和相对路径</title>
    <url>/2020/11/29/%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%92%8C%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h1><p><strong>绝对路径</strong>：相对于磁盘的位置定位文件的地址<br><strong>相对路径</strong>：相对于引用文件本身定位被引用文件的地址</p>
<p>Note:<br>./ 当前文件所在目录下<br>../ 当前文件所在目录的上一级目录</p>
]]></content>
      <tags>
        <tag>绝对路径</tag>
        <tag>相对路径</tag>
      </tags>
  </entry>
  <entry>
    <title>python | 统计字符串中各个字符出现的次数并返回出现次数最多的字符</title>
    <url>/2022/04/05/%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%90%84%E4%B8%AA%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E5%B9%B6%E8%BF%94%E5%9B%9E%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="找出字符串中出现次数最多的字符"><a href="#找出字符串中出现次数最多的字符" class="headerlink" title="找出字符串中出现次数最多的字符"></a>找出字符串中出现次数最多的字符</h1><pre><code>string = &quot;abcdaab&quot;
word_frequency = dict()
for ch in string:
    if ch not in word_frequency.keys():
        word_frequency[ch] = 1
    else:
        word_frequency[ch] += 1
print(word_frequency)
print(max(word_frequency, key=word_frequency.get))
</code></pre>
<p><a href="https://blog.csdn.net/weixin_42444693/article/details/104203479?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&utm_relevant_index=1">参考资料</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
        <category>找出字符串中出现次数最多的字符</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>找出字符串中出现次数最多的字符</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis | 缓存和数据库的一致性问题</title>
    <url>/2022/05/21/%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="缓存和数据库的一致性问题"><a href="#缓存和数据库的一致性问题" class="headerlink" title="缓存和数据库的一致性问题"></a>缓存和数据库的一致性问题</h1><p>1、想要提高应用的性能，可以引入「缓存」来解决<br>2、引入缓存后，需要考虑缓存和数据库一致性问题，可选的方案有：「更新数据库 + 更新缓存」、「更新数据库 + 删除缓存」<br>3、更新数据库 + 更新缓存方案，在「并发」场景下无法保证缓存和数据一致性，且存在「缓存资源浪费」和「机器性能浪费」的情况发生<br>4、在更新数据库 + 删除缓存的方案中，「先删除缓存，再更新数据库」在「并发」场景下依旧有数据不一致问题，解决方案是「延迟双删」，但这个延迟时间很难评估，所以推荐用「先更新数据库，再删除缓存」的方案<br>5、在「先更新数据库，再删除缓存」方案下，为了保证两步都成功执行，需配合「消息队列」或「订阅变更日志」的方案来做，本质是通过「重试」的方式保证数据一致性<br>6、在「先更新数据库，再删除缓存」方案下，「读写分离 + 主从库延迟」也会导致缓存和数据库不一致，缓解此问题的方案是「延迟双删」，凭借经验发送「延迟消息」到队列中，延迟删除缓存，同时也要控制主从库延迟，尽可能降低不一致发生的概率<br><a href="https://mp.weixin.qq.com/s?__biz=MzIyOTYxNDI5OA==&mid=2247487312&idx=1&sn=fa19566f5729d6598155b5c676eee62d&chksm=e8beb8e5dfc931f3e35655da9da0b61c79f2843101c130cf38996446975014f958a6481aacf1&scene=178&cur_album_id=1699766580538032128#rd">参考资料</a></p>
]]></content>
      <categories>
        <category>Redis</category>
        <category>缓存和数据库的一致性问题</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 网络、模型、算法的区别</title>
    <url>/2021/11/09/%E7%BD%91%E7%BB%9Cand%E6%A8%A1%E5%9E%8Band%E7%AE%97%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="网络、模型、算法的区别"><a href="#网络、模型、算法的区别" class="headerlink" title="网络、模型、算法的区别"></a>网络、模型、算法的区别</h1><p>网络: 一种简单的网络结构，不包含任何权重参数。</p>
<p>模型： 设计一个网络后，在某些数据集上进行训练，得到一个包含权重参数的数据，称为模型。</p>
<p>算法： 在模型的基础上通过一些代码具体实现某些相关目的，这些代码以及模型文件等等资源被称为某算法。</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程 | 网络中常见的协议以及术语</title>
    <url>/2020/10/22/%E7%BD%91%E7%BB%9C%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8D%8F%E8%AE%AE%E4%BB%A5%E5%8F%8A%E6%9C%AF%E8%AF%AD/</url>
    <content><![CDATA[<h1 id="几种常见tcp、ip协议以及常见术语"><a href="#几种常见tcp、ip协议以及常见术语" class="headerlink" title="几种常见tcp、ip协议以及常见术语"></a>几种常见tcp、ip协议以及常见术语</h1><p>ICMP(internet 控制报文协议)—&gt;使用ping命令时</p>
<p>ARP(地址解析协议)—&gt;根据IP地址找MAC地址</p>
<p>RARP(反向地址解析协议)—&gt;根据MAC地址找IP地址</p>
<p>MAC(媒体访问控制地址)—&gt;网卡的编号</p>
<p>IP:标记逻辑上的地址</p>
<p>mac：标记实际转发数据时的设备地址</p>
<p>DHCP(动态主机配置协议):发现当前局域网内没有IP的电脑，给这台电脑自动分配IP</p>
<p>netmask:和ip地址一起来确定网络号</p>
<p>默认网关：发送的ip不在同一个网段内，那么会把这个数据转发给默认网关<br><b>Note:</b><br>MAC地址在两个设备之间通信时在变化<br>IP地址在整个通信过程中都不会发生变化</p>
]]></content>
      <categories>
        <category>python</category>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC | 编码过滤器CharacterEncodingFilter</title>
    <url>/2022/03/12/%E7%BC%96%E7%A0%81%E8%BF%87%E6%BB%A4%E5%99%A8CharacterEncodingFilter/</url>
    <content><![CDATA[<h1 id="CharacterEncodingFilter编码过滤器"><a href="#CharacterEncodingFilter编码过滤器" class="headerlink" title="CharacterEncodingFilter编码过滤器"></a>CharacterEncodingFilter编码过滤器</h1><p>SpringMVC通过配置CharacterEncodingFilter编码过滤器来解决项目中的乱码问题，只需要在web.xml中配置CharacterEncodingFilter即可。</p>
<pre><code>&lt;!-- 配置编码过滤器 --&gt;
  &lt;filter&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;UTF-8&lt;/param-value&gt;
    &lt;/init-param&gt;
  &lt;/filter&gt;
  &lt;filter-mapping&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>SpringMVC</category>
        <category>编码过滤器CharacterEncodingFilter</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 罗马数字转整数</title>
    <url>/2021/08/27/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<h1 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13.罗马数字转整数"></a>13.罗马数字转整数</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>
<p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000</p>
<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。<br>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：<br>    I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>    X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>    C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/roman-to-integer/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>通常情况下，罗马数字中小的数字在大的数字的右边。若输入的字符串满足该情况，那么可以将每个字符视作一个单独的值，累加每个字符对应的数值即可。<br>例如 XXVII 可视作 X+X+V+I+I=10+10+5+1+1=27。<br>若存在小的数字在大的数字的左边的情况，根据规则需要减去小的数字。对于这种情况，我们也可以将每个字符视作一个单独的值，若一个数字右侧的数字比它大，则将该数字的符号取反。<br>例如 XIV 可视作 X−I+V=10−1+5=14。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):
    def romanToInt(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: int
        &quot;&quot;&quot;
        # SYMBOL_VALUES = &#123;
        #     &#39;I&#39;: 1,
        #     &#39;V&#39;: 5,
        #     &#39;X&#39;: 10,
        #     &#39;L&#39;: 50,
        #     &#39;C&#39;: 100,
        #     &#39;D&#39;: 500,
        #     &#39;M&#39;: 1000,
        # &#125;
        # ans = 0
        # n = len(s)
        # for i, ch in enumerate(s):
        #     value = SYMBOL_VALUES[ch]
        #     if i &lt; n - 1 and value &lt; SYMBOL_VALUES[s[i+1]]:
        #         ans -= value
        #     else:
        #         ans += value
        # return ans

        roman2int = &#123;
            &#39;I&#39;: 1,
            &#39;V&#39;: 5,
            &#39;X&#39;: 10,
            &#39;L&#39;: 50,
            &#39;C&#39;: 100,
            &#39;D&#39;: 500,
            &#39;M&#39;: 1000,
        &#125;

        num = 0
        i = 0
        while i &lt; len(s):
            if s[i] == &#39;I&#39; and i+1 &lt; len(s) and (s[i+1] == &#39;V&#39; or s[i+1] == &#39;X&#39;):
                num += (roman2int[s[i+1]] - roman2int[s[i]])
                i += 2
            elif s[i] == &#39;X&#39; and i+1 &lt; len(s) and (s[i+1] == &#39;L&#39; or s[i+1] == &#39;C&#39;):
                num += (roman2int[s[i+1]] - roman2int[s[i]])
                i += 2
            elif s[i] == &#39;C&#39; and i+1 &lt; len(s) and (s[i+1] == &#39;D&#39; or s[i+1] == &#39;M&#39;):
                num += (roman2int[s[i+1]] - roman2int[s[i]])
                i += 2
            else:
                num += roman2int[s[i]]
                i += 1

        return num



if __name__ == &quot;__main__&quot;:
    slt = Solution()
    s = &quot;MCMXCIV&quot;
    int_num = slt.romanToInt(s)
    print(&quot;罗马数字 &#123;&#125; 对应的整数为 &#123;&#125; &quot;.format(s, int_num))
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>脑电伪迹降噪方法整理</title>
    <url>/2021/11/15/%E8%84%91%E7%94%B5%E4%BC%AA%E8%BF%B9%E9%99%8D%E5%99%AA%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="脑电伪迹降噪方法整理"><a href="#脑电伪迹降噪方法整理" class="headerlink" title="脑电伪迹降噪方法整理"></a>脑电伪迹降噪方法整理</h1><p><a href="https://mp.weixin.qq.com/s/gRIP-fuYsZv2p92qptOmew">脑电伪迹降噪方法整理</a></p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>伪迹移除</category>
        <category>脑电伪迹降噪方法整理</category>
      </categories>
      <tags>
        <tag>伪迹移除</tag>
        <tag>EEG</tag>
      </tags>
  </entry>
  <entry>
    <title>EEG | 脑电信号采用深度学习方法存在的问题</title>
    <url>/2020/11/10/%E8%84%91%E7%94%B5%E4%BF%A1%E5%8F%B7%E9%87%87%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="脑电信号采用深度学习方法存在的问题"><a href="#脑电信号采用深度学习方法存在的问题" class="headerlink" title="脑电信号采用深度学习方法存在的问题"></a>脑电信号采用深度学习方法存在的问题</h1><p>深度学习是一种构造多层神经网络的机器学习方法，具有发现数据中隐藏的分布式特征表示的能力。</p>
<h2 id="脑电信号特征提取方法："><a href="#脑电信号特征提取方法：" class="headerlink" title="脑电信号特征提取方法："></a>脑电信号特征提取方法：</h2><p>时域分析方法<br>频域分析方法<br>时频域分析犯法<br>非线性分析方法</p>
<h2 id="脑电信号采用深度学习方法目前存在的问题"><a href="#脑电信号采用深度学习方法目前存在的问题" class="headerlink" title="脑电信号采用深度学习方法目前存在的问题"></a>脑电信号采用深度学习方法目前存在的问题</h2><p>（1）<b style="color:red">深度神经网络层数的最优化，不是越多的网络层数就能得到最好的结果</b><br>（2）数据量也是造成深度学习方法无法深入的原因</p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>EEG</tag>
      </tags>
  </entry>
  <entry>
    <title>EEG | 脑电数据集下载网站</title>
    <url>/2021/04/17/%E8%84%91%E7%94%B5%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8B%E8%BD%BD%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h1 id="脑电数据集下载网站"><a href="#脑电数据集下载网站" class="headerlink" title="脑电数据集下载网站"></a>脑电数据集下载网站</h1><p><a href="www.physionet.org">网站1</a></p>
<p><a href="https://archive.ics.uci.edu/ml/datasets/EEG+Database">网站2</a></p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
      </categories>
      <tags>
        <tag>EEG</tag>
        <tag>数据集</tag>
      </tags>
  </entry>
  <entry>
    <title>期刊 | 脑电期刊</title>
    <url>/2022/01/04/%E8%84%91%E7%94%B5%E6%9C%9F%E5%88%8A/</url>
    <content><![CDATA[<h1 id="脑电期刊"><a href="#脑电期刊" class="headerlink" title="脑电期刊"></a>脑电期刊</h1><p>名称：Biomedical Siganl Processing and Control<br>网址：<a href="https://www.sciencedirect.com/journal/biomedical-signal-processing-and-control">Biomedical Signal Processing and Control</a><br>SCI分区：2</p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>脑电期刊</category>
        <category>Biomedical Signal Processing and Control</category>
      </categories>
  </entry>
  <entry>
    <title>spring | 自动装配</title>
    <url>/2022/03/06/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/</url>
    <content><![CDATA[<h1 id="自动装配（自动为属性赋值）"><a href="#自动装配（自动为属性赋值）" class="headerlink" title="自动装配（自动为属性赋值）"></a>自动装配（自动为属性赋值）</h1><p>1.项目目录<br><img src="/2022/03/06/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/1.PNG"></p>
<p>2.Emp.java</p>
<pre><code>package com.atguigu.ioc.auto;

public class Emp &#123;
    private Integer eid;
    private String ename;
    //private Car car;//类型可以写该类以及该类的父类
    private CarExtends car;
    //private Dept dept;//类型可以写该类以及该类的父类
    private DeptI dept;
    public Integer getEid() &#123;
        return eid;
    &#125;
    public void setEid(Integer eid) &#123;
        this.eid = eid;
    &#125;
    public String getEname() &#123;
        return ename;
    &#125;
    public void setEname(String ename) &#123;
        this.ename = ename;
    &#125;
    public CarExtends getCar() &#123;
        return car;
    &#125;
    public void setCar(CarExtends car) &#123;
        this.car = car;
    &#125;
    public DeptI getDept() &#123;
        return dept;
    &#125;
    public void setDept(DeptI dept) &#123;
        this.dept = dept;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Emp [eid=&quot; + eid + &quot;, ename=&quot; + ename + &quot;, car=&quot; + car + &quot;, dept=&quot; + dept + &quot;]&quot;;
    &#125;
    
&#125;
</code></pre>
<p>3.CarExtends.java(Car的父类)</p>
<pre><code>package com.atguigu.ioc.auto;

public class CarExtends &#123;

&#125;
</code></pre>
<p>4.Car.java</p>
<pre><code>package com.atguigu.ioc.auto;

public class Emp &#123;
    private Integer eid;
    private String ename;
    //private Car car;//类型可以写该类以及该类的父类
    private CarExtends car;
    //private Dept dept;//类型可以写该类以及该类的父类
    private DeptI dept;
    public Integer getEid() &#123;
        return eid;
    &#125;
    public void setEid(Integer eid) &#123;
        this.eid = eid;
    &#125;
    public String getEname() &#123;
        return ename;
    &#125;
    public void setEname(String ename) &#123;
        this.ename = ename;
    &#125;
    public CarExtends getCar() &#123;
        return car;
    &#125;
    public void setCar(CarExtends car) &#123;
        this.car = car;
    &#125;
    public DeptI getDept() &#123;
        return dept;
    &#125;
    public void setDept(DeptI dept) &#123;
        this.dept = dept;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Emp [eid=&quot; + eid + &quot;, ename=&quot; + ename + &quot;, car=&quot; + car + &quot;, dept=&quot; + dept + &quot;]&quot;;
    &#125;
    
&#125;
</code></pre>
<p>5.DeptI.java（接口）</p>
<pre><code>package com.atguigu.ioc.auto;

public interface DeptI &#123;

&#125;
</code></pre>
<p>6.Dept.java（DeptI接口的实现类）</p>
<pre><code>package com.atguigu.ioc.auto;

public class Dept implements DeptI&#123;
    private Integer did;
    private String dname;
    public Integer getDid() &#123;
        return did;
    &#125;
    public void setDid(Integer did) &#123;
        this.did = did;
    &#125;
    public String getDname() &#123;
        return dname;
    &#125;
    public void setDname(String dname) &#123;
        this.dname = dname;
    &#125;
&#125;
</code></pre>
<p>7.auto.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    
    &lt;!--
        autowire:根据某种策略自动未非字面量属性赋值
        autowire=&quot;byName|byType&quot;
        byName:通过属性名和spring容器中bean的id进行比较，若一致则可直接赋值
        byType:通过spring容器中bean的类型，为兼容性（子类对象为父类赋值，实现类为接口赋值）的属性赋值 
                在使用byType的过程中，要求spring容器中只能有一个能为属性赋值的bean
        
        选用建议：当设置autowire属性，会最作用于该bean中所有的非字面量属性，因此谁都不用
     --&gt;
    
    &lt;bean id=&quot;emp&quot; class=&quot;com.atguigu.ioc.auto.Emp&quot; autowire=&quot;byName&quot;&gt;&lt;!-- byName/byType --&gt;
        &lt;property name=&quot;eid&quot; value=&quot;1001&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;ename&quot; value=&quot;张三&quot;&gt;&lt;/property&gt;
        &lt;!-- &lt;property name=&quot;car&quot; ref=&quot;car&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt; --&gt;
    &lt;/bean&gt;
    
    &lt;bean id=&quot;car&quot; class=&quot;com.atguigu.ioc.auto.Car&quot;&gt;
        &lt;property name=&quot;cid&quot; value=&quot;666666&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;cname&quot; value=&quot;霸道&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    
    &lt;bean id=&quot;dept&quot; class=&quot;com.atguigu.ioc.auto.Dept&quot;&gt;
        &lt;property name=&quot;did&quot; value=&quot;1111&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;dname&quot; value=&quot;开发部&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>8.Test.java</p>
<pre><code>package com.atguigu.ioc.auto;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test &#123;

    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;auto.xml&quot;);
        
        Emp bean = ac.getBean(&quot;emp&quot;, Emp.class);
        
        System.out.println(bean);
    &#125;
&#125;
</code></pre>
<p>9.运行结果</p>
<pre><code>Emp [eid=1001, ename=张三, car=com.atguigu.ioc.auto.Car@31ef45e3, dept=com.atguigu.ioc.auto.Dept@598067a5]
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>spring</category>
        <category>自动装配（自动为属性赋值）</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>伪迹移除 | 自适应滤波器</title>
    <url>/2021/02/23/%E8%87%AA%E9%80%82%E5%BA%94%E6%BB%A4%E6%B3%A2%E5%99%A8/</url>
    <content><![CDATA[<h1 id="Adaptive-Filter"><a href="#Adaptive-Filter" class="headerlink" title="Adaptive Filter"></a>Adaptive Filter</h1><p>Adaptive Filter is a system with a linear filter that has a transfer function controlled by variable parameters and a means to adjust those parameters according to an optimization algorithm.The filter weights can adapt based on the feedback from output of the system and it requires a reference input o compare the desired output with the observed output.</p>
<h2 id="The-use-of-adaptive-filter-for-EOG-artifact-removal"><a href="#The-use-of-adaptive-filter-for-EOG-artifact-removal" class="headerlink" title="The use of adaptive filter for EOG artifact removal"></a>The use of adaptive filter for EOG artifact removal</h2><p><img src="/2021/02/23/%E8%87%AA%E9%80%82%E5%BA%94%E6%BB%A4%E6%B3%A2%E5%99%A8/1.PNG"><br>where s[n] is observed signal,x[n] is original EEG,r[n] is artifact,x’[n] is artifact-free EEG.</p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>伪迹移除</category>
      </categories>
      <tags>
        <tag>自适应滤波器</tag>
      </tags>
  </entry>
  <entry>
    <title>Java | 获取Class对象的四种方式</title>
    <url>/2022/03/10/%E8%8E%B7%E5%8F%96Class%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="获取Class对象的四种方式"><a href="#获取Class对象的四种方式" class="headerlink" title="获取Class对象的四种方式"></a>获取Class对象的四种方式</h1><p>反射可以动态获取类的信息，这需要依靠 Class 对象。Class 类对象将一个类的方法、变量等信息告诉运行的程序。Java 提供了四种方式获取 Class 对象:</p>
<ol>
<li>知道具体类的情况下可以使用：</li>
</ol>
<pre><code>Class alunbarClass = TargetObject.class;
</code></pre>
<p>但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象，通过此方式获取 Class 对象不会进行初始化</p>
<ol start="2">
<li>通过 Class.forName()传入类的全路径获取：</li>
</ol>
<pre><code>Class alunbarClass1 = Class.forName(&quot;cn.javaguide.TargetObject&quot;);
</code></pre>
<ol start="3">
<li>通过对象实例instance.getClass()获取：</li>
</ol>
<pre><code>TargetObject o = new TargetObject();
Class alunbarClass2 = o.getClass();
</code></pre>
<ol start="4">
<li>通过类加载器xxxClassLoader.loadClass()传入类路径获取:</li>
</ol>
<pre><code>Class clazz = ClassLoader.loadClass(&quot;cn.javaguide.TargetObject&quot;);
</code></pre>
<p>通过类加载器获取 Class 对象不会进行初始化，意味着不进行包括初始化等一系列步骤，静态代码块和静态对象不会得到执行</p>
<span id="more"></span>
<p><strong>示例</strong></p>
<pre><code>class Student&#123;
    private Integer sid;
    private String sname;
    public Integer getSid() &#123;
        return sid;
    &#125;
    public void setSid(Integer sid) &#123;
        this.sid = sid;
    &#125;
    public String getSname() &#123;
        return sname;
    &#125;
    public void setSname(String sname) &#123;
        this.sname = sname;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Student [sid=&quot; + sid + &quot;, sname=&quot; + sname + &quot;]&quot;;
    &#125;
    
&#125;

public class Test &#123;
    public static void main(String[] args)&#123;
        
        //获取 Class 对象的四种方式
        System.out.println(&quot;方式一:&quot; + Student.class);
        
        try &#123;
            System.out.println(&quot;方式二:&quot; + Class.forName(&quot;Student&quot;));
        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125;
        
        Student s1 = new Student();
        System.out.println(&quot;方式三:&quot; + s1.getClass());
        
        try &#123;
            System.out.println(&quot;方式四:&quot;+ClassLoader.getSystemClassLoader().loadClass(&quot;Student&quot;));
            
        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125;
        
        try &#123;
            //使用反射操作Student类的方法以及参数
            Student s2 = s1.getClass().newInstance();
            s2.setSname(&quot;zhangsan&quot;);
            s2.setSid(1);
            System.out.println(s2);
        &#125; catch (InstantiationException e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125; catch (IllegalAccessException e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125;
        
        
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
        <category>获取Class对象的四种方式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
        <tag>Class对象</tag>
      </tags>
  </entry>
  <entry>
    <title>requests | 获取网站新文章</title>
    <url>/2021/10/29/%E8%8E%B7%E5%8F%96%E7%BD%91%E7%AB%99%E6%96%B0%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="Python爬虫-已爬取目标网站所有文章，后续如何只获取新文章"><a href="#Python爬虫-已爬取目标网站所有文章，后续如何只获取新文章" class="headerlink" title="Python爬虫~已爬取目标网站所有文章，后续如何只获取新文章?"></a>Python爬虫~已爬取目标网站所有文章，后续如何只获取新文章?</h1><p>代码：</p>
<pre><code>print(&quot;文章刷新中......&quot;)

# 定义函数，获取想要的文章并批量写入word文件
import requests
from bs4 import BeautifulSoup
import docx
from docx.shared import Pt  # 用于设定字体大小（磅值）
from docx.oxml.ns import qn  # 用于应用中文字体
import random
import time
import os


def Get_article_to_word(url, date):
    user_agent_list = [
        &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36&quot;,
        &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&quot;,
        &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36&quot;,
        &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.62 Safari/537.36&quot;,
        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36&quot;,
        &quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)&quot;,
        &quot;Mozilla/5.0 (Macintosh; U; PPC Mac OS X 10.5; en-US; rv:1.9.2.15) Gecko/20110303 Firefox/3.6.15&quot;
        ]
    header = &#123;&#39;User-Agent&#39;: random.choice(user_agent_list)&#125;
    wb_data = requests.get(url, headers=header)
    soup = BeautifulSoup(wb_data.content)
    title = soup.select(&#39;.headword&#39;)[0].text.strip()  # 获得标题
    content1 = soup.select(&quot;.MsoNormal&quot;)  # 针对正文布局为 class = &quot;MsoNormal&quot;
    content2 = soup.select(&quot;#art_content&quot;)  # 针对正文布局为 id = &quot;art_content&quot;

    doc = docx.Document()  # 新建空白word文档
    # 设定全局字体
    doc.styles[&#39;Normal&#39;].font.name = u&#39;宋体&#39;
    doc.styles[&#39;Normal&#39;]._element.rPr.rFonts.set(qn(&#39;w:eastAsia&#39;), u&#39;宋体&#39;)

    # 写入标题行，并设置字体格式
    p = doc.add_paragraph()
    r = p.add_run(title)
    r.bold = True
    r.font.size = Pt(18)

    doc.add_paragraph(date)  # 写入日期
    doc.add_paragraph(url)  # 写入文章链接

    dirs = os.getcwd() + &quot;\\文章&quot;
    if not os.path.exists(dirs):
        os.makedirs(dirs)
    # 写入正文
    for i in content2:
        doc.add_paragraph(i.text)
    for i in content1:
        doc.add_paragraph(i.text)
    doc.save(f&quot;&#123;dirs&#125;\\&#123;title&#125;.docx&quot;)


# 判断网站是否有新文章
import requests
import json

header = &#123;
    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.75 &#39;
                  &#39;Safari/537.36&#39;&#125;
form_data = &#123;&#39;_q&#39;: &#39;Article.list&#39;,
             &#39;siteId&#39;: &#39;7e0b3b27-2622-4aa7-b6f8-abfe5c5df922&#39;,
             &#39;catalogId&#39;: &#39;34f92da3-d6d0-4e96-899f-d7f581c18162&#39;,
             &#39;pub&#39;: &#39;true&#39;,
             &#39;limit&#39;: 150,  # 网站更新速度较慢，每次查看是否有更新的时候，只获取前10页共150篇文章的信息
             &#39;start&#39;: 1&#125;

# 这是异步加载，请求方法是POST
url = &quot;http://www.bicpa.org.cn/dtzj/zxgg/getArticles.action&quot;
res = requests.post(url, data=form_data, headers=header)
article_data0 = res.text.split(&quot;&#123;success:true,datas:&quot;)[1]  # 去掉字符串前面的无用信息“&#123;success:true,datas:”
article_data = article_data0.split(&quot;,total:&quot;)[0]  # 去掉字符串后面的无用信息“,total:xxxx&#125;”
obj = json.loads(article_data)

# 载入数据库中的所有链接，作为判断基准
f = open(os.getcwd() + &#39;\\links.txt&#39;, &#39;r&#39;)
link_database = f.read()  # 读取成一个大字符串

# 将所有新文章链接写入文本文件
path = r&quot;http://www.bicpa.org.cn&quot;
links_file = open(&#39;links.txt&#39;, &#39;a&#39;)  # 避免覆盖已有数据，用添加模式`a`写入
counter_link = 0  # 新文章链接计数器
counter_download = 0  # 新下载文章计数器
for info in obj:
    link = path + info[&#39;url&#39;] + info[&#39;primaryKey&#39;] + &quot;.html&quot;  # 拼接链接信息
    if link in link_database:  # 判断新提取的链接是否已存在于数据库
        pass
    else:
        links_file.write(link + &quot;\n&quot;)  # 写入链接信息
        counter_link += 1

        # 下载标题含有&quot;委员会专家提示&quot;的文章
        if &quot;委员会专家提示&quot; in info[&#39;title&#39;]:
            Get_article_to_word(link, info[&quot;publishDate&quot;])  # 调用写好的函数，下载文章到word文件
            counter_download += 1  # 每下载一篇文章，计数器增加1

links_file.close()  # 写完后关闭文件

# 显示每次的结果
if counter_link == 0:
    print(&quot;没有文章更新！&quot;)
else:
    print(f&quot;共获取到 &#123;counter_link&#125; 篇新文章的链接，并加入数据库。&quot;)

if counter_download == 0:
    print(&quot;没有&#39;委员会专家提示&#39;文章更新！&quot;)
else:
    print(f&quot;共下载 &#123;counter_download&#125; 篇&#39;委员会专家提示&#39;新文章，请到文件夹查看。&quot;)

print(&quot;程序运行完成，关闭窗口退出.&quot;)
input()
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>requests</category>
      </categories>
      <tags>
        <tag>os</tag>
        <tag>python-docx</tag>
        <tag>requests</tag>
        <tag>BeautifulSoup</tag>
        <tag>json</tag>
        <tag>random</tag>
        <tag>time</tag>
      </tags>
  </entry>
  <entry>
    <title>基于JavaWeb的网上购物商城 | 菜单栏信息展示</title>
    <url>/2022/01/14/%E8%8F%9C%E5%8D%95%E6%A0%8F%E4%BF%A1%E6%81%AF%E5%B1%95%E7%A4%BA/</url>
    <content><![CDATA[<h1 id="菜单栏信息展示"><a href="#菜单栏信息展示" class="headerlink" title="菜单栏信息展示"></a>菜单栏信息展示</h1><p>实现功能：在网站首页的菜单栏显示所有的商品分类（登录/不登录状态下都会显示）—使用Filter实现<br>注：<br>（1）本功能的实现与首页热门商品展示类似<br>（2）需要将web.xml的LoginFilter的url-pattern路径配置为/*</p>
<span id="more"></span>
<p><strong>LoginFilter.java</strong><br>在实现首页热门商品展示的代码中进行功能添加(在LoginFilter.java的doFlter方法中添加如下码)</p>
<pre><code>public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException &#123;
        // TODO Auto-generated method stub
        try &#123;
            //收集首页数据
            ProductService ps = new ProductService();
            List&lt;Product&gt; list = ps.findProList();
            
            //收集导航栏信息
            List&lt;Category&gt; clist = ps.findCateList();
            
            request.setAttribute(&quot;clist&quot;, clist);
            request.setAttribute(&quot;list&quot;, list);

            chain.doFilter(request, response);
        &#125; catch (SQLException e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125;
    &#125;
</code></pre>
<p><strong>创建Category.java</strong></p>
<pre><code>package com.oracle.bean;

public class Category &#123;
    private String cid;
    private String cname;
    public Category() &#123;
        super();
        // TODO Auto-generated constructor stub
    &#125;
    public Category(String cid, String cname) &#123;
        super();
        this.cid = cid;
        this.cname = cname;
    &#125;
    public String getCid() &#123;
        return cid;
    &#125;
    public void setCid(String cid) &#123;
        this.cid = cid;
    &#125;
    public String getCname() &#123;
        return cname;
    &#125;
    public void setCname(String cname) &#123;
        this.cname = cname;
    &#125;
    
&#125;
</code></pre>
<p><strong>ProductService.java</strong><br>在实现首页热门商品展示的代码中进行功能添加(在ProductService.java中添加如下代码)</p>
<pre><code>public List&lt;Category&gt; findCateList() throws SQLException &#123;
        // TODO Auto-generated method stub
        ProductDao pd = new ProductDao();
        List&lt;Category&gt; clist = pd.findCateList();
        return clist;
    &#125;
    
</code></pre>
<p><strong>ProductDao.java</strong><br>在实现首页热门商品展示的代码中进行功能添加(在ProductDao.java中添加如下代码)</p>
<pre><code>public List&lt;Category&gt; findCateList() throws SQLException &#123;
        // TODO Auto-generated method stub
        QueryRunner qr = new QueryRunner(DataSourceUtils.getDataSource());
        
        String sql = &quot;select * from category&quot;;
        
        List&lt;Category&gt; clist = qr.query(sql, new BeanListHandler&lt;&gt;(Category.class));
        return clist;
    &#125;
</code></pre>
<p><strong>header.jsp</strong><br>修改header.jsp中的对应代码（如下所示）</p>
<pre><code>&lt;ul class=&quot;nav navbar-nav&quot;&gt;
    &lt;c:forEach items=&quot;$&#123;clist&#125;&quot; var=&quot;cate&quot;&gt;
        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;$&#123;cate.cname&#125;&lt;/a&gt;&lt;/li&gt;
    &lt;/c:forEach&gt;
&lt;/ul&gt;
</code></pre>
]]></content>
      <categories>
        <category>项目经历</category>
        <category>JavaWeb</category>
        <category>基于JavaWeb的网上购物商城</category>
        <category>菜单栏信息展示</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
        <tag>基于JavaWeb的网上购物商城</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer Vision | 虚假名人照片生成</title>
    <url>/2021/11/20/%E8%99%9A%E5%81%87%E5%90%8D%E4%BA%BA%E7%85%A7%E7%89%87%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<h1 id="虚假名人照片生成"><a href="#虚假名人照片生成" class="headerlink" title="虚假名人照片生成"></a>虚假名人照片生成</h1><h2 id="1-虚假照片生成有什么用？"><a href="#1-虚假照片生成有什么用？" class="headerlink" title="1. 虚假照片生成有什么用？"></a>1. 虚假照片生成有什么用？</h2><p>生成一些“并不存在的人”的照片<br>给定一系列真人照片，通过GAN技术生成一些类似的照片。但这些照片上的人并不真实存在。<br>这些照片可以用作一些影视作品中的“遗像”，这样，既保证了影视作品的真实性，又不需要使用真人照片。</p>
<h2 id="2-数据集情况"><a href="#2-数据集情况" class="headerlink" title="2.数据集情况"></a>2.数据集情况</h2><p>CelebA（名人照片数据集）<br>网址：<a href="http://mmlab.ie.cuhk.edu.hk/projects/CelebA.html">http://mmlab.ie.cuhk.edu.hk/projects/CelebA.html</a><br><strong>·</strong> 人脸照片，拥有超过200K张名人照片<br><strong>·</strong> 照片中人的姿态不一，背景杂乱</p>
<h2 id="模型介绍"><a href="#模型介绍" class="headerlink" title="模型介绍"></a>模型介绍</h2><p>DCGAN generator</p>
]]></content>
      <categories>
        <category>项目经历</category>
        <category>Deep Learning</category>
        <category>Computer Vision</category>
        <category>虚假名人照片生成</category>
      </categories>
      <tags>
        <tag>虚假名人照片生成</tag>
      </tags>
  </entry>
  <entry>
    <title>python | 装饰器</title>
    <url>/2021/11/07/%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><p>顾名思义，从字面意思就可以理解，它是用来”装饰”Python的工具，使得代码更具有Python简洁的风格。换句话说，它是一种函数的函数，因为装饰器传入的参数就是一个函数，然后通过实现各种功能来对这个函数的功能进行增强。<br><strong>注：装饰器输入一个函数，输出一个函数</strong><br><strong>装饰器最大的优势</strong>是用于<strong>解决重复性</strong>的操作，其主要使用的场景有如下几个：<br>1.计算函数运行时间<br>2.给函数打日志<br>3.类型检查<br>当然，如果遇到其他重复操作的场景也可以类比使用装饰器。</p>
<span id="more"></span>
<pre><code># 1.原始需求
def worker1():
    print(&#39;我是一个勤劳的工作者！&#39;)
def worker2():
    print(&#39;我是一个勤劳的工作者！&#39;)
def worker3():
    print(&#39;我是一个勤劳的工作者！&#39;)

# 2.我现在想要打印一些日志信息
def worker1():
    print(&#39;worker1 is working...&#39;)
    print(&#39;我是一个勤劳的工作者！&#39;)
worker1()


# 3.装饰器输入一个函数，输出一个函数
def print_working(func):
    def wrapper():
        print(f&#39;&#123;func.__name__&#125; is working...&#39;)
        func()
    return wrapper

def worker1():
    print(&#39;我是一个勤劳的工作者！&#39;)
def worker2():
    print(&#39;我是一个勤劳的工作者！&#39;)
def worker3():
    print(&#39;我是一个勤劳的工作者！&#39;)

worker1 = print_working(worker1)
worker1()
worker2= print_working(worker2)
worker2()

# 4.装饰器
@print_working
def worker1():
    print(&#39;我是一个勤劳的工作者！&#39;)

@print_working
def worker2():
    print(&#39;我是一个勤劳的工作者！&#39;)

@print_working
def worker3():
    print(&#39;我是一个勤劳的工作者！&#39;)

worker1()
worker2()
worker3()

# 5.装饰器示例
def arg_decorator(func):
def wrapper(*args, **kw):
    print(f&#39;&#123;func.__name__&#125; is working...&#39;)
    func(*args, **kw)
return wrapper

# 带参数的装饰器
@arg_decorator
def student_info(name, age=18, *books, **kw):
    print(f&#39;我的名字叫&#123;name&#125;, 今年&#123;age&#125;岁，我有很多本书：&#39;)
    for book in books:
        print(book)
    print(kw)

student_info(&#39;Molly&#39;,18, &#39;语文书&#39;,&#39;数学书&#39;,height=170)
    
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
        <category>装饰器</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title>urllib.request | 解码json数据</title>
    <url>/2021/08/05/%E8%A7%A3%E7%A0%81json%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="使用json提供的loads-str-函数进行JSON数据的解码"><a href="#使用json提供的loads-str-函数进行JSON数据的解码" class="headerlink" title="使用json提供的loads(str)函数进行JSON数据的解码"></a>使用json提供的loads(str)函数进行JSON数据的解码</h1><p><strong>函数说明：</strong><br>    str - JSON字符串<br>    返回值 - python数据<br><strong>示例代码：</strong></p>
<pre><code># coding=utf-8

import urllib.request
import json

# 使用json模块的loads(str)函数进行JSON数据的解码
url = &#39;http://localhost:8080/NoteWebService/note.do?action=query&amp;ID=10&#39;

req = urllib.request.Request(url)

with urllib.request.urlopen(req) as response:
    data = response.read()
    json_data = data.decode()
    print(&quot;JSON字符串：&quot;, json_data)

    py_dict = json.loads(json_data)  # 解码JSON字符串，返回字典
    print(&#39;备忘录ID：&#39;, py_dict[&#39;ID&#39;])
    print(&#39;备忘录日期：&#39;, py_dict[&#39;CDate&#39;])
    print(&#39;备忘录内容：&#39;, py_dict[&#39;Content&#39;])
    print(&#39;用户ID：&#39;, py_dict[&#39;UserID&#39;])
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>内置模块</category>
        <category>urllib</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>urllib</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 计算图</title>
    <url>/2021/06/19/%E8%AE%A1%E7%AE%97%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h1><p>一个计算流程图，就是正向或者说从左到右的计算来计算成本函数𝐽，你可能<br>需要优化的函数，然后反向从右到左计算导数。<br><img src="/2021/06/19/%E8%AE%A1%E7%AE%97%E5%9B%BE/1.png"><br><b>参考吴恩达深度学习视频：</b><a href="https://www.bilibili.com/video/BV1FT4y1E74V?p=15&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV1FT4y1E74V?p=15&amp;spm_id_from=pageDriver</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>计算图</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC | 设置springMVC配置文件的位置以及名称并控制servlet的加载时间</title>
    <url>/2022/03/12/%E8%AE%BE%E7%BD%AEspringMVC%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E5%90%8D%E7%A7%B0%E5%B9%B6%E6%8E%A7%E5%88%B6servlet%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<h1 id="设置springMVC配置文件的位置以及名称并控制servlet的加载时间"><a href="#设置springMVC配置文件的位置以及名称并控制servlet的加载时间" class="headerlink" title="设置springMVC配置文件的位置以及名称并控制servlet的加载时间"></a>设置springMVC配置文件的位置以及名称并控制servlet的加载时间</h1><p>设置springMVC配置文件的位置以及名称并控制servlet的加载时间只需要在web.xml文件中做以下配置即可：</p>
<p>快捷方式：Alt + / dispatcherservlet</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&gt;
  &lt;display-name&gt;SpringMVC02&lt;/display-name&gt;
  &lt;welcome-file-list&gt;
    &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;
  &lt;/welcome-file-list&gt;
  
  &lt;!-- The front controller of this Spring Web application, responsible for handling all application requests --&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;!-- 设置springMVC配置文件的位置以及名称 --&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        
        &lt;!-- 
            设置servlet的加载时间
            默认在第一次访问时加载，若设置此标签，会将servlet的加载时间提前到项目启动时
            此标签中可以整数，但是写负整数和0和没有设置时一样的效果，只有设置为正整数才会将servlet的加载时间提前到项目启动时
            值越小，优先级越高
         --&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;!-- Map all requests to the DispatcherServlet for handling --&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>SpringMVC</category>
        <category>设置springMVC配置文件的位置以及名称并控制servlet的加载时间</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>python-docx | 设置word文档里表格的格式</title>
    <url>/2021/10/24/%E8%AE%BE%E7%BD%AEword%E6%96%87%E6%A1%A3%E9%87%8C%E8%A1%A8%E6%A0%BC%E7%9A%84%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="设置word文档里表格的格式"><a href="#设置word文档里表格的格式" class="headerlink" title="设置word文档里表格的格式"></a>设置word文档里表格的格式</h1><p>以下代码实现使用python-docx对word文档里表格的格式进行设置。</p>
<span id="more"></span>

<pre><code># 单元格边框设置函数
from docx.table import _Cell
from docx.oxml import OxmlElement
from docx.oxml.ns import qn


def Set_cell_border(cell: _Cell, **kwargs):
    &quot;&quot;&quot;
    设置单元格边框函数
    使用方法:
    Set_cell_border(
        cell,
        top=&#123;&quot;sz&quot;: 12, &quot;val&quot;: &quot;single&quot;, &quot;color&quot;: &quot;#FF0000&quot;, &quot;space&quot;: &quot;0&quot;&#125;,
        bottom=&#123;&quot;sz&quot;: 12, &quot;color&quot;: &quot;#00FF00&quot;, &quot;val&quot;: &quot;single&quot;&#125;,
        start=&#123;&quot;sz&quot;: 24, &quot;val&quot;: &quot;dashed&quot;, &quot;shadow&quot;: &quot;true&quot;&#125;,
        end=&#123;&quot;sz&quot;: 12, &quot;val&quot;: &quot;dashed&quot;&#125;,
    )
    传入参数有cell, 即单元格；top指上边框；bottom指下边框；start指左边框；end指右边框。
    &quot;sz&quot;指线的粗细程度；&quot;val&quot;指线型，比如单线，虚线等；&quot;color&quot;指颜色，颜色编码可百度；
    &quot;space&quot;指间隔，一般不设置，设置的值大于0会导致线错开；&quot;shadow&quot;指边框阴影
    &quot;&quot;&quot;
    tc = cell._tc
    tcPr = tc.get_or_add_tcPr()

    tcBorders = tcPr.first_child_found_in(&quot;w:tcBorders&quot;)
    if tcBorders is None:
        tcBorders = OxmlElement(&#39;w:tcBorders&#39;)
        tcPr.append(tcBorders)

    for edge in (&#39;start&#39;, &#39;top&#39;, &#39;end&#39;, &#39;bottom&#39;, &#39;insideH&#39;, &#39;insideV&#39;):
        edge_data = kwargs.get(edge)
        if edge_data:
            tag = &#39;w:&#123;&#125;&#39;.format(edge)

            element = tcBorders.find(qn(tag))
            if element is None:
                element = OxmlElement(tag)
                tcBorders.append(element)

            for key in [&quot;sz&quot;, &quot;val&quot;, &quot;color&quot;, &quot;space&quot;, &quot;shadow&quot;]:
                if key in edge_data:
                    element.set(qn(&#39;w:&#123;&#125;&#39;.format(key)), str(edge_data[key]))


# 定义单元格填充颜色函数
from docx.oxml.ns import nsdecls
from docx.oxml import parse_xml


def Set_Background_Color(cell, rgbColor):
    shading_elm = parse_xml(
        r&#39;&lt;w:shd &#123;&#125; w:fill=&quot;&#123;color_value&#125;&quot;/&gt;&#39;.format(nsdecls(&#39;w&#39;), color_value=rgbColor))  # 固定写法，照抄即可
    cell._tc.get_or_add_tcPr().append(shading_elm)


from docx.enum.text import WD_ALIGN_PARAGRAPH  # 设置水平居中对齐需要用到的库
from docx.enum.table import WD_ALIGN_VERTICAL  # 设置垂直居中对齐需要用到的库
from docx.shared import Cm  # 长度单位（厘米cm用到的库)
from docx import Document

doc = Document(&quot;收货记录.docx&quot;)  # 打开word文件
table = doc.tables[0]
max_row = len(table.rows)  # 获取表格总行数

# 1.最后一行中，“总数”两个字要加粗
run = table.cell(max_row - 1, 4).paragraphs[0].runs[0]  # 获取最后一行第五列对应单元格中的文字块，即“总数”字样所在单元格
run.font.bold = True  # 将文字块设置为粗体

# 2.最后一行的行高要调大一点，现在这样扁扁的，难看
table.rows[max_row - 1].height = Cm(1)  # 将最后一行的行高设置为1厘米

# 3.最后一行那几个空单元格有框线，太碍眼，得去掉，将总数及左边两个cell左边框和下边框设成白色
for i in range(3):
    cell = table.cell(max_row - 1, i)
    Set_cell_border(
        cell,
        bottom=&#123;&quot;color&quot;: &quot;#FFFFFF&quot;&#125;,
        start=&#123;&quot;color&quot;: &quot;#FFFFFF&quot;&#125;,
        end=&#123;&quot;color&quot;: &quot;#FFFFFF&quot;&#125;
    )

cell_1 = table.cell(max_row - 1, 3)
Set_cell_border(cell_1, start=&#123;&quot;color&quot;: &quot;#FFFFFF&quot;&#125;, bottom=&#123;&quot;color&quot;: &quot;#FFFFFF&quot;&#125;)

cell_2 = table.cell(max_row - 1, 6)
Set_cell_border(cell_2, end=&#123;&quot;color&quot;: &quot;#FFFFFF&quot;&#125;, bottom=&#123;&quot;color&quot;: &quot;#FFFFFF&quot;&#125;)

# 4.各单元格水平和垂直方向都要居中对齐
for row in range(1, max_row):
    for col in range(len(table.columns)):
        table.cell(row, col).paragraphs[0].alignment = WD_ALIGN_PARAGRAPH.CENTER
        table.cell(row, col).vertical_alignment = WD_ALIGN_VERTICAL.CENTER

# 5.数量列≥85的，底色设置为橙色
qty = []  # 存储数量信息
# 读取第二行到29行，第2，3列中的数据
for i in range(1, max_row - 1):
    qty_info = table.rows[i].cells[5].text  # cells[5]指表格第6列
    qty.append(int(qty_info))

# 将数量≥85的单元格填色
row = 1  # 行计数器
for i in qty:
    if i &gt;= 85:
        cell = table.cell(row, 5)  # 第6列数据为数量，列索引是5
        Set_Background_Color(cell, &quot;98F5FF&quot;)  # 填充颜色，&quot;98F5FF&quot;是蓝色的编码
    row += 1  # 跳转到下一行

doc.save(&quot;收货记录-整理.docx&quot;)
</code></pre>
<p><a href="收货记录.docx">收货记录.docx</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>python-docx</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python-docx</tag>
      </tags>
  </entry>
  <entry>
    <title>win32com | 识别加密word文件</title>
    <url>/2021/10/31/%E8%AF%86%E5%88%AB%E5%8A%A0%E5%AF%86word%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="识别加密word文件"><a href="#识别加密word文件" class="headerlink" title="识别加密word文件"></a>识别加密word文件</h1><p>Python本身是难以识别word文件的加密状态的，那我们可以考虑利用程序在处理有密码的文档的时候的报错信息来进行处理。word文件有两种密码，一种是“打开密码”，另一种是“修改密码”。对于前者，若不输入正确的密码，是无法打开文件查看内容的；对于后者，即使不知道密码，还是可以用只读模式打开文件，查看内容并另存为新的文件的。<br>因此对于设置了“修改密码”的doc文件，并不影响用如下程序另存为docx文件。只是在另存之前，窗口会弹出如下对话框，我们只需要点击一下“只读”即可，程序就能正常运行下去。<br>如果设置了“打开密码”，程序在运行的时候也会弹出对话框，让输入密码。如果输入正确的密码，程序也是可以运行的；如果不知道密码或输入错误密码，则程序会出现如下的“com_error”错误。如果不知道密码，可以加入try..except..语句，让程序在except语句中将这个文件移动到名字为“有密码文件”的文件夹，以便后续处理。</p>
<span id="more"></span>
<p>实现代码：</p>
<pre><code>from win32com import client as wc  # 导入模块

file = r&quot;C:\Users\dywei\python\python_excel\实例65_Python区分出加密的word文件\doc文件\\测试-有打开密码.doc&quot;
word = wc.Dispatch(&quot;Word.Application&quot;)  # 打开word应用程序
doc = word.Documents.Open(file)  # 打开word文件
doc.SaveAs(&quot;&#123;&#125;x&quot;.format(file), 12)  # 另存为后缀为&quot;.docx&quot;的文件，其中参数12指docx文件
doc.Close()  # 关闭原来word文件
word.Quit()

# 增加异常处理语句
import shutil  # 用于操作文件和文件夹
from win32com import client as wc

file = r&quot;C:\Users\dywei\python\python_excel\实例65_Python区分出加密的word文件\doc文件\\测试-有打开密码.doc&quot;
try:
    word = wc.Dispatch(&quot;Word.Application&quot;)  # 打开word应用程序
    doc = word.Documents.Open(file)  # 打开word文件
    doc.SaveAs(&quot;&#123;&#125;x&quot;.format(file), 12)  # 另存为后缀为&quot;.docx&quot;的文件，其中参数12指docx文件
    doc.Close()  # 关闭原来word文件
    word.Quit()
except:
    # 将有密码的文件移动到专门的文件夹
    shutil.move(file, r&quot;C:\Users\dywei\python\python_excel\实例65_Python区分出加密的word文件\有密码文件&quot;)
    print(f&quot;已移动加密文件 &#123;file&#125;&quot;)

# #文件有“打开密码”的情况
# import docx
# doc = docx.Document(&#39;docx文件\\报告-有打开密码.docx&#39;)
# PackageNotFoundError: Package not found at &#39;docx文件\报告-有打开密码.docx&#39;

# 文件有“修改密码”的情况
import docx

doc = docx.Document(&#39;docx文件\\报告-有修改密码.docx&#39;)
p = doc.paragraphs[0]
pNew = p.insert_paragraph_before()
run = pNew.add_run(&quot;测试&quot;)
doc.save(&quot;docx文件\\报告-有修改密码.docx&quot;)

import docx
import shutil
file = &quot;docx文件\\报告-有打开密码.docx&quot;
try:
    doc = docx.Document(file)
    pass
except:
    shutil.move(file, &#39;有密码文件&#39;)
    print(f&quot;已移动加密文件 &#123;file&#125; 到指定文件夹&quot;)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>win32com</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>win32com</tag>
        <tag>python-docx</tag>
        <tag>shutil</tag>
      </tags>
  </entry>
  <entry>
    <title>wordcloud | 词云</title>
    <url>/2021/10/28/%E8%AF%8D%E4%BA%91/</url>
    <content><![CDATA[<h1 id="词云"><a href="#词云" class="headerlink" title="词云"></a>词云</h1><p>根据文章中的关键词的词频生成词云图。</p>
<span id="more"></span>

<p>实现代码：</p>
<pre><code>import numpy as np  # numpy数据处理库
import wordcloud  # 词云库
from PIL import Image  # 图像处理库，用于读取背景图片
import matplotlib.pyplot as plt  # 图像展示库，以便在notebook中显示图片
from openpyxl import load_workbook  # 读取词频Excel文件
import os  # 获取词频Excel文件路径

# 将存好的Excel词频表读取成字典
path = &#39;词频&#39;  # 文件所在文件夹
files = [path + &quot;\\&quot; + i for i in os.listdir(path)]  # 获取文件夹下的文件名,并拼接完整路径
maskImage = np.array(Image.open(&#39;background.png&#39;))  # 定义词频背景图

for file in files:
    # 将词频Excel文件读取为字典
    wb = load_workbook(file)
    ws = wb.active
    wordFreq = &#123;&#125;
    for i in range(2, ws.max_row + 1):
        word = ws[&quot;A&quot; + str(i)].value
        freq = ws[&quot;B&quot; + str(i)].value
        wordFreq[word] = freq

        # 定义词云样式
    wc = wordcloud.WordCloud(
        font_path=&#39;C:/Windows/Fonts/simhei.ttf&#39;,  # 设置字体
        mask=maskImage,  # 设置背景图
        max_words=500,  # 最多显示词数
        max_font_size=100)  # 字号最大值

    # 生成词云图
    wc.generate_from_frequencies(wordFreq)  # 从字典生成词云
    # 保存图片到指定文件夹
    wc.to_file(&quot;词云图\\&#123;&#125;.png&quot;.format(file.split(&quot;\\&quot;)[1][:4]))
    # 在notebook中显示词云图
    plt.imshow(wc)  # 显示词云
    plt.axis(&#39;off&#39;)  # 关闭坐标轴
    plt.show()  # 显示图像
</code></pre>
<p><a href="https://victory-liao.github.io/2021/10/27/python%E8%AF%8D%E9%A2%91%E5%88%86%E6%9E%90/#more">词频文件夹</a><br><a href="background.PNG">background.PNG</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>wordcloud</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>wordcloud</tag>
        <tag>词云</tag>
      </tags>
  </entry>
  <entry>
    <title>锁 | 读写锁+HashMap实现线程安全的HashMap</title>
    <url>/2022/06/06/%E8%AF%BB%E5%86%99%E9%94%81-HashMap%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84HashMap/</url>
    <content><![CDATA[<h1 id="读写锁-HashMap实现线程安全的HashMap"><a href="#读写锁-HashMap实现线程安全的HashMap" class="headerlink" title="读写锁+HashMap实现线程安全的HashMap"></a>读写锁+HashMap实现线程安全的HashMap</h1><p>ReadWriteLockCache组合一个非线程安全的HashMap作为缓存的实现，同时使用读写锁的读锁和写锁来保证ReadWriteLockCaChe是线程安全的。<br><strong>代码：</strong></p>
<pre><code>package concurrency.AQS; 

import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class ReadWriteLockCache &#123;
    public static void main(String[] args) &#123;
        ReadWriteLockCache.put(&quot;user1&quot;, &quot;123&quot;);
        ReadWriteLockCache.put(&quot;user2&quot;, &quot;456&quot;);
        ReadWriteLockCache.put(&quot;user3&quot;, &quot;789&quot;);
        for(Entry entry : ReadWriteLockCache.map.entrySet())&#123;
            System.out.println(entry.getKey()+&quot;:&quot;+entry.getValue());
        &#125;
        System.out.println(&quot;==========================&quot;);
        ReadWriteLockCache.put(&quot;user1&quot;, &quot;1233&quot;);
        for(Entry entry : ReadWriteLockCache.map.entrySet())&#123;
            System.out.println(entry.getKey()+&quot;:&quot;+entry.getValue());
        &#125;
        System.out.println(&quot;==========================&quot;);
        System.out.println(&quot;user1&quot; + ReadWriteLockCache.get(&quot;user1&quot;));
        System.out.println(&quot;==========================&quot;);
        ReadWriteLockCache.clear();
        for(Entry entry : ReadWriteLockCache.map.entrySet())&#123;
            System.out.println(entry.getKey()+&quot;:&quot;+entry.getValue());
        &#125;
        
    &#125;
    
    static Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
    static ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
    static Lock r = rwl.readLock();
    static Lock w = rwl.writeLock();
    
    //获取一个key对应的value
    public static final Object get(String key)&#123;
        r.lock();
        try&#123;
            return map.get(key);
        &#125;finally&#123;
            r.unlock();
        &#125;
    &#125;
    
    //设置key对应的value，并返回旧的value
    public static final Object put(String key, Object value)&#123;
        w.lock();
        try&#123;
            return map.put(key, value);
        &#125;finally&#123;
            w.unlock();
        &#125;
    &#125;
    
    //清空所有内容
    public static final void clear()&#123;
        w.lock();
        try&#123;
            map.clear();
        &#125;finally&#123;
            w.unlock();
        &#125;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
        <category>锁</category>
        <category>读写锁+HashMap实现线程安全的HashMap</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>负载均衡</title>
    <url>/2022/05/31/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p><a href="https://blog.csdn.net/wanghangzhen/article/details/118554304">负载均衡</a></p>
]]></content>
      <tags>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>基于JavaWeb的网上购物商城 | 购物车</title>
    <url>/2022/01/15/%E8%B4%AD%E7%89%A9%E8%BD%A6/</url>
    <content><![CDATA[<h1 id="购物车"><a href="#购物车" class="headerlink" title="购物车"></a>购物车</h1><p><strong>实现功能：</strong><br>用户在登录状态下可以将商品加入购物车（如下图所示）。<br><img src="/2022/01/15/%E8%B4%AD%E7%89%A9%E8%BD%A6/1.PNG"></p>
<span id="more"></span>
<p><strong>product_info.jsp</strong><br>（1）给购物车按钮增加onclick属性。</p>
<pre><code>&lt;div style=&quot;margin: 20px 0 10px 0;; text-align: center;&quot;&gt;
    &lt;a href=&quot;#&quot;&gt; &lt;input
        style=&quot;background: url(&#39;./images/product.gif&#39;) no-repeat scroll 0 -600px rgba(0, 0, 0, 0); height: 36px; width: 127px;&quot;
        value=&quot;加入购物车&quot; type=&quot;button&quot; onclick=&quot;cart()&quot;&gt;
    &lt;/a&gt; &amp;nbsp;收藏商品
&lt;/div&gt;
</code></pre>
<p>（2）使用js编写cart()</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    function cart()&#123;
        location.href=&quot;$&#123;pageContext.request.contextPath&#125;/product?method=cart&amp;pid=$&#123;p.pid&#125;&amp;proNumber=&quot;+$(&quot;#quantity&quot;).val();
    &#125;
&lt;/script&gt;
</code></pre>
<p><strong>CartItem.java</strong><br>一个购物项（由一个商品、数量、小计构成）<br><img src="/2022/01/15/%E8%B4%AD%E7%89%A9%E8%BD%A6/2.PNG"></p>
<pre><code>package com.oracle.bean;

public class CartItem &#123;
    private Product pro = new Product();
    private double subTotal;
    private int count;
    public CartItem() &#123;
        super();
        // TODO Auto-generated constructor stub
    &#125;
    public CartItem(Product pro, double subTotal, int count) &#123;
        super();
        this.pro = pro;
        this.subTotal = subTotal;
        this.count = count;
    &#125;
    public Product getPro() &#123;
        return pro;
    &#125;
    public void setPro(Product pro) &#123;
        this.pro = pro;
    &#125;
    public double getSubTotal() &#123;
        return subTotal;
    &#125;
    public void setSubTotal(double subTotal) &#123;
        this.subTotal = subTotal;
    &#125;
    public int getCount() &#123;
        return count;
    &#125;
    public void setCount(int count) &#123;
        this.count = count;
    &#125;
    
&#125;
</code></pre>
<p><strong>Cart.java</strong><br>购物车（由一个存储许多购物项的Map集合、总计金额构成）<br><img src="/2022/01/15/%E8%B4%AD%E7%89%A9%E8%BD%A6/3.PNG"></p>
<pre><code>package com.oracle.bean;

import java.util.HashMap;
import java.util.List;

public class Cart &#123;
    private HashMap&lt;String, CartItem&gt; map = new HashMap&lt;&gt;();
    private double subMoney;
    public Cart() &#123;
        super();
        // TODO Auto-generated constructor stub
    &#125;
    public Cart(HashMap&lt;String, CartItem&gt; map, double subMoney) &#123;
        super();
        this.map = map;
        this.subMoney = subMoney;
    &#125;
    public HashMap&lt;String, CartItem&gt; getMap() &#123;
        return map;
    &#125;
    public void setMap(HashMap&lt;String, CartItem&gt; map) &#123;
        this.map = map;
    &#125;
    public double getSubMoney() &#123;
        return subMoney;
    &#125;
    public void setSubMoney(double subMoney) &#123;
        this.subMoney = subMoney;
    &#125;
    
&#125;
</code></pre>
<p><strong>ProductServlet.java</strong><br>在ProductServlet的doGet方法中添加购物车的判断并完成cart方法。</p>
<pre><code>public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
    String method = request.getParameter(&quot;method&quot;);
    if(&quot;getProById&quot;.equals(method)) &#123;
        getProById(request, response);
    &#125;else if(&quot;findListByCate&quot;.equals(method)) &#123;
        findListByCate(request, response);
    &#125;else if(&quot;cart&quot;.equals(method)) &#123;
        cart(request, response);
    &#125;
&#125;

public void cart(HttpServletRequest request, HttpServletResponse response) &#123;
    // TODO Auto-generated method stub
    //接收前台参数
    try &#123;
        String pid = request.getParameter(&quot;pid&quot;);
        String pn = request.getParameter(&quot;proNumber&quot;);
        int proNumber = Integer.parseInt(pn);
        //查询商品信息
        ProductService ps = new ProductService();
        Product pro = ps.getProById(pid);
        
        //从session中获取购物车
        HttpSession session = request.getSession();
        Cart cart = (Cart)session.getAttribute(&quot;cart&quot;);
        //判断用户是否登录
        User user = (User)session.getAttribute(&quot;user&quot;);
        if(user==null) &#123;
            //跳转到首页
            request.getRequestDispatcher(&quot;/login.jsp&quot;).forward(request, response);
            return;
        &#125;
        
        //判断购物车是否为空
        if(cart==null) &#123;
            //创建一个新的购物车
            cart = new Cart();
        &#125;
        //否则有数据    有数据的话添加商品
        HashMap&lt;String, CartItem&gt; map = cart.getMap();
        if(map.containsKey(pid)) &#123;
            //购物车中已经存在当前要购买的商品
            //获取购物车中商品的数量
            CartItem ci = map.get(pid);
            //获取购物车中商品的数量
            int count = ci.getCount();
            //购物车商品数量+需要购买的商品的数量=总数
            int newCount = count+proNumber;
            //商品小计
            double subTotal = newCount * pro.getShop_price();
            
            ci.setCount(newCount);
            ci.setSubTotal(subTotal);
            map.put(pid, ci);
        &#125;else &#123;
            //购物车中不存在购买的商品
            CartItem ca = new CartItem();
            ca.setPro(pro);
            ca.setCount(proNumber);
            ca.setSubTotal(proNumber*pro.getShop_price());
            map.put(pid, ca);
        &#125;
        //定义变量存储总计
        double totalMoney=0.0;
        Set&lt;String&gt; keySet = map.keySet();
        for(String key:keySet) &#123;
            CartItem cc = map.get(key);
            totalMoney+=cc.getSubTotal();
        &#125;
        cart.setSubMoney(totalMoney);
        cart.setMap(map);
        
        //把购物车放入session中
        session.setAttribute(&quot;cart&quot;, cart);
        
        //请求转发到购物车页面解析
        request.getRequestDispatcher(&quot;/cart.jsp&quot;).forward(request, response);
        
    &#125; catch (Exception e) &#123;
        // TODO Auto-generated catch block
        e.printStackTrace();
    &#125;
&#125;public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
    String method = request.getParameter(&quot;method&quot;);
    if(&quot;getProById&quot;.equals(method)) &#123;
        getProById(request, response);
    &#125;else if(&quot;findListByCate&quot;.equals(method)) &#123;
        findListByCate(request, response);
    &#125;else if(&quot;cart&quot;.equals(method)) &#123;
        cart(request, response);
    &#125;
&#125;

public void cart(HttpServletRequest request, HttpServletResponse response) &#123;
    // TODO Auto-generated method stub
    //接收前台参数
    try &#123;
        String pid = request.getParameter(&quot;pid&quot;);
        String pn = request.getParameter(&quot;proNumber&quot;);
        int proNumber = Integer.parseInt(pn);
        //查询商品信息
        ProductService ps = new ProductService();
        Product pro = ps.getProById(pid);
        
        //从session中获取购物车
        HttpSession session = request.getSession();
        Cart cart = (Cart)session.getAttribute(&quot;cart&quot;);
        //判断用户是否登录
        User user = (User)session.getAttribute(&quot;user&quot;);
        if(user==null) &#123;
            //跳转到首页
            request.getRequestDispatcher(&quot;/login.jsp&quot;).forward(request, response);
            return;
        &#125;
        
        //判断购物车是否为空
        if(cart==null) &#123;
            //创建一个新的购物车
            cart = new Cart();
        &#125;
        //否则有数据    有数据的话添加商品
        HashMap&lt;String, CartItem&gt; map = cart.getMap();
        if(map.containsKey(pid)) &#123;
            //购物车中已经存在当前要购买的商品
            //获取购物车中商品的数量
            CartItem ci = map.get(pid);
            //获取购物车中商品的数量
            int count = ci.getCount();
            //购物车商品数量+需要购买的商品的数量=总数
            int newCount = count+proNumber;
            //商品小计
            double subTotal = newCount * pro.getShop_price();
            
            ci.setCount(newCount);
            ci.setSubTotal(subTotal);
            map.put(pid, ci);
        &#125;else &#123;
            //购物车中不存在购买的商品
            CartItem ca = new CartItem();
            ca.setPro(pro);
            ca.setCount(proNumber);
            ca.setSubTotal(proNumber*pro.getShop_price());
            map.put(pid, ca);
        &#125;
        //定义变量存储总计
        double totalMoney=0.0;
        Set&lt;String&gt; keySet = map.keySet();
        for(String key:keySet) &#123;
            CartItem cc = map.get(key);
            totalMoney+=cc.getSubTotal();
        &#125;
        cart.setSubMoney(totalMoney);
        cart.setMap(map);
        
        //把购物车放入session中
        session.setAttribute(&quot;cart&quot;, cart);
        
        //请求转发到购物车页面解析
        request.getRequestDispatcher(&quot;/cart.jsp&quot;).forward(request, response);
        
    &#125; catch (Exception e) &#123;
        // TODO Auto-generated catch block
        e.printStackTrace();
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>项目经历</category>
        <category>JavaWeb</category>
        <category>基于JavaWeb的网上购物商城</category>
        <category>购物车</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
        <tag>基于JavaWeb的网上购物商城</tag>
        <tag>购物车</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 赎金信</title>
    <url>/2021/09/01/%E8%B5%8E%E9%87%91%E4%BF%A1/</url>
    <content><![CDATA[<h1 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383.赎金信"></a>383.赎金信</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。<br>(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/ransom-note/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>遍历ransomNote中的每一个元素，并查找这个元素是否在magazine中，如果没有查找到，则返回False，如果查找到了，则将这个元素在magazine中移除，以此类推，直到遍历完ransomNote中的每一个元素。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool:
        ransomNote = list(ransomNote)
        magazine = list(magazine)

        for i in range(len(ransomNote)):
            if ransomNote[i] in magazine:
                magazine.remove(ransomNote[i])
                print(ransomNote)
            else:
                return False

        if i == len(ransomNote)-1:
            return True


if __name__ == &#39;__main__&#39;:
    s = Solution()
    res = s.canConstruct(&#39;aa&#39;, &#39;aab&#39;)
    print(res)

    # list1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;]
    # list1.remove(&#39;a&#39;)
    # print(list1)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>软件架构 | 软件设计策略</title>
    <url>/2021/03/11/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h1 id="软件设计策略"><a href="#软件设计策略" class="headerlink" title="软件设计策略"></a>软件设计策略</h1><p>1.面向对象设计</p>
<p>2.面向功能设计(结构化)</p>
<p>3.面向主题设计</p>
<p>4.面向数据结构设计(数据库)</p>
]]></content>
      <categories>
        <category>SA</category>
      </categories>
      <tags>
        <tag>软件架构</tag>
      </tags>
  </entry>
  <entry>
    <title>python | 迭代器</title>
    <url>/2022/03/27/%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><pre><code># 创建一个返回数字的迭代器，初始值为 1，逐步递增 1：
class MyNumbers:
    def __iter__(self):
        self.a = 0
        return self

    def __next__(self):
        self.a = self.a + 1
        return self.a

# 奇数迭代器
class MyOddNumbers:
    def __iter__(self):
        self.num = 1
        return self

    def __next__(self):
        self.num = self.num + 2
        return self.num

# 偶数迭代器
class MyEvenNumbers:
    def __iter__(self):
        self.num = 0
        return self

    def __next__(self):
        self.num = self.num + 2
        return self.num

myclass = MyNumbers()
myiter = iter(myclass)
print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))
print(&quot;======================================&quot;)
my_odd_numbers = MyOddNumbers()
my_odd_numbers_iter = iter(my_odd_numbers)
print(next(my_odd_numbers_iter))
print(next(my_odd_numbers_iter))
print(next(my_odd_numbers_iter))
print(next(my_odd_numbers_iter))
print(&quot;======================================&quot;)
my_even_numbers = MyEvenNumbers()
my_even_numbers_iter = iter(my_even_numbers)
print(next(my_even_numbers_iter))
print(next(my_even_numbers_iter))
print(next(my_even_numbers_iter))
print(next(my_even_numbers_iter))
</code></pre>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>迭代器</tag>
        <tag>iterator</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis | 逆向工程</title>
    <url>/2022/04/16/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h1><p>1.项目目录<br><img src="/2022/04/16/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/1.PNG"><br>2.导入逆向工程的jar包</p>
<pre><code>mybatis-generator-core-1.3.2.jar
</code></pre>
<p>3.编写MBG的配置文件</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE generatorConfiguration
  PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
  &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;

&lt;generatorConfiguration&gt;

  &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;
    &lt;!-- 设置连接数据库的信息 --&gt;
    &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;
        connectionURL=&quot;jdbc:mysql://localhost:3306/ssm&quot;
        userId=&quot;root&quot;
        password=&quot;root&quot;&gt;
    &lt;/jdbcConnection&gt;

    &lt;javaTypeResolver &gt;
      &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt;
    &lt;/javaTypeResolver&gt;

    &lt;!-- javabean的生成策略 --&gt;
    &lt;javaModelGenerator targetPackage=&quot;com.atguigu.bean&quot; targetProject=&quot;.\src&quot;&gt;
      &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;
      &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt;
    &lt;/javaModelGenerator&gt;


    &lt;!-- 映射文件的生成策略 --&gt;
    &lt;sqlMapGenerator targetPackage=&quot;com.atguigu.mapper&quot;  targetProject=&quot;.\conf&quot;&gt;
      &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;
    &lt;/sqlMapGenerator&gt;

    &lt;!-- mapper接口的生成策略 --&gt;
    &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.atguigu.mapper&quot;  targetProject=&quot;.\src&quot;&gt;
      &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;
    &lt;/javaClientGenerator&gt;

    &lt;!-- 设置要将数据库中的哪张表逆向生成哪一个javabean --&gt;
    &lt;table tableName=&quot;emp&quot; domainObjectName=&quot;Emp&quot;&gt;&lt;/table&gt;
    &lt;table tableName=&quot;dept&quot; domainObjectName=&quot;Dept&quot;&gt;&lt;/table&gt;

  &lt;/context&gt;
&lt;/generatorConfiguration&gt;
</code></pre>
<p>4.运行代码生成器生成代码</p>
<pre><code>@Test
public void testMBG() throws Exception &#123;
   List&lt;String&gt; warnings = new ArrayList&lt;String&gt;();
   boolean overwrite = true;
   File configFile = new File(&quot;mbg.xml&quot;);
   ConfigurationParser cp = new ConfigurationParser(warnings);
   Configuration config = cp.parseConfiguration(configFile);
   DefaultShellCallback callback = new DefaultShellCallback(overwrite);
   MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings);
   myBatisGenerator.generate(null);
&#125;
</code></pre>
<p>5.逆向工程的使用<br>基本查询与带条件查询测试</p>
<pre><code>@Test
    public void testCRUD() throws Exception&#123;
        SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
        SqlSession sqlSession = sqlSessionFactory.openSession(true);
        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
        
//        Emp emp = mapper.selectByPrimaryKey(2);
//        System.out.println(emp);
        
        EmpExample example = new EmpExample();
        
        Criteria c1 = example.createCriteria();
        c1.andEnameLike(&quot;%a%&quot;);
        c1.andSexEqualTo(&quot;1&quot;);
        
        Criteria c2 = example.createCriteria();
        c2.andDidEqualTo(2);
        
        example.or(c2);
        
        List&lt;Emp&gt; list = mapper.selectByExample(example);
        for (Emp emp : list) &#123;
            System.out.println(emp);
        &#125;
        
        //查询全部
//        List&lt;Emp&gt; list1 = mapper.selectByExample(null);
//        for (Emp emp : list1) &#123;
//            System.out.println(emp);
//        &#125;
    &#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>MyBatis</category>
        <category>逆向工程</category>
      </categories>
      <tags>
        <tag>逆向工程</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 逆波兰表达式求值</title>
    <url>/2021/08/27/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
    <content><![CDATA[<h1 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150.逆波兰表达式求值"></a>150.逆波兰表达式求值</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>根据 逆波兰表示法，求表达式的值。<br>有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。<br>说明：<br>    整数除法只保留整数部分。<br>    给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p>
<p>示例 1：<br>输入：tokens = [“2”,”1”,”+”,”3”,”*”]<br>输出：9<br>解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.栈<br>遍历逆波兰表达式中的每一个字符，遇到数字则将数字入栈，遇到运算符则将栈顶的两个操作数出栈作此运算符对应的运算，再将运算结果入栈，…，以此类推，直到遍历完整个表达式，栈中剩余的元素就是表达式的结果。<br>2.数组模拟栈<br>对于一个有效的逆波兰表达式，其长度 n 一定是奇数，且操作数的个数一定比运算符的个数多 1 个，即包含 (n+1)/2 个操作数和 (n-1)/2 个运算符。考虑遇到操作数和运算符时，栈内元素个数分别会如何变化：<br>    如果遇到操作数，则将操作数入栈，因此栈内元素增加 1 个；<br>    如果遇到运算符，则将两个操作数出栈，然后将一个新操作数入栈，因此栈内元素先减少 2 个再增加 1 个，结果是栈内元素减少 1 个。<br>由此可以得到操作数和运算符与栈内元素个数变化的关系：遇到操作数时，栈内元素增加 1 个；遇到运算符时，栈内元素减少 1 个。<br>最坏情况下，(n+1)/2 个操作数都在表达式的前面，(n-1)/2 个运算符都在表达式的后面，此时栈内元素最多为 (n+1)/2 个。在其余情况下，栈内元素总是少于 (n+1)/2 个。因此，在任何情况下，栈内元素最多可能有 (n+1)/2 个，将数组的长度定义为 (n+1)/2 即可。<br>具体实现方面，创建数组 stack 模拟栈，数组下标 0 的位置对应栈底，定义 index 表示栈顶元素的下标位置，初始时栈为空，index=−1。当遇到操作数和运算符时，进行如下操作：<br>    如果遇到操作数，则将 index 的值加 111，然后将操作数赋给 stack[index]；<br>    如果遇到运算符，则将 index 的值减 111，此时 stack[index] 和 stack[index+1] 的元素分别是左操作数和右操作数，使用运算符对两个操作数进行运算，将运算得到的新操作数赋给 stack[index]。<br>整个逆波兰表达式遍历完毕之后，栈内只有一个元素，因此 index=0，此时 stack[index] 即为逆波兰表达式的值。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):
    def evalRPN(self, tokens):
        &quot;&quot;&quot;
        使用栈进行表达式求值

        :type tokens: List[str]
        :rtype: int
        &quot;&quot;&quot;
        op_to_binary_fn = &#123;
            &quot;+&quot;: lambda x, y: x + y,
            &#39;-&#39;: lambda x, y: x - y,
            &#39;*&#39;: lambda x, y: x * y,
            &#39;/&#39;: lambda x, y: int(x / y),
        &#125;

        stack = list()
        for token in tokens:
            try:
                num = int(token)
            except ValueError:
                num2 = stack.pop()
                num1 = stack.pop()
                num = op_to_binary_fn[token](num1, num2)
            finally:
                stack.append(num)

        return stack[0]

    def evalRPN1(self, tokens):
        &quot;&quot;&quot;
        使用数组模拟栈进行表达式求值

        :type tokens: List[str]
        :rtype: int
        &quot;&quot;&quot;
        op_to_binary_fn = &#123;
            &quot;+&quot;: lambda x, y: x + y,
            &#39;-&#39;: lambda x, y: x - y,
            &#39;*&#39;: lambda x, y: x * y,
            &#39;/&#39;: lambda x, y: int(x / y),
        &#125;
        n = len(tokens)
        stack = [0] * ((n + 1) // 2)
        index = -1
        for token in tokens:
            try:
                num = int(token)
                index += 1
                stack[index] = num
            except ValueError:
                index -= 1
                stack[index] = op_to_binary_fn[token](stack[index], stack[index + 1])
        return stack[0]


if __name__ == &quot;__main__&quot;:
    slt = Solution()
    # tokens = [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]
    # tokens = [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]
    tokens = [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]
    print(&quot;表达式的值为：&#123;&#125;&quot;.format(slt.evalRPN1(tokens)))
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>python | 闭包</title>
    <url>/2021/11/07/%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>python中的闭包从表现形式上定义（解释）为：如果在一个内部函数里，对在外部作用域（但不是在全局作用域）的变量进行引用，那么内部函数就被认为是闭包(closure).<br><strong>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</strong></p>
<span id="more"></span>
<p><strong>闭包示例：</strong></p>
<pre><code># 示例1
def create_pointer(my_string):
    def pointer(n):
        return my_string[n]
    return pointer

pointer = create_pointer(&#39;my name is Molly&#39;)
pointer(5)

# 示例2
def count():
fs = []
for i in range(1, 4):
    def f():
        # print(id(i))
        return i*i
    fs.append(f)
return fs

f1, f2, f3 = count()

print(f1())
print(f2())
print(f3())

# 返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。
def count():
def f(j):
    def g():
        # print(id(j))
        return j*j
    return g
fs = []
for i in range(1, 4):
    fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()
return fs

f1, f2, f3 = count()
print(f1())
print(f2())
print(f3())
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
        <category>闭包</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 防止模型过拟合的6种必备方法</title>
    <url>/2021/07/03/%E9%98%B2%E6%AD%A2%E6%A8%A1%E5%9E%8B%E8%BF%87%E6%8B%9F%E5%90%88%E7%9A%846%E7%A7%8D%E5%BF%85%E5%A4%87%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="防止模型过拟合的6种必备方法"><a href="#防止模型过拟合的6种必备方法" class="headerlink" title="防止模型过拟合的6种必备方法"></a>防止模型过拟合的6种必备方法</h1><p>在训练机器学习模型时常常会遇到模型过拟合的情况，即模型在训练集上的表现良好，但是在验证集或者<br>测试集上表现相对较差；<br><b>常见的防止过拟合的方法：</b><br>1.使用K重交叉验证方法或者留一验证方法<br>2.数据增强<br>3.正则化<br>4.早停<br>5.Dropout<br>6.移除特征<br><a href="https://mp.weixin.qq.com/s/RP9iFbyw-aNMKx-UAOe-aA">参考资料</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>过拟合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java | 静态代理</title>
    <url>/2022/03/10/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h1 id="静态代理案例"><a href="#静态代理案例" class="headerlink" title="静态代理案例"></a>静态代理案例</h1><p>通过静态代理来帮助发短信(短信发送类和代理类实现相同的接口)<br><strong>SmsService.java(接口)</strong></p>
<pre><code>package proxy;

public interface SmsService &#123;
    String send(String message);
&#125;
</code></pre>
<p><strong>SmsServiceImpl.java(实现类)</strong></p>
<pre><code>package proxy;

public class SmsServiceImpl implements SmsService&#123;

    @Override
    public String send(String message) &#123;
        System.out.println(&quot;send message:&quot; + message);
        return message;
    &#125;

&#125;
</code></pre>
<p><strong>SmsProxy.java(代理类)</strong></p>
<pre><code>package proxy;

public class SmsProxy implements SmsService&#123;
    private final SmsService smsService;
    
    public SmsProxy(SmsService smsService)&#123;
        this.smsService = smsService;
    &#125;
    
    @Override
    public String send(String message) &#123;
        System.out.println(&quot;before method send()&quot;);
        smsService.send(message);
        System.out.println(&quot;after method send()&quot;);
        return null;
    &#125;
&#125;
</code></pre>
<p><strong>Main.java(测试类)</strong></p>
<pre><code>package proxy;

public class Main &#123;
    public static void main(String[] args)&#123;
        SmsService smsService = new SmsServiceImpl();
        SmsProxy smsProxy = new SmsProxy(smsService);
        smsProxy.send(&quot;java&quot;);
    &#125;
&#125;
</code></pre>
<p><strong>运行结果</strong><br><img src="/2022/03/10/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/1.PNG"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
        <category>静态代理</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>静态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb项目开发 | 项目技术栈</title>
    <url>/2022/01/09/%E9%A1%B9%E7%9B%AE%E6%8A%80%E6%9C%AF%E6%A0%88/</url>
    <content><![CDATA[<h1 id="项目技术栈"><a href="#项目技术栈" class="headerlink" title="项目技术栈"></a>项目技术栈</h1><p>表格列出了开发网上购物商城所用到的技术。</p>
<table>
<thead>
<tr>
<th>技术</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>html</td>
<td>写静态页面</td>
</tr>
<tr>
<td>css</td>
<td>渲染页面</td>
</tr>
<tr>
<td>js/jquery</td>
<td>可以为html增加动画效果</td>
</tr>
<tr>
<td>bootstrap</td>
<td>前端框架</td>
</tr>
<tr>
<td>Servlet</td>
<td>接受请求,处理请求,生成动态的web资源</td>
</tr>
<tr>
<td>Request</td>
<td>请求</td>
</tr>
<tr>
<td>session</td>
<td>服务器端会话技术</td>
</tr>
<tr>
<td>filter</td>
<td>过滤请求和响应</td>
</tr>
<tr>
<td>jsp</td>
<td>动态展示数据</td>
</tr>
<tr>
<td>el和jstl</td>
<td>el:jsp中的输出表达式 jstl:减少页面JAVA代码量 让结构更加清晰</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb项目开发</category>
        <category>项目技术栈</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 飞桨推出的深度学习资料一站式获取平台项目</title>
    <url>/2021/06/23/%E9%A3%9E%E6%A1%A8%E6%8E%A8%E5%87%BA%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E4%B8%80%E7%AB%99%E5%BC%8F%E8%8E%B7%E5%8F%96%E5%B9%B3%E5%8F%B0%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="飞桨推出的深度学习资料一站式获取平台项目"><a href="#飞桨推出的深度学习资料一站式获取平台项目" class="headerlink" title="飞桨推出的深度学习资料一站式获取平台项目"></a>飞桨推出的深度学习资料一站式获取平台项目</h1><p>这是飞桨推出的深度学习资料一站式获取平台项目，可以看看有没有符合自己的资料哈~~</p>
<p><a href="https://github.com/PaddlePaddle/awesome-DeepLearning">飞桨PaddlePaddle</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>飞桨</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 验证回文串</title>
    <url>/2021/08/28/%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125.验证回文串"></a>125.验证回文串</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。<br>说明：本题中，我们将空字符串定义为有效的回文串。</p>
<span id="more"></span>
<p>示例 1:<br>输入: “A man, a plan, a canal: Panama”<br>输出: true<br>解释：”amanaplanacanalpanama” 是回文串</p>
<p><a href="https://leetcode-cn.com/problems/count-and-say/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.判断第i(0 &lt; i &lt; len(new_s)//2)个字符与倒数第i个字符是否相等来确定字符串是否回文，其中new_s是去除了除数字字母外字符的字符串<br>2.判断反转字符串是否与原字符串相同<br>3.双指针（去除除数字字母外的其他字符）<br>初始时，左右指针分别指向字符串的两侧，随后我们不断地将这两个指针相向移动，每次移动一步，并判断这两个指针指向的字符是否相同。当这两个指针相遇时，就说明是回文串。<br>4.双指针（直接在原字符串上进行判断）<br>与3.相同</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def isPalindrome(self, s: str) -&gt; bool:
        import re
        new_s = re.sub(r&#39;\W|_&#39;, &#39;&#39;, s).lower()
        len_new_s = len(new_s)
        i = 0
        while i &lt; len_new_s // 2:
            if new_s[i] == new_s[len_new_s-i-1]:
                i += 1
            else:
                break
        if i == len_new_s // 2:
            return True
        else:
            return False

    def isPalindrome1(self, s: str) -&gt; bool:
        &quot;&quot;&quot;
        筛选+判断（判断反转字符串是否与原字符串相同）
        :param s:
        :return:
        &quot;&quot;&quot;
        new_s = &quot;&quot;.join(ch.lower() for ch in s if ch.isalnum())
        return new_s == new_s[::-1]

    def isPalindrome2(self, s: str) -&gt; bool:
        &quot;&quot;&quot;
        双指针
        &quot;&quot;&quot;
        new_s = &quot;&quot;.join(ch.lower() for ch in s if ch.isalnum())
        left, right = 0, len(new_s) - 1

        while left &lt; right:
            if new_s[left] != new_s[right]:
                return False

            left, right = left + 1, right - 1

        return True

    def isPalindrome3(self, s: str) -&gt; bool:
        &quot;&quot;&quot;在原字符串上直接判断&quot;&quot;&quot;
        n = len(s)
        left, right = 0, n - 1

        while left &lt; right:
            while left &lt; right and not s[left].isalnum():
                left += 1
            while left &lt; right and not s[right].isalnum():
                right -= 1
            if left &lt; right:
                if s[left].lower() != s[right].lower():
                    return False
                left, right = left + 1, right - 1

        return True


if __name__ == &quot;__main__&quot;:
    slt = Solution()
    string = &quot;abcb&quot;
    res = slt.isPalindrome(string)
    print(res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>python | 高阶函数</title>
    <url>/2021/11/07/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><p>高阶函数：一个函数可以接收另一个函数作为参数，这种函数就称为高阶函数</p>
<span id="more"></span>

<h1 id="print本身是一个内建函数"><a href="#print本身是一个内建函数" class="headerlink" title="print本身是一个内建函数"></a>print本身是一个内建函数</h1><pre><code>print(&#39;hello!&#39;)
</code></pre>
<h1 id="函数名其实就是指向函数的变量！"><a href="#函数名其实就是指向函数的变量！" class="headerlink" title="函数名其实就是指向函数的变量！"></a>函数名其实就是指向函数的变量！</h1><pre><code>my_print = print 
my_print(&#39;a&#39;)
</code></pre>
<h1 id="那么，函数的名字也可以作为一个变量，传入其它函数"><a href="#那么，函数的名字也可以作为一个变量，传入其它函数" class="headerlink" title="那么，函数的名字也可以作为一个变量，传入其它函数"></a>那么，函数的名字也可以作为一个变量，传入其它函数</h1><pre><code>def func_x(x, f):
    return f(x)

func_x(-1, abs)
</code></pre>
<h1 id="一个函数可以接收另一个函数作为参数，这种函数就称之为高阶函数。"><a href="#一个函数可以接收另一个函数作为参数，这种函数就称之为高阶函数。" class="headerlink" title="一个函数可以接收另一个函数作为参数，这种函数就称之为高阶函数。"></a>一个函数可以接收另一个函数作为参数，这种函数就称之为高阶函数。</h1><pre><code>int2str = lambda x : str(x)
func_x(-112, int2str)
</code></pre>
<h1 id="一个更复杂的例子"><a href="#一个更复杂的例子" class="headerlink" title="一个更复杂的例子"></a>一个更复杂的例子</h1><pre><code>def func_xy(x, y, f):
    return f(x,y)

add = lambda x,y : x+y 
mul = lambda x,y : x*y 
SS = lambda x,y : x**2 + y**2

print(func_xy(1,2,add))
print(func_xy(1,2,mul))
print(func_xy(1,2,SS))
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
        <category>高阶函数</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>高阶函数</tag>
      </tags>
  </entry>
  <entry>
    <title>ICA | 鸡尾酒宴会问题</title>
    <url>/2021/02/21/%E9%B8%A1%E5%B0%BE%E9%85%92%E5%AE%B4%E4%BC%9A%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="鸡尾酒宴会问题"><a href="#鸡尾酒宴会问题" class="headerlink" title="鸡尾酒宴会问题"></a>鸡尾酒宴会问题</h1><p>鸡尾酒宴会问题是独立成分分析(Indepen Compon Analysis)的经典问题。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>假设在party中有n个人，他们可以同时说话，我们也在房间中一些角落里共放置了n个声音接收器（Microphone）用来记录声音。宴会过后，我们从n个麦克风中得到了一组数据<br><img src="/2021/02/21/%E9%B8%A1%E5%B0%BE%E9%85%92%E5%AE%B4%E4%BC%9A%E9%97%AE%E9%A2%98/1.png"><br>，i表示采样的时间顺序，也就是说共得到了m组采样，每一组采样都是n维的。我们的目标是单单从这m组采样数据中分辨出每个人说话的信号。</p>
<p>将第二个问题细化一下，有n个信号源<br><img src="/2021/02/21/%E9%B8%A1%E5%B0%BE%E9%85%92%E5%AE%B4%E4%BC%9A%E9%97%AE%E9%A2%98/2.png"><br>,每一维都是一个人的声音信号，每个人发出的声音信号独立。A是一个未知的混合矩阵（mixing matrix），用来组合叠加信号s，那么<br>X = AS<br>X的意义在上文解释过，这里的x不是一个向量，是一个矩阵。其中每个列向量是<br><img src="/2021/02/21/%E9%B8%A1%E5%B0%BE%E9%85%92%E5%AE%B4%E4%BC%9A%E9%97%AE%E9%A2%98/3.png"><br>表示成图就是<br><img src="/2021/02/21/%E9%B8%A1%E5%B0%BE%E9%85%92%E5%AE%B4%E4%BC%9A%E9%97%AE%E9%A2%98/4.jpg"><br><img src="/2021/02/21/%E9%B8%A1%E5%B0%BE%E9%85%92%E5%AE%B4%E4%BC%9A%E9%97%AE%E9%A2%98/5.png"><br>x(i)的每个分量都由s(i)的分量线性表示。A和s都是未知的，x是已知的，我们要想办法根据x来推出s。这个过程也称作为盲信号分离。<br><img src="/2021/02/21/%E9%B8%A1%E5%B0%BE%E9%85%92%E5%AE%B4%E4%BC%9A%E9%97%AE%E9%A2%98/8.png"><br>将W表示成<br><img src="/2021/02/21/%E9%B8%A1%E5%B0%BE%E9%85%92%E5%AE%B4%E4%BC%9A%E9%97%AE%E9%A2%98/9.png"><br>其中<img src="/2021/02/21/%E9%B8%A1%E5%B0%BE%E9%85%92%E5%AE%B4%E4%BC%9A%E9%97%AE%E9%A2%98/10.png">,起始就是将wi携程行向量形式。那么得到：<br><img src="/2021/02/21/%E9%B8%A1%E5%B0%BE%E9%85%92%E5%AE%B4%E4%BC%9A%E9%97%AE%E9%A2%98/11.png"></p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>伪迹移除</category>
      </categories>
      <tags>
        <tag>ICA</tag>
        <tag>鸡尾酒宴会问题</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC | REST CRUD</title>
    <url>/2022/03/13/REST-CRUD/</url>
    <content><![CDATA[<h1 id="REST-CRUD案例"><a href="#REST-CRUD案例" class="headerlink" title="REST CRUD案例"></a>REST CRUD案例</h1><p>1.项目目录<br><img src="/2022/03/13/REST-CRUD/1.PNG"></p>
<span id="more"></span>
<p>2.导入上图中的所有jar包<br>3.配置web.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&gt;
  &lt;display-name&gt;RestEmp&lt;/display-name&gt;
  &lt;welcome-file-list&gt;
    &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;
  &lt;/welcome-file-list&gt;
  
  &lt;filter&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;UTF-8&lt;/param-value&gt;
    &lt;/init-param&gt;
  &lt;/filter&gt;
  &lt;filter-mapping&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;
  
  &lt;filter&gt;
    &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;
  &lt;/filter&gt;
  &lt;filter-mapping&gt;
    &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;
  
  &lt;!-- The front controller of this Spring Web application, responsible for handling all application requests --&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

    &lt;!-- Map all requests to the DispatcherServlet for handling --&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<p>4.配置springMVC.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&gt;
    
    &lt;context:component-scan base-package=&quot;com.atguigu.rest.crud&quot;&gt;&lt;/context:component-scan&gt;
    
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/view/&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;
        &lt;!-- &lt;property name=&quot;order&quot; value=&quot;1&quot;&gt;&lt;/property&gt; --&gt;
    &lt;/bean&gt;
    
    &lt;!-- &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;order&quot; value=&quot;2&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt; --&gt;
    
    &lt;!-- 处理静态资源 --&gt;
    &lt;mvc:default-servlet-handler/&gt;
    &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;
&lt;/beans&gt;
</code></pre>
<p>5.准备项目所需要的bean、dao<br>5.1 Employee.java</p>
<pre><code>package com.atguigu.rest.crud.bean;

public class Employee &#123;

    private Integer id;
    private String lastName;

    private String email;
    //1 male, 0 female
    private Integer gender;
    
    private Department department;

    public Integer getId() &#123;
        return id;
    &#125;

    public void setId(Integer id) &#123;
        this.id = id;
    &#125;

    public String getLastName() &#123;
        return lastName;
    &#125;

    public void setLastName(String lastName) &#123;
        this.lastName = lastName;
    &#125;

    public String getEmail() &#123;
        return email;
    &#125;

    public void setEmail(String email) &#123;
        this.email = email;
    &#125;

    public Integer getGender() &#123;
        return gender;
    &#125;

    public void setGender(Integer gender) &#123;
        this.gender = gender;
    &#125;

    public Department getDepartment() &#123;
        return department;
    &#125;

    public void setDepartment(Department department) &#123;
        this.department = department;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Employee [id=&quot; + id + &quot;, lastName=&quot; + lastName + &quot;, email=&quot;
                + email + &quot;, gender=&quot; + gender + &quot;, department=&quot; + department
                + &quot;]&quot;;
    &#125;

    public Employee(Integer id, String lastName, String email, Integer gender,
            Department department) &#123;
        super();
        this.id = id;
        this.lastName = lastName;
        this.email = email;
        this.gender = gender;
        this.department = department;
    &#125;

    public Employee() &#123;
        // TODO Auto-generated constructor stub
    &#125;
&#125;
</code></pre>
<p>5.2 Department.java</p>
<pre><code>package com.atguigu.rest.crud.bean;

public class Department &#123;

    private Integer id;
    private String departmentName;

    public Department() &#123;
        // TODO Auto-generated constructor stub
    &#125;
    
    public Department(int i, String string) &#123;
        this.id = i;
        this.departmentName = string;
    &#125;

    public Integer getId() &#123;
        return id;
    &#125;

    public void setId(Integer id) &#123;
        this.id = id;
    &#125;

    public String getDepartmentName() &#123;
        return departmentName;
    &#125;

    public void setDepartmentName(String departmentName) &#123;
        this.departmentName = departmentName;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Department [id=&quot; + id + &quot;, departmentName=&quot; + departmentName
                + &quot;]&quot;;
    &#125;
    
&#125;
</code></pre>
<p>5.3 EmployeeDao.java</p>
<pre><code>package com.atguigu.rest.crud.dao;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Repository;

import com.atguigu.rest.crud.bean.Department;
import com.atguigu.rest.crud.bean.Employee;

@Repository
public class EmployeeDao &#123;

    private static Map&lt;Integer, Employee&gt; employees = null;
    
    @Autowired
    private DepartmentDao departmentDao;
    
    static&#123;
        employees = new HashMap&lt;Integer, Employee&gt;();

        employees.put(1001, new Employee(1001, &quot;E-AA&quot;, &quot;aa@163.com&quot;, 1, new Department(101, &quot;D-AA&quot;)));
        employees.put(1002, new Employee(1002, &quot;E-BB&quot;, &quot;bb@163.com&quot;, 1, new Department(102, &quot;D-BB&quot;)));
        employees.put(1003, new Employee(1003, &quot;E-CC&quot;, &quot;cc@163.com&quot;, 0, new Department(103, &quot;D-CC&quot;)));
        employees.put(1004, new Employee(1004, &quot;E-DD&quot;, &quot;dd@163.com&quot;, 0, new Department(104, &quot;D-DD&quot;)));
        employees.put(1005, new Employee(1005, &quot;E-EE&quot;, &quot;ee@163.com&quot;, 1, new Department(105, &quot;D-EE&quot;)));
    &#125;
    
    private static Integer initId = 1006;
    
    public void save(Employee employee)&#123;
        if(employee.getId() == null)&#123;
            employee.setId(initId++);
        &#125;
        
        employee.setDepartment(departmentDao.getDepartment(employee.getDepartment().getId()));
        employees.put(employee.getId(), employee);
    &#125;
    
    public Collection&lt;Employee&gt; getAll()&#123;
        return employees.values();
    &#125;
    
    public Employee get(Integer id)&#123;
        return employees.get(id);
    &#125;
    
    public void delete(Integer id)&#123;
        employees.remove(id);
    &#125;
&#125;
</code></pre>
<p>5.4 DepartmentDao.java</p>
<pre><code>package com.atguigu.rest.crud.dao;

import java.util.Collection;

import java.util.HashMap;
import java.util.Map;

import org.springframework.stereotype.Repository;

import com.atguigu.rest.crud.bean.Department;


@Repository
public class DepartmentDao &#123;

    private static Map&lt;Integer, Department&gt; departments = null;
    
    static&#123;
        departments = new HashMap&lt;Integer, Department&gt;();
        
        departments.put(101, new Department(101, &quot;D-AA&quot;));
        departments.put(102, new Department(102, &quot;D-BB&quot;));
        departments.put(103, new Department(103, &quot;D-CC&quot;));
        departments.put(104, new Department(104, &quot;D-DD&quot;));
        departments.put(105, new Department(105, &quot;D-EE&quot;));
    &#125;
    
    public Collection&lt;Department&gt; getDepartments()&#123;
        return departments.values();
    &#125;
    
    public Department getDepartment(Integer id)&#123;
        return departments.get(id);
    &#125;
    
&#125;
</code></pre>
<p>6.准备项目需要的所有页面<br>6.1 list.jsp</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%@taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
&lt;title&gt;展示员工信息&lt;/title&gt;
&lt;%-- &lt;link rel=&quot;stylesheet&quot; href=&quot;$&#123;pageContext.servletContext.contextPath&#125;/css/index_like.css&quot;&gt; --%&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;$&#123;pageContext.servletContext.contextPath&#125;/css/index_work.css&quot;&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;$&#123;pageContext.servletContext.contextPath&#125;/js/jquery-1.8.2.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    $(function()&#123;
        $(&quot;.del&quot;).click(function()&#123;
            //submit()将所获得的form元素提交
            if(confirm(&quot;确认删除吗？&quot;))&#123;
                $(&quot;form&quot;).attr(&quot;action&quot;, this.href).submit();//$(this).attr(&quot;href&quot;)
                return false;//将超链接的默认行为取消
            &#125;
            return false;//将超链接的默认行为取消
        &#125;);
    &#125;);//预加载函数或文档就绪函数
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;th&gt;ID&lt;/th&gt;
            &lt;th&gt;LASTNAME&lt;/th&gt;
            &lt;th&gt;EMAIL&lt;/th&gt;
            &lt;th&gt;GENDER&lt;/th&gt;
            &lt;th&gt;DEPARTMENTNAME&lt;/th&gt;
            &lt;th&gt;OPTION(&lt;a href=&quot;emp&quot;&gt;ADD&lt;/a&gt;)&lt;/th&gt;
        &lt;/tr&gt;
        &lt;c:forEach items=&quot;$&#123;emps&#125;&quot; var=&quot;emp&quot;&gt;
            &lt;tr&gt;
                &lt;td&gt;$&#123;emp.id&#125;&lt;/td&gt;
                &lt;td&gt;$&#123;emp.lastName&#125;&lt;/td&gt;
                &lt;td&gt;$&#123;emp.email&#125;&lt;/td&gt;
                &lt;td&gt;$&#123;emp.gender==0?&#39;女&#39;:&#39;男&#39;&#125;&lt;/td&gt;
                &lt;td&gt;$&#123;emp.department.departmentName&#125;&lt;/td&gt;
                &lt;td&gt;
                    &lt;a href=&quot;emp/$&#123;emp.id&#125;&quot;&gt;UPDATE&lt;/a&gt;
                    &lt;a class=&quot;del&quot; href=&quot;emp/$&#123;emp.id&#125;&quot;&gt;DELETE&lt;/a&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
        &lt;/c:forEach&gt;
    &lt;/table&gt;
    
    &lt;form method=&quot;post&quot;&gt;
        &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;DELETE&quot;&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>6.2 add.jsp</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%@taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
&lt;title&gt;添加员工信息&lt;/title&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;$&#123;pageContext.servletContext.contextPath&#125;/css/index_work.css&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form action=&quot;emp&quot; method=&quot;post&quot;&gt;
        &lt;table&gt;
        &lt;tr&gt;
            &lt;th colspan=&quot;2&quot;&gt;添加员工信息&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;LASTNAME&lt;/td&gt;
            &lt;td&gt;
                &lt;input type=&quot;text&quot; name=&quot;lastName&quot;&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;EMAIL&lt;/td&gt;
            &lt;td&gt;
                &lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;GENDER&lt;/td&gt;
            &lt;td&gt;
                &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot;&gt;男
                &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot;&gt;女
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;DEPARTMENT&lt;/td&gt;
            &lt;td&gt;
                &lt;select name=&quot;department.id&quot;&gt;
                    &lt;option&gt;-SELECT DEPARTMENT-&lt;/option&gt;
                    &lt;c:forEach items=&quot;$&#123;depts&#125;&quot; var=&quot;dept&quot;&gt;
                        &lt;option value=&quot;$&#123;dept.id&#125;&quot;&gt;$&#123;dept.departmentName&#125;&lt;/option&gt;
                    &lt;/c:forEach&gt;
                    
                &lt;/select&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td colspan=&quot;2&quot;&gt;
                &lt;input type=&quot;submit&quot; name=&quot;ADD&quot;&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>6.3 update.jsp</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%@taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
&lt;title&gt;修改员工信息&lt;/title&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;$&#123;pageContext.servletContext.contextPath&#125;/css/index_work.css&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form action=&quot;$&#123;pageContext.servletContext.contextPath&#125;/emp&quot; method=&quot;post&quot;&gt;
        &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot;&gt;
        &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;$&#123;emp.id&#125;&quot;&gt;
        &lt;table&gt;
        &lt;tr&gt;
            &lt;th colspan=&quot;2&quot;&gt;修改员工信息&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;LASTNAME&lt;/td&gt;
            &lt;td&gt;
                &lt;input type=&quot;text&quot; name=&quot;lastName&quot; value=&quot;$&#123;emp.lastName&#125;&quot;&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;EMAIL&lt;/td&gt;
            &lt;td&gt;
                &lt;input type=&quot;text&quot; name=&quot;email&quot; value=&quot;$&#123;emp.email&#125;&quot;&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;GENDER&lt;/td&gt;
            &lt;td&gt;
                &lt;%-- &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot; &lt;c:if test=&quot;$&#123;emp.gender==1&#125;&quot;&gt; checked=&quot;checked&quot;&lt;/c:if&gt;&gt;男
                &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot; &lt;c:if test=&quot;$&#123;emp.gender==0&#125;&quot;&gt; checked=&quot;checked&quot;&lt;/c:if&gt;&gt;女 --%&gt;
                &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot; $&#123;emp.gender==1?&#39;checked&#39;:&#39;&#39;&#125;&gt;男
                &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot; $&#123;emp.gender==0?&#39;checked&#39;:&#39;&#39;&#125;&gt;女
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;DEPARTMENT&lt;/td&gt;
            &lt;td&gt;
                &lt;select name=&quot;department.id&quot;&gt;
                    &lt;option&gt;-SELECT DEPARTMENT-&lt;/option&gt;
                    &lt;c:forEach items=&quot;$&#123;depts&#125;&quot; var=&quot;dept&quot;&gt;
                        &lt;option value=&quot;$&#123;dept.id&#125;&quot; $&#123;dept.id==emp.department.id?&#39;selected&#39;:&#39;&#39;&#125;&gt;$&#123;dept.departmentName&#125;&lt;/option&gt;
                    &lt;/c:forEach&gt;
                &lt;/select&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td colspan=&quot;2&quot;&gt;
                &lt;input type=&quot;submit&quot; name=&quot;UPDATE&quot;&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>6.4 edit.jsp</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;
&lt;%@ taglib uri=&quot;http://www.springframework.org/tags/form&quot; prefix=&quot;form&quot; %&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
&lt;title&gt;编辑员工信息&lt;/title&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;$&#123;pageContext.servletContext.contextPath &#125;/css/index_work.css&quot; /&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- 使用SpringMVC from标签重构添加/修改页面 --&gt;
    &lt;!-- modelAttribute自定义回显对象的属性名 --&gt;
    &lt;form:form action=&quot;$&#123;pageContext.servletContext.contextPath &#125;/emp&quot; method=&quot;post&quot; modelAttribute=&quot;emp&quot;&gt;
        
        &lt;c:if test=&quot;$&#123;empty emp.id&#125;&quot; var=&quot;flag&quot;&gt;&lt;/c:if&gt;
        &lt;c:if test=&quot;$&#123;!flag&#125;&quot;&gt;
            &lt;form:hidden path=&quot;id&quot;/&gt;
            &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot; /&gt;
        &lt;/c:if&gt;
        
        &lt;table&gt;
            &lt;tr&gt;
                &lt;th colspan=&quot;2&quot;&gt;
                    &lt;c:if test=&quot;$&#123;flag &#125;&quot;&gt;添加员工信息&lt;/c:if&gt;
                    &lt;c:if test=&quot;$&#123;!flag &#125;&quot;&gt;修改员工信息&lt;/c:if&gt;
                &lt;/th&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;LASTNAME&lt;/td&gt;
                &lt;td&gt;
                    &lt;form:input path=&quot;lastName&quot;/&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;EMAIL&lt;/td&gt;
                &lt;td&gt;
                    &lt;form:input path=&quot;email&quot;/&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;GENDER&lt;/td&gt;
                &lt;td&gt;
                    &lt;form:radiobuttons path=&quot;gender&quot; items=&quot;$&#123;genders&#125;&quot;/&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;DEPARTMENT&lt;/td&gt;
                &lt;td&gt;
                    &lt;form:select path=&quot;department.id&quot; items=&quot;$&#123;depts&#125;&quot; itemLabel=&quot;departmentName&quot; itemValue=&quot;id&quot;&gt;&lt;/form:select&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td colspan=&quot;2&quot;&gt;
                    &lt;c:if test=&quot;$&#123;flag&#125;&quot;&gt;
                        &lt;input type=&quot;submit&quot; value=&quot;ADD&quot; /&gt;
                    &lt;/c:if&gt;
                    &lt;c:if test=&quot;$&#123;!flag&#125;&quot;&gt;
                        &lt;input type=&quot;submit&quot; value=&quot;UPDATE&quot; /&gt;
                    &lt;/c:if&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
        &lt;/table&gt;
    &lt;/form:form&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>7.EmpController_Old.java(实现添加修改的第一种方式，选择第二种方式时注释掉EmpController_Old类的@Controller注解)</p>
<pre><code>package com.atguigu.rest.crud.controller;

import java.util.Collection;
import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

import com.atguigu.rest.crud.bean.Department;
import com.atguigu.rest.crud.bean.Employee;
import com.atguigu.rest.crud.dao.DepartmentDao;
import com.atguigu.rest.crud.dao.EmployeeDao;

//@Controller
public class EmpController_Old &#123;
    //添加修改的第一种方式
    @Autowired
    private EmployeeDao employeeDao;
    
    @Autowired
    private DepartmentDao departmentDao;
    
    /**
     * 获取所有的员工信息
     */
    @RequestMapping(value=&quot;/emps&quot;)
    public String getAll(Map&lt;String, Object&gt; map)&#123;
        Collection&lt;Employee&gt; emps = employeeDao.getAll();
        map.put(&quot;emps&quot;, emps);
        return &quot;list&quot;;
    &#125;
    
    /**
     * 跳转到添加页面
     */
    @RequestMapping(value=&quot;/emp&quot;, method=RequestMethod.GET)
    public String toAdd(Map&lt;String, Object&gt; map)&#123;
        Collection&lt;Department&gt; depts = departmentDao.getDepartments();
        map.put(&quot;depts&quot;, depts);
        return &quot;add&quot;;
    &#125;
    
    /**
     * 添加员工信息
     */
    @RequestMapping(value=&quot;/emp&quot;, method=RequestMethod.POST)
    public String addEmp(Employee employee)&#123;
        employeeDao.save(employee);
        return &quot;redirect:/emps&quot;;
    &#125;
    
    /**
     * 获取要回显的数据，跳转到修改页面，并回显
     */
    @RequestMapping(value=&quot;/emp/&#123;id&#125;&quot;, method=RequestMethod.GET)
    public String toUpdate(@PathVariable(&quot;id&quot;)Integer id, Map&lt;String, Object&gt; map)&#123;
        //获取要修改的员工信息
        Employee emp = employeeDao.get(id);
        //所有的部门信息，供用户选择
        Collection&lt;Department&gt; depts = departmentDao.getDepartments();
        map.put(&quot;emp&quot;, emp);
        map.put(&quot;depts&quot;, depts);
        return &quot;update&quot;;
    &#125;
    
    @RequestMapping(value=&quot;/emp&quot;, method=RequestMethod.PUT)
    public String updateEmp(Employee employee)&#123;
        employeeDao.save(employee);//修改
        return &quot;redirect:/emps&quot;;
    &#125;
&#125;
</code></pre>
<p>8.EmpController.java(实现添加修改的第二种方式，选择第一种方式时注释掉EmpController类的@Controller注解)</p>
<pre><code>package com.atguigu.rest.crud.controller;

import java.util.Collection;

import java.util.HashMap;
import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

import com.atguigu.rest.crud.bean.Department;
import com.atguigu.rest.crud.bean.Employee;
import com.atguigu.rest.crud.dao.DepartmentDao;
import com.atguigu.rest.crud.dao.EmployeeDao;

@Controller
public class EmpController &#123;
    //添加修改的第二种方式

    @Autowired
    private EmployeeDao employeeDao;
    
    @Autowired
    private DepartmentDao departmentDao;
    
    /**
     * 获取所有的员工信息
     * @param map
     * @return
     */
    @RequestMapping(value=&quot;/emps&quot;)
    public String getAll(Map&lt;String, Object&gt; map) &#123;
        Collection&lt;Employee&gt; emps = employeeDao.getAll();
        map.put(&quot;emps&quot;, emps);
        return &quot;list&quot;;
    &#125;
    
    /**
     * 跳转到添加页面
     * @return
     */
    @RequestMapping(value=&quot;/emp&quot;, method=RequestMethod.GET)
    public String toAdd(Map&lt;String, Object&gt; map) &#123;
        //获取所有的部门信息
        Collection&lt;Department&gt; depts = departmentDao.getDepartments();
        //创建存储性别gender的信息
        Map&lt;String, String&gt; genders = new HashMap&lt;&gt;();
        genders.put(&quot;0&quot;, &quot;女&quot;);
        genders.put(&quot;1&quot;, &quot;男&quot;);
        map.put(&quot;depts&quot;, depts);
        map.put(&quot;genders&quot;, genders);
        //form标签有自动回显的功能，会在页面中能够默认获取request作用于中command属性的值
        //map.put(&quot;command&quot;, new Employee());
        //若在&lt;form:form&gt;设置了modelAttribute，就可以自定义回显对象的属性名
        map.put(&quot;emp&quot;, new Employee());
        return &quot;edit&quot;;
    &#125;
    
    /**
     * 添加员工信息
     * @param employee
     * @return
     */
    @RequestMapping(value=&quot;/emp&quot;, method=RequestMethod.POST)
    public String addEmp(Employee employee) &#123;
        employeeDao.save(employee);
        return &quot;redirect:/emps&quot;;
    &#125;
    
    /**
     * 获取要回显的数据，跳转到修改页面，并回显
     * @param id
     * @param map
     * @return
     */
    @RequestMapping(value=&quot;/emp/&#123;id&#125;&quot;, method=RequestMethod.GET)
    public String toUpdate(@PathVariable(&quot;id&quot;) Integer id, Map&lt;String, Object&gt; map) &#123;
        //获取要修改的员工信息
        Employee emp = employeeDao.get(id);
        //所有的部门信息，供用户选择
        Collection&lt;Department&gt; depts = departmentDao.getDepartments();
        //设置存储性别的map集合
        Map&lt;String, String&gt; genders = new HashMap&lt;&gt;();
        genders.put(&quot;0&quot;, &quot;女&quot;);
        genders.put(&quot;1&quot;, &quot;男&quot;);
        map.put(&quot;emp&quot;, emp);
        map.put(&quot;depts&quot;, depts);
        map.put(&quot;genders&quot;, genders);
        return &quot;edit&quot;;
    &#125;
    
    /**
     * 修改员工信息
     */
    @RequestMapping(value=&quot;/emp&quot;, method=RequestMethod.PUT)
    public String updateEmp(Employee employee) &#123;
        employeeDao.save(employee);//修改
        return &quot;redirect:/emps&quot;;
    &#125;
    
    @RequestMapping(value=&quot;/emp/&#123;id&#125;&quot;, method=RequestMethod.DELETE)
    public String deleteEmp(@PathVariable(&quot;id&quot;)Integer id)&#123;
        employeeDao.delete(id);
        return &quot;redirect:/emps&quot;;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>SpringMVC</category>
        <category>REST CRUD</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>CRUD</tag>
        <tag>SpringMVC</tag>
        <tag>REST</tag>
      </tags>
  </entry>
  <entry>
    <title>基于JavaWeb的网上购物商城 | 商品详情页展示及分类商品列表显示</title>
    <url>/2022/01/14/%E5%95%86%E5%93%81%E8%AF%A6%E6%83%85%E9%A1%B5%E5%B1%95%E7%A4%BA%E5%8F%8A%E5%88%86%E7%B1%BB%E5%95%86%E5%93%81%E5%88%97%E8%A1%A8%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<h1 id="商品详情页展示及分类商品列表显示"><a href="#商品详情页展示及分类商品列表显示" class="headerlink" title="商品详情页展示及分类商品列表显示"></a>商品详情页展示及分类商品列表显示</h1><p><strong>实现功能：</strong><br>1）点击某一个商品，网页显示商品的详情信息<br><strong>改动index.jsp页面中的热门商品部分的代码,展示商品详情页</strong></p>
<span id="more"></span>

<pre><code>&lt;!-- 热门商品 --&gt;
&lt;div class=&quot;container-fluid&quot;&gt;
    &lt;div class=&quot;col-md-12&quot;&gt;
        &lt;h2&gt;热门商品&amp;nbsp;&amp;nbsp;&lt;img src=&quot;img/title2.jpg&quot;/&gt;&lt;/h2&gt;
    &lt;/div&gt;
    &lt;div class=&quot;col-md-2&quot; style=&quot;border:1px solid #E7E7E7;border-right:0;padding:0;&quot;&gt;
        &lt;img src=&quot;products/hao/big01.jpg&quot; width=&quot;205&quot; height=&quot;404&quot; style=&quot;display: inline-block;&quot;/&gt;
    &lt;/div&gt;
    &lt;div class=&quot;col-md-10&quot;&gt;
        &lt;div class=&quot;col-md-6&quot; style=&quot;text-align:center;height:200px;padding:0px;&quot;&gt;
            &lt;a href=&quot;product_info.htm&quot;&gt;
                &lt;img src=&quot;products/hao/middle01.jpg&quot; width=&quot;516px&quot; height=&quot;200px&quot; style=&quot;display: inline-block;&quot;&gt;
            &lt;/a&gt;
        &lt;/div&gt;
        
        &lt;c:forEach items=&quot;$&#123;list&#125;&quot; var=&quot;pro&quot;&gt;
            &lt;div class=&quot;col-md-2&quot; style=&quot;text-align:center;height:200px;padding:10px 0px;&quot;&gt;
                &lt;a href=&quot;product_info.htm&quot;&gt;
                    &lt;img src=&quot;$&#123;pageContext.request.contextPath&#125;/$&#123;pro.pimage&#125;&quot; width=&quot;130&quot; height=&quot;130&quot; style=&quot;display: inline-block;&quot;&gt;
                &lt;/a&gt;
                &lt;p&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/product?method=getProById&amp;pid=$&#123;pro.pid&#125;&quot; style=&#39;color:#666&#39;&gt;$&#123;pro.pname&#125;&lt;/a&gt;&lt;/p&gt;
                &lt;p&gt;&lt;font color=&quot;#E4393C&quot; style=&quot;font-size:16px&quot;&gt;&amp;yen;$&#123;pro.shop_price&#125;&lt;/font&gt;&lt;/p&gt;
            &lt;/div&gt;
        &lt;/c:forEach&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p><strong>product_info.jsp</strong><br>改动product_info.jsp的代码动态显示商品的详情信息。</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;
&lt;title&gt;会员登录&lt;/title&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap.min.css&quot; type=&quot;text/css&quot; /&gt;
&lt;script src=&quot;js/jquery-1.11.3.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;js/bootstrap.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;!-- 引入自定义css文件 style.css --&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot; type=&quot;text/css&quot; /&gt;

&lt;style&gt;
body &#123;
    margin-top: 20px;
    margin: 0 auto;
&#125;

.carousel-inner .item img &#123;
    width: 100%;
    height: 300px;
&#125;
&lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;!-- 引入header.jsp --&gt;
    &lt;jsp:include page=&quot;/header.jsp&quot;&gt;&lt;/jsp:include&gt;

    &lt;div class=&quot;container&quot;&gt;
        &lt;div class=&quot;row&quot;&gt;

            &lt;div style=&quot;margin: 0 auto; width: 950px;&quot;&gt;
                &lt;div class=&quot;col-md-6&quot;&gt;
                    &lt;img style=&quot;opacity: 1; width: 400px; height: 350px;&quot; title=&quot;&quot;
                        class=&quot;medium&quot;
                        src=&quot;$&#123;pageContext.request.contextPath&#125;/$&#123;p.pimage&#125;&quot;&gt;
                &lt;/div&gt;

                &lt;div class=&quot;col-md-6&quot;&gt;
                    &lt;div&gt;
                        &lt;strong&gt;$&#123;p.pname&#125;&lt;/strong&gt;
                    &lt;/div&gt;
                    &lt;div
                        style=&quot;border-bottom: 1px dotted #dddddd; width: 350px; margin: 10px 0 10px 0;&quot;&gt;
                        &lt;div&gt;编号：$&#123;p.pid&#125;&lt;/div&gt;
                    &lt;/div&gt;

                    &lt;div style=&quot;margin: 10px 0 10px 0;&quot;&gt;
                        亿家价: &lt;strong style=&quot;color: #ef0101;&quot;&gt;￥：$&#123;p.shop_price&#125;元/份&lt;/strong&gt; 参 考 价：
                        &lt;del&gt;￥$&#123;p.market_price&#125;元/份&lt;/del&gt;
                    &lt;/div&gt;

                    &lt;div style=&quot;margin: 10px 0 10px 0;&quot;&gt;
                        促销: &lt;a target=&quot;_blank&quot; title=&quot;限时抢购 (2014-07-30 ~ 2015-01-01)&quot;
                            style=&quot;background-color: #f07373;&quot;&gt;限时抢购&lt;/a&gt;
                    &lt;/div&gt;

                    &lt;div
                        style=&quot;padding: 10px; border: 1px solid #e7dbb1; width: 330px; margin: 15px 0 10px 0;; background-color: #fffee6;&quot;&gt;
                        &lt;div style=&quot;margin: 5px 0 10px 0;&quot;&gt;白色&lt;/div&gt;

                        &lt;div
                            style=&quot;border-bottom: 1px solid #faeac7; margin-top: 20px; padding-left: 10px;&quot;&gt;
                            购买数量: &lt;input id=&quot;quantity&quot; name=&quot;quantity&quot; value=&quot;1&quot;
                                maxlength=&quot;4&quot; size=&quot;10&quot; type=&quot;text&quot;&gt;
                        &lt;/div&gt;

                        &lt;div style=&quot;margin: 20px 0 10px 0;; text-align: center;&quot;&gt;
                            &lt;a href=&quot;cart.htm&quot;&gt; &lt;input
                                style=&quot;background: url(&#39;./images/product.gif&#39;) no-repeat scroll 0 -600px rgba(0, 0, 0, 0); height: 36px; width: 127px;&quot;
                                value=&quot;加入购物车&quot; type=&quot;button&quot;&gt;
                            &lt;/a&gt; &amp;nbsp;收藏商品
                        &lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;
            &lt;div style=&quot;width: 950px; margin: 0 auto;&quot;&gt;
                &lt;div
                    style=&quot;background-color: #d3d3d3; width: 930px; padding: 10px 10px; margin: 10px 0 10px 0;&quot;&gt;
                    &lt;strong&gt;商品介绍&lt;/strong&gt;
                &lt;/div&gt;

                &lt;div&gt;
                    &lt;img
                        src=&quot;image/r___________renleipic_01/bigPic139f030b-d68b-41dd-be6d-b94cc568d3c5.jpg&quot;&gt;
                &lt;/div&gt;

                &lt;div
                    style=&quot;background-color: #d3d3d3; width: 930px; padding: 10px 10px; margin: 10px 0 10px 0;&quot;&gt;
                    &lt;strong&gt;商品参数&lt;/strong&gt;
                &lt;/div&gt;
                &lt;div style=&quot;margin-top: 10px; width: 900px;&quot;&gt;
                    &lt;table class=&quot;table table-bordered&quot;&gt;
                        &lt;tbody&gt;
                            &lt;tr class=&quot;active&quot;&gt;
                                &lt;th colspan=&quot;2&quot;&gt;基本参数&lt;/th&gt;
                            &lt;/tr&gt;
                            &lt;tr&gt;
                                &lt;th width=&quot;10%&quot;&gt;级别&lt;/th&gt;
                                &lt;td width=&quot;30%&quot;&gt;标准&lt;/td&gt;
                            &lt;/tr&gt;
                            &lt;tr&gt;
                                &lt;th width=&quot;10%&quot;&gt;标重&lt;/th&gt;
                                &lt;td&gt;500&lt;/td&gt;
                            &lt;/tr&gt;
                            &lt;tr&gt;
                                &lt;th width=&quot;10%&quot;&gt;浮动&lt;/th&gt;
                                &lt;td&gt;200&lt;/td&gt;
                            &lt;/tr&gt;
                        &lt;/tbody&gt;
                    &lt;/table&gt;
                &lt;/div&gt;

                
                
            &lt;/div&gt;

        &lt;/div&gt;
    &lt;/div&gt;


    &lt;!-- 引入footer.jsp --&gt;
    &lt;jsp:include page=&quot;/footer.jsp&quot;&gt;&lt;/jsp:include&gt;

&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p><strong>ProductServlet.java</strong></p>
<pre><code>package com.oracle.servlet;

import java.io.IOException;
import java.sql.SQLException;
import java.util.List;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.oracle.bean.Product;
import com.oracle.service.ProductService;

public class ProductServlet extends HttpServlet &#123;
    private static final long serialVersionUID = 1L;

    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        String method = request.getParameter(&quot;method&quot;);
        if(&quot;getProById&quot;.equals(method)) &#123;
            getProById(request, response);
        &#125;else if(&quot;findListByCate&quot;.equals(method)) &#123;
            findListByCate(request, response);
        &#125;
    &#125;

    public void findListByCate(HttpServletRequest request, HttpServletResponse response) &#123;
        // TODO Auto-generated method stub
        try &#123;
            String cid = request.getParameter(&quot;cid&quot;);
            ProductService ps = new ProductService();
            List&lt;Product&gt; plist = ps.findListByCate(cid);
            
            request.setAttribute(&quot;plist&quot;, plist);
            request.getRequestDispatcher(&quot;/product_list.jsp&quot;).forward(request, response);
        &#125; catch (Exception e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125;
        
    &#125;

    public void getProById(HttpServletRequest request, HttpServletResponse response) &#123;
        // TODO Auto-generated method stub
        try &#123;
            String pid = request.getParameter(&quot;pid&quot;);
            
            ProductService ps = new ProductService();
            Product p = ps.getProById(pid);
            
            request.setAttribute(&quot;p&quot;, p);
            request.getRequestDispatcher(&quot;/product_info.jsp&quot;).forward(request, response);
            
        &#125; catch (Exception e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125;
        
    &#125;

    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        doGet(request, response);
    &#125;
&#125;
</code></pre>
<p><strong>ProductService.java</strong></p>
<pre><code>package com.oracle.service;

import java.sql.SQLException;
import java.util.List;

import com.oracle.bean.Category;
import com.oracle.bean.Product;
import com.oracle.dao.ProductDao;

public class ProductService &#123;

    public List&lt;Product&gt; findProList() throws SQLException &#123;
        // TODO Auto-generated method stub
        ProductDao pd = new ProductDao();
        List&lt;Product&gt; list = pd.findProList();
        return list;
    &#125;

    public List&lt;Category&gt; findCateList() throws SQLException &#123;
        // TODO Auto-generated method stub
        ProductDao pd = new ProductDao();
        List&lt;Category&gt; clist = pd.findCateList();
        return clist;
    &#125;

    public Product getProById(String pid) throws SQLException &#123;
        // TODO Auto-generated method stub
        ProductDao pd = new ProductDao();
        Product p = pd.getProById(pid);
        return p;
    &#125;

    public List&lt;Product&gt; findListByCate(String cid) throws SQLException &#123;
        // TODO Auto-generated method stub
        ProductDao pd = new ProductDao();
        List&lt;Product&gt; plist = pd.findListByCate(cid);
        return plist;
    &#125;

&#125;
</code></pre>
<p><strong>ProductDao.java</strong></p>
<pre><code>package com.oracle.dao;

import java.sql.SQLException;
import java.util.List;

import org.apache.commons.dbutils.QueryRunner;
import org.apache.commons.dbutils.handlers.BeanHandler;
import org.apache.commons.dbutils.handlers.BeanListHandler;

import com.oracle.bean.Category;
import com.oracle.bean.Product;
import com.oracle.utils.DataSourceUtils;

public class ProductDao &#123;

    public List&lt;Product&gt; findProList() throws SQLException &#123;
        // TODO Auto-generated method stub
        QueryRunner qr = new QueryRunner(DataSourceUtils.getDataSource());
        
        String sql = &quot;select * from product where pflag=? order by pdate desc limit 0,9&quot;;
        
        List&lt;Product&gt; list = qr.query(sql, new BeanListHandler&lt;&gt;(Product.class), 0);
        return list;
    &#125;

    public List&lt;Category&gt; findCateList() throws SQLException &#123;
        // TODO Auto-generated method stub
        QueryRunner qr = new QueryRunner(DataSourceUtils.getDataSource());
        
        String sql = &quot;select * from category&quot;;
        
        List&lt;Category&gt; clist = qr.query(sql, new BeanListHandler&lt;&gt;(Category.class));
        return clist;
    &#125;

    public Product getProById(String pid) throws SQLException &#123;
        // TODO Auto-generated method stub
        QueryRunner qr = new QueryRunner(DataSourceUtils.getDataSource());
        
        String sql = &quot;select * from product where pid=?&quot;;
        
        Product p = qr.query(sql, new BeanHandler&lt;&gt;(Product.class), pid);
        return p;
    &#125;

    public List&lt;Product&gt; findListByCate(String cid) throws SQLException &#123;
        // TODO Auto-generated method stub
        QueryRunner qr = new QueryRunner(DataSourceUtils.getDataSource());
        
        String sql = &quot;select * from product where cid=? and pflag=? order by pdate desc&quot;;
        
        List&lt;Product&gt; plist = qr.query(sql, new BeanListHandler&lt;&gt;(Product.class), cid, 0);
        return plist;
    &#125;

&#125;
</code></pre>
<p>2）点击菜单栏的商品类别显示对应类别的商品（与（1）都使用上面列出的ProductServlet/ProductService/ProductDao）<br><strong>header.jsp</strong></p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;
&lt;!DOCTYPE html&gt;
&lt;!-- 登录 注册 购物车... --&gt;
&lt;div class=&quot;container-fluid&quot;&gt;
    &lt;div class=&quot;col-md-4&quot;&gt;
        &lt;img src=&quot;img/logo2.png&quot; /&gt;
    &lt;/div&gt;
    &lt;div class=&quot;col-md-5&quot;&gt;
        &lt;img src=&quot;img/header.png&quot; /&gt;
    &lt;/div&gt;
    &lt;div class=&quot;col-md-3&quot; style=&quot;padding-top:20px&quot;&gt;
        &lt;ol class=&quot;list-inline&quot;&gt;
            &lt;c:if test=&quot;$&#123;empty user&#125;&quot;&gt;
                &lt;li&gt;&lt;a href=&quot;login.jsp&quot;&gt;登录&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href=&quot;register.jsp&quot;&gt;注册&lt;/a&gt;&lt;/li&gt;
            &lt;/c:if&gt;
            &lt;c:if test=&quot;$&#123;not empty user&#125;&quot;&gt;
                &lt;li&gt;$&#123;user.username&#125;&lt;/li&gt;
                &lt;li&gt;&lt;a href=&quot;cart.jsp&quot;&gt;购物车&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href=&quot;order_list.jsp&quot;&gt;我的订单&lt;/a&gt;&lt;/li&gt;
            &lt;/c:if&gt;
        &lt;/ol&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;!-- 导航条 --&gt;
&lt;div class=&quot;container-fluid&quot;&gt;
    &lt;nav class=&quot;navbar navbar-inverse&quot;&gt;
        &lt;div class=&quot;container-fluid&quot;&gt;
            &lt;!-- Brand and toggle get grouped for better mobile display --&gt;
            &lt;div class=&quot;navbar-header&quot;&gt;
                &lt;button type=&quot;button&quot; class=&quot;navbar-toggle collapsed&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#bs-example-navbar-collapse-1&quot; aria-expanded=&quot;false&quot;&gt;
                    &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt;
                    &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;
                    &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;
                    &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;
                &lt;/button&gt;
                &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;首页&lt;/a&gt;
            &lt;/div&gt;

            &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;bs-example-navbar-collapse-1&quot;&gt;
                &lt;ul class=&quot;nav navbar-nav&quot;&gt;
                    &lt;c:forEach items=&quot;$&#123;clist&#125;&quot; var=&quot;cate&quot;&gt;
                        &lt;li&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/product?method=findListByCate&amp;cid=$&#123;cate.cid&#125;&quot;&gt;$&#123;cate.cname&#125;&lt;/a&gt;&lt;/li&gt;
                    &lt;/c:forEach&gt;
                &lt;/ul&gt;
                &lt;form class=&quot;navbar-form navbar-right&quot; role=&quot;search&quot;&gt;
                    &lt;div class=&quot;form-group&quot;&gt;
                        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Search&quot;&gt;
                    &lt;/div&gt;
                    &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Submit&lt;/button&gt;
                &lt;/form&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/nav&gt;
&lt;/div&gt;
</code></pre>
<p><strong>product_list.jsp</strong></p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;
&lt;title&gt;会员登录&lt;/title&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap.min.css&quot; type=&quot;text/css&quot; /&gt;
&lt;script src=&quot;js/jquery-1.11.3.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;js/bootstrap.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;!-- 引入自定义css文件 style.css --&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot; type=&quot;text/css&quot; /&gt;

&lt;style&gt;
body &#123;
    margin-top: 20px;
    margin: 0 auto;
    width: 100%;
&#125;

.carousel-inner .item img &#123;
    width: 100%;
    height: 300px;
&#125;
&lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;


    &lt;!-- 引入header.jsp --&gt;
    &lt;jsp:include page=&quot;/header.jsp&quot;&gt;&lt;/jsp:include&gt;


    &lt;div class=&quot;row&quot; style=&quot;width: 1210px; margin: 0 auto;&quot;&gt;
        
        &lt;c:forEach items=&quot;$&#123;plist&#125;&quot; var=&quot;pro&quot;&gt;
            &lt;div class=&quot;col-md-2&quot;&gt;
                &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/product?method=getProById&amp;pid=$&#123;pro.pid&#125;&quot;&gt; 
                    &lt;img src=&quot;$&#123;pageContext.request.contextPath&#125;/$&#123;pro.pimage&#125;&quot; width=&quot;170&quot; height=&quot;170&quot; style=&quot;display: inline-block;&quot;&gt;
                &lt;/a&gt;
                &lt;p&gt;
                    &lt;a href=&quot;product_info.html&quot; style=&#39;color: green&#39;&gt;$&#123;pro.pname&#125;&lt;/a&gt;
                &lt;/p&gt;
                &lt;p&gt;
                    &lt;font color=&quot;#FF0000&quot;&gt;商城价：&amp;yen;$&#123;pro.shop_price&#125;&lt;/font&gt;
                &lt;/p&gt;
            &lt;/div&gt;
        &lt;/c:forEach&gt;
    &lt;/div&gt;

    &lt;!--分页 --&gt;
    &lt;div style=&quot;width: 380px; margin: 0 auto; margin-top: 50px;&quot;&gt;
        &lt;ul class=&quot;pagination&quot; style=&quot;text-align: center; margin-top: 10px;&quot;&gt;
            &lt;li class=&quot;disabled&quot;&gt;&lt;a href=&quot;#&quot; aria-label=&quot;Previous&quot;&gt;&lt;span
                    aria-hidden=&quot;true&quot;&gt;&amp;laquo;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
            &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;1&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;2&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;3&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;4&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;5&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;6&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;7&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;8&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;9&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;#&quot; aria-label=&quot;Next&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;raquo;&lt;/span&gt;
            &lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;!-- 分页结束 --&gt;



    &lt;!-- 引入footer.jsp --&gt;
    &lt;jsp:include page=&quot;/footer.jsp&quot;&gt;&lt;/jsp:include&gt;

&lt;/body&gt;

&lt;/html&gt;
</code></pre>
]]></content>
      <categories>
        <category>项目经历</category>
        <category>JavaWeb</category>
        <category>基于JavaWeb的网上购物商城</category>
        <category>商品详情页展示及分类商品列表显示</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
        <tag>基于JavaWeb的网上购物商城</tag>
      </tags>
  </entry>
  <entry>
    <title>基于JavaWeb的网上购物商城 | 首页热门商品展示</title>
    <url>/2022/01/14/%E9%A6%96%E9%A1%B5%E7%83%AD%E9%97%A8%E5%95%86%E5%93%81%E5%B1%95%E7%A4%BA/</url>
    <content><![CDATA[<h1 id="首页热门商品展示"><a href="#首页热门商品展示" class="headerlink" title="首页热门商品展示"></a>首页热门商品展示</h1><p>实现功能：在网站首页显示热门商品或最新上架商品（登录/不登录状态下都会显示）—使用Filter实现</p>
<span id="more"></span>
<p><strong>LoginFilter.java(src/com.oracle.filter)</strong></p>
<pre><code>package com.oracle.filter;

import java.io.IOException;
import java.sql.SQLException;
import java.util.List;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;

import com.oracle.bean.Product;
import com.oracle.service.ProductService;

public class LoginFilter implements Filter&#123;

    @Override
    public void destroy() &#123;
        // TODO Auto-generated method stub
        
    &#125;

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException &#123;
        // TODO Auto-generated method stub
        try &#123;
            //收集首页数据
            ProductService ps = new ProductService();
            List&lt;Product&gt; list = ps.findProList();
            
            request.setAttribute(&quot;list&quot;, list);
            
            chain.doFilter(request, response);//放行
        &#125; catch (SQLException e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125;
    &#125;

    @Override
    public void init(FilterConfig arg0) throws ServletException &#123;
        // TODO Auto-generated method stub
        
    &#125;

&#125;
</code></pre>
<p><strong>Product.java(src/com.oracle.bean)</strong></p>
<pre><code>package com.oracle.bean;

public class Product &#123;
//
//Field Type Comment
//pidvar char(64) NOT NULL
//pname varchar(50) NULL
//market_price double NULL
//shop_price double NULL
//pimage varchar(200) NULL
//pdate date NULL
//is_hot int(11) NULL
//pdesc varchar(255) NULL
//pflag int(11) NULL
//cid varchar(64) NULL
    private String pid;
    private String pname;
    private double market_price;
    private double shop_price;
    private String pimage;
    private String pdate;
    private int is_hot;
    private String pdesc;
    private int pflag;
    private String cid;
    public Product() &#123;
        super();
        // TODO Auto-generated constructor stub
    &#125;
    public Product(String pid, String pname, double market_price, double shop_price, String pimage, String pdate,
            int is_hot, String pdesc, int pflag, String cid) &#123;
        super();
        this.pid = pid;
        this.pname = pname;
        this.market_price = market_price;
        this.shop_price = shop_price;
        this.pimage = pimage;
        this.pdate = pdate;
        this.is_hot = is_hot;
        this.pdesc = pdesc;
        this.pflag = pflag;
        this.cid = cid;
    &#125;
    public String getPid() &#123;
        return pid;
    &#125;
    public void setPid(String pid) &#123;
        this.pid = pid;
    &#125;
    public String getPname() &#123;
        return pname;
    &#125;
    public void setPname(String pname) &#123;
        this.pname = pname;
    &#125;
    public double getMarket_price() &#123;
        return market_price;
    &#125;
    public void setMarket_price(double market_price) &#123;
        this.market_price = market_price;
    &#125;
    public double getShop_price() &#123;
        return shop_price;
    &#125;
    public void setShop_price(double shop_price) &#123;
        this.shop_price = shop_price;
    &#125;
    public String getPimage() &#123;
        return pimage;
    &#125;
    public void setPimage(String pimage) &#123;
        this.pimage = pimage;
    &#125;
    public String getPdate() &#123;
        return pdate;
    &#125;
    public void setPdate(String pdate) &#123;
        this.pdate = pdate;
    &#125;
    public int getIs_hot() &#123;
        return is_hot;
    &#125;
    public void setIs_hot(int is_hot) &#123;
        this.is_hot = is_hot;
    &#125;
    public String getPdesc() &#123;
        return pdesc;
    &#125;
    public void setPdesc(String pdesc) &#123;
        this.pdesc = pdesc;
    &#125;
    public int getPflag() &#123;
        return pflag;
    &#125;
    public void setPflag(int pflag) &#123;
        this.pflag = pflag;
    &#125;
    public String getCid() &#123;
        return cid;
    &#125;
    public void setCid(String cid) &#123;
        this.cid = cid;
    &#125;
&#125;
</code></pre>
<p><strong>ProductService.java(src/com.oracle.service)</strong></p>
<pre><code>package com.oracle.service;

import java.sql.SQLException;
import java.util.List;

import com.oracle.bean.Product;
import com.oracle.dao.ProductDao;

public class ProductService &#123;

    public List&lt;Product&gt; findProList() throws SQLException &#123;
        // TODO Auto-generated method stub
        ProductDao pd = new ProductDao();
        List&lt;Product&gt; list = pd.findProList();
        return list;
    &#125;

&#125;
</code></pre>
<p><strong>ProductDao.java(src/com.oracle.dao)</strong></p>
<pre><code>package com.oracle.dao;

import java.sql.SQLException;
import java.util.List;

import org.apache.commons.dbutils.QueryRunner;
import org.apache.commons.dbutils.handlers.BeanListHandler;

import com.oracle.bean.Product;
import com.oracle.utils.DataSourceUtils;

public class ProductDao &#123;

    public List&lt;Product&gt; findProList() throws SQLException &#123;
        // TODO Auto-generated method stub
        QueryRunner qr = new QueryRunner(DataSourceUtils.getDataSource());
        
        String sql = &quot;select * from product where pflag=? order by pdate desc limit 0,9&quot;;
        
        List&lt;Product&gt; list = qr.query(sql, new BeanListHandler&lt;&gt;(Product.class), 0);
        return list;
    &#125;

&#125;
</code></pre>
<p><strong>index.jsp</strong>(WebContent/)<br>在热门商品部分使用jstl标签和el表达式解析查询到的数据。</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;
        &lt;title&gt;oracle商城首页&lt;/title&gt;
        &lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap.min.css&quot; type=&quot;text/css&quot; /&gt;
        &lt;script src=&quot;js/jquery-1.11.3.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
        &lt;script src=&quot;js/bootstrap.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;div class=&quot;container-fluid&quot;&gt;

            &lt;!-- 引入header.jsp --&gt;
            &lt;jsp:include page=&quot;/header.jsp&quot;&gt;&lt;/jsp:include&gt;

            &lt;!-- 轮播图 --&gt;
            &lt;div class=&quot;container-fluid&quot;&gt;
                &lt;div id=&quot;carousel-example-generic&quot; class=&quot;carousel slide&quot; data-ride=&quot;carousel&quot;&gt;
                    &lt;!-- 轮播图的中的小点 --&gt;
                    &lt;ol class=&quot;carousel-indicators&quot;&gt;
                        &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;0&quot; class=&quot;active&quot;&gt;&lt;/li&gt;
                        &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;1&quot;&gt;&lt;/li&gt;
                        &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;2&quot;&gt;&lt;/li&gt;
                    &lt;/ol&gt;
                    &lt;!-- 轮播图的轮播图片 --&gt;
                    &lt;div class=&quot;carousel-inner&quot; role=&quot;listbox&quot;&gt;
                        &lt;div class=&quot;item active&quot;&gt;
                            &lt;img src=&quot;img/1.jpg&quot;&gt;
                            &lt;div class=&quot;carousel-caption&quot;&gt;
                                &lt;!-- 轮播图上的文字 --&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                        &lt;div class=&quot;item&quot;&gt;
                            &lt;img src=&quot;img/2.jpg&quot;&gt;
                            &lt;div class=&quot;carousel-caption&quot;&gt;
                                &lt;!-- 轮播图上的文字 --&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                        &lt;div class=&quot;item&quot;&gt;
                            &lt;img src=&quot;img/3.jpg&quot;&gt;
                            &lt;div class=&quot;carousel-caption&quot;&gt;
                                &lt;!-- 轮播图上的文字 --&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;

                    &lt;!-- 上一张 下一张按钮 --&gt;
                    &lt;a class=&quot;left carousel-control&quot; href=&quot;#carousel-example-generic&quot; role=&quot;button&quot; data-slide=&quot;prev&quot;&gt;
                        &lt;span class=&quot;glyphicon glyphicon-chevron-left&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;
                        &lt;span class=&quot;sr-only&quot;&gt;Previous&lt;/span&gt;
                    &lt;/a&gt;
                    &lt;a class=&quot;right carousel-control&quot; href=&quot;#carousel-example-generic&quot; role=&quot;button&quot; data-slide=&quot;next&quot;&gt;
                        &lt;span class=&quot;glyphicon glyphicon-chevron-right&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;
                        &lt;span class=&quot;sr-only&quot;&gt;Next&lt;/span&gt;
                    &lt;/a&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            
            &lt;!-- 热门商品 --&gt;
            &lt;div class=&quot;container-fluid&quot;&gt;
                &lt;div class=&quot;col-md-12&quot;&gt;
                    &lt;h2&gt;热门商品&amp;nbsp;&amp;nbsp;&lt;img src=&quot;img/title2.jpg&quot;/&gt;&lt;/h2&gt;
                &lt;/div&gt;
                &lt;div class=&quot;col-md-2&quot; style=&quot;border:1px solid #E7E7E7;border-right:0;padding:0;&quot;&gt;
                    &lt;img src=&quot;products/hao/big01.jpg&quot; width=&quot;205&quot; height=&quot;404&quot; style=&quot;display: inline-block;&quot;/&gt;
                &lt;/div&gt;
                &lt;div class=&quot;col-md-10&quot;&gt;
                    &lt;div class=&quot;col-md-6&quot; style=&quot;text-align:center;height:200px;padding:0px;&quot;&gt;
                        &lt;a href=&quot;product_info.htm&quot;&gt;
                            &lt;img src=&quot;products/hao/middle01.jpg&quot; width=&quot;516px&quot; height=&quot;200px&quot; style=&quot;display: inline-block;&quot;&gt;
                        &lt;/a&gt;
                    &lt;/div&gt;
                    
                    &lt;c:forEach items=&quot;$&#123;list&#125;&quot; var=&quot;pro&quot;&gt;
                        &lt;div class=&quot;col-md-2&quot; style=&quot;text-align:center;height:200px;padding:10px 0px;&quot;&gt;
                            &lt;a href=&quot;product_info.htm&quot;&gt;
                                &lt;img src=&quot;$&#123;pageContext.request.contextPath&#125;/$&#123;pro.pimage&#125;&quot; width=&quot;130&quot; height=&quot;130&quot; style=&quot;display: inline-block;&quot;&gt;
                            &lt;/a&gt;
                            &lt;p&gt;&lt;a href=&quot;product_info.html&quot; style=&#39;color:#666&#39;&gt;$&#123;pro.pname&#125;&lt;/a&gt;&lt;/p&gt;
                            &lt;p&gt;&lt;font color=&quot;#E4393C&quot; style=&quot;font-size:16px&quot;&gt;&amp;yen;$&#123;pro.shop_price&#125;&lt;/font&gt;&lt;/p&gt;
                        &lt;/div&gt;
                    &lt;/c:forEach&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            
            &lt;!-- 广告条 --&gt;
            &lt;div class=&quot;container-fluid&quot;&gt;
                &lt;img src=&quot;products/hao/ad.jpg&quot; width=&quot;100%&quot;/&gt;
            &lt;/div&gt;
            
            &lt;!-- 最新商品 --&gt;
            &lt;div class=&quot;container-fluid&quot;&gt;
                &lt;div class=&quot;col-md-12&quot;&gt;
                    &lt;h2&gt;最新商品&amp;nbsp;&amp;nbsp;&lt;img src=&quot;img/title2.jpg&quot;/&gt;&lt;/h2&gt;
                &lt;/div&gt;
                &lt;div class=&quot;col-md-2&quot; style=&quot;border:1px solid #E7E7E7;border-right:0;padding:0;&quot;&gt;
                    &lt;img src=&quot;products/hao/big01.jpg&quot; width=&quot;205&quot; height=&quot;404&quot; style=&quot;display: inline-block;&quot;/&gt;
                &lt;/div&gt;
                &lt;div class=&quot;col-md-10&quot;&gt;
                    &lt;div class=&quot;col-md-6&quot; style=&quot;text-align:center;height:200px;padding:0px;&quot;&gt;
                        &lt;a href=&quot;product_info.htm&quot;&gt;
                            &lt;img src=&quot;products/hao/middle01.jpg&quot; width=&quot;516px&quot; height=&quot;200px&quot; style=&quot;display: inline-block;&quot;&gt;
                        &lt;/a&gt;
                    &lt;/div&gt;
                
                    &lt;div class=&quot;col-md-2&quot; style=&quot;text-align:center;height:200px;padding:10px 0px;&quot;&gt;
                        &lt;a href=&quot;product_info.htm&quot;&gt;
                            &lt;img src=&quot;products/hao/small03.jpg&quot; width=&quot;130&quot; height=&quot;130&quot; style=&quot;display: inline-block;&quot;&gt;
                        &lt;/a&gt;
                        &lt;p&gt;&lt;a href=&quot;product_info.html&quot; style=&#39;color:#666&#39;&gt;冬瓜&lt;/a&gt;&lt;/p&gt;
                        &lt;p&gt;&lt;font color=&quot;#E4393C&quot; style=&quot;font-size:16px&quot;&gt;&amp;yen;299.00&lt;/font&gt;&lt;/p&gt;
                    &lt;/div&gt;
    
                    &lt;div class=&quot;col-md-2&quot; style=&quot;text-align:center;height:200px;padding:10px 0px;&quot;&gt;
                        &lt;a href=&quot;product_info.htm&quot;&gt;
                            &lt;img src=&quot;products/hao/small04.jpg&quot; width=&quot;130&quot; height=&quot;130&quot; style=&quot;display: inline-block;&quot;&gt;
                        &lt;/a&gt;
                        &lt;p&gt;&lt;a href=&quot;product_info.html&quot; style=&#39;color:#666&#39;&gt;冬瓜&lt;/a&gt;&lt;/p&gt;
                        &lt;p&gt;&lt;font color=&quot;#E4393C&quot; style=&quot;font-size:16px&quot;&gt;&amp;yen;299.00&lt;/font&gt;&lt;/p&gt;
                    &lt;/div&gt;

                    &lt;div class=&quot;col-md-2 yes-right-border&quot; style=&quot;text-align:center;height:200px;padding:10px 0px;&quot;&gt;
                        &lt;a href=&quot;product_info.htm&quot;&gt;
                            &lt;img src=&quot;products/hao/small05.jpg&quot; width=&quot;130&quot; height=&quot;130&quot; style=&quot;display: inline-block;&quot;&gt;
                        &lt;/a&gt;
                        &lt;p&gt;&lt;a href=&quot;product_info.html&quot; style=&#39;color:#666&#39;&gt;冬瓜&lt;/a&gt;&lt;/p&gt;
                        &lt;p&gt;&lt;font color=&quot;#E4393C&quot; style=&quot;font-size:16px&quot;&gt;&amp;yen;299.00&lt;/font&gt;&lt;/p&gt;
                    &lt;/div&gt;
                    
                    &lt;div class=&quot;col-md-2&quot; style=&quot;text-align:center;height:200px;padding:10px 0px;&quot;&gt;
                        &lt;a href=&quot;product_info.htm&quot;&gt;
                            &lt;img src=&quot;products/hao/small03.jpg&quot; width=&quot;130&quot; height=&quot;130&quot; style=&quot;display: inline-block;&quot;&gt;
                        &lt;/a&gt;
                        &lt;p&gt;&lt;a href=&quot;product_info.html&quot; style=&#39;color:#666&#39;&gt;冬瓜&lt;/a&gt;&lt;/p&gt;
                        &lt;p&gt;&lt;font color=&quot;#E4393C&quot; style=&quot;font-size:16px&quot;&gt;&amp;yen;299.00&lt;/font&gt;&lt;/p&gt;
                    &lt;/div&gt;
    
                    &lt;div class=&quot;col-md-2&quot; style=&quot;text-align:center;height:200px;padding:10px 0px;&quot;&gt;
                        &lt;a href=&quot;product_info.htm&quot;&gt;
                            &lt;img src=&quot;products/hao/small04.jpg&quot; width=&quot;130&quot; height=&quot;130&quot; style=&quot;display: inline-block;&quot;&gt;
                        &lt;/a&gt;
                        &lt;p&gt;&lt;a href=&quot;product_info.html&quot; style=&#39;color:#666&#39;&gt;冬瓜&lt;/a&gt;&lt;/p&gt;
                        &lt;p&gt;&lt;font color=&quot;#E4393C&quot; style=&quot;font-size:16px&quot;&gt;&amp;yen;299.00&lt;/font&gt;&lt;/p&gt;
                    &lt;/div&gt;

                    &lt;div class=&quot;col-md-2 yes-right-border&quot; style=&quot;text-align:center;height:200px;padding:10px 0px;&quot;&gt;
                        &lt;a href=&quot;product_info.htm&quot;&gt;
                            &lt;img src=&quot;products/hao/small05.jpg&quot; width=&quot;130&quot; height=&quot;130&quot; style=&quot;display: inline-block;&quot;&gt;
                        &lt;/a&gt;
                        &lt;p&gt;&lt;a href=&quot;product_info.html&quot; style=&#39;color:#666&#39;&gt;冬瓜&lt;/a&gt;&lt;/p&gt;
                        &lt;p&gt;&lt;font color=&quot;#E4393C&quot; style=&quot;font-size:16px&quot;&gt;&amp;yen;299.00&lt;/font&gt;&lt;/p&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;col-md-2&quot; style=&quot;text-align:center;height:200px;padding:10px 0px;&quot;&gt;
                        &lt;a href=&quot;product_info.htm&quot;&gt;
                            &lt;img src=&quot;products/hao/small03.jpg&quot; width=&quot;130&quot; height=&quot;130&quot; style=&quot;display: inline-block;&quot;&gt;
                        &lt;/a&gt;
                        &lt;p&gt;&lt;a href=&quot;product_info.html&quot; style=&#39;color:#666&#39;&gt;冬瓜&lt;/a&gt;&lt;/p&gt;
                        &lt;p&gt;&lt;font color=&quot;#E4393C&quot; style=&quot;font-size:16px&quot;&gt;&amp;yen;299.00&lt;/font&gt;&lt;/p&gt;
                    &lt;/div&gt;
    
                    &lt;div class=&quot;col-md-2&quot; style=&quot;text-align:center;height:200px;padding:10px 0px;&quot;&gt;
                        &lt;a href=&quot;product_info.htm&quot;&gt;
                            &lt;img src=&quot;products/hao/small04.jpg&quot; width=&quot;130&quot; height=&quot;130&quot; style=&quot;display: inline-block;&quot;&gt;
                        &lt;/a&gt;
                        &lt;p&gt;&lt;a href=&quot;product_info.html&quot; style=&#39;color:#666&#39;&gt;冬瓜&lt;/a&gt;&lt;/p&gt;
                        &lt;p&gt;&lt;font color=&quot;#E4393C&quot; style=&quot;font-size:16px&quot;&gt;&amp;yen;299.00&lt;/font&gt;&lt;/p&gt;
                    &lt;/div&gt;

                    &lt;div class=&quot;col-md-2 yes-right-border&quot; style=&quot;text-align:center;height:200px;padding:10px 0px;&quot;&gt;
                        &lt;a href=&quot;product_info.htm&quot;&gt;
                            &lt;img src=&quot;products/hao/small05.jpg&quot; width=&quot;130&quot; height=&quot;130&quot; style=&quot;display: inline-block;&quot;&gt;
                        &lt;/a&gt;
                        &lt;p&gt;&lt;a href=&quot;product_info.html&quot; style=&#39;color:#666&#39;&gt;冬瓜&lt;/a&gt;&lt;/p&gt;
                        &lt;p&gt;&lt;font color=&quot;#E4393C&quot; style=&quot;font-size:16px&quot;&gt;&amp;yen;299.00&lt;/font&gt;&lt;/p&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;            
            
            &lt;!-- 引入footer.jsp --&gt;
            &lt;jsp:include page=&quot;/footer.jsp&quot;&gt;&lt;/jsp:include&gt;
            
        &lt;/div&gt;
    &lt;/body&gt;

&lt;/html&gt;
</code></pre>
]]></content>
      <categories>
        <category>项目经历</category>
        <category>JavaWeb</category>
        <category>基于JavaWeb的网上购物商城</category>
        <category>首页热门商品展示</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
        <tag>基于JavaWeb的网上购物商城</tag>
      </tags>
  </entry>
</search>
