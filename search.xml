<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>伪迹移除 | 1D-ResCNN model to remove artifact</title>
    <url>/2020/10/10/1D-ResCNN-model-to-remove-artifact/</url>
    <content><![CDATA[<h1 id="A-novel-end-to-end-1D-ResCNN-model-to-remove-artifact-from-EEG-signals"><a href="#A-novel-end-to-end-1D-ResCNN-model-to-remove-artifact-from-EEG-signals" class="headerlink" title="A novel end-to-end 1D-ResCNN model to remove artifact from EEG signals"></a>A novel end-to-end 1D-ResCNN model to remove artifact from EEG signals</h1><div>
<b>two stages of end-to-end manner:</b>
<ul>
<li>training stage:an objective function is often adopted to optimize the model parameters.</li>
<li>test stage:the trained 1D-ResCNN model is used as a filter to automatically remove noise from the contaminated EEG signal.</li>
</ul>
</div>
<span id="more"></span>

<div style="background-color:yellowgreen;">
<b backgroundclor="green">1D-ResCNN model‘s advantages:</b>
<ul>
<li>achieves smaller RMSE and better signal-to-noise ratio(SNR).</li>
<li>better noise suppression ability.</li>
<li>the nonlinear characteristics of EEG after denosing are significantly maintained(preserved).</li>
<li>the EEG denosing performance under unknown noise is further improved.</li>  
</ul>
</div>

]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>伪迹移除</category>
      </categories>
      <tags>
        <tag>1D-ResCNN</tag>
        <tag>伪迹移除</tag>
      </tags>
  </entry>
  <entry>
    <title>脑电分类 | 1D卷积和LSTM脑电信号识别</title>
    <url>/2021/07/03/1D%E5%8D%B7%E7%A7%AF%E5%92%8CLSTM%E8%84%91%E7%94%B5%E4%BF%A1%E5%8F%B7%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<h1 id="1D卷积和LSTM脑电信号识别"><a href="#1D卷积和LSTM脑电信号识别" class="headerlink" title="1D卷积和LSTM脑电信号识别"></a>1D卷积和LSTM脑电信号识别</h1><p>这是一个非常重要的文章！！！ This is a very important article!!!</p>
<table>
<thead>
<tr>
<th>模型</th>
<th>框架</th>
<th>准确率</th>
</tr>
</thead>
<tbody><tr>
<td>CNN+LSTM</td>
<td>TensorFlow</td>
<td>70%</td>
</tr>
</tbody></table>
<p><a href="https://blog.csdn.net/zyb228/article/details/109193128">参考资料</a></p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>脑电分类</category>
        <category>CNN+LSTM</category>
      </categories>
      <tags>
        <tag>脑电分类</tag>
        <tag>LSTM</tag>
        <tag>CNN+LSTM</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 | 23种设计模式总结</title>
    <url>/2021/03/11/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="23种设计模式总结-未完成"><a href="#23种设计模式总结-未完成" class="headerlink" title="23种设计模式总结(未完成)"></a>23种设计模式总结(未完成)</h1><p>以下内容对23中设计模式进行简单介绍：</p>
<span id="more"></span>

<p>1-12设计模式为创建型，13-23设计模式为行为型</p>
<h2 id="1-抽象工厂"><a href="#1-抽象工厂" class="headerlink" title="1.抽象工厂"></a>1.抽象工厂</h2><p>客户类和工厂类分离(判断逻辑和事务处理分开)</p>
<p>客户想抽象工厂请求，抽象工厂再向具体工厂请求生产具体的产品</p>
<p>example:出行方式</p>
<h2 id="2-生成器"><a href="#2-生成器" class="headerlink" title="2.生成器"></a>2.生成器</h2><p>将一个复杂的对象的<b>构建与它的表示分离</b>，使得同样的构建过程有不同的表示</p>
<h2 id="3-工厂方法"><a href="#3-工厂方法" class="headerlink" title="3.工厂方法"></a>3.工厂方法</h2><p>让子类决定实例化哪一个类</p>
<h2 id="4-原型"><a href="#4-原型" class="headerlink" title="4.原型"></a>4.原型</h2><p>example:范文</p>
<h2 id="5-单例"><a href="#5-单例" class="headerlink" title="5.单例"></a>5.单例</h2><p>保证一个类只有一个实力，提供一个访问它的全局访问点</p>
<h2 id="6-适配器"><a href="#6-适配器" class="headerlink" title="6.适配器"></a>6.适配器</h2><p>example:连接电源和笔记本的适配器</p>
<h2 id="7-桥"><a href="#7-桥" class="headerlink" title="7.桥"></a>7.桥</h2><p>抽象部分与实现部分分离</p>
<h2 id="8-组合"><a href="#8-组合" class="headerlink" title="8.组合"></a>8.组合</h2><p>整体-部分的关系，使用户对单个、组合对象的使用具有一致性<br>example:双击打开文件/文件夹</p>
<h2 id="9-装饰"><a href="#9-装饰" class="headerlink" title="9.装饰"></a>9.装饰</h2><p>动态地给一个对象(而不是整个类)添加一些额外的职责<br>example：生日蛋糕</p>
<h2 id="10-外观"><a href="#10-外观" class="headerlink" title="10.外观"></a>10.外观</h2><p>为子系统的一组接口，提供一个统一的接口<br>example: 陕师大主页-各学院网站</p>
<h2 id="11-享元"><a href="#11-享元" class="headerlink" title="11.享元"></a>11.享元</h2><p>以共享的方式高效的支持大量的细粒度对象</p>
<h2 id="12-代理"><a href="#12-代理" class="headerlink" title="12.代理"></a>12.代理</h2><p>example:中国驻美大使馆是中国政府在美国的代理</p>
<h2 id="13-责任链"><a href="#13-责任链" class="headerlink" title="13.责任链"></a>13.责任链</h2><p>example: 提问</p>
<h2 id="14-命令"><a href="#14-命令" class="headerlink" title="14.命令"></a>14.命令</h2><p>将一个请求封装成一个对象</p>
<h2 id="15-解释器"><a href="#15-解释器" class="headerlink" title="15.解释器"></a>15.解释器</h2><h2 id="16-迭代器"><a href="#16-迭代器" class="headerlink" title="16.迭代器"></a>16.迭代器</h2><p>可以顺序访问一个聚合对象中的元素，不必暴露对象的内部表示</p>
<h2 id="17-调停者-中介者"><a href="#17-调停者-中介者" class="headerlink" title="17.调停者/中介者"></a>17.调停者/中介者</h2><p>example:租房子-中介</p>
<h2 id="18-备忘录"><a href="#18-备忘录" class="headerlink" title="18.备忘录"></a>18.备忘录</h2><p>example:游戏记录、系统还原、任务迁移</p>
<h2 id="19-观察者"><a href="#19-观察者" class="headerlink" title="19.观察者"></a>19.观察者</h2><h2 id="20-状态"><a href="#20-状态" class="headerlink" title="20.状态"></a>20.状态</h2><p>允许一个对象在其内部状态改变的时候改变行为，这个对象看上去像是改变了它的类一样</p>
<h2 id="21-策略"><a href="#21-策略" class="headerlink" title="21.策略"></a>21.策略</h2><p>将每一个算法封装到具有共同接口的独立的类<br>example:御敌之策(兵来将挡、水来土掩)、出行方式</p>
<h2 id="22-模板方法"><a href="#22-模板方法" class="headerlink" title="22.模板方法"></a>22.模板方法</h2><p>定义一个算法中操作的股价，将一些步骤延迟到子类中</p>
<h2 id="23-访问者"><a href="#23-访问者" class="headerlink" title="23.访问者"></a>23.访问者</h2><p>数据结构与操作分离</p>
]]></content>
      <categories>
        <category>SA</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithms | 算法基础</title>
    <url>/2020/10/09/Algorithms-1/</url>
    <content><![CDATA[<h1 id="算法基础"><a href="#算法基础" class="headerlink" title="算法基础"></a>算法基础</h1><h2 id="算法定义"><a href="#算法定义" class="headerlink" title="算法定义"></a>算法定义</h2><p><strong>解决一个具体问题的<strong style="color:red">方法</strong>称为一个算法</strong></p>
<h2 id="算法的特征"><a href="#算法的特征" class="headerlink" title="算法的特征"></a>算法的特征</h2><p>1）确定性：组成算法的每条指令清晰、无歧义<br>2）有限性：算法中每条指令的执行次数有限<br>3）可行性：每条指令是简单的、具体的<br>4）输入：有零个或多个外部量作为算法的输入<br>5）输出：算法产生至少一个量作为输出</p>
<p><strong style="color:blue">算法是程序之灵魂</strong></p>
<span id="more"></span>
<h2 id="算法的优劣"><a href="#算法的优劣" class="headerlink" title="算法的优劣"></a>算法的优劣</h2><ul>
<li><blockquote>
<p>时间复杂度：算法运行所需要的<strong>运算步骤</strong></p>
<blockquote>
<p>通常表示为问题规模n的函数T(n)</p>
</blockquote>
</blockquote>
</li>
<li><blockquote>
<p>空间复杂度：算法运行所需要的<strong>内存单元</strong></p>
<blockquote>
<p>通常表示为问题规模n的函数S(n)</p>
</blockquote>
</blockquote>
</li>
<li><blockquote>
<p>时空特性</p>
</blockquote>
</li>
</ul>
<ul>
<li>稳定性</li>
<li>健壮性（鲁棒性）</li>
<li>可靠性</li>
<li>实现难度</li>
<li>模块化</li>
</ul>
<h2 id="算法的内容"><a href="#算法的内容" class="headerlink" title="算法的内容"></a>算法的内容</h2><ul>
<li><blockquote>
<p>算法设计</p>
<blockquote>
<p>针对具体问题，设计一个解决方案</p>
</blockquote>
</blockquote>
<ul>
<li>正确</li>
<li>步骤尽量少</li>
<li>占用空间尽量少</li>
<li>实现简单</li>
<li>其他</li>
</ul>
</li>
<li><blockquote>
<p>算法分析</p>
<blockquote>
<p>正确性分析-证明（归纳法）<br>  时空效率分析-计数<br>  时空特性分析-经验</p>
</blockquote>
</blockquote>
</li>
</ul>
<p>Example 1:时间效率分析-计数</p>
<pre><code>for(i=1;i&lt;=n;i=2*i)
&#123;
    for(j=1;j&lt;=i;j++)
    &#123;
        laugh++;
    &#125;
&#125;
</code></pre>
<p>result:1+2+…+2^ceil(log2 n) = <strong>2^(ceil(log2 n)+1) - 1</strong></p>
<p>Example 2:Horner 算法</p>
<pre><code>Horner(int a[n],real x)
&#123;
    real p = 0;
    for(i=0;i&lt;=n;i++)
    &#123;   
        p+=p*x*a[n-i];
    &#125;
    return p;
&#125;
</code></pre>
<h2 id="算法时间复杂度分析"><a href="#算法时间复杂度分析" class="headerlink" title="算法时间复杂度分析"></a>算法时间复杂度分析</h2><ul>
<li>最坏情况时间复杂度—T(n)表示算法对规模为n的任意输入所需要的<strong>最大步骤</strong></li>
<li>平均时间复杂度——T(n)表示算法对规模为n的所有<strong>输入所需的步骤的平均值</strong></li>
<li>最好情况时间复杂度—T(n)表示算法对规模为n的任意输入所需要的<strong>最小步骤</strong></li>
<li><blockquote>
<p><strong style="color:red">Big idea:</strong>渐进时间复杂度—当n增大时用T(n)的<strong>主要部分</strong>代替T(n)</p>
<blockquote>
<p>常用在理论分析中   理论分析与实际情况有可能不一致</p>
</blockquote>
</blockquote>
</li>
</ul>
<p>e.g. 对a1 a2 … an-1 an 进行排序<br>最好情况：1 2 … n<br>最坏情况：n n-1 ..1<br>2 1 3 …n n-1</p>
<h2 id="算法设计与分析的步骤"><a href="#算法设计与分析的步骤" class="headerlink" title="算法设计与分析的步骤"></a>算法设计与分析的步骤</h2><ol>
<li>问题的描述（Description）</li>
<li>数据结构的选择(Selection)</li>
<li>算法设计(Design)</li>
<li>算法分析(Analysis)</li>
<li>算法的实现(Implement)</li>
</ol>
<p>Example 3:isPrime </p>
<pre><code>isPrime(n)
&#123;
    for(i=2;i&lt;sqrt(n);i++)
    &#123;
        if(n%i==0) return false
    &#125;
    return true
&#125;
</code></pre>
<p>Example 4:euclid</p>
<pre><code>euclid(int a,int b)
&#123;
    if(b==0) return a;
    else return euclid(b,a%b);
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithms | 动态规划</title>
    <url>/2020/11/06/Algorithms-3/</url>
    <content><![CDATA[<h1 id="动态规划与分治"><a href="#动态规划与分治" class="headerlink" title="动态规划与分治"></a>动态规划与分治</h1><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>利用问题的解与其子问题的解之间的关系（动态规划方程），以<strong>自底向上</strong>的方式递归地从子问题的<strong>最优解</strong>逐步构造出整个问题的解的算法</p>
<h2 id="分治-Divide-and-Conquer"><a href="#分治-Divide-and-Conquer" class="headerlink" title="分治(Divide and Conquer)"></a>分治(Divide and Conquer)</h2><p>将一个问题<strong>分</strong>为若干个子问题，将这些子问题分别求解；将求出的小规模的子问题的解<strong>合并</strong>为一个更大规模的问题的解，自底向上求出原来问题的解</p>
<h2 id="核心思想：大问题—-gt-小问题"><a href="#核心思想：大问题—-gt-小问题" class="headerlink" title="核心思想：大问题—&gt;小问题"></a>核心思想：大问题—&gt;小问题</h2><h2 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h2><p>分治：自顶向下<br>动态规划：自底向上</p>
<h2 id="动态规划的基本步骤"><a href="#动态规划的基本步骤" class="headerlink" title="动态规划的基本步骤"></a>动态规划的基本步骤</h2><ul>
<li>找出最优解的性质，并刻画其结构特征</li>
<li>建立动态规划方程</li>
<li>以自底向上的方式解动态规划方程</li>
<li>根据计算最优质的时得到的信息构造最优解</li>
</ul> 

<h2 id="Pseudocode"><a href="#Pseudocode" class="headerlink" title="Pseudocode:"></a>Pseudocode:</h2><pre><code>dynamic-program(P)
&#123;
    for(i=1;i&lt;=n;i++)
    &#123;
        compute(solution of each Pi);//解规模为i的各子问题
        use(solution of each Pi) merge(solution of each Pi+1);
        //将规模为i的各子问题的解合并为规模为i+1的问题的解
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习 | AdaBoost</title>
    <url>/2021/04/17/AdaBoost/</url>
    <content><![CDATA[<h1 id="AdaBoost"><a href="#AdaBoost" class="headerlink" title="AdaBoost"></a>AdaBoost</h1><h2 id="集成方法"><a href="#集成方法" class="headerlink" title="集成方法"></a>集成方法</h2><p>集成方法(ensemble method)/元算法(meta-algorithm):将不同的分类器组合起来的组合结果</p>
<p><b>集成方法的多种形式</b>：<br>1.不同算法的集成<br>2.同一种算法在不同设置下的集成<br>3.数据集不同部分分配给不同分类器之后的集成</p>
<p>基分类器一般采用的是弱可学习（weakly learnable）分类器，通过集成方法，组合成一个强可学习（strongly learnable）分类器</p>
<p><b>弱可学习：</b><br>是指学习的正确率仅略优于随机猜测的多项式学习算法</p>
<p><b>强可学习：</b><br>指正确率较高的多项式学习算法。</p>
<p>集成学习的泛化能力一般比单一的基分类器要好，这是因为大部分基分类器都分类错误的概率远低于单一基分类器的。</p>
<p><b>集成方法主要包括Bagging和Boosting两种方法</b>，Bagging和Boosting都是将已有的分类或回归算法通过一定方式组合起来，形成一个性能更加强大的分类器，更准确的说这是一种分类算法的组装方法，即<b>将弱分类器组装成强分类器</b>的方法。</p>
<h3 id="Bagging"><a href="#Bagging" class="headerlink" title="Bagging"></a>Bagging</h3><h3 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h3><h3 id="Bagging、boosting二者之间的区别"><a href="#Bagging、boosting二者之间的区别" class="headerlink" title="Bagging、boosting二者之间的区别"></a>Bagging、boosting二者之间的区别</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h2 id="AdaBoost-1"><a href="#AdaBoost-1" class="headerlink" title="AdaBoost"></a>AdaBoost</h2><h2 id="分类器性能评价"><a href="#分类器性能评价" class="headerlink" title="分类器性能评价"></a>分类器性能评价</h2><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2>]]></content>
      <categories>
        <category>机器学习</category>
        <category>AdaBoost</category>
      </categories>
      <tags>
        <tag>AdaBoost</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>伪迹移除 | Artifact suppression using data adaptive time domain filtering</title>
    <url>/2020/10/10/Artifact-suppression-using-data-adaptive-time-domain-filtering/</url>
    <content><![CDATA[<h1 id="Artifact-suppression-from-EEG-signals-using-data-adaptive-time-domain-filtering"><a href="#Artifact-suppression-from-EEG-signals-using-data-adaptive-time-domain-filtering" class="headerlink" title="Artifact suppression from EEG signals using data adaptive time domain filtering"></a>Artifact suppression from EEG signals using data adaptive time domain filtering</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>This paper presents a <strong style="color:red">data adaptive filtering</strong> approach to separate the EOG artifact from the recorded EEG signal.</p>
<span id="more"></span>
<p><strong style="color:red">Empirical mode decomposition(EMD)</strong> technique is used to implement the <strong style="color:red">time domain filter</strong>.</p>
<p><strong style="color:red">Fractional Gaussian noise(fGn)</strong> is used here as the <strong style="color:red">reference signal</strong> to detect the distinguish feature of EOG signal to be used to separate from EEG.</p>
<p>EMD is applied to the raw EEG and fGn separately to produce a finite number band limited signals named <strong style="color:red">intrinsic mode functions(IMFs)</strong>.</p>
<p>The energies of individual IMFs of fGn and that of raw EEG are compared to derive the energy based threshold for the suppression of EOG effects. </p>
<p>The separation results using EMD based approach is also compared with wavelet thresholding technique. </p>
<p><strong style="color:red">The experimental results show that the data adaptive filtering technique performs better than the wavelet based approach.</strong></p>
<div style="background-color:yellowgreen;">
<b backgroundclor="green">proposed method's advantages</b>
<ul>
<li>efficiently separates the EOG artifact <b>without changing the amplitude and other necessary properties of the EEG signals</b></li>
<li><b>full data adaptive nature</b></li>
</ul>
</div>

<p><strong style="color:yellow"><i>Note:</i></strong></p>
<ul>
<li>Frequency analysis or filtering —–&gt; deal with single channel signal</li>
<li>Frequency regression analysis   —–&gt; suppress the eye-movement artifact</li>
<li>Time-invariant band-pass filtering or Fourier transform(FT) —–&gt; extract the target frequency component(specific frequency range)</li>
<li>classical time-frequency analyzers(FFT based filtering or short-time Fourier transform(STFT)) —–&gt; non-stationary signal<br>Note:will bring the spectral distrotion</li>
<li>PCA:extracts and sort out the principal components according to the influence on the overall data space.<br>Note:It requires some priori knowledge to identify the PC as the artifact</li>
<li>ICA:<br>key word:decompose<br>problem of using ICA:extracted components do not confirm the original scale and sequences.</li>
<li>main limitation of the filtering method:introduce some spectral distortion </li>
<li>EMD:<br>key benefit of using EMD: automatic decomposition and fully data adaptive<br>UEMD:<br>BEMD:suppress EOG artifacts<br>MEMD:multi-variate data analysis</li>
</ul>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>伪迹移除</category>
      </categories>
      <tags>
        <tag>伪迹移除</tag>
      </tags>
  </entry>
  <entry>
    <title>伪迹移除 | Artifacts reduction algorithms&#39;s two main ways</title>
    <url>/2020/10/11/Artifacts-reduction-algorithms-two-main-ways/</url>
    <content><![CDATA[<h1 id="Artifacts-reduction-algorithms’s-two-main-ways"><a href="#Artifacts-reduction-algorithms’s-two-main-ways" class="headerlink" title="Artifacts reduction algorithms’s two main ways"></a>Artifacts reduction algorithms’s two main ways</h1><div style>
    <h1 style="color:red">Regression and Filtering Methods</h1>
    <h2 style="color:purple">Regression</h2>
    The regression model use a function to fit the data to smooth the data.    <br>
    Disadvantages:<br>
    1.this method only works for reference channels that are available.<br>
    2.EEG signal being non-linear and non-stationary process,linear regression is not the best choice for analysis in such applications.<br>
    3.it can only be used to treat few particular types of artifact,not all types.
    <h2 style="color:purple">Filtering</h2>
    <h3 style="color:green">linear adaptive filters</h3>
    Note:too sensitive and unstable to adjust the parameters<br>
    <h3 style="color:green">non-linear adaptive filters(include Volterra filters and neural network based adptive filters)</h3>
    Note:stronger processing capabilities and complex calculation<br>
    Disadvantages:<br>
    filters may eliminate useful EEG signals during artifact deletion.<br>
</div>
<span id="more"></span>
<div style>
    <h1 style="color:red">Separate or Decompose EEG Data and Noise Data into Other Domains</h1>
    <h2 style="color:purple">EMD(Empiricla Mode Decomposition)</h2>
    decompose the input signals into multiple empirical modes according to IMF. <br>
    Note:EMD is an empirical and data-driven method<br>
    Disadvantages:<br>
    computationally complex<br>
    may not be suitable for online application<br>
    <h2 style="color:purple">ICA(developed from BSS)</h2>
    separate the ideal signal and noise included in the EEG signal as independent components<br> 
    Disadvantages:<br>
    1.not automatic<br>
    2.requiring human intervention makes results subjective and time 
    consuming<br>
    3.cannot operate on single-channel data<br>
    4.high computational complexity<br>
    <h2 style="color:purple">WT(wavelet transfrom)</h2>
    maps the signal to the wavelet domain.<br>
    According to the wavelet coefficients of signal and noise,they have different properties and mechanisms at different scales,eliminating the wavelet coefficients generated by noise and maximally retaining the coefficients fo real signals.
</div>
    ]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>伪迹移除</category>
      </categories>
      <tags>
        <tag>伪迹移除</tag>
        <tag>EMD</tag>
        <tag>ICA</tag>
      </tags>
  </entry>
  <entry>
    <title>伪迹移除 | Automatic artifacts removal</title>
    <url>/2020/10/10/Automatic-removal-using-ICA-and-the-dipole-model/</url>
    <content><![CDATA[<h1 id="Automatic-removal-of-eye-movement-artifacts-from-the-EEG-using-ICA-and-the-dipole-model"><a href="#Automatic-removal-of-eye-movement-artifacts-from-the-EEG-using-ICA-and-the-dipole-model" class="headerlink" title="Automatic removal of eye movement artifacts from the EEG using ICA and the dipole model"></a>Automatic removal of eye movement artifacts from the EEG using ICA and the dipole model</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>In this study,we proposed and evaluated the use of <strong style="color:red"> Independent Component Analysis(ICA) combining the EEG dipole model</strong> to <strong style="color:red"> automatically remove</strong> eye movement artifacts from the EEG <strong style="color:red">without needing EOG as a reference</strong>.</p>
<span id="more"></span>

<p>We <strong>separated</strong> the EEG data into independent components using the ICA method,and <strong>determined</strong> the source localization of these independent components with a single dipole model.</p>
<p>The EEG signal was <strong>reconstructed</strong> by antomatically excluding those components localized within a preset eye model.</p>
<p>The <strong>experimental results</strong> indicate that the dipole model is very efficient at automatically<br>substracting the eye movement artifacts,while retaining the EEG slow waves and making their<br>interpretation easier.</p>
<h2 id="Methods-Comparison"><a href="#Methods-Comparison" class="headerlink" title="Methods Comparison"></a>Methods Comparison</h2><h3 id="other-methods’s-disadvantages-filter、recording-of-horizontal-and-vertical-EOG"><a href="#other-methods’s-disadvantages-filter、recording-of-horizontal-and-vertical-EOG" class="headerlink" title="other methods’s disadvantages:(filter、recording of horizontal and vertical EOG)"></a>other methods’s disadvantages:(filter、recording of horizontal and vertical EOG)</h3><ul>
<li>used a simple <strong>filtering concept</strong>,simply <strong>ignoring very low frequencies</strong>(below 1.5 or 2 Hz)</li>
<li>would not perform well in the context of a large amount of <strong>frontal slow waves</strong> (EOG recordingwould be contaminated by this slow wave activity)</li>
</ul>
<div style="background-color:yellowgreen;">
<b backgroundclor="green">ICA's advantages:</b>
<ul>
<li>The ICA algorithm is computationally efficient.</li>
<li>better noise suppression ability.</li>
<li>ICA can simultaneously separate the EEG and artifacts into independent components without relying on the availability of reference artifacts.</li>
<li>avoids the problem of mutual contamination between EEG and EOG channels that could not be solved with filters,regression and PCA.</li>  
<li>The corrected EEG can easily be derived by a combination of the components without artifacts.</li>
</ul>
</div>

<h3 id="A-crucial-step-for-ocular-artifact-correction-using-ICA-algorithms"><a href="#A-crucial-step-for-ocular-artifact-correction-using-ICA-algorithms" class="headerlink" title="A crucial step for ocular artifact correction using ICA algorithms:"></a>A crucial step for ocular artifact correction using ICA algorithms:</h3><p>to correctly identify the artifact components among the decomposed indepent components.</p>
<p>Manually identifying:</p>
<ul>
<li>subjective </li>
<li>inconvenient </li>
<li>time consuming</li>
</ul>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>伪迹移除</category>
      </categories>
      <tags>
        <tag>伪迹移除</tag>
        <tag>ICA</tag>
      </tags>
  </entry>
  <entry>
    <title>C# | C#中的访问修饰符</title>
    <url>/2021/07/03/C-%E4%B8%AD%E7%9A%84%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="C-中的访问修饰符"><a href="#C-中的访问修饰符" class="headerlink" title="C#中的访问修饰符"></a>C#中的访问修饰符</h1><p><b>public:</b>任何公有成员可以被外部的类访问<br><b>Code:</b></p>
<pre><code>using System;

namespace ConsoleApp1
&#123;   
    class Rectangles
    &#123;
        //成员变量
        public double length;
        public double width;

        public double GetArea()
        &#123;
            return length * width;
        &#125;

        public void Display()
        &#123;
            Console.WriteLine(&quot;Length: &#123;0&#125;&quot;, length);
            Console.WriteLine(&quot;Width: &#123;0&#125;&quot;, width);
            Console.WriteLine(&quot;Area: &#123;0&#125;&quot;, GetArea());
        &#125;
    &#125;
    class PublicTest
    &#123;
        static void Main(string[] args)
        &#123;
            Rectangles r = new Rectangles();
            //另一个类中用internal修饰的变量在这里可以访问
            r.length = 4.5;
            r.width = 3.5;
            r.Display();
            Console.ReadLine();
        &#125;
    &#125;
&#125;
</code></pre>
<span id="more"></span>
<p><b>private:</b>只有同一个类中的函数可以访问它的私有成员<br><b>Code:</b></p>
<pre><code>using System;
using System.Collections.Generic;
using System.Text;

namespace ConsoleApp1
&#123;
    class Rectangle1
    &#123;
        private double length;
        private double width;

        public void AcceptDetails()
        &#123;
            Console.WriteLine(&quot;Please input length:&quot;);
            length = Convert.ToDouble(Console.ReadLine());
            Console.WriteLine(&quot;Please input Width:&quot;);
            width = Convert.ToDouble(Console.ReadLine());
        &#125;

        public double GetArea()
        &#123;
            return length * width;
        &#125;

        public void Display()
        &#123;
            Console.WriteLine(&quot;Length:&#123;0&#125;&quot;, length);
            Console.WriteLine(&quot;Width:&#123;0&#125;&quot;, width);
            Console.WriteLine(&quot;Area:&#123;0&#125;&quot;, GetArea());
        &#125;
    &#125;
    class PrivateTest
    &#123;
        static void Main(string[] args)
        &#123;
            Rectangle1 r = new Rectangle1();
            //另一个类中用private修饰的变量在这里不可以访问
            *//*r.length = 3.4;*//*
            r.AcceptDetails();
            r.Display();
            Console.ReadLine();

        &#125;
    &#125;
&#125;
</code></pre>
<p><b>internal:</b>带有 internal 访问修饰符的任何成员可以被定义在该<strong>成员所定义的应用程序内的任何类或方法访问</strong>。<br><b>Code:</b></p>
<pre><code>using System;
using System.Collections.Generic;
using System.Text;

namespace ConsoleApp1
&#123;
    class Rectangle2
    &#123;
        internal double length;
        internal double width;

        double GetArea()
        &#123;
            return length * width;
        &#125;

        public void Display()
        &#123;
            Console.WriteLine(&quot;长度： &#123;0&#125;&quot;, length);
            Console.WriteLine(&quot;宽度： &#123;0&#125;&quot;, width);
            Console.WriteLine(&quot;面积： &#123;0&#125;&quot;, GetArea());
        &#125;
    &#125;

    class InternalTest
    &#123;
        static void Main(string[] args)
        &#123;
            Rectangle2 r = new Rectangle2();
            //另一个类中用internal修饰的变量在这里可以访问
            r.length = 4.5;
            r.width = 3.5;
            r.Display();
            Console.ReadLine();
        &#125;
    &#125;
&#125;
</code></pre>
<p><b>protected:</b>Protected 访问修饰符允许子类访问它的基类的成员变量和成员函数<br><b>Code:</b></p>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>脑电分类 | CNNLSTM混合分类脑电信号</title>
    <url>/2021/07/01/CNNLSTM%E6%B7%B7%E5%90%88%E5%88%86%E7%B1%BB%E8%84%91%E7%94%B5%E4%BF%A1%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="使用CNN-LSTM混合深度学习分类基于MUSE采集的运动想象EEG信号"><a href="#使用CNN-LSTM混合深度学习分类基于MUSE采集的运动想象EEG信号" class="headerlink" title="使用CNN-LSTM混合深度学习分类基于MUSE采集的运动想象EEG信号"></a>使用CNN-LSTM混合深度学习分类基于MUSE采集的运动想象EEG信号</h1><table>
<thead>
<tr>
<th>模型</th>
<th>Epochs</th>
<th>训练集大小</th>
<th>验证集大小</th>
<th>训练集准确率</th>
<th>验证集准确率</th>
</tr>
</thead>
<tbody><tr>
<td>CNN+LSTM</td>
<td>300</td>
<td>90%</td>
<td>10%</td>
<td>98.6%</td>
<td>96.5%</td>
</tr>
</tbody></table>
<p><a href="https://blog.csdn.net/zyb228/article/details/109542063">参考资料 Click Here!</a><br><a href="https://ieeexplore.ieee.org/document/9155016">论文地址</a></p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>脑电分类</category>
        <category>CNN+LSTM</category>
      </categories>
      <tags>
        <tag>脑电分类</tag>
        <tag>LSTM</tag>
        <tag>CNN+LSTM</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | CPU or GPU?</title>
    <url>/2021/06/21/CPU-or-GPU/</url>
    <content><![CDATA[<h1 id="CPU-or-GPU"><a href="#CPU-or-GPU" class="headerlink" title="CPU or GPU?"></a>CPU or GPU?</h1><p>与CPU相比，GPU擅长SIMD(Single Instruction Multiple Data)计算.<br><a href="https://blog.csdn.net/luoyajingfeng2/article/details/90752019">参考资料</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>GPU | CPU和GPU的设计区别</title>
    <url>/2021/10/11/CPU%E5%92%8CGPU%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="CPU和GPU的设计区别"><a href="#CPU和GPU的设计区别" class="headerlink" title="CPU和GPU的设计区别"></a>CPU和GPU的设计区别</h1><p><a href="https://www.cnblogs.com/biglucky/p/4223565.html">点击链接查看CPU和GPU的设计区别！！！</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>GPU</category>
      </categories>
      <tags>
        <tag>GPU</tag>
        <tag>CPU</tag>
      </tags>
  </entry>
  <entry>
    <title>C# | CSharp参数传递</title>
    <url>/2021/07/03/CSharp%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<h1 id="CSharp参数传递"><a href="#CSharp参数传递" class="headerlink" title="CSharp参数传递"></a>CSharp参数传递</h1><p>1.按值传递参数<br>Code:</p>
<pre><code>using System;
namespace ConsoleApp1
&#123;
    class ValueParameterPassTest
    &#123;
        public void swap(int x, int y)
        &#123;
            int temp;

            temp = x;
            x = y;
            y = temp;
        &#125;

        /*static void Main()
        &#123;
            int a = 100;
            int b = 200;

            Console.WriteLine(&quot;在交换之前，a 的值： &#123;0&#125;&quot;, a);
            Console.WriteLine(&quot;在交换之前，b 的值： &#123;0&#125;&quot;, b);

            ValueParameterPassTest v = new ValueParameterPassTest();

            //按值传递参数
            //v.swap(a, b);

            Console.WriteLine(&quot;在交换之后，a 的值： &#123;0&#125;&quot;, a);
            Console.WriteLine(&quot;在交换之后，b 的值： &#123;0&#125;&quot;, b);

        &#125;*/
    &#125;
&#125;
</code></pre>
<span id="more"></span>
<p>2.按引用传递参数<br>Code:</p>
<pre><code>using System;

namespace ConsoleApp1
&#123;
    class ReferenceParameterPassTest
    &#123;
        public void swap(ref int x, ref int y)
        &#123;
            int temp;

            temp = x; /* 保存 x 的值 */
            x = y;    /* 把 y 赋值给 x */
            y = temp; /* 把 temp 赋值给 y */
        &#125;

        /*static void Main(string[] args)
        &#123;
            ReferenceParameterPassTest n = new ReferenceParameterPassTest();
            *//* 局部变量定义 *//*
            int a = 100;
            int b = 200;

            Console.WriteLine(&quot;在交换之前，a 的值： &#123;0&#125;&quot;, a);
            Console.WriteLine(&quot;在交换之前，b 的值： &#123;0&#125;&quot;, b);

            *//* 调用函数来交换值 *//*
            n.swap(ref a, ref b);

            Console.WriteLine(&quot;在交换之后，a 的值： &#123;0&#125;&quot;, a);
            Console.WriteLine(&quot;在交换之后，b 的值： &#123;0&#125;&quot;, b);

            Console.ReadLine();

        &#125;*/
    &#125;
&#125;
</code></pre>
<p>3.按输出传递参数<br>Code:</p>
<pre><code>using System;

namespace ConsoleApp1
&#123;
    /*class OutputParameterPassTest
    &#123;
        public void getValue(out int x)
        &#123;
            int temp = 5;
            x = temp;
        &#125;

        static void Main()
        &#123;
            OutputParameterPassTest o = new OutputParameterPassTest();
            int a = 100;

            Console.WriteLine(&quot;在方法调用之前，a的值:&#123;0&#125;&quot;, a);

            o.getValue(out a);

            Console.WriteLine(&quot;在方法调用之后，a的值:&#123;0&#125;&quot;, a);
            Console.ReadLine();
        &#125;
    &#125;*/


    class OutputParameterPassTest
    &#123;
        public void getValues(out int x, out int y)
        &#123;
            Console.WriteLine(&quot;Please input first value:&quot;);

            x = Convert.ToInt32(Console.ReadLine());

            Console.WriteLine(&quot;Please input second vale:&quot;);

            y = Convert.ToInt32(Console.ReadLine());
        &#125;

        static void Main()
        &#123;
            //提供给输出参数的变量不需要赋值。当需要从一个参数没有指
            //定初始值的方法中返回值时，输出参数特别有用
            OutputParameterPassTest o = new OutputParameterPassTest();
            int a, b;

            o.getValues(out a, out b);

            Console.WriteLine(&quot;在方法调用之后，a 的值： &#123;0&#125;&quot;, a);
            Console.WriteLine(&quot;在方法调用之后，b 的值： &#123;0&#125;&quot;, b);
            Console.ReadLine();
        &#125;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>Django | DTL中的url反向解析</title>
    <url>/2021/07/30/DTL%E4%B8%AD%E7%9A%84url%E5%8F%8D%E5%90%91%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="DTL中的url反向解析"><a href="#DTL中的url反向解析" class="headerlink" title="DTL中的url反向解析"></a>DTL中的url反向解析</h1><p><strong>反向解析：</strong> 根据配置的url来动态生成链接地址<br><strong>语法：</strong> { % url ‘namespace:name’ p1 p2 %}<br><strong>好处：</strong> 如果改变了url配置不需要再去改每一个链接地址</p>
<span id="more"></span>

<h2 id="反向解析举例"><a href="#反向解析举例" class="headerlink" title="反向解析举例"></a>反向解析举例</h2><p>1.注册应用(settings.py)</p>
<pre><code>INSTALLED_APPS = (
    &#39;django.contrib.admin&#39;,
    &#39;django.contrib.auth&#39;,
    &#39;django.contrib.contenttypes&#39;,
    &#39;django.contrib.sessions&#39;,
    &#39;django.contrib.messages&#39;,
    &#39;django.contrib.staticfiles&#39;,
    &#39;app_name&#39;
)
</code></pre>
<p>1.配置主url(project_name/urls.py project_name为项目文件夹)</p>
<pre><code>from django.conf.urls import include, url
from django.contrib import admin

urlpatterns = [
    url(r&#39;^admin/&#39;, include(admin.site.urls)),
    url(r&#39;^&#39;, include(&#39;app_name.urls&#39;, namespace=&#39;app_name&#39;))
]
/*
app_name:创建的应用名，为项目下的应用文件夹
app_name.urls:应用的urls，应用文件夹下的urls.py
*/
</code></pre>
<p>2.配置应用url(app_anme/urls.py)</p>
<pre><code>from django.conf.urls import url
import views

urlpatterns = [
    url(r&#39;^$&#39;, views.index, name=&#39;index&#39;),
    url(r&#39;^(\d+)/(\d+)$&#39;, views.show, name=&#39;show&#39;),
]
</code></pre>
<p>3.定义视图(app_name/views.py)<br>app_name/index.html处于project_name/templates/app_name/</p>
<pre><code>from django.shortcuts import render
from models import *


def index(request):
    context = &#123;&#125;

    return render(request, &#39;app_name/index.html&#39;, context)


def show(request, id1, id2):
    context = &#123;&#39;id1&#39;: id1, &#39;id2&#39;: id2&#125;
    return render(request, &#39;app_name/show.html&#39;, context)
</code></pre>
<p>4.定义模板<br>index.html</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;a href=&quot;&#123;% url 'app_name:show' '123' '456' %&#125;&quot;&gt;显示&lt;/a&gt;
&lt;hr&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>show.html</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&#123;&#123;id1&#125;&#125;
&#123;&#123;id2&#125;&#125;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>5.配置模板路径DIRS（settings.py）<br>模板文件夹templates在project_name文件夹下</p>
<pre><code>TEMPLATES = [
    &#123;
        &#39;BACKEND&#39;: &#39;django.template.backends.django.DjangoTemplates&#39;,
        &#39;DIRS&#39;: [os.path.join(BASE_DIR, &#39;templates&#39;)],
        &#39;APP_DIRS&#39;: True,
        &#39;OPTIONS&#39;: &#123;
            &#39;context_processors&#39;: [
                &#39;django.template.context_processors.debug&#39;,
                &#39;django.template.context_processors.request&#39;,
                &#39;django.contrib.auth.context_processors.auth&#39;,
                &#39;django.contrib.messages.context_processors.messages&#39;,
            ],
        &#125;,
    &#125;,
]
</code></pre>
<p>6.运行服务器，在浏览器地址栏输入 localhost:8000/123/456,请求服务器。</p>
]]></content>
      <categories>
        <category>python</category>
        <category>框架</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>DTL</tag>
      </tags>
  </entry>
  <entry>
    <title>Django | Django中使用MySQL数据库</title>
    <url>/2021/07/25/Django%E4%B8%AD%E4%BD%BF%E7%94%A8MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h1 id="Django中使用MySQL数据库"><a href="#Django中使用MySQL数据库" class="headerlink" title="Django中使用MySQL数据库"></a>Django中使用MySQL数据库</h1><p>1.在虚拟环境中安装mysql包</p>
<pre><code>pip install mysql-python
</code></pre>
<p>2.在mysql中创建数据库</p>
<pre><code>create databases database_name charset=utf8
</code></pre>
<p><b style="color:red">3.在settings.py中修改DATABASES项</b></p>
<pre><code>DATABASES = &#123;
    &#39;default&#39;: &#123;
        &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;,
        &#39;NAME&#39;: &#39;database_name&#39;,
        &#39;USER&#39;: &#39;root&#39;,
        &#39;PASSWORD&#39;: &#39;1234&#39;,
        &#39;HOST&#39;: &#39;localhost&#39;,
        &#39;PORT&#39;: &#39;3306&#39;,
    &#125;
&#125;
</code></pre>
<p>4.开发流程<br>1）在models.py中定义模型类(继承models.Model)</p>
<pre><code>class Example(models.Model):
    field1 = 
    field2 = 
    ...
</code></pre>
<p>2）把应用加入settings.py文件的installed_app项</p>
<pre><code>INSTALLED_APPS = (
    &#39;django.contrib.admin&#39;,
    &#39;django.contrib.auth&#39;,
    &#39;django.contrib.contenttypes&#39;,
    &#39;django.contrib.sessions&#39;,
    &#39;django.contrib.messages&#39;,
    &#39;django.contrib.staticfiles&#39;,
    &#39;app_name&#39;,
)
</code></pre>
<p>3）生成迁移文件</p>
<pre><code>python manage.py makemigrations
</code></pre>
<p>4）执行迁移生成表</p>
<pre><code>python manage.py migrate
</code></pre>
<p>5）使用模型类进行crud操作</p>
<p><strong>注：</strong><br>使用数据库生成模型类<br>python manage.py inspectdb &gt; app_name/models.py</p>
]]></content>
      <categories>
        <category>python</category>
        <category>框架</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django | Django模型查询</title>
    <url>/2021/07/26/Django%E6%A8%A1%E5%9E%8B%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h1 id="Django模型查询"><a href="#Django模型查询" class="headerlink" title="Django模型查询"></a>Django模型查询</h1><h2 id="查询集的两个特性："><a href="#查询集的两个特性：" class="headerlink" title="查询集的两个特性："></a>查询集的两个特性：</h2><p>1.<strong>惰性执行</strong><br>创建查询集不会带来任何数据库的访问，直到调用数据时，才会访问数据库<br>2.<strong>缓存</strong><br>case1:构成了两个查询集，无法重用缓存，每次查询都会与数据库进行一次交互</p>
<pre><code>print([e.attr for e in Entry.objects.all()])
print([e.attr for e in Entry.objects.all()])
</code></pre>
<p>case2:两次循环使用同一个查询集，第二次使用缓存中的数据</p>
<pre><code>querylist=ExampleModel.objects.all()
print([e.attr for e in querylist])
print([e.attr for e in querylist])
</code></pre>
<p>case3:何时查询集不会被缓存<br>对整个查询集的子集进行求值时不会缓存</p>
<pre><code>query=ExampleModel.objects.all()
for ... in query[0:10]
for ... in query[11:20]
</code></pre>
<h2 id="字段查询"><a href="#字段查询" class="headerlink" title="字段查询"></a>字段查询</h2><p>实现where子名，作为方法filter()、exclude()、get()的参数<br>语法：属性名称__比较运算符=值<br>举例：查询模型类中属性attr1包含1的对象<br>query_list = ExampleModel.objects.filter(attr1__contains=’1’)  </p>
<p><strong>比较运算符：</strong><br>exact、contains、startswith、endswith、isnull、isnotnull、gt、gte、lt、lte、year、<br>month、day、week_day、hour、minute、second<br>注：跨关联查询（语法：模型类名__属性名__比较运算符）</p>
<p><strong>聚合函数：</strong><br>aggregate(Avg()/Count/Max/Min/Sum)</p>
<h2 id="F对象和Q对象"><a href="#F对象和Q对象" class="headerlink" title="F对象和Q对象"></a>F对象和Q对象</h2><p>1.通过构造F对象来比较模型中的两个列<br>举例：query_list = ExampleModel.objects.filter(attr1=F(‘attr2’))<br>2.通过构造Q对象来实现or查询<br>举例：query_list = ExampleModel.objects.filter(Q(pk__lt=6) | Q(attr__gt=1))</p>
]]></content>
      <categories>
        <category>python</category>
        <category>框架</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>EEG | EEG Pathology Detection Based on Deep Learning</title>
    <url>/2020/11/05/EEG-Pathology-Detection-Based-on-Deep-Learning/</url>
    <content><![CDATA[<p>EEG Pathology Detection Based on Deep Learning</p>
<h1 id="Target-EEG-Pathology-Detection"><a href="#Target-EEG-Pathology-Detection" class="headerlink" title="Target: EEG Pathology Detection"></a>Target: EEG Pathology Detection</h1><h1 id="Proposed-Methonds"><a href="#Proposed-Methonds" class="headerlink" title="Proposed Methonds:"></a>Proposed Methonds:</h1><p>Method One:Shallow CNN Model<br>Method Two:Deep CNN Model(AlexNet)<br>Method Three:Fusion stategy based on a multiplayer perception<br>Fusion of CNN features of several distinct temporal segments of the EEG signal</p>
<p><b style="color:red">In future study:investigate different fusion strategies</b></p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
      </categories>
      <tags>
        <tag>CNN</tag>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title>脑电基础知识 | 简单了解EEG</title>
    <url>/2020/10/11/EEG-introduction/</url>
    <content><![CDATA[<h1 id="简单了解EEG"><a href="#简单了解EEG" class="headerlink" title="简单了解EEG"></a>简单了解EEG</h1><h2 id="What"><a href="#What" class="headerlink" title="What?"></a>What?</h2><p>EEG is the electrical response of brain cells in the cerebral cortex.</p>
<h2 id="How-to-record"><a href="#How-to-record" class="headerlink" title="How to record?"></a>How to record?</h2><p>typically collected by an electrode collection system(10/20 system)placed on the head of the brain. </p>
<span id="more"></span>
<h2 id="characteristic"><a href="#characteristic" class="headerlink" title="characteristic"></a>characteristic</h2><ul>
<li>a highly random <b>nonlinear non-stationary signal</b></li>
<li>contains very <b>complex components</b></li>
<li>the signal amplitude is microvolts,and the <b>intensity is very weak</b>.</li>
<li>it is very <b>susceptible</b> to other <b>physiological signals</b> of the human body(<b>EOG/ECG/EMG</b>) or interference from non-physiological signals such as spatial electromagnetic noise.</li>
</ul>
<h2 id="Existed-problem"><a href="#Existed-problem" class="headerlink" title="Existed problem"></a>Existed problem</h2><p><b>Artifacts often mask the waveform characteristics of EEG</b>,which makes the reading of EEG signals more difficult<br>and bring great difficulties to the subsequent research and application of EEG signal.</p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>脑电基础知识</category>
      </categories>
      <tags>
        <tag>EEG</tag>
      </tags>
  </entry>
  <entry>
    <title>GPU | GPU利用率低？</title>
    <url>/2021/10/09/GPU%E5%88%A9%E7%94%A8%E7%8E%87%E4%BD%8E%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="GPU利用率低？"><a href="#GPU利用率低？" class="headerlink" title="GPU利用率低？"></a>GPU利用率低？</h1><p><a href="https://blog.csdn.net/qq_32998593/article/details/92849585">GPU利用率低？</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>GPU</category>
      </categories>
      <tags>
        <tag>GPU</tag>
      </tags>
  </entry>
  <entry>
    <title>urllib.request | GET请求</title>
    <url>/2021/08/05/GET%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<h1 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h1><p>使用urllib.request模块可以在python中访问互联网资源，以下是发送GET请求的示例代码。</p>
<pre><code># coding=utf-8

import urllib.request

# url中？后的内容是请求参数，多个参数之间以&amp;分割
url = &#39;http://localhost:8080/NoteWebService/note.do?action=query&amp;ID=10&#39;

# 创建Request对象，默认是GET请求
req = urllib.request.Request(url)

with urllib.request.urlopen(req) as response:
    data = response.read()  # 读取数据，为字节序列数据
    json_data = data.decode()  # 将字节序列数据转换为字符串
    print(json_data)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>内置模块</category>
        <category>urllib</category>
      </categories>
      <tags>
        <tag>urllib</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP | HTTP请求方法</title>
    <url>/2020/11/09/HTTP%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h1><h2 id="常见的几种请求方式"><a href="#常见的几种请求方式" class="headerlink" title="常见的几种请求方式"></a>常见的几种请求方式</h2><table>
<thead>
<tr>
<th>Methods</th>
<th>Descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>获取数据 例如：获取指定的页面</td>
</tr>
<tr>
<td>POST</td>
<td>修改数据 例如：提交表单、上传文件</td>
</tr>
<tr>
<td>PUT</td>
<td>保存数据</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除 例如：删除指定页面</td>
</tr>
<tr>
<td>OPTION</td>
<td>询问服务器的某种支持特性</td>
</tr>
<tr>
<td>HEAD</td>
<td>用于获取报头</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程 | I/O密集型和计算密集型</title>
    <url>/2020/11/02/IO%E5%AF%86%E9%9B%86%E5%9E%8B%E5%92%8C%E8%AE%A1%E7%AE%97%E5%AF%86%E9%9B%86%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="I-O密集型和计算密集型"><a href="#I-O密集型和计算密集型" class="headerlink" title="I/O密集型和计算密集型"></a>I/O密集型和计算密集型</h1><p><strong>I/O密集型</strong>—&gt;需要网络功能，大量的时间都在等待网络数据的到来—&gt;通常使用多线程/协程</p>
<p><strong>计算密集型</strong>—&gt;需要占用大量的cpu资源—&gt;通常使用多进程</p>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习 | K近邻算法(KNN)</title>
    <url>/2021/02/21/K%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95-KNN/</url>
    <content><![CDATA[<h1 id="K近邻算法-KNN"><a href="#K近邻算法-KNN" class="headerlink" title="K近邻算法(KNN)"></a>K近邻算法(KNN)</h1><h2 id="KNN算法原理"><a href="#KNN算法原理" class="headerlink" title="KNN算法原理"></a>KNN算法原理</h2><p>k近邻法(k-nearest neighbor, k-NN)一种基本分类与回归方法。它的工作原理是：存在一个样本数据集合，也称作为训练样本集，并且样本集中每个数据都存在标签，即我们知道样本集中每一个数据与所属分类的对应关系。输入没有标签的新数据后，将新的数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本最相似数据(最近邻)的分类标签。一般来说，我们只选择样本数据集中前k个最相似的数据，这就是k-近邻算法中k的出处，通常k是不大于20的整数。最后，选择k个最相似数据中出现次数最多的分类，作为新数据的分类。</p>
<span id="more"></span>
<h2 id="距离度量"><a href="#距离度量" class="headerlink" title="距离度量"></a>距离度量</h2><p>我们已经知道k-近邻算法根据特征比较，然后提取样本集中特征最相似数据（最近邻）的分类标签，那么如何进行比较？KNN算法通过距离（欧式距离）度量进行判断。<br><b>Note:</b>距离度量方法还有切比雪夫距离、马氏距离、巴氏距离等；</p>
<h2 id="简单k-近邻算法步骤"><a href="#简单k-近邻算法步骤" class="headerlink" title="简单k-近邻算法步骤"></a>简单k-近邻算法步骤</h2><p>1.计算已知类别数据集中的点与当前点的距离<br>2.按照距离递增次序排序<br>3.选取与当前点距离最小的k个点<br>4.确定前k个点所在类别的出现频率<br>5.返回前k个点所出现频率最高的类别作为当前点的预测分类</p>
<h2 id="KNN的一般流程"><a href="#KNN的一般流程" class="headerlink" title="KNN的一般流程"></a>KNN的一般流程</h2><p>1.收集数据：爬虫/第三方提供的免费/收费数据。一般来讲，数据放在txt文本文件中，按照一定的格式进行存储，便于解析和处理。<br>2.准备数据：使用python解析、预处理数据<br>3.分析数据：可以使用很多方法对数据进行分析。例如使用Matplotlib将数据可视化<br>4.测试算法：计算错误率<br>5.使用算法：错误率在可接受范围内，就可以使用k-近邻算法进行分类</p>
<h2 id="KNN的优缺点"><a href="#KNN的优缺点" class="headerlink" title="KNN的优缺点"></a>KNN的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>1.简单好用，容易理解，精度高，理论成熟，既可以用来做<b>分类</b>也可以用来做<b>回归</b><br>2.可用于数值型数据和离散型数据<br>3.训练时间复杂度为O(n);无数据输入假定；<br>4.对异常值不敏感</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>1.<b>计算复杂性高</b>；空间复杂性高<br>2.样本不平衡问题（即有些类别的样本数量很多，而其他样本的数量很少）<br>3.<b>一般数值很大的时候不用这个，计算量太大。但是单个样本也不能太少，否则容易发生误分。</b><br>4.最大的缺点是无法给出数据的内在含义  </p>
<h2 id="实战代码地址"><a href="#实战代码地址" class="headerlink" title="实战代码地址"></a>实战代码地址</h2><p><a href="https://github.com/victory-liao/Machine-Learning">Click here to look up code</a></p>
<h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><p><a href="https://cuijiahua.com/blog/2017/11/ml_1_knn.html">KNN</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>KNN</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>KNN</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux | vim | vim常用命令及三种命令模式</title>
    <url>/2020/10/08/Linux-vim/</url>
    <content><![CDATA[<h1>vim常用命令</h1> 
yy:复制 光标所在的这一行
numyy:复制 光标所在行开始向下的num行<br><br>

<p>p:paste<br><br></p>
<p>dd:剪切 光标所在的这一行<br><br>numdd:剪切 光标所在行向下num行<br><br>D:从当前的光标开始剪切，一直到行末<br><br>d0:从单签光标开始剪切，一直到行首<br><br>x：删除当前的光标，每次只会删除一个<br><br>X：删除当前光标前面那个，每次只会删除一个<br><br></p>
<span id="more"></span>
<p>h：left j：down k：up l：right<br><br></p>
<p>H:当前屏幕的最上方<br><br>M:当前屏幕的中间<br><br>L:当前屏幕的下方<br><br></p>
<p>ctrl+f 向下翻一页<br><br>ctrl+b 向上翻一页<br><br></p>
<p>ctrl+u 向上翻半页<br><br>ctrl+d 向下翻半页<br><br></p>
<p>numG:快速定位到第num行代码<br><br>G:快速回到整个代码的最后一行<br><br>gg:快速回到整个代码的第一行<br><br></p>
<p>w:向后跳一个单词的长度<br><br>b：向前跳一个单词的长度<br><br></p>
<p>u:撤销刚刚的操作<br><br>ctrl+r：反撤销<br><br></p>
<p>选中一片代码<br><br>v:<br><br>V:<br><br>‘&gt;&gt;:向右移动代码<br><br>&lt;&lt;:向左移动代码<br><br></p>
<p>.:重复执行上一次的命令<br><br></p>
<p>r:替换一个字符<br><br>R:替换光标以及后边的字符<br><br></p>
<p>/string:查找 n:下一个 N：上一个<br><br></p>
<p>shift+zz==wq<br><br></p>
<p>末行模式：<br><br>w:保存<br><br>q:退出<br><br>wq:保存并退出<br><br><br>x:退出</p>
<h1>vim三种命令模式</h1>
![vim三种命令模式](./Linux-vim/vim.jpg)  





]]></content>
      <categories>
        <category>Linux</category>
        <category>vim</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习 | Logistic回归</title>
    <url>/2021/03/06/Logistic%E5%9B%9E%E5%BD%92/</url>
    <content><![CDATA[<h1 id="Logistic回归"><a href="#Logistic回归" class="headerlink" title="Logistic回归"></a>Logistic回归</h1><p>Logistic回归是一种<b>分类</b>算法，通常用于<b>二分类</b>问题(例如：明天是否会下雨)，但也可以用于多分类问题。</p>
<span id="more"></span>
<h2 id="Logistic回归与梯度上升算法"><a href="#Logistic回归与梯度上升算法" class="headerlink" title="Logistic回归与梯度上升算法"></a>Logistic回归与梯度上升算法</h2><h3 id="Logistic回归-1"><a href="#Logistic回归-1" class="headerlink" title="Logistic回归"></a>Logistic回归</h3><p><b>回归：</b>利用一条直线对一些数据点进行拟合的过程。</p>
<p>Logistic回归是分类方法，它利用的是Sigmoid函数阈值在[0,1]这个特性。</p>
<p><b>Logistic回归进行分类的主要思想：</b>根据现有数据对分类边界线建立回归公式，以此进行分类</p>
<p>其实，Logistic回归本质上是一个基于条件概率的判别模型(Discriminative Model)。</p>
<p><b>Sigmoid函数(Logistic函数)：</b><br><img src="/2021/03/06/Logistic%E5%9B%9E%E5%BD%92/1.png"><br><img src="/2021/03/06/Logistic%E5%9B%9E%E5%BD%92/2.jpg"><br><img src="/2021/03/06/Logistic%E5%9B%9E%E5%BD%92/3.png"><br>整合成一个公式：<br><img src="/2021/03/06/Logistic%E5%9B%9E%E5%BD%92/5.jpg"></p>
<p><b>Sigmoid函数的图像：</b><br><img src="/2021/03/06/Logistic%E5%9B%9E%E5%BD%92/6.png"><br>z是一个矩阵，θ是参数列向量(要求解的)，x是样本列向量(给定的数据集)。θ^T表示θ的转置。g(z)函数实现了任意实数到[0,1]的映射，这样我们的数据集([x0,x1,…,xn])，不管是大于1或者小于0，都可以映射到[0,1]区间进行分类。hθ(x)给出了输出为1的概率。比如当hθ(x)=0.7，那么说明有70%的概率输出为1。输出为0的概率是输出为1的补集，也就是30%。</p>
<p>如果我们有合适的参数列向量θ([θ0,θ1,…θn]^T)，以及样本列向量x([x0,x1,…,xn])，那么我们对样本x分类就可以通过上述公式计算出一个概率，如果这个概率大于0.5，我们就可以说样本是正样本，否则样本是负样本。</p>
<p><b>如何得到合适的参数向量θ？</b><br>根据sigmoid函数的特性，我们可以做出如下的假设：<br><img src="/2021/03/06/Logistic%E5%9B%9E%E5%BD%92/7.jpg"><br>两个概率公式合而为一：(损失函数-Loss Function)<br><img src="/2021/03/06/Logistic%E5%9B%9E%E5%BD%92/8.jpg"><br>取对数：<br><img src="/2021/03/06/Logistic%E5%9B%9E%E5%BD%92/9.jpg"><br>这个损失函数，是对于一个样本而言的。给定一个样本，我们就可以通过这个损失函数求出，样本所属类别的概率，而这个概率越大越好，所以也就是求解这个损失函数的最大值。既然概率出来了，那么最大似然估计也该出场了。假定样本与样本之间相互独立，那么整个样本集生成的概率即为所有样本生成概率的乘积，再将公式对数化，便可得到如下公式：<br><img src="/2021/03/06/Logistic%E5%9B%9E%E5%BD%92/10.png"><br>其中，m为样本的总数，y(i)表示第i个样本的类别，x(i)表示第i个样本，需要注意的是θ是多维向量，x(i)也是多维向量。</p>
<p>综上所述，满足J(θ)的最大的θ值即是我们需要求解的模型。</p>
<p>怎么求解使J(θ)最大的θ值呢？因为是<b>求最大值</b>，所以我们需要使用<b>梯度上升算法</b>。如果面对的问题是求解使J(θ)<b>最小</b>的θ值，那么我们就需要使用<b>梯度下降算法</b>。面对我们这个问题，如果使<b>J(θ) := -J(θ)</b>，那么问题就从求极大值转换成求极小值了，使用的算法就从梯度上升算法变成了梯度下降算法，它们的思想都是相同的，学会其一，就也会了另一个。</p>
<h3 id="梯度上升算法"><a href="#梯度上升算法" class="headerlink" title="梯度上升算法"></a>梯度上升算法</h3><p>爬坡这个动作用数学公式表达即为：<br><img src="/2021/03/06/Logistic%E5%9B%9E%E5%BD%92/11.png"><br>其中，α为步长，也就是学习速率，控制更新的幅度。<br>梯度上升迭代公式：<br><img src="/2021/03/06/Logistic%E5%9B%9E%E5%BD%92/12.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><b>Logistic回归的一般过程：</b><br>1.收集数据：采用任意方法收集数据。<br>2.准备数据：由于需要进行距离计算，因此要求数据类型为数值型。另外，结构化数据格式则最佳。<br>3.分析数据：采用任意方法对数据进行分析。<br>4.训练算法：大部分时间将用于训练，训练的目的是为了找到最佳的分类回归系数。<br>5.测试算法：一旦训练步骤完成，分类将会很快。<br>6.使用算法：首先，我们需要输入一些数据，并将其转换成对应的结构化数值；接着，基于训练好的回归系数，就可以对这些数值进行简单的回归计算，判定它们属于哪个类别；在这之后，我们就可以在输出的类别上做一些其他分析工作。</p>
<p><b>Logistic回归的优缺点</b><br>优点：实现简单，易于理解和实现；计算代价不高，速度很快，存储资源低。<br>缺点：容易欠拟合，分类精度可能不高。</p>
<p><b>其他</b><br>1.Logistic回归的目的是寻找一个非线性函数Sigmoid的最佳拟合参数，求解过程可以由最优化算法完成。<br><br>2.改进的一些最优化算法，比如sag。它可以在新数据到来时就完成参数更新，而不需要重新读取整个数据集来进行批量处理。<br><br>机器学习的一个重要问题就是如何处理缺失数据。这个问题没有标准答案，取决于实际应用中的需求。现有一些解决方案，每种方案都各有优缺点。<br><br>3.我们需要根据数据的情况，这是Sklearn的参数，以期达到更好的分类效果。</p>
<p><a href="https://cuijiahua.com/blog/2017/11/ml_6_logistic_1.html">参考资料1</a><br><a href="https://cuijiahua.com/blog/2017/11/ml_7_logistic_2.html">参考资料2</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>Logistic Regression</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>逻辑回归</tag>
      </tags>
  </entry>
  <entry>
    <title>可视化 | Logistic回归可视化主要代码</title>
    <url>/2021/03/11/Logistic%E5%9B%9E%E5%BD%92%E5%8F%AF%E8%A7%86%E5%8C%96%E4%B8%BB%E8%A6%81%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h1 id="Logistic回归可视化主要代码"><a href="#Logistic回归可视化主要代码" class="headerlink" title="Logistic回归可视化主要代码"></a>Logistic回归可视化主要代码</h1><pre><code>import matplotlib.pyplot as plt

fig = plt.figure()
ax = fig.add_subplot(111)
ax.scatter(xcord1,ycord1,s=20,c=&#39;red&#39;,marker=&#39;s&#39;,alpha=0.5)
ax.plot(x,y)
plt.title()
plt.xlabel()
plt.ylabel()
plt.show()
</code></pre>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>可视化(Visualization)</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>逻辑回归</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL | MySQL常见的表操作语句</title>
    <url>/2021/10/14/MySQL%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A1%A8%E6%93%8D%E4%BD%9C%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h1 id="MySQL常见的表操作语句"><a href="#MySQL常见的表操作语句" class="headerlink" title="MySQL常见的表操作语句"></a>MySQL常见的表操作语句</h1><p>1.表的创建</p>
<pre><code>create table table_name(
id int auto_increment primary key not null,
name varchar(11) not null
);
</code></pre>
<p>2.增加记录</p>
<pre><code>insert into table_name values()
insert into table_name values(),(),()
insert into table_name() values()
insert into table_name() values(),(),()
</code></pre>
<p>3.修改记录</p>
<pre><code>update table_name set attr=val where...
</code></pre>
<p>4.删除记录</p>
<pre><code>delete from table_name where...
</code></pre>
<p>5.表查询</p>
<pre><code>条件：select * from table_name where...
聚合：select count(*)|min()|max()|avg() from table_name
分组：select gender,count(*) from table_name group by gender having....
排序：select * from table_name order by...
分页：select * from table_name limit start,count
</code></pre>
<p>连接查询：<a href="https://blog.csdn.net/zjt980452483/article/details/82945663">点击此处，查看更多关于连接查询！！！</a></p>
]]></content>
      <categories>
        <category>MySQl</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>GPU | NVIDIAGeForceGTX1650驱动安装</title>
    <url>/2021/10/09/NVIDIAGeForceGTX1650%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="NVIDIAGeForceGTX1650驱动安装"><a href="#NVIDIAGeForceGTX1650驱动安装" class="headerlink" title="NVIDIAGeForceGTX1650驱动安装"></a>NVIDIAGeForceGTX1650驱动安装</h1><p>当我们想使用GPU（可以用来加速）来跑深度学习代码前，需要进行显卡驱动安装，我的显卡是NVIDIA GeForce GTX 1650。</p>
<p><strong>需要安装：</strong><br>1.Cuda<br>2.CuDNN<br><strong>下载地址：</strong><br><a href="https://developer.nvidia.com/cuda-toolkit">Cuda</a><br><a href=" https://developer.nvidia.com/cudnn">CuDNN</a><br><strong>我的显卡使用的Cuda、CuDNN版本：</strong><br>1.Cuda-10.1<br>2.CuDNN-7.6<br>3.Tensorflow-gpu-1.15.0(可选，在这里我是想用来加速Tensorflow代码的训练)</p>
<p><strong>注意：深度学习框架、python、Cuda、CuDNN版本的对应以及Cuda与自己显卡的兼容性</strong><br><a href="https://blog.csdn.net/s_hikki/article/details/106107778">NVIDIA GeForce GTX 1650驱动安装</a><br><a href="https://tensorflow.google.cn/install/source_windows#configuration_options">版本对应参考资料</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>GPU</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>GPU</tag>
      </tags>
  </entry>
  <entry>
    <title>urllib.request | POST请求</title>
    <url>/2021/08/05/POST%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<h1 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h1><p>使用urllib.request模块可以在python中访问互联网资源，以下是发送POST请求的示例代码。</p>
<pre><code># coding=utf-8

import urllib.request

url = &#39;http://localhost:8080/NoteWebService/note.do&#39;

# 准备HTTP参数
params_dict = &#123;&#39;action&#39;: &#39;query&#39;, &#39;ID&#39;: &#39;10&#39;&#125;  # 准备将参数放到字典中
params_str = urllib.parse.urlencode(params_dict)  # 将字典参数转换为字符串，形式为action=query&amp;ID=10

# 字符串转换为字节序列对象
params_bytes = params_str.encode()  # 发送POST请求时的参数要以字节序列形式发送

req = urllib.request.Request(url, data=params_bytes)  # 发送POST请求
with urllib.request.urlopen(req) as response:
    data = response.read()
    json_data = data.decode()
    print(json_data)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>内置模块</category>
        <category>urllib</category>
      </categories>
      <tags>
        <tag>urllib</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Anaconda | ProxyError</title>
    <url>/2021/07/08/ProxyError/</url>
    <content><![CDATA[<p>在使用Anaconda创建虚拟环境时出错： ProxyError: Conda cannot proceed due to an error in your proxy configuration</p>
<p><a href="https://blog.csdn.net/littlehaes/article/details/103518285">解决办法！！！</a></p>
]]></content>
      <categories>
        <category>Anaconda</category>
      </categories>
      <tags>
        <tag>Anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title>python | Python变量单前下划线与双前下划线的区别</title>
    <url>/2020/11/29/Python%E5%8F%98%E9%87%8F%E5%8D%95%E5%89%8D%E4%B8%8B%E5%88%92%E7%BA%BF%E4%B8%8E%E5%8F%8C%E5%89%8D%E4%B8%8B%E5%88%92%E7%BA%BF%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="Python变量单前下划线与双前下划线的区别"><a href="#Python变量单前下划线与双前下划线的区别" class="headerlink" title="Python变量单前下划线与双前下划线的区别"></a>Python变量单前下划线与双前下划线的区别</h1><h2 id="variable"><a href="#variable" class="headerlink" title="_variable"></a>_variable</h2><p>表面上为私有，实际在外部可以访问</p>
<h2 id="variable-1"><a href="#variable-1" class="headerlink" title="__variable"></a>__variable</h2><p>实际上的私有，只能在内部访问，不能在外部访问（报错）</p>
<h2 id="variable-2"><a href="#variable-2" class="headerlink" title="_ variable _"></a>_ <em>variable</em> _</h2><p>魔法方法（magic method）/ 特殊方法</p>
<h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><pre><code>class TestPrivacy(object):
    _name = &#39;hello&#39; 
    __name = &#39;world&#39;
    
print(TestPrivacy._name) # Output:&#39;hello&#39;
print(TestPrivacy.__name) # Output: AttributeError: type object &#39;TestPrivacy&#39; has no attribute &#39;__name&#39;
</code></pre>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>UML | UML中的事物分类</title>
    <url>/2021/05/23/UML%E4%B8%AD%E7%9A%84%E4%BA%8B%E7%89%A9%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="UML中的事物分类"><a href="#UML中的事物分类" class="headerlink" title="UML中的事物分类"></a>UML中的事物分类</h1><p>1.结构事物<br>模型的<strong>静态部分</strong>，是UML模型中的名词，描述概念或物理元素。<br><strong>包括</strong>：类(class),(接口)interface,协作(collaboration),用例(use case),主动类(active class),构件(component),节点(node)</p>
<p>2.行为事物<br>模型的<strong>动态部分</strong>，描述了跨越时间和空间的行为。<br><strong>包括</strong>：交互(interaction)，状态机(state machine)</p>
<p><strong>交互</strong>：由在特定语境中共同完成一定任务的一组对象之间交换的<strong>消息</strong>组成，描述一个对象群体的行为或单个操作的行为</p>
<p><strong>状态机</strong>：描述了一个对象或一个交互在<strong>生命期内响应事件</strong>所经历的<strong>状态序列</strong></p>
<p>3.分组事物<br>分组事物是一些由<strong>模型分解成的组织部分</strong>，最主要的是<strong>包</strong></p>
<p>4.注释事物<br>用来描述、说明和标注模型的任何元素，主要是<strong>注解</strong></p>
]]></content>
      <categories>
        <category>UML</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>Web服务器</title>
    <url>/2020/11/09/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h1 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h1><p><strong>Web服务器是可以向发出请求的浏览器提供文档的程序。</strong></p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><pre><code># coding:utf-8
import socket
import re

from multiprocessing import Process

# 设置静态文件根目录
HTML_ROOT_DIR = &quot;./html&quot;


def handle_client(client_socket):
    &quot;&quot;&quot;处理客户端请求&quot;&quot;&quot;
    # 获取客户端请求数据
    request_data = client_socket.recv(1024)
    print(&quot;request data:&quot;,request_data)
    request_lines = request_data.splitlines()
    for line in request_lines:
        print(line)

    # 解析请求报文
    # &#39;GET / HTTP/1.1&#39;
    request_start_line = request_lines[0]
    #提取用户请求的文件名
    file_name = re.match(r&quot;\w+ +(/[^ ]*) &quot;,request_start_line.decode(&quot;utf-8&quot;)).group(1)

    if &quot;/&quot; == file_name:
        file_name = &quot;/index.html&quot;
    # 打开文件，读取内容
    try:
        file = open(HTML_ROOT_DIR + file_name,&quot;rb&quot;)
    except IOError:
        response_start_line = &quot;HTTP/1.1 404 Not Found\r\n&quot;
        response_headers = &quot;Server: My server\r\n&quot;
        response_body = &quot;the file is not found&quot;
    else:
        file_data = file.read()
        file.close()

        # 构造响应数据
        response_start_line = &quot;HTTP/1.1 200 OK\r\n&quot;
        response_headers = &quot;Server: My server\r\n&quot;
        response_body = file_data.decode(&quot;utf-8&quot;)

    response = response_start_line + response_headers + &quot;\r\n&quot; + response_body
    print(&quot;response:&quot;,response)

    # 向客户端返回响应数据
    client_socket.send(bytes(response,&quot;utf-8&quot;))

    #关闭客户端链接
    client_socket.close()

def main():
    server_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
    #SOL_SOCKET:设置选项级别为SOCKET
    #SO_REUSEADDR:1
    server_socket.bind((&quot;&quot;,7788))
    server_socket.listen(128)

    while True:
        client_socket,client_address= server_socket.accept()
        print(&quot;[%s,%s]用户连接上了&quot;%(client_address))
        handle_client_process = Process(target=handle_client,args=(client_socket,))
        handle_client_process.start()
        client_socket.close()

if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
<h2 id="访问Web服务器"><a href="#访问Web服务器" class="headerlink" title="访问Web服务器"></a>访问Web服务器</h2><p>在浏览器地址栏输入 127.0.0.1:7788或127.0.0.1:7788/index.html</p>
<h2 id="项目文件结构"><a href="#项目文件结构" class="headerlink" title="项目文件结构"></a>项目文件结构</h2><p><img src="/2020/11/09/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.JPG" alt="文件结构"></p>
]]></content>
      <tags>
        <tag>Web服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithms | 递归与分治</title>
    <url>/2020/10/16/algorithms-2/</url>
    <content><![CDATA[<h1 id="递归与分治策略"><a href="#递归与分治策略" class="headerlink" title="递归与分治策略"></a>递归与分治策略</h1><p><b style="color:red">分治与递归经常同时应用在算法设计中</b></p>
<h2 id="递归（Recursion）"><a href="#递归（Recursion）" class="headerlink" title="递归（Recursion）"></a>递归（Recursion）</h2><p>递归算法—<b>直接或间接地调用自身</b>的较小模式的算法<br>递归函数—用函数自身的较小模式给出其定义的函数</p>
<span id="more"></span>
<h3 id="example1-Fibonacci-Series"><a href="#example1-Fibonacci-Series" class="headerlink" title="example1:Fibonacci Series"></a>example1:Fibonacci Series</h3><p>Code1:</p>
<pre><code>fibonacci(int n)
&#123;
    if(n&lt;=1) return 1;//递归边界
    else return fibonacci(n-1)+fibonacci(n-2);//递归方程
&#125;
</code></pre>
<p>时间复杂度:T(n)=sqrt(2)^n<br>时间复杂度过高的原因：存在很多重复的计算</p>
<p>Code2:</p>
<pre><code>fibonacci(int n)
&#123;
    int f[3]=&#123;1,1&#125;;
    
    for(i=0;i&lt;=n;i++)
    &#123;
        f[2]=f[0]+f[1]; f[0]=f[1]; f[1]=f[2];
    &#125;
    
    return f[2];
&#125;
</code></pre>
<p>时间复杂度：O(n)</p>
<p><b style="color:red">设计更快的算法！！！</b></p>
<h3 id="example2-Hanoi塔"><a href="#example2-Hanoi塔" class="headerlink" title="example2:Hanoi塔"></a>example2:Hanoi塔</h3><p>Code:</p>
<pre><code>hanoi(int n,char a,char b,char c)//T(n)=O(2^n)
&#123;//将塔座a上的盘子移到塔座b上，塔座c为辅助塔座
    if(n&gt;0)
    &#123;
        hanoi(n-1,a,c,b);
        move(a,b);
        hanoi(n-1,c,b,a);
    &#125;
&#125;
</code></pre>
<h3 id="递归小结"><a href="#递归小结" class="headerlink" title="递归小结"></a>递归小结</h3><p>优点：结构清晰、可读性强—&gt;设计算法、调试程序比较方便<br>缺点：程序运行效率低</p>
<h2 id="分治-Divide-and-Conquer"><a href="#分治-Divide-and-Conquer" class="headerlink" title="分治(Divide and Conquer)"></a>分治(Divide and Conquer)</h2><h3 id="适用条件："><a href="#适用条件：" class="headerlink" title="适用条件："></a>适用条件：</h3><ol>
<li>该问题的规模缩小到一定程度就可以容易地解决</li>
<li>该问题<b>可以分解为若干个规模较小的相同问题</b>，即该问题具有最优子结构性质</li>
<li>该问题分解出的子问题的解可以<b>合并</b>为该问题的解</li>
<li>该问题分解出的各个子问题是相互独立的（<b>子问题之间不包含公共的子问题</b>）</li>
</ol>

<h3 id="基本步骤："><a href="#基本步骤：" class="headerlink" title="基本步骤："></a>基本步骤：</h3><pre><code>divide-and-conquer(p)
&#123;
    if(|p|&lt;=n0) naive(p);//解决朴素问题
    divide p into smaller p1,p2...pa//分解问题
    for(i=1;i&lt;=a;i++)
    &#123;
        yi=divide-and-conquer(pi);//递归的解各子问题
    &#125;
    return merge(y1,y2...ya);将子问题的解合并为原问题解
&#125;
</code></pre>
<p><b style="color:yellow">Note:</b><br>在用分治法设计算法时，最好使子问题的规模大致相同(将一个问题分为大小相等的a个子问题的处理方法是行之有效的)。<br>这种做法出自<strong>平衡子问题</strong>的思想</p>
<h3 id="example1-Binary-Search-Algorithm"><a href="#example1-Binary-Search-Algorithm" class="headerlink" title="example1:Binary Search Algorithm"></a>example1:Binary Search Algorithm</h3><p>Code:</p>
<pre><code>binarySearch(int a[],int x)//T(n) = O(logn)
&#123;
    int n = sizeof(a),left = 0,right = n-1;
    
    while (left&lt;=right)
    &#123;
        int middle = (left+right)/2;
        if(x == a[middle]) return middle;
        if(x&gt;a[middle]) left = middle + 1;
        else right = middle-1;
    &#125;
    
    return -1;//x not found
&#125;
</code></pre>
<h3 id="example2-Powering-a-number"><a href="#example2-Powering-a-number" class="headerlink" title="example2:Powering a number"></a>example2:Powering a number</h3><p><b>Problem:</b>Compute a^n,where n is subjected to N.<br><b>Naive algorithm:</b>O(n)<br><b>Divide-and-conquer algorithm:</b><br>Code:</p>
<pre><code>power(int a,int n)//T(n)=O(logn)
&#123;
    if(n==1) return a;
    else if(n%2==0) return power(a,n/2)*power(a,n/2);
    else return power(a,(n-1)/2*power(a,(n-1)/2*a);
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>伪迹移除 | comparison of methods of artifacts removal</title>
    <url>/2021/02/09/comparison-of-methods-of-artifacts-removal/</url>
    <content><![CDATA[<h1 id="Comparison-of-Methods-of-Artifacts-Removal"><a href="#Comparison-of-Methods-of-Artifacts-Removal" class="headerlink" title="Comparison of Methods of Artifacts Removal"></a>Comparison of Methods of Artifacts Removal</h1><div style>
    <h1 style="color: red">Regression Methods</h1>
    <p>
        Regression methods often assume that the scal potential is a <em>linear combination</em> of brain and other potentials(EOG、ECG、EMG).By subtracting propagated EOG/ECG/EMG from EEG recordings,EEG signals can be recovered.
    </p>
    <p>
        Regression can also be done in frequency domain based on the concept that <em>subtraction in the frequency domain is equivalent to filtering in the time domain</em>.By eliminating spectral estimates of EOG/EMG/ECG from EEG recordings,it is possible to recover the non-contaminated EEG.
    </p>
    <p style>
        <b>Disadvantages:</b>
        Both types of regression methods are <em>off-line and rely on EOG/ECG/EMG recordings</em>,which are however,not always available.
    </p>
</div>
<hr>
<span id="more"></span>

<div style>
    <h1 style="color: red">PCA(Principle Component Analysis)</h1>
    <p>
        This method assumes that each <em>EEG channel recording is simultaneously generated by multiple sources</em> across the scalp. By decomposing multiple channel EEG data into principle components using PCA,the artifactual sources can be identified and removed.
    </p>
    <p style>
        <b>Disadvantages:</b>
        PCA methods usually <em>failed to completely separate artifacts</em> from cerebral activities,and the <em>orthogonal assumption</em> fro data components,which is always required while using PCA,is <em>hardly satisfied</em>.
    </p>
</div>
<hr>

<div style>
    <h1 style="color:red">ICA(Independent Component Analysis)</h1>
    <p>
        ICA was originally developed fro blind source separation(<em>BSS</em>)
    </p>
    <p style>
        <b>Disadvantages:</b>
        ICA usually requires a large amount of data and visual inspection to eliminate noisy independent components,making the method <em>time-consuming and not suitable for real-time applications</em>.        
    </p>
</div>
<hr>

<div style>
    <h1 style="color:red">Wavelet Analysis</h1>
    <p>
        It is effective to mesure and manipulate <em>non-stationary signals</em>.In wavelet-based methods,the wavelet thresholding techniques have received significant attention.For this class of methods,wavelet coefficitents at low-frequency sub-bands are corrected by some thresholding functions before signal reconstruction.
    </p>
    <p style>
        <b>Advantages:</b>
        As an online artifact removal method,the most important advantage of using this method for EEG correction is that <em>it does not rely on either the reference signal or visual inspection.
    </em></p>
    <p style>
        <b>Disadvantages:</b>
        It performance is not consistent because the method is sensitive to the selections of wavelet basis and thresholding functions.
    </p>
</div>






]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>伪迹移除</category>
      </categories>
      <tags>
        <tag>ICA</tag>
        <tag>PCA</tag>
        <tag>小波变换</tag>
      </tags>
  </entry>
  <entry>
    <title>cookie | cookie</title>
    <url>/2021/07/29/cookie/</url>
    <content><![CDATA[<p>在基于HTTP的请求当中，客户端发送请求到服务器端，服务器端响应请求返回一些信息（包含cookie）。<br>1.cookie是什么？<br>cookie:存储在浏览器当中的文本信息，存储格式：键值对，一旦你访问某个网站，存储了这个键值对，后面再次请求这个服务器时，cookie会自动加到请求报文的头里面发送到服务器。<br><img src="/2021/07/29/cookie/cookie1.png"><br>2.cookie是怎么来的？<br>我们在服务器端设置（set_cookie()）的，通过response返回到浏览器，浏览器将cookie存储下来<br><strong>注：cookie是区别于域名的，跨域名不能共享cookie信息</strong><br>3.一种常见的场景<br>假设我们在淘宝网站浏览了运动鞋商品，在我们浏览其他网站时会看到与我们之前浏览的运动鞋类似的商品推荐，<br>“cookie是区别于域名的”，这句话似乎错了？？<br>答：此时的现象并不是其他网站读取了淘宝网站的cookie，而是在其他网站内嵌了淘宝网站，即此时的运动鞋商品<br>推荐的信息是从淘宝网站本身读取到的，原理如下图所示：<br><img src="/2021/07/29/cookie/cookie.png"></p>
]]></content>
      <categories>
        <category>cookie</category>
      </categories>
      <tags>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title>Django | django中两种模板目录设置</title>
    <url>/2021/07/30/django%E4%B8%AD%E4%B8%A4%E7%A7%8D%E6%A8%A1%E6%9D%BF%E7%9B%AE%E5%BD%95%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="django中两种模板目录设置"><a href="#django中两种模板目录设置" class="headerlink" title="django中两种模板目录设置"></a>django中两种模板目录设置</h1><p>在进行django项目开发中，我们需要创建一个用于存放模板的文件夹，模板文件夹通常放在以下两个位置之一。<br>第一种的项目目录为蓝色框所框选的目录，第二种的项目目录为红色框所框选的目录。<br><img src="/2021/07/30/django%E4%B8%AD%E4%B8%A4%E7%A7%8D%E6%A8%A1%E6%9D%BF%E7%9B%AE%E5%BD%95%E8%AE%BE%E7%BD%AE/content.png"></p>
<h2 id="位置（1）的优缺点："><a href="#位置（1）的优缺点：" class="headerlink" title="位置（1）的优缺点："></a>位置（1）的优缺点：</h2><p><strong>优点：</strong> 便于移植（首次开发完application应用，可将application应用移植到其他项目）<br><strong>缺点：</strong> 项目下的每个应用都有一个templates文件夹，不便于管理</p>
<h2 id="位置（2）的优缺点："><a href="#位置（2）的优缺点：" class="headerlink" title="位置（2）的优缺点："></a>位置（2）的优缺点：</h2><p><strong>优点：</strong> 便于管理模板文件<br><strong>缺点：</strong> 不方便移植到其他项目中</p>
]]></content>
      <categories>
        <category>python</category>
        <category>框架</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django | django中模板文件中的链接地址怎么写</title>
    <url>/2021/07/28/django%E4%B8%AD%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80%E6%80%8E%E4%B9%88%E5%86%99/</url>
    <content><![CDATA[<h1 id="django中模板文件中的链接地址怎么写"><a href="#django中模板文件中的链接地址怎么写" class="headerlink" title="django中模板文件中的链接地址怎么写?"></a>django中模板文件中的链接地址怎么写?</h1><p>在进行django项目开发中，通常会遇到一个场景：我们在当前页面点击一个链接，跳转到其他的页面，<br>那么在当前页面中的这个标签中的地址我们应该如何去写？</p>
<span id="more"></span>

<p><img src="/2021/07/28/django%E4%B8%AD%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80%E6%80%8E%E4%B9%88%E5%86%99/1.png"><br>假定我们当前处于 <a href="http://www.xxx.com/doc/a.html">www.xxx.com/doc/a.html</a> ,我们需要跳转到 b.html，那么我们可以这样写标签中的url,<br><a href="/b.html">,在这里url中的第一个斜杠代表的是根目录（www.xxx.com），之后浏览器将会把这个url<br>解析为 www.xxx.com/b.html。</a></p>
<p>另一种情况：<br>假设我们将标签中的url写为 <a href="b.html"></a>,浏览器将会把此url地址解析为 <a href="http://www.xxx.com/doc/b.html">www.xxx.com/doc/b.html</a> ,<br>前面没有斜杠即从为当前目录。</p>
]]></content>
      <categories>
        <category>python</category>
        <category>框架</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django | django开发流程</title>
    <url>/2021/04/15/django%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="django开发流程"><a href="#django开发流程" class="headerlink" title="django开发流程"></a>django开发流程</h1><p>1.安装虚拟环境<br>conda create -n python27 python==2.7<br>2..安装django<br>pip install django==1.8.2<br>3.创建项目<br>django-adming startproject project_name<br>4.创建应用<br>python manage.py startapp app_name<br>5.将app应用加入到installed_apps中<br>6.app_name/models.py中定义模型类<br>6.数据库配置(settings.py-DATABASES)<br>7.生成迁移文件<br>python manage.py makemigrations<br>8.执行迁移<br>python manage.py migrate<br>9.开启服务器<br>python manage.py runserver ip:port<br>10.创建管理员用户<br>python manage.py createsuperuser，按提示输入用户名、邮箱、密码<br>11.向admin注册app_name的模型<br>app_name/admin.py<br>admin.site.register(BookInfo)</p>
<p>注：<br>python shell—python manage.py shell</p>
]]></content>
      <categories>
        <category>python</category>
        <category>框架</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django | django自定义错误页面</title>
    <url>/2021/07/28/django%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[<h1 id="django自定义错误页面"><a href="#django自定义错误页面" class="headerlink" title="django自定义错误页面"></a>django自定义错误页面</h1><p>在进行django项目开发时，如果用户请求一个不存在的页面，将会显示以下界面：<br><img src="/2021/07/28/django%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2/1.png"><br>我们可以自定义一个错误页面来展示提示信息。</p>
<p>django版本：1.8.2</p>
<p><strong>步骤：</strong><br>1.修改settings.py</p>
<pre><code>DEBUG = False
ALLOWED_HOSTS = [&#39;*&#39;]
</code></pre>
<p>2.在templates文件夹下创建404.html页面</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
找不到了
&lt;hr/&gt;
&#123;&#123; request_path &#125;&#125;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>3.运行服务器，访问一个不存在的页面，将显示自定义的错误页面<br><img src="/2021/07/28/django%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2/2.png"></p>
]]></content>
      <categories>
        <category>python</category>
        <category>框架</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>脑电基础知识 | five major brain waves</title>
    <url>/2020/12/07/five-major-brain-waves/</url>
    <content><![CDATA[<h1 id="Five-Major-Brain-Waves"><a href="#Five-Major-Brain-Waves" class="headerlink" title="Five Major Brain Waves"></a>Five Major Brain Waves</h1><p>Five major brain waves can be distinguished by their frequency ranges:</p>
<table>
<thead>
<tr>
<th>frequency band</th>
<th>frequency range</th>
</tr>
</thead>
<tbody><tr>
<td>delta</td>
<td>0.5-4Hz</td>
</tr>
<tr>
<td>theta</td>
<td>4-8Hz</td>
</tr>
<tr>
<td>alpha</td>
<td>8-13Hz</td>
</tr>
<tr>
<td>beta</td>
<td>13-30Hz</td>
</tr>
<tr>
<td>gamma</td>
<td>30-50Hz</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>脑电基础知识</category>
      </categories>
      <tags>
        <tag>EEG</tag>
      </tags>
  </entry>
  <entry>
    <title>论文框架与写作技巧 | 论文框架</title>
    <url>/2021/02/10/framework-of-paper/</url>
    <content><![CDATA[<h1 id="Framework-of-Paper"><a href="#Framework-of-Paper" class="headerlink" title="Framework of Paper"></a>Framework of Paper</h1><div id="div1" style>
    <em>How to write a paper?</em><br>
    In fact,we need to write as follows:<br>
    Problem X is important<br>
    Previous works A, B, and C have been done<br>
    A, B, and C have their weakness<br>
    Your work D<br>
    Theoretical analysis<br>
    Experimental comparison against A, B, and C<br>
    Why D is better<br>
    Strength and weakness of D<br>
    Future work on D<br>
    So there is a framework of paper as folllows! 
    <span id="more"></span>
</div>


<div style>
    <h1 style="color: red">Title</h1>
    <h2 style="color: red">Abstract---Summarize your contributions</h2>
    What is the problem<br>
    What is your work<br>  
    Features of your work<br>  
    Advantages of your work<br>  
    Results<br>  
    <h2 style="color: red">Introduction---Background and organization of the paper</h2>
    Problem X is important<br>  
    A, B, and C have been done<br>  
    A, B, and C have their weakness<br>
    Our work D<br>
    Features and advantages of D<br>
    Results<br>
    Organization of the paper<br>
    <h2 style="color: red">Previous work---Why your work,the differences</h2>
    Categorization of previous works<br>
    One or two sentences for a work(Strength,Weakness)<br>
    <h2 style="color: red">Your contribution---Introduce your work</h2>
    Motivation<br>
    Definition,notation<br>
    Algorithm(Pseudocode,Diagram,Explanations)<br>
    <h2 style="color: red">Theoretical analysis---Theoretical support to your work</h2>
    Definition,notation<br>
    Lemma<br>
    Theorem<br>
    Proof<br>
    <h2 style="color: red">Experiments---Experimental to your work</h2>
    Experimental design<br>
    Comparison<br>
    Discussion<br>
    <h2 style="color: red">Discussion---The relationship between your work and some very related works</h2>
    Work A:<br>
    Why it is very related<br>
    Difference to your work<br>
    Work B:<br>
    Why it is very related<br>
    Difference to your work<br>
    <h2 style="color: red">Conclusion---summary and future work</h2>
    Summary<br>
    Future work<br>
    <h2 style="color: red">Acknowledgement</h2>
    <h2 style="color: red">Reference</h2>
    <h2 style="color: red">Appendix</h2>
</div>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>论文框架与写作技巧</category>
      </categories>
      <tags>
        <tag>论文</tag>
        <tag>论文框架</tag>
      </tags>
  </entry>
  <entry>
    <title>python | getattr()函数</title>
    <url>/2021/05/20/getattr-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="python-getattr-函数"><a href="#python-getattr-函数" class="headerlink" title="python getattr()函数"></a>python getattr()函数</h1><p>描述：getattr()函数用于返回一个对象属性值</p>
<p>参数：<br>object – 对象<br>name – 对象属性(字符串)<br>default – 默认返回值(如果不提供该参数，在没有对应属性时，将触发AttributeError)</p>
<p>实例：<br>class A(object):<br>    bar = 1</p>
<p>a = A()<br>print(getattr(a, ‘bar’))  # 获取属性bar值 result:1<br>print(getattr(a, ‘bar2’))  # 属性bar2不存在，触发异常<br>print(getattr(a, ‘bar2’, 3)  # result:3</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo | hexo博客换电脑了怎么办</title>
    <url>/2021/08/30/hexo%E5%8D%9A%E5%AE%A2%E6%8D%A2%E7%94%B5%E8%84%91%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E/</url>
    <content><![CDATA[<h1 id="hexo博客换电脑了怎么办"><a href="#hexo博客换电脑了怎么办" class="headerlink" title="hexo博客换电脑了怎么办"></a>hexo博客换电脑了怎么办</h1><p>我们搭建的hexo博客在更换电脑之后，如果重新搭建博客比较费时费力，可以按照以下资料快速在新的电脑上使用hexo博客发布内容。</p>
<p><a href="https://www.cnblogs.com/study-everyday/p/8902136.html">参考资料1</a><br><a href="https://www.cnblogs.com/study-everyday/p/8902136.html">参考资料2</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>python | pip安装出现Cannot fetch index base URL http://pypi.python.org/simple/解决方法</title>
    <url>/2021/01/28/pip%E5%AE%89%E8%A3%85%E5%87%BA%E7%8E%B0Cannot-fetch-index-base-URL-http-pypi-python-org-simple-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="pip安装出现Cannot-fetch-index-base-URL-http-pypi-python-org-simple-解决方法"><a href="#pip安装出现Cannot-fetch-index-base-URL-http-pypi-python-org-simple-解决方法" class="headerlink" title="pip安装出现Cannot fetch index base URL http://pypi.python.org/simple/解决方法"></a>pip安装出现Cannot fetch index base URL <a href="http://pypi.python.org/simple/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95">http://pypi.python.org/simple/解决方法</a></h1><p>1.sudo vi .pip/pip.conf<br>2.添加以下内容<br>[global]<br>index-url=<a href="http://pypi.doubanio.com/simple/">http://pypi.doubanio.com/simple/</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>itertools | product</title>
    <url>/2021/09/04/product/</url>
    <content><![CDATA[<h1 id="itertools-product"><a href="#itertools-product" class="headerlink" title="itertools.product()"></a>itertools.product()</h1><p>使用product()前需要导入itertools库<br><strong>用法1：</strong></p>
<pre><code>print(list(itertools.product(‘a&#39;, repeat=4)))   # 等价于 print(list(itertools.product(&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;)))

a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
print(list(itertools.product(a, repeat=2)))  # s等价于 print(list(itertools.product(a, a)))
</code></pre>
<p><strong>用法2：</strong></p>
<pre><code>print(list(itertools.product(a, b)))  # 等价于 print(list((x, y) for x in a for y in b))
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>内置模块</category>
        <category>itertools</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>itertools</tag>
      </tags>
  </entry>
  <entry>
    <title>pycharm同步代码到远程服务器</title>
    <url>/2021/04/18/pycharm%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%88%B0%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h1 id="pycharm同步代码到远程服务器"><a href="#pycharm同步代码到远程服务器" class="headerlink" title="pycharm同步代码到远程服务器"></a>pycharm同步代码到远程服务器</h1><p>1.在pycharm菜单栏点Tools–&gt;Deployment–&gt;Configuration<br>如果显示Please add a web server to configure,点+增加一个要配置的web服务器，传输协议选择SFTP，并输入新服务器的名称。<br>2.在connection选项中选择或输入对应信息<br>Type:SFTP<br>Host:服务器ip地址 Port:22(默认为22)<br>Username:<br>Authentication:Password<br>Password:<br>3.点Test Connection测试是否成功连接服务器<br>4.在Mappings选项中选择 Deployment path(将项目/文件部署到服务器的哪个路径下)<br>5.Tools–&gt;start SSH session<br>6.Tools–&gt;Deployment–&gt;upload to 刚刚输入的新服务器名称</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>pygame最小开发框架</title>
    <url>/2021/05/21/pygame%E6%9C%80%E5%B0%8F%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="pygame最小开发框架"><a href="#pygame最小开发框架" class="headerlink" title="pygame最小开发框架"></a>pygame最小开发框架</h1><pre><code>import pygame, sys

pygame.init()
screen = pygame.display.set_mode((1206, 780))
pygame.display.set_caption(&quot;Pygame&quot;)

while True:
        for event in pygame.event.get():
                if event.type == pygame.QUIT:
                        sys.exit()

        pygame.display.update()
</code></pre>
<p><img src="/2021/05/21/pygame%E6%9C%80%E5%B0%8F%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/pygame.jpg" alt="pygame最小开发框架"></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>pygame</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pygame</tag>
      </tags>
  </entry>
  <entry>
    <title>python | python @property</title>
    <url>/2021/05/20/python-property/</url>
    <content><![CDATA[<h1 id="python-property"><a href="#python-property" class="headerlink" title="python property"></a>python property</h1><pre><code>class Test(object):
        def __init__(self):
            self.__num = 100

           # def getNum(self):
           #     return self.__num
            #
        # def setNum(self,newNum):
            #     self.__num = newNum

        @property
        def num(self):
                return self.__num

        @num.setter
        def num(self,newNum):
                self.__num = newNum


t = Test()
t.num = 50
print(t.num)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python | python str 对象</title>
    <url>/2021/05/15/python-str-%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="python中的str对象"><a href="#python中的str对象" class="headerlink" title="python中的str对象"></a>python中的str对象</h1><p>python中的str对象是不可变对象，因此不存在修改字符串这一说法。<br>即：在s = ‘test’后写 s = ‘test1’</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python | python zip()函数</title>
    <url>/2021/05/20/python-zip-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="python-zip-函数"><a href="#python-zip-函数" class="headerlink" title="python zip()函数"></a>python zip()函数</h1><p>example:<br>1.zip() 压缩(zip)<br>case 1:<br>list1 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]<br>print([row for row in zip(list1)]) # ([1, 2, 3],), ([4, 5, 6],), ([7, 8, 9],)</p>
<p>case 2:<br>list1 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]<br>list2 = [[7, 8, 9], [4, 5, 6], [1, 2, 3]]<br>print([row for row in zip(list1, list2)])  # [([1, 2, 3], [7, 8, 9]), ([4, 5, 6], [4, 5, 6]), ([7, 8, 9], [1, 2, 3])]</p>
<p>2.zip(*) 解压(unzip)<br>list1 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]<br>print([row for row in zip(*list1)])  # [(1, 4, 7), (2, 5, 8), (3, 6, 9)]</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python | python 广播</title>
    <url>/2021/06/21/python-%E5%B9%BF%E6%92%AD/</url>
    <content><![CDATA[<h1 id="python-广播"><a href="#python-广播" class="headerlink" title="python 广播"></a>python 广播</h1><pre><code>&quot;&quot;&quot;
Calories from Carbs,Proteins,Fats in 100g of different foods:

           Apples        Beef        Eggs        Potatoes
   
Carb    [94.91525424  0.          2.83140283 88.42652796]
Protein [ 2.03389831 43.51464435 33.46203346 10.40312094]
Fat     [ 3.05084746 56.48535565 63.70656371  1.17035111]
 
Q:Calculate % of calories from Carbs,Proteins,Fats.Can you do this without
explicit for-loop?
&quot;&quot;&quot;

import numpy as np

A = np.array([[56.0,0.0,4.4,68.0],
             [1.2,104.0,52.0,8.0],
             [1.8,135.0,99.0,0.9]])
print(A)
cal = A.sum(axis=0)
print(cal)
percentage = 100*A/cal.reshape(1,4)
print(percentage)
</code></pre>
<p><a href="https://www.bilibili.com/video/BV1FT4y1E74V?p=21">参考吴恩达深度学习视频</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python | python中如何实现函数重载的效果</title>
    <url>/2021/08/02/python%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%9A%84%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<h1 id="python中如何实现函数重载的效果"><a href="#python中如何实现函数重载的效果" class="headerlink" title="python中如何实现函数重载的效果"></a>python中如何实现函数重载的效果</h1><h2 id="什么是函数重载？"><a href="#什么是函数重载？" class="headerlink" title="什么是函数重载？"></a>什么是函数重载？</h2><p>函数重载，即可以定义多个同名函数，但是参数列表不同，这样在调用时可以传递不同的实参。</p>
<h2 id="python中没有函数重载的概念"><a href="#python中没有函数重载的概念" class="headerlink" title="python中没有函数重载的概念"></a>python中没有函数重载的概念</h2><p>函数重载会增加代码量，所以在python中没有函数重载的概念，而是<strong>为函数的参数提供默认值</strong>实现的。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><pre><code># coding=utf-8

def make_coffee(name=&#39;卡布奇诺&#39;)：
    return &quot;制作一杯&#123;&#125;&quot;.format(name)
    
coffee1 = make_coffee(&#39;拿铁&#39;)  # 提供参数
coffee2 = make_coffee()  # 没有提供参数，使用默认值
print(coffee1)
print(coffee2)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python | python 翻转列表</title>
    <url>/2021/05/20/python-%E7%BF%BB%E8%BD%AC%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="python-翻转列表"><a href="#python-翻转列表" class="headerlink" title="python 翻转列表"></a>python 翻转列表</h1><p>list1 = [1, 2, 3]<br>print(list1[::-1])  # [3, 2, 1]</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python | python中的filter函数和map函数</title>
    <url>/2021/08/02/python%E4%B8%AD%E7%9A%84filter%E5%87%BD%E6%95%B0%E5%92%8Cmap%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="python中的filter函数和map函数"><a href="#python中的filter函数和map函数" class="headerlink" title="python中的filter函数和map函数"></a>python中的filter函数和map函数</h1><h2 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h2><p>filter()用于对容器中的元素进行过滤处理</p>
<pre><code># coding=utf-8
# 提供过滤条件函数
def f1(x):
    return x &gt; 50
    
data1 = [66, 15, 91, 28, 98, 50, 7, 90, 99]
filtered = filter(f1, data1)
data2 = list(filtered)
print(data2)


# lambda实现
data1 = [66, 15, 91, 28, 98, 50, 7, 90, 99]
filtered = filter(lambda x : (x &gt; 50), data1)
data2 = list(filtered)
print(data2)
</code></pre>
<h2 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h2><p>map()用于对容器中的元素进行映射或变换</p>
<pre><code># coding=utf-8
# 提供变换规则的函数
def f1(x):
    return x * 2

data1 = [66, 15, 91, 28, 98, 50, 7, 90, 99]
mapped = map(f1, data1)
data2 = list(mapped)
print(data2)


# lambda实现
data1 = [66, 15, 91, 28, 98, 50, 7, 90, 99]
mapped = map(lambda x : (x * 2), data1)
data2 = list(mapped)
print(data2)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python | python中的iter()与next()</title>
    <url>/2021/02/26/python%E4%B8%AD%E7%9A%84iter-%E4%B8%8Enext/</url>
    <content><![CDATA[<h1 id="python中的iter-与next"><a href="#python中的iter-与next" class="headerlink" title="python中的iter()与next()"></a>python中的iter()与next()</h1><p>可迭代对象(Iterable)：可以直接作用于for循环的对象</p>
<p>分类：<br>1.集合数据类型 list、tuple、dict、set、str<br>2.generator(包括生成器和带yield的generator function)<br>Note:生成器不但可以作用于 for 循环，还可以被 next() 函数不断调用并返回下一个值</p>
<p>生成器都是Iterator,但list、tuple、dict、str、set虽然是Iterable,却不是Iterator，可以使用iter()函数把list…Iterable编程Iterator</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python | python可变参数</title>
    <url>/2021/08/02/python%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h1 id="python可变参数"><a href="#python可变参数" class="headerlink" title="python可变参数"></a>python可变参数</h1><p>python中的函数可以定义<strong>接受不确定数量的参数</strong>，这种参数被称为<strong>可变参数</strong>。</p>
<p>可变参数有两种：1）参数前加*  2）参数前加**<br>*可变参数在函数中被组装成一个元组<br>**可变参数在函数中被组装成一个字典、</p>
<p>代码示例：</p>
<pre><code># *可变参数
def sum(*numbers):
    total = 0.0
    
    for number in numbers:
        total += number
        
    return total
    
print(sum(100.0, 20.0, 30.0))  # 150
print(sum(30.0, 80.0))  # 110

# **可变参数
# coding=utf-8

def show_info(**info):
    print(&#39;-----show_info-----&#39;)
    for key,value in info.items():
        print(&quot;&#123;0&#125; - &#123;1&#125;&quot;.format(key, value)
        
show_info(name=&#39;Tony&#39;, age=18, sex=True)
show_info(student_name=&#39;Tony&#39;, student_no=&#39;1000&#39;)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python资源大全</title>
    <url>/2021/07/03/python%E8%B5%84%E6%BA%90%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<p>awesome-python 是 vinta 发起维护的 Python 资源列表，内容包括：Web 框架、网络爬虫、网络内容提取、模板引擎、数据库、数据可视化、图片处理、文本处理、自然语言处理、机器学习、日志、代码分析等。<br><a href="http://jobbole.github.io/awesome-python-cn/">python资源大全中文版</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python | re.match与re.search的区别</title>
    <url>/2020/11/08/re-match%E4%B8%8Ere-search%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="re-match与re-search的区别"><a href="#re-match与re-search的区别" class="headerlink" title="re.match与re.search的区别"></a>re.match与re.search的区别</h1><p>re.match从字符串的起始位置匹配一个模式，如果字符串开始不符合正则表达式，则匹配失败。<br>re.search匹配整个字符串，直到找到一个匹配</p>
<h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><pre><code>s = &quot;Cats are smarter than dogs&quot;
re.match(r&quot;dogs&quot;,s)#匹配失败
re.search(r&quot;dogs&quot;,s)#匹配成功
</code></pre>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python | re sub的使用方法</title>
    <url>/2021/08/27/re-sub%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="re-sub的使用方法"><a href="#re-sub的使用方法" class="headerlink" title="re.sub的使用方法"></a>re.sub的使用方法</h1><p>re.sub()实现相对复杂的替换</p>
<p><a href="https://www.jianshu.com/p/8c1d1a38f9b9">使用方法</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>re</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>re</tag>
      </tags>
  </entry>
  <entry>
    <title>matplotlib | recorded EEG visualization</title>
    <url>/2021/10/12/recorded-EEG-visualization/</url>
    <content><![CDATA[<h1 id="recorded-EEG-visualization"><a href="#recorded-EEG-visualization" class="headerlink" title="recorded EEG visualization"></a>recorded EEG visualization</h1><p>在做脑电（EEG）的相关研究时,通常我们需要使用公开的脑电数据集合，公开数据集包含了以及采集好的脑电数据。<br>我们可以使用python的第三方库matplotlib将数据集中的脑电数据进行可视化。</p>
<span id="more"></span>

<p>下面以绘制8个通道的脑电数据为例对脑电数据进行可视化：<br>注意：实例中使用公开数据集DEAP,详细信息可参考<a href="http://www.eecs.qmul.ac.uk/mmv/datasets/deap/">DEAP 官网</a></p>
<p><strong>示例代码：</strong></p>
<pre><code>import os
import glob
import pickle
import matplotlib.pyplot as plt

# 参数设置
window_size = 1
sampling_rate = 500


# 获取数据文件列表并划分(训练文件/测试文件)
data_dir = &quot;data_preprocessed_python/&quot;
file_list = glob.glob(os.path.join(data_dir, &quot;*&quot;))  # 整个数据集包含32个subject的样本数据
print(&quot;len(file_list):&quot;, len(file_list))


def get_data_and_label(file_list):
    &quot;&quot;&quot;
    获得固定窗口大小的数据和对应的标签

    Arrray name         Array shape         Array contents
    ---------------------------------------------------------------------------------------------
    data                40 x 40 x 8064      video/trial x channel x data
    labels              40 x 4              videl/trial x label(valence,arousal,dominance,liking)
    ---------------------------------------------------------------------------------------------
    &quot;&quot;&quot;
    data = []
    valence_labels = []
    arousal_labels = []

    for file in file_list:
        x = pickle.load(open(file, &#39;rb&#39;), encoding=&#39;latin1&#39;)  # type(x):dict &#123;&#39;labels&#39;:array(),&#39;data&#39;:array()&#125;

        labels = x[&#39;labels&#39;]
        valence_labels.extend(labels[:, 0])
        arousal_labels.extend(labels[:, 1])

        dat = x[&#39;data&#39;]
        data.extend(dat[:, :, :window_size * sampling_rate])

    return data

print(&quot;开始获取脑电波数据...&quot;)
data = get_data_and_label(file_list)
print(&quot;脑电波数据已获取，开始绘制脑电波...&quot;)
x = range(sampling_rate)
fig, ax = plt.subplots(3, 3)
ax[0][0].plot(x, list(data[0][0]))
ax[0][0].set_title(&#39;Fp1&#39;)
ax[0][1].plot(x, list(data[0][1]))
ax[0][1].set_title(&#39;AF3&#39;)
ax[0][2].plot(x, list(data[0][2]))
ax[0][2].set_title(&#39;F3&#39;)
ax[1][0].plot(x, list(data[0][3]))
ax[1][0].set_title(&#39;F7&#39;)
ax[1][1].plot(x, list(data[0][4]))
ax[1][1].set_title(&#39;FC5&#39;)
ax[1][2].plot(x, list(data[0][5]))
ax[1][2].set_title(&#39;FC1&#39;)
ax[2][0].plot(x, list(data[0][6]))
ax[2][0].set_title(&#39;C3&#39;)
ax[2][1].plot(x, list(data[0][7]))
ax[2][1].set_title(&#39;T7&#39;)
ax[2][2].plot(x, list(data[0][8]))
ax[2][2].set_title(&#39;CP5&#39;)
plt.show()
print(&quot;脑电波绘制完成！&quot;)
</code></pre>
<p><strong>绘制的脑电波：</strong></p>
<p><img src="/2021/10/12/recorded-EEG-visualization/500_brainwave.png"></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>matplotlib</category>
      </categories>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL | Access denied for user &#39;root&#39;@&#39;localhost&#39;</title>
    <url>/2021/04/18/root-localhost/</url>
    <content><![CDATA[<h1 id="ERROR-Access-denied-for-user-‘root’-’localhost’"><a href="#ERROR-Access-denied-for-user-‘root’-’localhost’" class="headerlink" title="ERROR: Access denied for user ‘root’@’localhost’"></a>ERROR: Access denied for user ‘root’@’localhost’</h1><p>在安装mysql时，安装过程中没有提示输入密码，安装完成之后，在终端输入mysql报错Access denied for ‘root’@’localhost’,但是使用sudo mysql可以进入。</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h2><p>1.在终端输：sudo mysql 进入mysql<br>2.mysql&gt; use mysql<br>3.mysql&gt; alter user ‘root’@’localhost’ identified with mysql_native_password by ‘your password’</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Movies | sacrifice</title>
    <url>/2020/10/29/sacrifice/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="79e80760dd3d238a6e9a15b5be6ada3d11c39cf7b5591ebe4ef6d0374ab585ab">06cac7a4498bdc1ba84f9a7c2df89776a693a413eda0c1b32a74d9891b7b55a7901574726315dcdbc8314bb123e764c805202b86c9e30f9ce1445163b5696416a3bf9fda41bf13ed75c625bf6d79fbbbe96455d4c695063426ae736fb1ea1800bebd246813a28203ca22c1a7fe1305c347e97942718e0f945446f1363c99c5acca82179441369cf4493a004544c59043b24c113d8724aa6ceecbc5e1aedda601d321f50df2f2d0db5577cac7472095493d561a9bffa6b0448cf9cdc05d6447cf0e275a47a08ac48c0be83e0483b9c4a0ed3a5c7a7a22020d536f97a2a7903aa177d9d4d1d8bec07a9496b1d99fdfbe1aa89e08bd98e1b26fcf9a8efddd565e98688bc0af5133dd2b3261fbed6718c7f74b12064a0ce4270ea3523f42b3c93843946a1a9542a7796eb9b8af85fc6b23a26fc32d05b0f7e182d152c1e1410379d7fe2fe64c585e71bea30c4b37b35c322556c5a1034dbcf25bb987f524ff2610802740b1b797a7b9f9589fcabeb5650e98dc2807708ce8e9150c79e880ac3850d65677a0f0fe5920963a4a0af0a6921d2ec83a36ad47f861443a4fb718aa779b624d8fa2aab326c71a0fc6e1964a222fa6a4eac6e1d7db09c6e4858af318953ce0ad7a685ad5e9b454b2fde24126b5a03e88a28f4b490c6a0723fc6cee8b166c7200372465ff06793ce6f43f8a0a6734333e62a33b9fe5cc5fab81c188708bfdd9711f2a1ea07c8ac3bbc7124e4580d0518d1505c7843119484ed8c627324c6d6c270178efc5812df6fe6edfd521c83aaa54fa7a8cb7312435570206e91c1372684e0406d8c9e805702a1d4aec50cd7936c9e6b225f8cf5c5d672a4d09360c2cf2a7c61e20762521bc43b3b42cb1b1d4401efaf77060a368f90c05d89a932d3acb201d78bab5b05f7173ae28a5f888f13f37d5b6c3bc35fc4035c278f1dfecbf333bfb8067d48f07dea05cb0696f50e8e4008ba6f3ed72a475b95a06249c6a951689927c8a1e911906fecd41a47e5a51f3b5d68aa2f9184a590cd2306cce891770a161575ef050ca37761518ec408c7e3a14a76af47d1e78583a9ddd915c4524704afbeb4d0b26bb55df64d2a37a29755916adf48fd38f06e7c0615a98537e70397d5b94f99534b6cc71126c9ae55ab8bb49ff40f09a7eaf1946e323a0ed080e2e2aea3aacabbedaba2bebe989536d10480269727690f20dde3228e18c35ffdd7c848aa9907af197f8aca420bb6ba417dc3565140e6d31b081475d4c2d23b3551be1ef18fc654d21d227bd4a4e88c9db6e02773080ad3ca5ef83d995cebab3cd935e0faba541fb168190f23acbd6577cb3f858e57e366268bb4c6a9648f27b3073c1626707a0194eea8e3f6d181bc5b8069f472ecd256d80040e822c5689333db495b87c1be67ecbd591457d2b3e1ded7971a93c4dbce535e3128b8a7a77e29bfe3956a3f1802bb066bdae0bd1e2f8642d1eafdcce584e23e2eceffd4977a1f0eb5989bdd4ffc5132fa5b5cb5252b12a53f6b690e7aa28fe3926ab645671cf10452cab9a8c19f61c68a22bcaa3c9e92339f6ec3e9ecfe32f93d18058eb7ad76e59cfcbd69ff698b7ade19404ba67152bc5283191262e79804bb5637b4ba77773ffc3cd4cd618d9a094f288f15b8b9423664a503dc9d3d7528b73f6026a544617f9a0e2d0980f5ae6fbe6502535a3aa33cc4014e3decb8fe27fb3bf41053478846a731a02d6717d0effdde3e7d787de370f2bdd61ca46057e3bded549473f79f5b8563d3d940eae0f730ae31fbf75e52ecb10995fc1c7b51d93e3ce4f7b7d2a5b6252920816c48f97a720b16707fb33919da891fb3660ca999f168e272244004786f5f412b17c00950deec7c3e4970fc68f3cfce80218a5eae3c16c746fdd412b75fe4e767bcf63dd1933895cc249ab73456010f667a81411e0dfaf01fbb20ccee4f89ee8a30d2381e86daefa6f2a4eb43003fae18fa7663c1eec27929229a60c05da989796453d61dfb634d749e8084b9cbbb4e5a8ad388edf011464c87edad762ce5a821b4cc232d376c1b3e411b8dde670d787da6676777d4284cfb8f250e90f8745543cabdd62a8b95c687fa7bee4b99a7aed560f31d18f3cb2a93828ec8b923d6947aca01dd3ff9723d8e2896bd59324fe69cfc29714683ffcafb7a3b6fef802f931b3b6ecdcbd0ad4fa24fd2222ccd1e68018c0b5e22a9b37d94d7555bc5610c3a65bb92eb57dd53e0dc3fd3ee5abf738197958b86c11238a50d265ab71d6971e8c7fc5cb92ab9b4cecc89a621554d2b726b10a1c21078a044ad5246314e42c2225ab359d06710b5407a6ac2204fe87fb762493dd47237adcd67ad3350627fb4bda29b61743949b1f72113fea8a5df815ff5cde7de64e03c4ff88aeb22675</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Movies</category>
      </categories>
      <tags>
        <tag>金刚川</tag>
      </tags>
  </entry>
  <entry>
    <title>Django | session实现用户登录</title>
    <url>/2021/07/29/session%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<h1 id="session实现用户登录"><a href="#session实现用户登录" class="headerlink" title="session实现用户登录"></a>session实现用户登录</h1><p>下面将使用session实现用户登录，如下图所示效果：<br><img src="/2021/07/29/session%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95/login.gif"></p>
<h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><p>1.在views.py文件中创建视图(假定我们创建了一个名为booktest的应用)</p>
<pre><code>def index(request):
    uname = request.session.get(&#39;myname&#39;, default=&#39;未登录&#39;)
    context = &#123;&#39;uname&#39;: uname&#125;
    return render(request, &#39;booktest/index.html&#39;, context)


def login(request):
    return render(request, &#39;booktest/login.html&#39;)


def login_handle(request):
    uname = request.POST[&#39;uname&#39;]
    request.session[&#39;myname&#39;] = uname
    return redirect(&#39;/booktest/index/&#39;)


def logout(request):
    # del request.session[&#39;myname&#39;]  # 删除会话
    # request.session.clear()  # 清除所有会话
    request.session.flush()  # 删除当前的会话数据并删除会话的Cookie
    return redirect(&#39;/booktest/index/&#39;)
</code></pre>
<p>2.配置url</p>
<pre><code>主url:
from django.conf.urls import include, url
from django.contrib import admin

urlpatterns = [
    url(r&#39;^booktest/&#39;, include(&quot;booktest.urls&quot;, namespace=&#39;booktest&#39;)),
]
应用url:
from django.conf.urls import include, url
import views


urlpatterns = [
    url(r&#39;^index/$&#39;, views.index),
    url(r&#39;^login/$&#39;, views.login),
    url(r&#39;^login_handle/$&#39;, views.login_handle),
    url(r&#39;^logout/$&#39;, views.logout3),

]
</code></pre>
<p>3.创建模板</p>
<pre><code>index.html

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
你好：&#123;&#123; uname &#125;&#125;
&lt;br&gt;
&lt;a href=&quot;/booktest/session2/&quot;&gt;登录&lt;/a&gt;
&lt;br&gt;
&lt;a href=&quot;/booktest/session3/&quot;&gt;退出&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;

login.html

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form method=&quot;post&quot; action=&quot;/booktest/session2_handle/&quot;&gt;
    &lt;input type=&quot;text&quot; name=&quot;uname&quot;&gt;
    &lt;input type=&quot;submit&quot; name=&quot;登录&quot;&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>4.配置模板路径DIRS<br>注：templates为和应用同级的文件夹，本应用的模板存在templates/booktest/下</p>
<pre><code>TEMPLATES = [
    &#123;
        &#39;BACKEND&#39;: &#39;django.template.backends.django.DjangoTemplates&#39;,
        &#39;DIRS&#39;: [os.path.join(BASE_DIR, &#39;templates&#39;)],
        &#39;APP_DIRS&#39;: True,
        &#39;OPTIONS&#39;: &#123;
            &#39;context_processors&#39;: [
                &#39;django.template.context_processors.debug&#39;,
                &#39;django.template.context_processors.request&#39;,
                &#39;django.contrib.auth.context_processors.auth&#39;,
                &#39;django.contrib.messages.context_processors.messages&#39;,
            ],
        &#125;,
    &#125;,
]
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>框架</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | sigmoid or tanh</title>
    <url>/2021/06/24/sigmoid-or-tanh/</url>
    <content><![CDATA[<h1 id="sigmoid-or-tanh？"><a href="#sigmoid-or-tanh？" class="headerlink" title="sigmoid or tanh？"></a>sigmoid or tanh？</h1><p>Sigmoid outputs a value between 0 and 1 which makes it a very good choice for binary classification.<br>You can classify as 0 if the output is less than 0.5 and classify as 1 if the output is more than 0.5.<br>It can be done with tanh as well but it is less convenient as the output is between -1 and 1.(Sigmoid<br>输出的值介于 0 和 1 之间，这使其成为二元分类的一个非常好的选择。 如果输出小于 0.5，则可以将其归类为 0，如果输出<br>大于 0.5，则归类为 1。 它也可以用 tanh 来完成，但是它不太方便，因为输出在<br>-1 和 1 之间。)</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>激活函数</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程 | tcp三次握手四次挥手</title>
    <url>/2020/10/26/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    <content><![CDATA[<h1 id="使用tcp协议进行通信过程中的三次握手和四次挥手"><a href="#使用tcp协议进行通信过程中的三次握手和四次挥手" class="headerlink" title="使用tcp协议进行通信过程中的三次握手和四次挥手"></a>使用tcp协议进行通信过程中的三次握手和四次挥手</h1><p>TCP在真正的读写操作之前，server与client之间必须建立一个连接。<br>当读写操作完成后，双方不再需要这个连接时它们可以释放这个连接。<br>连接的<strong>建立</strong>通过<strong>三次握手</strong>，<strong>释放</strong>则需要<strong>四次挥手</strong><br><img src="/2020/10/26/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/tcp.JPG" alt="tcp三次握手和四次挥手"></p>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>三次握手</tag>
        <tag>四次挥手</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程 | tcp与udp的稳定性</title>
    <url>/2020/10/26/tcp%E4%B8%8Eudp%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7/</url>
    <content><![CDATA[<h1 id="tcp稳定而udp不稳定的原因"><a href="#tcp稳定而udp不稳定的原因" class="headerlink" title="tcp稳定而udp不稳定的原因"></a>tcp稳定而udp不稳定的原因</h1><p><b style="color:red">在tcp中，如果有一方收到了对方的数据，一定会发送ack确认包给发送方，而在udp中，没有这个过程，因此导致了tcp稳定，而udp不稳定。</b></p>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>TCP</tag>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程 | tcp的客户端/服务器端代码编写</title>
    <url>/2020/10/22/tcp%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99/</url>
    <content><![CDATA[<h1 id="tcp的客户端-服务器端代码编写"><a href="#tcp的客户端-服务器端代码编写" class="headerlink" title="tcp的客户端/服务器端代码编写"></a>tcp的客户端/服务器端代码编写</h1><h2 id="tcp服务器端代码编写"><a href="#tcp服务器端代码编写" class="headerlink" title="tcp服务器端代码编写"></a>tcp服务器端代码编写</h2><pre><code>#coding=utf-8
from socket import *

# 创建socket
tcpSerSocket = socket(AF_INET, SOCK_STREAM)

# 绑定本地信息
address = (&#39;&#39;, 7788)
tcpSerSocket.bind(address)

# 使用socket创建的套接字默认的属性是主动的，使用listen将其变为被动的，这样就可以接收别人的链接了
tcpSerSocket.listen(5)

# 如果有新的客户端来链接服务器，那么就产生一个新的套接字专门为这个客户端服务器
# newSocket用来为这个客户端服务
# tcpSerSocket就可以省下来专门等待其他新客户端的链接
newSocket, clientAddr = tcpSerSocket.accept()

# 接收对方发送过来的数据，最大接收1024个字节
recvData = newSocket.recv(1024)
print(&#39;接收到的数据为:%s&#39;%recvData)

# 发送一些数据到客户端
newSocket.send(&quot;thank you !&quot;)

# 关闭为这个客户端服务的套接字，只要关闭了，就意味着为不能再为这个客户端服务了，如果还需要服务，只能再次重新连接
newSocket.close()

# 关闭监听套接字，只要这个套接字关闭了，就意味着整个程序不能再接收任何新的客户端的连接
tcpSerSocket.close()
</code></pre>
<span id="more"></span>
<h2 id="tcp客户端代码编写"><a href="#tcp客户端代码编写" class="headerlink" title="tcp客户端代码编写"></a>tcp客户端代码编写</h2><pre><code>#coding=utf-8
from socket import *

# 创建socket
tcpClientSocket = socket(AF_INET, SOCK_STREAM)

# 链接服务器
serAddr = (&#39;192.168.1.102&#39;, 7788)
tcpClientSocket.connect(serAddr)

# 提示用户输入数据
sendData = input(&quot;请输入要发送的数据：&quot;)

tcpClientSocket.send(sendData)

# 接收对方发送过来的数据，最大接收1024个字节
recvData = tcpClientSocket.recv(1024)
print(&#39;接收到的数据为:%s&#39;%recvData)

# 关闭套接字
tcpClientSocket.close()
</code></pre>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>tcp客户端</tag>
        <tag>tcp服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>软件架构 | ten things every architect should know</title>
    <url>/2021/03/11/ten-things-every-architect-should-know/</url>
    <content><![CDATA[<h1 id="Ten-Things-Every-Architect-Should-Know"><a href="#Ten-Things-Every-Architect-Should-Know" class="headerlink" title="Ten Things Every Architect Should Know"></a>Ten Things Every Architect Should Know</h1><p>1.<b>People</b> are the platform</p>
<p>2.All solutions are obsolete</p>
<p>3.<b>Data</b> is forever</p>
<p>4.Flexibility breeds complexity</p>
<p>5.Nothing works as expected</p>
<p>6.<b>Documentation</b> is the universal source code</p>
<p>7.Know the <b>business</b></p>
<p>8.Maintain the <b>version</b></p>
<p>9.Software architext should also be coders</p>
<p>10.There is no substitute for <b>experiences</b></p>
]]></content>
      <categories>
        <category>SA</category>
      </categories>
      <tags>
        <tag>软件架构</tag>
      </tags>
  </entry>
  <entry>
    <title>python | tensorflow安装遇到问题</title>
    <url>/2021/05/13/tensorflow%E5%AE%89%E8%A3%85%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="Python中解决ModuleNotFoundError-No-module-named-‘tensorflow-api’问题"><a href="#Python中解决ModuleNotFoundError-No-module-named-‘tensorflow-api’问题" class="headerlink" title="Python中解决ModuleNotFoundError: No module named ‘tensorflow._api’问题"></a>Python中解决ModuleNotFoundError: No module named ‘tensorflow._api’问题</h1><p><a href="https://blog.csdn.net/u012270544/article/details/96424907">点击这里查看问题解决方法</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>python | ubuntu下虚拟环境的安装与配置</title>
    <url>/2021/01/28/ubuntu%E4%B8%8B%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="ubuntu下虚拟环境的安装与配置"><a href="#ubuntu下虚拟环境的安装与配置" class="headerlink" title="ubuntu下虚拟环境的安装与配置"></a>ubuntu下虚拟环境的安装与配置</h1><h2 id="为什么要搭建虚拟环境"><a href="#为什么要搭建虚拟环境" class="headerlink" title="为什么要搭建虚拟环境?"></a>为什么要搭建虚拟环境?</h2><pre><code>如果在一台电脑上, 有不同项目, 需要用到同一个包的不同版本, 新版本会覆盖以前的版本, 其它的项目就可能无法正常运行了.。
解决方法：虚拟环境
    作用：虚拟环境可以搭建独立的python运行环境`, 使得单个项目的运行环境与其它项目互不影响。
    所有的虚拟环境都位于/home/用户名下的隐藏目录.virtualenvs下。
</code></pre>
<h2 id="如何搭建虚拟环境"><a href="#如何搭建虚拟环境" class="headerlink" title="如何搭建虚拟环境?"></a>如何搭建虚拟环境?</h2><pre><code>安装虚拟环境的命令：
sudo pip install virtualenvo
sudo pip install virtualenvwrapper

安装完虚拟环境后，如果提示找不到mkvirtualenv命令，须配置环境变量：

# 1、创建目录用来存放虚拟环境
mkdir \$HOME/.virtualenvs
# 2、打开~/.bashrc文件，并添加如下：
export WORKON_HOME=$HOME/.virtualenvs
source /usr/local/bin/virtualenvwrapper.sh
# 3、运行
source ~/.bashrc

创建虚拟环境的命令 :
在python3中，创建虚拟环境

mkvirtualenv -p python3 虚拟环境名称
例 ：
mkvirtualenv -p python3 django_py3
</code></pre>
<p>创建成功后会自动工作在这个虚拟环境上,工作在虚拟环境上, 提示符最前面会出现 “虚拟环境名称”。<br>如何使用虚拟环境?</p>
<pre><code>查看虚拟环境的命令 :

workon 两次tab键 或者 回车

使用虚拟环境的命令：

workon 虚拟环境名称
例 ：使用名为django_py3的虚拟环境
workon django_py3

退出虚拟环境的命令 :

deactivate

删除虚拟环境的命令 :

rmvirtualenv 虚拟环境名称
例 ：删除虚拟环境django_py3
先退出：deactivate
再删除：rmvirtualenv django_py3
</code></pre>
<h2 id="如何在虚拟环境中安装工具包"><a href="#如何在虚拟环境中安装工具包" class="headerlink" title="如何在虚拟环境中安装工具包"></a>如何在虚拟环境中安装工具包</h2><p>workon进入虚拟环境后，再使用pip进行包的安装，其安装方法和普通的安装方式一样。</p>
<pre><code>安装指定Django版本示例:

pip install django==1.11.11

python3下的安装路径：

~/.virtualenvs/django_py3/lib/python3.5/site-packages/
</code></pre>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>虚拟环境</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程 | udp+多线程模拟QQ</title>
    <url>/2020/10/17/udp-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E6%8B%9FQQ/</url>
    <content><![CDATA[<h1 id="在linux环境下使用-udp-多线程-模拟QQ"><a href="#在linux环境下使用-udp-多线程-模拟QQ" class="headerlink" title="在linux环境下使用 udp+多线程 模拟QQ"></a>在linux环境下使用 <b>udp+多线程</b> 模拟QQ</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><strong>程序主要的两个功能</strong>：</p>
<ul>
<li>发送数据（Send Data） </li>
<li>接收数据（Reveive Data）</li>
</ul>
<p><strong>使用多线程的原因</strong><br>不使用多线程的情况下，在程序暂停等待发送方输入发送内容时，若发送方不输入内容，则程序一直卡在这里；此时另外一放发送数据由于程序暂时等待输入内容也不能打印消息。<br>使用了多线程，接收数据、发送数据的程序分别由一个线程来处理，且两个线程互不影响，发送方不输入内容时，另一方发送消息发送方就能接收到。<br><b>Note:通信的两台计算机必须在同一个局域网！！！</b></p>
<span id="more"></span>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code># coding=utf-8
# 1.receive data then print out
from threading import Thread
from socket import *

def recvData():
    while True:
        recvInfo = udpSocket.recvfrom(1024)
        print(&quot;&gt;&gt;%s:%s\n&lt;&lt;&quot;%(str(recvInfo[1]),recvInfo[0]),end=&quot;&quot;)

# 2.detect the keyboard and send the data
def sendData():
    print(&quot;&lt;&lt;&quot;,end=&quot;&quot;)
    while True:
        sendInfo =  input(&quot;&quot;)
        udpSocket.sendto(sendInfo.encode(&#39;gb2312&#39;),(destIp,destPort))

udpSocket = None
destIp = &quot;&quot;
destPort = 0 

def main():
    global udpSocket
    global destIp
    global destPort

    destIp = input(&quot;Destination ip:&quot;)
    destPort = int(input(&quot;Destination port:&quot;))

    udpSocket = socket(AF_INET,SOCK_DGRAM)
    udpSocket.bind((&quot;&quot;,4567))

    tr = Thread(target=recvData)
    ts = Thread(target=sendData)
    
    tr.start()
    ts.start()

    tr.join()
    ts.join()

if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<h2 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h2><p><img src="/2020/10/17/udp-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E6%8B%9FQQ/udp.jpg" alt="udp"></p>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>UDP</tag>
        <tag>SOCKET</tag>
      </tags>
  </entry>
  <entry>
    <title>电脑使用小技巧 | windows关闭弹框广告</title>
    <url>/2021/01/28/windows%E5%85%B3%E9%97%AD%E5%BC%B9%E6%A1%86%E5%B9%BF%E5%91%8A/</url>
    <content><![CDATA[<h1 id="如何关闭烦人的桌面广告弹框"><a href="#如何关闭烦人的桌面广告弹框" class="headerlink" title="如何关闭烦人的桌面广告弹框"></a>如何关闭烦人的桌面广告弹框</h1><p>1.打开“控制面板”<br><img src="/2021/01/28/windows%E5%85%B3%E9%97%AD%E5%BC%B9%E6%A1%86%E5%B9%BF%E5%91%8A/1.png"><br>2.进入“网络和Internet”<br><img src="/2021/01/28/windows%E5%85%B3%E9%97%AD%E5%BC%B9%E6%A1%86%E5%B9%BF%E5%91%8A/2.png"><br>3.进入“Internet选项”<br><img src="/2021/01/28/windows%E5%85%B3%E9%97%AD%E5%BC%B9%E6%A1%86%E5%B9%BF%E5%91%8A/3.png"><br>4.选择“隐私”选项卡，勾选“启用弹出窗口阻止程序”，然后点“设置”<br><img src="/2021/01/28/windows%E5%85%B3%E9%97%AD%E5%BC%B9%E6%A1%86%E5%B9%BF%E5%91%8A/4.png"><br>5.阻止级别选“高”，点击“关闭”<br><img src="/2021/01/28/windows%E5%85%B3%E9%97%AD%E5%BC%B9%E6%A1%86%E5%B9%BF%E5%91%8A/5.png"><br>6.重启电脑</p>
]]></content>
      <categories>
        <category>电脑使用小技巧</category>
      </categories>
  </entry>
  <entry>
    <title>wxPython | wxPython控件</title>
    <url>/2021/08/03/wxPython%E6%8E%A7%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="wxPython控件"><a href="#wxPython控件" class="headerlink" title="wxPython控件"></a>wxPython控件</h1><p>1.实现三个文本输入空间和三个静态文本<br>1.1界面效果<br><img src="/2021/08/03/wxPython%E6%8E%A7%E4%BB%B6/1.png"><br>1.2示例代码</p>
<pre><code>class MyFrame(wx.Frame):
    def __init__(self):
        super().__init__(None, title=&quot;文本输入控件&quot;, size=(300, 260))
        panel = wx.Panel(parent=self)
        tc1 = wx.TextCtrl(panel)
        tc2 = wx.TextCtrl(panel, style=wx.TE_PASSWORD)
        tc3 = wx.TextCtrl(panel, style=wx.TE_MULTILINE)

        userid = wx.StaticText(panel, label=&quot;用户ID：&quot;)
        pwd = wx.StaticText(panel, label=&quot;密码：&quot;)
        content = wx.StaticText(panel, label=&quot;多行文本：&quot;)

        # 创建垂直方向的盒子布局管理器对象
        vbox = wx.BoxSizer(wx.VERTICAL)

        # 添加控件到vbox布局管理器
        vbox.Add(userid, flag=wx.EXPAND | wx.LEFT, border=10)
        vbox.Add(tc1, flag=wx.EXPAND | wx.ALL, border=10)
        vbox.Add(pwd, flag=wx.EXPAND | wx.LEFT, border=10)
        vbox.Add(tc2, flag=wx.EXPAND | wx.ALL, border=10)
        vbox.Add(content, flag=wx.EXPAND | wx.LEFT, border=10)
        vbox.Add(tc3, flag=wx.EXPAND | wx.ALL, border=10)

        # 设置面板采用vbox布局管理器
        panel.SetSizer(vbox)

        # 设置tc1初始值
        tc1.SetValue(&#39;tony&#39;)
        # 获取tc1值
        print(&#39;读取用户ID：&#123;0&#125;&#39;.format(tc1.GetValue()))

        tc2.SetValue(&#39;123&#39;)

        tc3.SetValue(&#39;这是一个多行文本！这是一个多行文本！这是一个多行文本！这是一个多行文本！这是一个多行文本！这是一个多行文本！&#39;)


app = wx.App()
frm = MyFrame()
frm.Show()
app.MainLoop()
</code></pre>
<span id="more"></span>

<p>2.实现一组复选框和一组单选按钮<br>2.1界面效果<br><img src="/2021/08/03/wxPython%E6%8E%A7%E4%BB%B6/2.png"><br>2.2示例代码</p>
<pre><code>class MyFrame(wx.Frame):
    def __init__(self):
        super().__init__(None, title=&quot;复选框和单选按钮&quot;, size=(330, 120))
        panel = wx.Panel(parent=self)

        st1 = wx.StaticText(panel, label=&quot;选择你喜欢的编程语言：&quot;)
        cb1 = wx.CheckBox(panel, id=1, label=&#39;Python&#39;)
        cb2 = wx.CheckBox(panel, id=2, label=&#39;Java&#39;)
        cb2.SetValue(True)
        cb3 = wx.CheckBox(panel, id=3, label=&#39;C++&#39;)
        self.Bind(wx.EVT_CHECKBOX, self.on_checkbox_click, id=1, id2=3)

        st2 = wx.StaticText(panel, label=&quot;选择性别：&quot;)
        radio1 = wx.RadioButton(panel, id=4, label=&#39;男&#39;, style=wx.RB_GROUP)
        radio2 = wx.RadioButton(panel, id=5, label=&#39;女&#39;)
        self.Bind(wx.EVT_RADIOBUTTON, self.on_radio1_click, id=4, id2=5)

        st3 = wx.StaticText(panel, label=&quot;是否婚配：&quot;)
        radio3 = wx.RadioButton(panel, id=6, label=&#39;Yes&#39;, style=wx.RB_GROUP)
        radio4 = wx.RadioButton(panel, id=7, label=&#39;No&#39;)
        self.Bind(wx.EVT_RADIOBUTTON, self.on_radio2_click, id=6, id2=7)

        hbox1 = wx.BoxSizer(wx.HORIZONTAL)
        hbox1.Add(st1, flag=wx.LEFT | wx.RIGHT, border=5)
        hbox1.Add(cb1)
        hbox1.Add(cb2)
        hbox1.Add(cb3)

        hbox2 = wx.BoxSizer(wx.HORIZONTAL)
        hbox2.Add(st2, flag=wx.LEFT | wx.RIGHT, border=5)
        hbox2.Add(radio1)
        hbox2.Add(radio2)

        hbox3 = wx.BoxSizer(wx.HORIZONTAL)
        hbox3.Add(st3, flag=wx.LEFT | wx.RIGHT, border=5)
        hbox3.Add(radio3)
        hbox3.Add(radio4)

        vbox = wx.BoxSizer(wx.VERTICAL)
        vbox.Add(hbox1, flag=wx.ALL, border=10)
        vbox.Add(hbox2, flag=wx.ALL, border=10)
        vbox.Add(hbox3, flag=wx.ALL, border=10)

        panel.SetSizer(vbox)

    def on_checkbox_click(self, event):
        cb = event.GetEventObject()
        print(&#39;选择&#123;0&#125;,状态&#123;1&#125;&#39;.format(cb.GetLabel(), event.IsChecked()))

    def on_radio1_click(self, event):
        rb = event.GetEventObject()
        print(&#39;第一组&#123;0&#125;被选中&#39;.format(rb.GetLabel()))

    def on_radio2_click(self, event):
        rb = event.GetEventObject()
        print(&#39;第二组&#123;0&#125;被选中&#39;.format(rb.GetLabel()))


app = wx.App()
frm = MyFrame()
frm.Show()
app.MainLoop()  
</code></pre>
<p>3.单选列表和多选列表<br>3.1界面效果<br><img src="/2021/08/03/wxPython%E6%8E%A7%E4%BB%B6/3.png"><br>3.2示例代码</p>
<pre><code>class MyFrame(wx.Frame):
    def __init__(self):
        super().__init__(None, title=&quot;列表&quot;, size=(350, 175))
        panel = wx.Panel(parent=self)

        st1 = wx.StaticText(parent=panel, label=&quot;选择你喜欢的编程语言：&quot;)
        list1 = [&#39;Python&#39;, &#39;C++&#39;, &#39;Java&#39;]
        # 创建列表控件，参数choices用于设置列表选项；参数style用于设置列表风格样式，wx.LB_SINGLE指单选列表控件
        lb1 = wx.ListBox(parent=panel, choices=list1, style=wx.LB_SINGLE)
        self.Bind(wx.EVT_LISTBOX, self.on_listbox1, lb1)

        st2 = wx.StaticText(parent=panel, label=&quot;选择你喜欢吃的水果：&quot;)
        list2 = [&#39;苹果&#39;, &#39;橘子&#39;, &#39;香蕉&#39;]
        lb2 = wx.ListBox(parent=panel, choices=list2, style=wx.LB_EXTENDED)  # style=wx.LB_EXTENDED表示创建多选列表控件
        self.Bind(wx.EVT_LISTBOX, self.on_listbox2, lb2)

        hbox1 = wx.BoxSizer(wx.HORIZONTAL)
        hbox1.Add(st1, proportion=1, flag=wx.LEFT | wx.RIGHT, border=5)
        hbox1.Add(lb1, proportion=1)

        hbox2 = wx.BoxSizer(wx.HORIZONTAL)
        hbox2.Add(st2, proportion=1, flag=wx.LEFT | wx.RIGHT, border=5)
        hbox2.Add(lb2, proportion=1)

        vbox = wx.BoxSizer(wx.VERTICAL)
        vbox.Add(hbox1, flag=wx.ALL | wx.EXPAND, border=5)
        vbox.Add(hbox2, flag=wx.ALL | wx.EXPAND, border=5)

        panel.SetSizer(vbox)

    def on_listbox1(self, event):
        listbox = event.GetEventObject()
        print(&#39;选择 &#123;0&#125;&#39;.format(listbox.GetSelection()))

    def on_listbox2(self, event):
        listbox = event.GetEventObject()
        print(&#39;选择 &#123;0&#125;&#39;.format(listbox.GetSelections()))


app = wx.App()
frm = MyFrame()
frm.Show()
app.MainLoop()
</code></pre>
<p>4.静态图片控件<br>4.1界面效果<br><img src="/2021/08/03/wxPython%E6%8E%A7%E4%BB%B6/4.png"><br>4.2示例代码</p>
<pre><code>class MyFrame(wx.Frame):
    def __init__(self):
        super().__init__(None, title=&#39;静态图片控件&#39;, size=(300, 300))
        self.panel = wx.Panel(parent=self)

        # 创建wx.Bitmap图片对象的列表
        self.bmps = [wx.Bitmap(&#39;images/1.jpg&#39;, wx.BITMAP_TYPE_JPEG),
                     wx.Bitmap(&#39;images/2.jpg&#39;, wx.BITMAP_TYPE_JPEG),
                     wx.Bitmap(&#39;images/3.jpg&#39;, wx.BITMAP_TYPE_JPEG)]

        b1 = wx.Button(self.panel, id=1, label=&#39;Button1&#39;)
        b2 = wx.Button(self.panel, id=2, label=&#39;Button2&#39;)
        self.Bind(wx.EVT_BUTTON, self.on_click, id=1, id2=2)

        self.image = wx.StaticBitmap(self.panel, bitmap=self.bmps[0])

        # 创建垂直方向的布局管理器对象vbox
        vbox = wx.BoxSizer(wx.VERTICAL)
        # 添加控件到布局管理器对象vbox
        vbox.Add(b1, proportion=1, flag=wx.EXPAND)
        vbox.Add(b2, proportion=1, flag=wx.EXPAND)
        vbox.Add(self.image, proportion=3, flag=wx.EXPAND)

        self.panel.SetSizer(vbox)

    def on_click(self, event):
        event_id = event.GetId()
        if event_id == 1:
            self.image.SetBitmap(self.bmps[1])
        else:
            self.image.SetBitmap(self.bmps[2])

        self.panel.Layout()  # 重新设置panel面板布局


app = wx.App()
frm = MyFrame()
frm.Show()
app.MainLoop()
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>wxPython</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>wxPython</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 下一个更大元素</title>
    <url>/2021/08/27/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="496-下一个更大元素"><a href="#496-下一个更大元素" class="headerlink" title="496.下一个更大元素"></a>496.下一个更大元素</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。<br>请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。<br>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/next-greater-element-i/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.暴力解法<br>对于每一个 nums1[i] 中的元素，先在 nums2 中找到它，然后向右遍历找到第 1 个大于 nums1[i] 的元素。<br>2.单调栈<br>步骤：<br>1）使用单调栈先对 nums2 中的每一个元素，求出它的右边第一个更大的元素；<br>2）将上一步的对应关系放入哈希表（HashMap）中；<br>3）再遍历数组 nums1，根据哈希表找出答案。<br>维护单调栈：<br>我们维护的栈恰好保证了单调性：栈中的元素从栈顶到栈底是单调不降的。<br>当我们遇到一个新的元素 nums2[i] 时，我们判断栈顶元素是否小于 nums2[i]，<br>如果是，那么栈顶元素的下一个更大元素即为 nums2[i]，我们将栈顶元素出栈。<br>重复这一操作，直到栈为空或者栈顶元素大于 nums2[i]。此时我们将 nums2[i] 入栈，<br>保持栈的单调性，并对接下来的 nums2[i + 1], nums2[i + 2] … 执行同样的操作。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):
    def nextGreaterElement(self, nums1, nums2):
        &quot;&quot;&quot;
        暴力解法
        对于每一个 nums1[i] 中的元素，先在 nums2 中找到它，然后向右遍历找到第 1 个大于 nums1[i] 的元素。

        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: List[int]
        &quot;&quot;&quot;
        # 使用内置方法list.index()/list.append()
        # next_greater_index = []  # 存储下一个更大元素下标的列表
        #
        # if len(nums1) &lt; 1:
        #     return next_greater_index
        #
        # for num in nums1:  # 遍历nums1中的每一个元素
        #     index = nums2.index(num)  # 定位nums1中的元素在nums2中的下标
        #     for i in range(index+1, len(nums2)):  # 遍历nums1中元素在nums2中所在位置之后的元素
        #         if nums2[i] &gt; num:  # 如果找到比nums1中元素更大的元素，则将下标加入下标列表
        #             next_greater_index.append(nums2[i])
        #             break
        #     else:
        #         next_greater_index.append(-1)
        #
        # return next_greater_index

        # 不使用内置方法list.index()/list.append()
        len1 = len(nums1)
        len2 = len(nums2)

        res = list()

        if len1 &lt; 1:
            return res

        for i in range(len1):
            cur_val = nums1[i]
            j = 0
            while j &lt; len2 and nums2[j] != cur_val:
                j += 1

            # nums2[j] = nums1[i]
            j += 1
            while j &lt; len2 and nums2[j] &lt; cur_val:
                j += 1

            if j == len2:
                res[i] = -1
                continue

            res[i] = nums2[j]
        return res

    def nextGreaterElement1(self, nums1, nums2):
        &quot;&quot;&quot;
        栈（单调栈）

        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: List[int]
        &quot;&quot;&quot;
        stack = list()
        map = &#123;&#125;
        # 对nums2中的每一个元素，求出它的右边第一个更大的元素；
        # 将对应关系放入哈希表（HashMap）中
        for i in range(len(nums2)):
            while len(stack) != 0 and stack[-1] &lt; nums2[i]:
                map[stack.pop()] = nums2[i]

            stack.append(nums2[i])

        # 遍历数组nums1，根据哈希表找出答案
        res = list()
        for j in range(len(nums1)):
            res.append(map.get(nums1[j], -1))

        return res


if __name__ == &quot;__main__&quot;:
    slt = Solution()

    res_list = slt.nextGreaterElement1([4, 1, 2], [1, 3, 4, 2])

    print(res_list)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>urllib.request | 下载图片</title>
    <url>/2021/08/05/%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h1 id="使用urllib-request库从互联网上下载图片"><a href="#使用urllib-request库从互联网上下载图片" class="headerlink" title="使用urllib.request库从互联网上下载图片"></a>使用urllib.request库从互联网上下载图片</h1><pre><code># coding=utf-8

import urllib.request as request

url = &#39;http://localhost:8080/NoteWebService/logo.png&#39;

with request.urlopen(url) as response:
    data = response.read()
    f_name = &#39;download.png&#39;
    with open(f_name, &#39;wb&#39;) as f:
        f.write(data)
        print(&#39;下载文件成功&#39;)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>内置模块</category>
        <category>urllib</category>
      </categories>
      <tags>
        <tag>urllib</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 两数之和</title>
    <url>/2021/08/27/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="1-两数相加"><a href="#1-两数相加" class="headerlink" title="1.两数相加"></a>1.两数相加</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。<br>你可以按任意顺序返回答案。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/two-sum/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.暴力枚举法<br>枚举数组中的每一个数x，寻找数组中是否存在target-x<br>2.哈希表<br>改进了方法1中寻找数组中是否存在target-x的过程</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):
    def twoSum(self, nums, target):  # O(N^2)
        &quot;&quot;&quot;
        暴力枚举法

        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        &quot;&quot;&quot;
        for i in range(len(nums)):
            for j in range(i+1, len(nums)):
                if nums[i] + nums[j] == target:
                    return [i, j]

    def twoSum1(self, nums, target):  # O(N)
        hashtable = dict()
        for i, num in enumerate(nums):
            if target - num in hashtable:
                return [hashtable[target - num], i]
            hashtable[nums[i]] = i
        return []


if __name__ == &quot;__main__&quot;:
    slt = Solution()
    t = slt.twoSum([2, 7, 11, 15], 9)
    print(t)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 两数相加</title>
    <url>/2021/08/27/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。<br>请你将两个数相加，并以相同形式返回一个表示和的链表。<br>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/add-two-numbers/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对应位置元素带进位相加</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># Definition for singly-linked list.
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):
    def addTwoNumbers(self, l1, l2):
        &quot;&quot;&quot;
        对应位置元素带进位相加
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        extra = 0
        root = n = ListNode(0)
        while l1 or l2 or extra:
            v1 = v2 = 0
            if l1:
                v1 = l1.val
                l1 = l1.next
            if l2:
                v2 = l2.val
                l2 = l2.next
            extra, val = divmod(v1 + v2 + extra, 10)
            n.next = ListNode(val)
            n = n.next
        return root.next

    def create_linked_list(self, num):
        link_list = ListNode(num % 10)
        r = link_list
        while num &gt;= 10:
            num = num // 10
            node = ListNode(num % 10)
            r.next = node
            r = r.next
        r.next = None
        return link_list

    def len_list(self, link_list):
        count = 0
        p = link_list
        while p is not None:
            count += 1
            p = p.next

        return count

class Solution1:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:
        &quot;&quot;&quot;
        将两个链表分别转化为一个整数,然后将两个整数相加,将结果的逆序构建成一个单链表
  
        t = 1
        res1 = 0

        while l1 is not None:
            res1 += l1.val * t
            t *= 10
            l1 = l1.next

        t = 1
        res2 = 0
        while l2 is not None:
            res2 += l2.val * t
            t *= 10
            l2 = l2.next

        res = res1 + res2
        print(res)

        res_list = ListNode(res % 10)
        r = res_list
        while res &gt;= 10:
            res //= 10
            node = ListNode(res % 10)
            r.next = node
            r = node
        r.next = None

        return res_list

if __name__ == &#39;__main__&#39;:
    slt = Solution()
    l1 = slt.create_linked_list(342)
    l2 = slt.create_linked_list(465)
    res = slt.addTwoNumbers1(l1, l2)

    while res is not None:
        print(res.val)
        res = res.next

    print(slt.len_list(l1))
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 为什么需要非线性激活函数</title>
    <url>/2021/06/23/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="为什么需要非线性激活函数"><a href="#为什么需要非线性激活函数" class="headerlink" title="为什么需要非线性激活函数?"></a>为什么需要非线性激活函数?</h1><p>为什么神经网络需要非线性激活函数？如果使用线性激活函数(恒等激励函数)，那么神经网络只是把输入线性组合<br>再输出。对于深度神经网络来说，如果使用了线性激活函数或者没有使用激活函数，那么无论你的神经网络有多少<br>层，它做的只是计算线性函数，这样的做法与直接去掉全部隐藏层无异。因此，必须通过非线性激活函数来引入非线性。</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>激活函数</tag>
      </tags>
  </entry>
  <entry>
    <title>伪迹移除 | 主成分分析</title>
    <url>/2021/02/23/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h1><p><b style="color: red">PCA is a type of spatial filter that transforms the time domain datasets into a different space by rotating axes in an N-dimensional space(where n is the number of variables or EEG channels) such that each dimension in the new space has minimum variance and the axes are orthogonal to each other.</b></p>
<p>PCA reduces data dimension and highlights specific features of data,which is usually difficult to identify in the spatially unfiltered data as the new components are created by weighted combinations of all EEG channels.</p>
<h2 id="One-important-limitation-of-PCA-or-SVD"><a href="#One-important-limitation-of-PCA-or-SVD" class="headerlink" title="One important limitation of PCA (or SVD)"></a>One important limitation of PCA (or SVD)</h2><p>it fails to separate/identify ocular or similar artifacts from<br>EEG when amplitudes are comparable since PCA depends on<br>the higher order statistical property</p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>伪迹移除</category>
      </categories>
      <tags>
        <tag>伪迹移除</tag>
        <tag>ICA</tag>
        <tag>EEG</tag>
        <tag>PCA</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 二进制求和</title>
    <url>/2021/08/29/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/</url>
    <content><![CDATA[<h1 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67.二进制求和"></a>67.二进制求和</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两个二进制字符串，返回它们的和（用二进制表示）。<br>输入为 非空 字符串且只包含数字 1 和 0。</p>
<span id="more"></span>
<p>示例 1:<br>输入: a = “11”, b = “1”<br>输出: “100”</p>
<p><a href="https://leetcode-cn.com/problems/add-binary/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.先将 a 和 b 转化成十进制数，求和后再转化为二进制数<br>2.列竖式<br>末尾对齐，逐位相加，逢二进一<br>具体的，我们可以取 n=max{∣a∣,∣b∣}，循环 n 次，从最低位开始遍历。我们使用一个变量 carry 表示上一个位置的进位，初始值为 0。记当前位置对其的两个位为 ai​ 和 bi​，则每一位的答案为 (carry+ai+bi) mod 2，下一位的进位为 ⌊(carry+ai+bi)/2⌋。重复上述步骤，直到数字 a 和 b 的每一位计算完毕。最后如果 carry 的最高位不为 0，则将最高位添加到计算结果的末尾。<br>注意，为了让各个位置对齐，你可以先反转这个代表二进制数字的字符串，然后低下标对应低位，高下标对应高位。当然你也可以直接把 a 和 b 中短的那一个补 0 直到和长的那个一样长，然后从高位向低位遍历，对应位置的答案按照顺序存入答案字符串内，最终将答案串反转。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def addBinary(self, a: str, b: str) -&gt; str:
        &quot;&quot;&quot;
        先将 aaa 和 bbb 转化成十进制数，求和后再转化为二进制数
        :param a:
        :param b:
        :return:
        &quot;&quot;&quot;
        # a = int(a, 2)  # 将二进制数转为十进制
        # b = int(b, 2)
        # print(a)
        # print(b)
        # return bin(a+b)[2:]

        return &#39;&#123;0:b&#125;&#39;.format(int(a, 2) + int(b, 2))

    def addBinary1(self, a: str, b: str) -&gt; str:
        ans = list()
        n = max(len(a), len(b))
        carry = 0

        list_a = []
        list_b = []
        for e in a:
            list_a.append(int(e))

        for e in b:
            list_b.append(int(e))

        print(list_a)
        print(list_b)

        for i in range(n):
            carry += list_a[len(a) - i - 1] if i &lt; len(a) else 0
            carry += list_b[len(b) - i - 1] if i &lt; len(b) else 0
            ans.append(str(int(carry % 2)))
            carry /= 2

        if carry &gt; 0:
            ans.append(&#39;1&#39;)

        return &#39;&#39;.join(ans[::-1])


if __name__ == &#39;__main__&#39;:
    s = Solution()
    a = &quot;11&quot;
    b = &quot;1&quot;
    res = s.addBinary1(a, b)
    print(res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程 | 从浏览器访问百度的整个访问过程</title>
    <url>/2020/10/26/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BF%E9%97%AE%E7%99%BE%E5%BA%A6%E7%9A%84%E6%95%B4%E4%B8%AA%E8%AE%BF%E9%97%AE%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="从浏览器访问百度的整个访问过程"><a href="#从浏览器访问百度的整个访问过程" class="headerlink" title="从浏览器访问百度的整个访问过程"></a>从浏览器访问百度的整个访问过程</h1><h2 id="实际场景"><a href="#实际场景" class="headerlink" title="实际场景"></a>实际场景</h2><p>在浏览器的地址输入栏，输入<a href="http://www.baidu.com访问百度./">www.baidu.com访问百度。</a></p>
<h2 id="访问过程"><a href="#访问过程" class="headerlink" title="访问过程"></a>访问过程</h2><ol>
<li>1.先要解析出baidu.com对应的ip地址</li>
<ol>
<li>1.先要知道默认网关的MAC地址</li>
<ol>
<li>1.使用ARP获取默认网关的MAC地址</li>
</ol>
<li>2.组织数据发送给默认网关（IP还是DNS服务器的IP，但MAC地址是默认网关的MAC地址）</li>
<li>3.默认网关拥有转发数据的能力，把数据转发给路由器</li>
<li>4.路由器根据自己的路由协议来选择一个合适的较快的路径转发数据给目的网关</li>
<li>5.目的网关（DNS服务器所在的网关），把数据转发给DNS服务器</li>
<li>6.DNS服务器查询解析出baidu.com对应的IP地址，并把它原路返回给请求这个域名的客户端</li>
</ol>
<li>2.得到了baidu.com对应的IP地址后会发送TCP的3次握手，进行连接</li>
<li>3.使用HTTP协议发送请求数据给WEB服务器</li>
<li>4.WEB服务器收到请求数据之后，通过查询自己的服务器得到响应的结果，原路返回个浏览器</li>
<li>5.浏览器接收到数据后，通过浏览器自己的渲染功能来显示这个网页</li>
<li>6.浏览器关闭TCP连接，即4次挥手</li>
</ol>


]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>伪迹移除 | 伪迹去除方法比较总结</title>
    <url>/2021/02/25/%E4%BC%AA%E8%BF%B9%E5%8E%BB%E9%99%A4%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="伪迹去除方法比较总结"><a href="#伪迹去除方法比较总结" class="headerlink" title="伪迹去除方法比较总结"></a>伪迹去除方法比较总结</h1><p>1.(定性比较 or 定量比较)很难对不同伪迹去除方法基于它们去除伪迹的能力进行一个比较，通常只能做一个<b>定性(qualitative)</b>的比较<br>2.(自动 or 半自动)很多基于EEG的应用需要<b>自动信息处理</b>，尤其是一些对<b>在线/实时(需要效率很高的算法和足够低的计算复杂度)</b>有要求的应用。基于<b>BSS(盲源分离)</b>的方法通常是<b>半自动</b>的,因为伪迹成分的识别需要一些训练或参数选择/调整。涉及ICA的伪迹检测/去除方法需要另一个方法才能实现全过程的自动<br>3.(单通道 or 多通道)基于<b>盲源分离</b>的方法需要<b>多通道</b>才能起作用，通道数量越多，越能很好的分离出单个的源(这种方法不能用于低通道 e.g. 4-6或者基于单通道的应用)。基于<b>小波变换和经验模态分解</b>的方法可以通过将单个数据序列分解为多个成分进行<b>单通道</b>分析。<br>4.(参考信号)大多数方法需要参考信号。</p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>伪迹移除</category>
      </categories>
      <tags>
        <tag>伪迹移除</tag>
        <tag>EEG</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程 | 使用tftp从服务器下载文件到客户端</title>
    <url>/2020/10/18/%E4%BD%BF%E7%94%A8tftp%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E5%88%B0%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
    <content><![CDATA[<h1 id="使用tftp协议从服务器下载文件到客户端"><a href="#使用tftp协议从服务器下载文件到客户端" class="headerlink" title="使用tftp协议从服务器下载文件到客户端"></a>使用tftp协议从服务器下载文件到客户端</h1><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code>import struct
from socket import *
import time
import os

def main():


    #0. 获取要下载的文件名字:
    downloadFileName = raw_input(&quot;请输入要下载的文件名:&quot;)    

    #1.创建socket
    udpSocket = socket(AF_INET, SOCK_DGRAM)

    requestFileData = struct.pack(&quot;!H%dsb5sb&quot;%len(downloadFileName), 1, downloadFileName, 0, &quot;octet&quot;, 0)

    #2. 发送下载文件的请求
    udpSocket.sendto(requestFileData, (&quot;192.168.119.215&quot;, 69))

    flag = True #表示能够下载数据，即不擅长，如果是false那么就删除
    num = 0
    f = open(downloadFileName, &quot;w&quot;)

    while True:
        #3. 接收服务发送回来的应答数据
        responseData = udpSocket.recvfrom(1024)

        # print(responseData)
        recvData, serverInfo = responseData

        opNum = struct.unpack(&quot;!H&quot;, recvData[:2])

        packetNum = struct.unpack(&quot;!H&quot;, recvData[2:4])

        print(packetNum[0])

        # print(&quot;opNum=%d&quot;%opNum)
        # print(opNum)

        # if 如果服务器发送过来的是文件的内容的话:
        if opNum[0] == 3: #因为opNum此时是一个元组(3,)，所以需要使用下标来提取某个数据
            

            #计算出这次应该接收到的文件的序号值，应该是上一次接收到的值的基础上+1
            num = num + 1

            # 如果一个下载的文件特别大，即接收到的数据包编号超过了2个字节的大小
            # 那么会从0继续开始，所以这里需要判断，如果超过了65535 那么就改为0
            if num==65536:
                num = 0

            # 判断这次接收到的数据的包编号是否是 上一次的包编号的下一个
            # 如果是才会写入到文件中，否则不能写入（因为会重复）
            if num == packetNum[0]:
                # 把收到的数据写入到文件中
                f.write(recvData[4:])
                num = packetNum[0]

            #整理ACK的数据包
            ackData = struct.pack(&quot;!HH&quot;, 4, packetNum[0])
            udpSocket.sendto(ackData, serverInfo)

        elif opNum[0] == 5:
            print(&quot;sorry，没有这个文件....&quot;)
            flag = False

        # time.sleep(0.1)

        if len(recvData)&lt;516:
            break

    if flag == True:
        f.close()
    else:
        os.unlink(downloadFileName)#如果没有要下载的文件，那么就需要把刚刚创建的文件进行删除

if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>tftp</tag>
      </tags>
  </entry>
  <entry>
    <title>免费看视频</title>
    <url>/2021/06/19/%E5%85%8D%E8%B4%B9%E7%9C%8B%E8%A7%86%E9%A2%91/</url>
    <content><![CDATA[<h1 id="免费看视频"><a href="#免费看视频" class="headerlink" title="免费看视频"></a>免费看视频</h1><p><b>在视频链接前加wn.run/</b></p>
]]></content>
      <tags>
        <tag>免费看视频</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 关于python or numpy在实现神经网络中的一些建议</title>
    <url>/2021/06/21/%E5%85%B3%E4%BA%8Epython-or-numpy%E5%9C%A8%E5%AE%9E%E7%8E%B0%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BB%BA%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="关于python-or-numpy在实现神经网络中的一些建议"><a href="#关于python-or-numpy在实现神经网络中的一些建议" class="headerlink" title="关于python or numpy在实现神经网络中的一些建议"></a>关于python or numpy在实现神经网络中的一些建议</h1><p>在编写神经网络时：<br>1.不要使用秩为1的一维数组<br>2.总是使用n x 1维矩阵(列向量-column vector)或者1 X n维矩阵(行向量-row vector)<br>3.敢于使用reshape()来确保你的矩阵或向量所需要的维数<br>4.在不完全确定一个向量的维维度时使用assert()语句<br>（Python assert（断言）用于判断一个表达式，在表达式条件为 false 的时候触发异常。<br>断言可以在条件不满足程序运行的情况下直接返回错误，而不必等待程序运行后出现崩溃的情况。）</p>
<p><b>demo:</b></p>
<pre><code>a = np.random.randn(5) # Don&#39;t use
# a.shape = (5,) # rank 1 array

a = np.random.randn(5,1) # a.shape=(5,1) column vector

a = np.random.randn(1,5) # a.shape=(1,5) row vector

assert(a.shape == (5,1))

a = a.reshape((5,1))
</code></pre>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习 | 决策树</title>
    <url>/2021/02/22/%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    <content><![CDATA[<h1 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h1><p>决策树(Decision Tree)是一种基本的<b>分类与回归方法</b>。决策树由结点(Node)和有向边(Directed Edge)组成。结点有两种类型：内部结点(Internnal Node)和叶结点(Leaf Node)。内部结点表示一个特征或属性，叶结点表示一个类。决策树还有一个唯一的根结点(Root Node)。</p>
<p>我们可以把<b>决策树</b>看成一个<b>if-then规则的集合</b>,将决策树转换成if-then规则的过程是这样的：<br><br>由决策树的根结点到叶结点的每一条路径构建一条规则；路径上内部结点的特征对应着规则的条件，而叶结点对应着规则的结论。<br><br>决策树的路径或其对应的if-then规则集合具有一个重要性质：<b>互斥并且完备</b>(每一个实例都只能被一条路径或一条规则所覆盖(覆盖：实例的特征与路径上的特征一致或实例满足规则的条件))。<br></p>
<h2 id="决策树做预测的步骤"><a href="#决策树做预测的步骤" class="headerlink" title="决策树做预测的步骤"></a>决策树做预测的步骤</h2><p>1.收集数据<br>2.准备数据(将收集的数据按照一定规则整理出来,方便后续进行处理)<br>3.分析数据(在决策树构造完成后，检查决策树图形是否符合预期)<br>4.训练算法(构造决策树/决策树学习—&gt;构造一个决策树的数据结构)<br>5.测试算法(使用经验树计算错误率。当错误率达到可接受范围，这个决策树就可以投放使用)<br>6.使用算法(<b>决策树可以更好地理解数据的内在含义</b>)</p>
<h2 id="如何构建决策树？—构建决策树的3个步骤"><a href="#如何构建决策树？—构建决策树的3个步骤" class="headerlink" title="如何构建决策树？—构建决策树的3个步骤"></a>如何构建决策树？—构建决策树的3个步骤</h2><h3 id="1-特征选择"><a href="#1-特征选择" class="headerlink" title="1.特征选择"></a>1.特征选择</h3><p><b>特征选择就是决定用哪个特征来划分特征空间</b><br><b>特征选择在于选取训练数据具有分类能力的特征</b><br>特征选择的标准：信息增益(Information Gain)/信息增益比。信息增益：在划分数据集之后信息发生的变化。<br><b style="color:red">Note:信息增益最高的特征是最好的选择</b></p>
<h4 id="1-1香农熵-熵-信息论之父克劳德-香农：集合信息的度量方式。"><a href="#1-1香农熵-熵-信息论之父克劳德-香农：集合信息的度量方式。" class="headerlink" title="1.1香农熵(熵)-信息论之父克劳德.香农：集合信息的度量方式。"></a>1.1香农熵(熵)-信息论之父克劳德.香农：集合信息的度量方式。</h4><p>熵定义为信息的期望值。在信息论与概率论中，熵是表示随机变脸不确定性的度量。如果待分类的事物可能划分在多个分类之中，则符号xi的信息定义为：<br><br><img src="/2021/02/22/%E5%86%B3%E7%AD%96%E6%A0%91/1.png"><br>其中p(xi)是该分类的概率。<br><br>通过上式，我们可以得到所有类别的信息。为了计算<b>熵，我们需要计算所有类别所有可能值包含的信息期望值</b>(<b>数学期望-反应随机变量平均取值的大小<b>)，公式如下：<br><br><img src="/2021/02/22/%E5%86%B3%E7%AD%96%E6%A0%91/2.png"><br>其中n是分类的数目。<b>熵越大，随机变量的不确定性就越大。</b></b></b></p>
<p>当熵中的概率由数据估计(特别是最大似然估计-Maximum Likelihood Estimation)得到时，所对应的熵称为<b>经验熵</b>(Empirical Entropy)</p>
<p>我们定义样本数据表中的数据为训练数据集D，则训练数据集D的经验熵为H(D)，|D|表示其样本容量，及样本个数。设有K个类Ck, = 1,2,3,…,K,|Ck|为属于类Ck的样本个数，因此经验熵公式就可以写为 ：<br><img src="/2021/02/22/%E5%86%B3%E7%AD%96%E6%A0%91/3.png"></p>
<h4 id="1-2信息增益"><a href="#1-2信息增益" class="headerlink" title="1.2信息增益"></a>1.2信息增益</h4><p>如何选择特征，需要看信息增益。也就是说，信息增益是相对特征而言的，信息增益越大，特征对最终的分类结果影响也就越大，我们就应该选择对最终分类结果影响最大的那个特征作为我们的分类特征。</p>
<p><b>条件熵H(Y|X)</b>表示在一直随机变量X的条件下随机变量Y的不确定性，随机变量X给定条件下随机变量Y的条件熵(Conditional Entropy)H(Y|X)，定义为X给定条件下Y的条件概率分布的熵对X的数学期望：<br><img src="/2021/02/22/%E5%86%B3%E7%AD%96%E6%A0%91/4.jpg"><br><img src="/2021/02/22/%E5%86%B3%E7%AD%96%E6%A0%91/5.jpg"><br>当条件熵中的概率由数据估计(特别是极大似然估计)得到时，岁对应的条件熵称为<b>条件经验熵</b>(empirical conditional entropy)。</p>
<p>特征A对训练数据集D的信息增益g(D,A)，定义为集合D的经验熵H(D)与特征A给定条件下D的经验条件熵H(D|A)之差，即：<br><img src="/2021/02/22/%E5%86%B3%E7%AD%96%E6%A0%91/6.jpg"><br><b>Note:</b>一般地，熵H(D)与条件熵H(D|A)之差称为互信息(mutual information)。决策树学习中的信息增益等价于训练数据集中类与特征的互信息。</p>
<p>设特征A有n个不同的取值{a1,a2,···,an}，根据特征A的取值将D划分为n个子集{D1,D2，···,Dn}，|Di|为Di的样本个数。记子集Di中属于Ck的样本的集合为Dik，即Dik = Di ∩ Ck，|Dik|为Dik的样本个数。于是经验条件熵的公式可以些为：<br><img src="/2021/02/22/%E5%86%B3%E7%AD%96%E6%A0%91/7.jpg"></p>
<h2>总结</h2>
<h3>决策树的一些优点</h3>
1.<b>易于理解和解释</b>。决策树可以<b>可视化</b>。<br>
2.<b>几乎不需要数据预处理</b>。其他方法经常需要数据标准化，创建虚拟变量和删除缺失值。决策树还不支持缺失值。<br>
3.使用树的<b>花费</b>(例如预测数据)是训练数据点(data points)数量的<b>对数</b>。<br>
4.可以<b>同时处理数值变量和分类变量</b>。其他方法大都适用于分析一种变量的集合。<br>
5.可以处理<b>多值输出</b>变量问题<br>
6.使用<b>白盒模型</b>.如果一个情况被观察到，使用逻辑判断容易表示这种规则。相反，如果是<b>黑盒模型</b>(例如<b>人工神经网络</b>)，结果会非常<b>难解释</b>。<br>
7.即使对真实模型来说，假设无效的情况下，也可以较好的使用<br>
<h3>决策树的一些缺点</h3>
1.决策树学习可能创建一个过于复杂的树，并不能很好的预测数据。也就是<b>过拟合</b>。修剪机制（现在不支持），<b>设置一个叶子节点需要的最小样本数量，或者数的最大深度，可以避免过拟合</b>。<br>
2.<b>决策树可能是不稳定的</b>，因为即使非常小的变异，可能会产生一颗完全不同的树。这个问题通过decision trees with an ensemble来缓解。<br>
3.<b>概念难以学习</b>，因为决策树没有很好的解释他们，例如，XOR, parity or multiplexer problems(奇偶校验或多路复用器问题)。<br>
4.<b>如果某些分类占优势，决策树将会创建一棵有偏差的树</b>。因此，建议在训练之前，先抽样使样本均衡。<br>

<p><a href="https://cuijiahua.com/blog/2017/11/ml_2_decision_tree_1.html">参考资源1</a><br><a href="https://cuijiahua.com/blog/2017/11/ml_3_decision_tree_2.html">参考资源2</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>Decision Tree</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>决策树</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程 | 几种web服务器的比较</title>
    <url>/2020/10/31/%E5%87%A0%E7%A7%8Dweb%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<h1 id="几种web服务器的比较"><a href="#几种web服务器的比较" class="headerlink" title="几种web服务器的比较"></a>几种web服务器的比较</h1><h2 id="select版服务器"><a href="#select版服务器" class="headerlink" title="select版服务器"></a>select版服务器</h2><p>优点：跨平台<br>缺点：<br>单个进程能够监视的文件描述符的数量存在最大限制（1024）<br>轮询检测，效率较低</p>
<h2 id="poll版服务器"><a href="#poll版服务器" class="headerlink" title="poll版服务器"></a>poll版服务器</h2><p>优点：解决了套接字有上限的问题<br>缺点：轮询检测</p>
<h2 id="epoll版服务器"><a href="#epoll版服务器" class="headerlink" title="epoll版服务器"></a>epoll版服务器</h2><p>优点：<br>没有1024的最大限制<br>事件通知机制，效率较高</p>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>python | 函数</title>
    <url>/2021/08/05/%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="python中的函数"><a href="#python中的函数" class="headerlink" title="python中的函数"></a>python中的函数</h1><p>python中的三种函数<br>1.函数：定义在模块中类之外的函数<br><strong>示例：</strong></p>
<pre><code>def add(a, b):
    res = a + b
    return res
</code></pre>
<p>2.嵌套函数：定义在函数中的函数<br><strong>示例：</strong></p>
<pre><code>def func1():
    def func2():
        pass
    ...
</code></pre>
<p>3.方法：定义在类中<br><strong>示例：</strong></p>
<pre><code>class A(object)：
    def _ _init_ _(self):   # 构造函数
        pass

    def a(self,...):   # 实例方法
        pass
    
    @classmethod
    def b(cls,...):  # 类方法
        pass
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 划分数据集前对数据的shuffle</title>
    <url>/2021/07/02/%E5%88%92%E5%88%86%E6%95%B0%E6%8D%AE%E9%9B%86%E5%89%8D%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%9A%84shuffle/</url>
    <content><![CDATA[<h1 id="划分数据集前对数据的shuffle"><a href="#划分数据集前对数据的shuffle" class="headerlink" title="划分数据集前对数据的shuffle"></a>划分数据集前对数据的shuffle</h1><p>划分数据集前对数据集和标签的shuffle很重要！！！划分数据集前对数据集和标签的shuffle很重要！！！划分数据集前对数据集和标签的shuffle很重要！！！<br>重要的事情说三遍！</p>
<p>shuffle对模型的accuracy有较大的影响，因此在将数据输入模型之前应该将数据集进行shuffle!</p>
<p><a href="https://blog.csdn.net/qq_38412868/article/details/85473973">Python如何打乱训练数据集顺序的几种方法</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Django | 创建模型对象的两种方式</title>
    <url>/2021/07/26/%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="创建模型对象的两种方式"><a href="#创建模型对象的两种方式" class="headerlink" title="创建模型对象的两种方式"></a>创建模型对象的两种方式</h1><p>使用关键字构造模型对象非常麻烦，一下介绍两种创建对象的方式。</p>
<span id="more"></span>

<p><strong>方式一：在模型类中增加一个类方法—不推荐使用</strong></p>
<pre><code>class ExampleModel(models.Model):
    ...
    @classmethod
    def create(cls, attr1, attr2, ...):
        e = ExampleModel()
        e.attr1 = attr1
        e.attr2 = attr2
        ...
        return e
</code></pre>
<p><strong>方式二：在自定义管理器中添加一个方法—推荐使用</strong></p>
<pre><code>class ExampleModelManager(models.Manager):
    def create(self, attr1, attr2, ...):
        e = ExampleModel()  # 使用在方式一中定义的模型类ExampleModel
        e.attr1 = attr1
        e.attr2 = attr2
        ...
        return e
        
</code></pre>
<p>**Note:**管理器是模型类的属性，用于将对象与数据表映射</p>
]]></content>
      <categories>
        <category>python</category>
        <category>框架</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 删除有序链表中的重复元素</title>
    <url>/2021/08/27/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="83-删除有序链表中的重复元素"><a href="#83-删除有序链表中的重复元素" class="headerlink" title="83.删除有序链表中的重复元素"></a>83.删除有序链表中的重复元素</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 只出现一次 。<br>返回同样按升序排列的结果链表。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>一次遍历法<br>由于链表是按照升序排序的链表，所有重复的元素是相邻的，我们只需遍历一次链表，并判断当前节点与当前节点的后一节点所对应元素是否相等，<br>如果相等则将后者删除，如果不相等，工作指针继续后移，…，以此类推，当遍历完整个链表之后，我们返回链表的头节点即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def deleteDuplicates(self, head):
        &quot;&quot;&quot;
        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        # prev = head
        # p = prev.next
        #
        # while p is not None:  #
        #     if prev.val == p.val:
        #         p = p.next
        #         prev.next = p
        #     else:
        #         prev = prev.next
        #         p = p.next
        #
        # return head


        if not head:
            return head

        cur = head
        while cur.next:
            if cur.val == cur.next.val:
                cur.next = cur.next.next
            else:
                cur = cur.next

        return head

    def create_linked_list(self, list):
        &quot;&quot;&quot;根据list中的所有元素构建单链表&quot;&quot;&quot;
        l = ListNode()  # 单链表头节点
        r = l  # 起始尾指针r指向头节点
        for e in list:
            node = ListNode(e)
            r.next = node
            r = r.next

        return l.next

    def print_linked_list(self, linked_list) -&gt; None:
        &quot;&quot;&quot;
        打印单链表中的所有元素

        :param linked_list: 单链表
        :return: 无
        &quot;&quot;&quot;
        print(&quot;----------------------------------------&quot;)
        pointer = linked_list
        while pointer is not None:
            print(pointer.val)
            pointer = pointer.next


if __name__ == &quot;__main__&quot;:
    slt = Solution()
    l1 = slt.create_linked_list([1, 1, 2, 3, 3])
    l = slt.deleteDuplicates(l1)
    slt.print_linked_list(l)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 删除链表中的节点</title>
    <url>/2021/08/27/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="237.删除链表中的节点"></a>237.删除链表中的节点</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>由于单链表不能直接访问当前节点的前一个节点，现要删除当前节点，我们可以将当前节点的下一个节点的值复制到当前节点，然后改变当前节点的next指针删除当前节点的下一个节点即可达到删除当前节点的效果。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def deleteNode(self, node):
        &quot;&quot;&quot;
        :type node: ListNode
        :rtype: void Do not return anything, modify node in-place instead.
        &quot;&quot;&quot;
        node.val = node.next.val
        node.next = node.next.next
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 删除链表元素</title>
    <url>/2021/08/27/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="203-删除链表元素"><a href="#203-删除链表元素" class="headerlink" title="203.删除链表元素"></a>203.删除链表元素</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.递归<br>链表的定义具有递归的性质，因此链表题目常可以用递归的方法求解。<br>对于给定的链表，首先对除了头节点 head 以外的节点进行删除操作，然后判断 head 的节点值是否等于给定的 val。如果 head 的节点值等于 val，则 head 需要被删除，因此删除操作后的头节点为 head.next；如果 head 的节点值不等于 val，则 head\ 保留，因此删除操作后的头节点还是 head。<br>递归的终止条件是 head 为空，此时直接返回 head。当 head 不为空时，递归地进行删除操作，然后判断 head 的节点值是否等于 val 并决定是否要删除 head。<br>2.迭代<br>用 temp 表示当前节点。如果 temp 的下一个节点不为空且下一个节点的节点值等于给定的 val，则需要删除下一个节点。删除下一个节点可以通过以下做法实现：<br>temp.next=temp.next.next<br>如果 temp 的下一个节点的节点值不等于给定的 val，则保留下一个节点，将 temp 移动到下一个节点即可。<br>当 temp 的下一个节点为空时，链表遍历结束，此时所有节点值等于 val 的节点都被删除。<br>具体实现方面，由于链表的头节点 head 有可能需要被删除，因此创建哑节点 dummyHead，令 dummyHead.next=head，初始化 temp=dummyHead，然后遍历链表进行删除操作。最终返回 dummyHead.next 即为删除操作后的头节点。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def removeElements(self, head, val):
        &quot;&quot;&quot;
        移除单链表head中所有值为val的节点（迭代法）

        时间复杂度：O(n)
        空间复杂度：O(1)

        :type head: ListNode
        :type val: int
        :rtype: ListNode
        &quot;&quot;&quot;
        # # 为单链表怎加一个头节点
        # head_node = ListNode()
        # head_node.next = head
        #
        # # 定义工作指针p和工作指针的前一个节点指针prev
        # prev = head_node  # prev指向头节点
        # p = prev.next  # p指向链表的第一个节点
        #
        # while p is not None:
        #     if p.val == val:
        #         prev.next = p.next
        #         p = p.next
        #     else:
        #         prev = p
        #         p = p.next
        #
        # return head_node.next

        dummyHead = ListNode()
        dummyHead.next = head
        temp = dummyHead

        while temp.next is not None:
            if temp.next.val == val:
                temp.next = temp.next.next
            else:
                temp = temp.next
        return dummyHead.next

    def removeElements1(self, head, val):
        &quot;&quot;&quot;
        移除单链表head中所有值为val的节点（递归法）

        时间复杂度：O(n)
        空间复杂度：O(n)

        :param head:
        :param val:
        :return:
        &quot;&quot;&quot;
        if head is None:
            return head

        head.next = self.removeElements1(head.next, val)

        return head.next if head.val == val else head

    def create_linked_list(self, list):
        &quot;&quot;&quot;根据list中的所有元素构建单链表&quot;&quot;&quot;
        l = ListNode()  # 单链表头节点
        r = l  # 起始尾指针r指向头节点
        for e in list:
            node = ListNode(e)
            r.next = node
            r = r.next

        return l.next

    def print_linked_list(self, linked_list) -&gt; None:
        &quot;&quot;&quot;
        打印单链表中的所有元素

        :param linked_list: 单链表
        :return: 无
        &quot;&quot;&quot;
        print(&quot;----------------------------------------&quot;)
        pointer = linked_list
        while pointer is not None:
            print(pointer.val)
            pointer = pointer.next


if __name__ == &quot;__main__&quot;:
    slt = Solution()

    linked_list = slt.create_linked_list([1, 2, 6, 3, 4, 5, 6])
    # linked_list = slt.create_linked_list([7, 7, 7, 7])

    slt.print_linked_list(linked_list)

    deleted_linked_list = slt.removeElements1(linked_list, 6)

    slt.print_linked_list(deleted_linked_list)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>算法刷题 | 刷题笔记</title>
    <url>/2021/06/24/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="刷题笔记"><a href="#刷题笔记" class="headerlink" title="刷题笔记"></a>刷题笔记</h1><p><a href="https://github.com/CyC2018/CS-Notes">刷题笔记1</a></p>
<p><a href="https://github.com/Jack-Cherish/LeetCode">刷题笔记2</a></p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 前向传播和反向传播中使用的cache</title>
    <url>/2021/06/30/%E5%89%8D%E5%90%91%E4%BC%A0%E6%92%AD%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84cache/</url>
    <content><![CDATA[<h1 id="前向传播和反向传播中使用的cache"><a href="#前向传播和反向传播中使用的cache" class="headerlink" title="前向传播和反向传播中使用的cache"></a>前向传播和反向传播中使用的cache</h1><p>the “cache” records values from the forward propagation units and sends it to the backward<br>propagation units because it is needed to compute the chain rule derivatives.(“cache”记录<br>来自正向传播单元的值并将其发送到反向传播单元，因为需要链式计算导数。)</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>前向传播</tag>
        <tag>反向传播</tag>
      </tags>
  </entry>
  <entry>
    <title>python | 匹配第n个分组的内容</title>
    <url>/2021/08/28/%E5%8C%B9%E9%85%8D%E7%AC%ACn%E4%B8%AA%E5%88%86%E7%BB%84%E7%9A%84%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<h1 id="1…-9"><a href="#1…-9" class="headerlink" title="\1…\9"></a>\1…\9</h1><p>\1…\9用来匹配与第n(1~9)个分组的内容，必须与()配合使用<br>例：在以下代码段中\2表示匹配第2个分组（一个括号代表一个分组）的内容，即\2匹配”world”字符串</p>
<pre><code>import re
string = &quot;helloworld world&quot;
pattern = r&#39;^(\w+)(world) \2$&#39;
print(re.search(pattern, string))
</code></pre>
<p><a href="https://www.jianshu.com/p/8a4ce87ef4b2">参考资料</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>re</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>re</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程 | 单任务服务器的缺点</title>
    <url>/2020/10/30/%E5%8D%95%E4%BB%BB%E5%8A%A1%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BC%BA%E7%82%B9/</url>
    <content><![CDATA[<h1 id="单任务服务器的缺点"><a href="#单任务服务器的缺点" class="headerlink" title="单任务服务器的缺点"></a>单任务服务器的缺点</h1><p><b style="color:red">为一个顾客服务的时候，不能为其他顾客服务</b><br><strong>注意点</strong>：accept()、recv()</p>
<span id="more"></span>

<pre><code>import socket 

serverSocket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
serverSocket.bind((&#39;&#39;,8080))
serverSocket.listen(5)

while True:
    #如果没有客户端到来，程序将阻塞等待
    clientSocket,clientAddr = serverSocket.accept()
    
    while True:
        #有一个客户端到来，将一直等待客户端发数据,若客户端一直不发数据，程序将一直卡在这里,从而造成程序不能处理新的客户端的请求
        recvData = newSocket.recv(1024)
        if data:
            print(&quot;%s:%s&quot;%(str(clientAddr),recvData))
        else:
            break
</code></pre>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 单词规律</title>
    <url>/2021/09/08/%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B/</url>
    <content><![CDATA[<h1 id="290-单词规律"><a href="#290-单词规律" class="headerlink" title="290.单词规律"></a>290.单词规律</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。<br>这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。</p>
<p>示例1:<br>输入: pattern = “abba”, str = “dog cat cat dog”<br>输出: true</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/word-pattern/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.哈希表<br>在本题中，我们需要判断字符与字符串之间是否恰好一一对应。即任意一个字符都对应着唯一的字符串，任意一个字符串也只被唯一的一个字符对应。在集合论中，这种关系被称为「双射」。<br>想要解决本题，我们可以利用哈希表记录每一个字符对应的字符串，以及每一个字符串对应的字符。然后我们枚举每一对字符与字符串的配对过程，不断更新哈希表，如果发生了冲突，则说明给定的输入不满足双射关系。<br>在实际代码中，我们枚举 pattern 中的每一个字符，利用双指针来均摊线性地找到该字符在 str 中对应的字符串。每次确定一个字符与字符串的组合，我们就检查是否出现冲突，最后我们再检查两字符串是否比较完毕即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):
    def wordPattern(self, pattern, s):
        &quot;&quot;&quot;
        :type pattern: str
        :type s: str
        :rtype: bool
        &quot;&quot;&quot;
        word2ch = dict()
        ch2word = dict()
        words = s.split()
        if len(pattern) != len(words):
            return False

        for ch, word in zip(pattern, words):
            if (word in word2ch and word2ch[word] != ch) or (ch in ch2word and ch2word[ch] != word):
                return False
            word2ch[word] = ch
            ch2word[ch] = word

        return True

    def wordPattern(self, pattern, s):
        dct = dict()
        s = s.split(&#39; &#39;)
        if len(s) != len(pattern):  # 两个字符串长度不相同，返回False
            return False

        for i in range(len(pattern)):
            if pattern[i] not in dct:  # 如果pattern[i]不在字典中，此时要加入pattern[i]
                if s[i] not in dct.values():  # 如果s[i]还未存在，则加入新的映射
                    dct[pattern[i]] = s[i]
                else:
                    return False  # 但是如果与dct[pattern[i]]对应的s[i]已经存在字典的值中，说明不是唯一映射
            else:
                if dct[pattern[i]] != s[i]:  # 如果pattern[i]在字典中，但是dct[pattern[i]]的值不等于s[i]，说明已存在其他映射
                    return False
        return True



if __name__ == &#39;__main__&#39;:
    slt = Solution()
    res = slt.wordPattern1(&quot;abba&quot;, &quot;dog cat cat dog&quot;)
    print(res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>哈希表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 反转字符串</title>
    <url>/2021/08/29/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。<br>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。<br>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p>
<span id="more"></span>
<p>示例 1：<br>输入：[“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]</p>
<p><a href="https://leetcode-cn.com/problems/reverse-string">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.字符串切片 —&gt; reversString()<br>2.使用list.reverse()方法 —&gt; reversString1()<br>3.使用reversed()函数 —&gt; reversString2()<br>4.使用栈 —&gt; reversString3()<br>将s列表看作一个栈，低端作为栈底，高端作为栈顶，依次将栈顶元素出栈即可。<br>5.for —&gt; reversString4()<br>将列表中的第i个元素与倒数第i个元素交换（0&lt; i &lt; len(s)//2）<br>6.递归 —&gt; reversString5()</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):
    def reverseString(self, s):
        &quot;&quot;&quot;
        :type s: List[str]
        :rtype: None Do not return anything, modify s in-place instead.
        &quot;&quot;&quot;
        return s[::-1]

    def reverseString1(self, s):
        s.reverse()

    def reverseString2(self, s):
        s[:] = list(reversed(s))

    def reverseString3(self, s):
        result = list()

        while len(s) &gt; 0:
            result.append(s.pop())

        s[:] = result

    def reverseString4(self, s):
        for i in range(len(s)//2):
            s[i], s[len(s) - i - 1] = s[len(s) - i - 1], s[i]

    # def reverseString5(self, s):
    #     if len(s) &lt; 1:
    #         return s
    #     return self.reverseString4(s[1:]) + s[0]
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 反转字符串2</title>
    <url>/2021/09/01/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B22/</url>
    <content><![CDATA[<h1 id="541-反转字符串2"><a href="#541-反转字符串2" class="headerlink" title="541.反转字符串2"></a>541.反转字符串2</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串 s 和一个整数 k，从字符串开头算起，每 2k 个字符反转前 k 个字符。<br>    如果剩余字符少于 k 个，则将剩余字符全部反转。<br>    如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p>
<span id="more"></span>
<p>示例 1：<br>输入：s = “abcdefg”, k = 2<br>输出：”bacdfeg”</p>
<p><a href="https://leetcode-cn.com/problems/reverse-string-ii/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>反转每个下标从 2k 的倍数开始的，长度为 k 的子串。若该子串长度不足 k，则反转整个子串</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def reverseStr(self, s: str, k: int) -&gt; str:
        t = list(s)
        for i in range(0, len(t), 2 * k):
            t[i: i + k] = reversed(t[i: i + k])
        return &quot;&quot;.join(t)


if __name__ == &#39;__main__&#39;:
    slt = Solution()
    s = &quot;abcdefg&quot;
    k = 2
    res = slt.reverseStr(s, k)  # bacdfeg
    print(res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 反转字符串中的元音字母</title>
    <url>/2021/09/01/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D/</url>
    <content><![CDATA[<h1 id="345-反转字符串中的元音字母"><a href="#345-反转字符串中的元音字母" class="headerlink" title="345.反转字符串中的元音字母"></a>345.反转字符串中的元音字母</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 s ，仅反转字符串中的所有元音字母，并返回结果字符串。<br>元音字母包括 ‘a’、’e’、’i’、’o’、’u’，且可能以大小写两种形式出现。</p>
<span id="more"></span>

<p><a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string">题目链接</a>+</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.先将字符串中的元音字母的位置找出来，然后再将各元音字母反转<br>2.双指针<br>我们可以使用两个指针 i 和 j 对字符串相向地进行遍历。<br>具体地，指针 i 初始时指向字符串 s 的首位，指针 j 初始时指向字符串 s 的末位。在遍历的过程中，我们不停地将 i 向右移动，直到 i 指向一个元音字母（或者超出字符串的边界范围）；同时，我们不停地将 j 向左移动，直到 j 指向一个元音字母。此时，如果 i&lt;j，那么我们交换 i 和 j 指向的元音字母，否则说明所有的元音字母均已遍历过，就可以退出遍历的过程。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def reverseVowels(self, s: str) -&gt; str:
        &quot;&quot;&quot;
        find ans reverse
        :param s:
        :return:
        &quot;&quot;&quot;
        vowels = list()
        s = list(s)
        for i in range(len(s)):
            ch = s[i].lower()
            if ch == &#39;a&#39; or ch == &#39;e&#39; or ch == &#39;i&#39; or ch == &#39;o&#39; or ch == &#39;u&#39;:
                vowels.append(i)

        for i in range(len(vowels)//2):
            s[vowels[i]], s[vowels[len(vowels) - i -1]] = s[vowels[len(vowels) - i -1]], s[vowels[i]]

        return &#39;&#39;.join(s)

    def reverseVowels1(self, s: str) -&gt; str:
        &quot;&quot;&quot;双指针&quot;&quot;&quot;
        def isVowel(ch: str) -&gt; bool:
            return ch in &quot;aeiouAEIOU&quot;

        n = len(s)
        s = list(s)
        i, j = 0, n - 1
        while i &lt; j:
            while i &lt; n and not isVowel(s[i]):
                i += 1
            while j &gt; 0 and not isVowel(s[j]):
                j -= 1
            if i &lt; j:
                s[i], s[j] = s[j], s[i]
                i += 1
                j -= 1

        return &#39;&#39;.join(s)


if __name__ == &quot;__main__&quot;:
    s = Solution()
    string = &quot;hello&quot;
    res = s.reverseVowels(string)
    print(res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 反转字符串中的单词3</title>
    <url>/2021/09/02/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D3/</url>
    <content><![CDATA[<h1 id="557-反转字符串中的单词3"><a href="#557-反转字符串中的单词3" class="headerlink" title="557.反转字符串中的单词3"></a>557.反转字符串中的单词3</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p>
<span id="more"></span>
<p>示例：<br>输入：”Let’s take LeetCode contest”<br>输出：”s’teL ekat edoCteeL tsetnoc”</p>
<p><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.将字符串按照空格划分开得到字符串中的每一个单词,然后将每个单词反转<br>，在将反转后的所有单词用空格拼接起来<br>2.使用额外空间<br>开辟一个新字符串。然后从头到尾遍历原字符串，直到找到空格为止，此时找到了一个单词，并能得到单词的起止位置。随后，根据单词的起止位置，可以将该单词逆序放到新字符串当中。如此循环多次，直到遍历完原字符串，就能得到翻转后的结果。<br>3.原地解法<br>此题也可以直接在原字符串上进行操作，避免额外的空间开销。当找到一个单词的时候，我们交换字符串第一个字符与倒数第一个字符，随后交换第二个字符与倒数第二个字符……如此反复，就可以在原空间上翻转单词。<br>需要注意的是，原地解法在某些语言（比如 Java，JavaScript，python）中不适用，因为在这些语言中 String 类型是一个不可变的类型。<br>在python中可以先将字符串转为列表然后进行算法设计。</p>
<p><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/solution/python-fan-zhuan-zi-fu-chuan-zhong-dan-ci-si-lu-xi/">更多思路参考“一行流”，简直牛逼！！！</a></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def reverseWords(self, s: str) -&gt; str:
        &quot;&quot;&quot;
        将字符串按照空格划分开得到字符串中的每一个单词
        将每个单词反转
        将反转后的所有单词用空格拼接起来
        &quot;&quot;&quot;
        words = s.split(&#39; &#39;)
        reversed_words = []
        for word in words:
            reversed_words.append(self.reverseStr(word))
        return &#39; &#39;.join(reversed_words)

    def reverseStr(self, s: str) -&gt; str:
        s = list(s)
        s[:] = s[::-1]
        return &#39;&#39;.join(s)

    def reverseWords2(self, s: str) -&gt; str:
        &quot;&quot;&quot;使用额外空间&quot;&quot;&quot;
        ret = &#39;&#39;
        length = len(s)
        i = 0
        while i &lt; length:
            start = i
            # 遍历字符串找到空格位置（找到了一个单词）
            while i &lt; length and s[i] != &#39; &#39;:
                i += 1
            # 根据单词的起止位置，可以将该单词逆序放到新字符串当中
            for p in range(start, i):
                ret += s[start + i - 1 - p]
            # 拼上单词后的空格
            while i &lt; length and s[i] == &#39; &#39;:
                i += 1
                ret += &#39; &#39;

        return ret

    def reverseWords3(self, s: str) -&gt; str:
        s = list(s)  # python中字符串为不可变类型，不支持原地修改，可转列表
        length = len(s)
        i = 0
        while i &lt; length:
            start = i

            while i &lt; length and s[i] != &#39; &#39;:
                i += 1

            left = start
            right = i - 1
            while left &lt; right:
                s[left], s[right] = s[right], s[left]
                left += 1
                right -= 1

            while i &lt; length and s[i] == &#39; &#39;:
                i += 1
        return &#39;&#39;.join(s)


if __name__ == &quot;__main__&quot;:
    slt = Solution()
    s = &quot;Let&#39;s take LeetCode contest&quot;
    res = slt.reverseWords3(s)
    print(&quot;反转单词后的字符串：&quot;, res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 反转链表</title>
    <url>/2021/08/27/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.递归<br>递：将大问题分解为小问题，将整个链表依次拆解直到只剩下一个节点<br>归：在链表只剩下一个节点时开始”归“，使用head.next.next = head,head.next = None这两行代码从后往前（从原链表的视角看）将链表中的每一个连接改为反向的<br>2.迭代<br>假设链表为 1→2→3→∅，我们想要把它改成 ∅←1←2←3。<br>在遍历链表时，将当前节点的 next 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。<br>3.头插法<br>首先创建一个只有头节点的反转链表，从头到尾遍历原链表，将每次遍历到的节点按照头插法插入反转链表中，以此类推，当我们遍历完整个链表时就得到一个反转链表。<br>头插法：即每次都将将要插入的节点作为链表的首节点（不是头节点）<br>头插法代码实现：</p>
<pre><code>node.next = head.next
head.next = node
</code></pre>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def reverseList(self, head):
        &quot;&quot;&quot;
        迭代法

        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        # if not head:
        #     return head
        #
        # p = head
        #
        # reversed = ListNode()
        # while p is not None:
        #     node = ListNode(p.val)
        #     node.next = reversed.next
        #     reversed.next = node
        #
        #     p = p.next
        #
        # return reversed.next

        prev = None
        curr = head
        while curr is not None:
            next = curr.next
            curr.next = prev
            prev = curr
            curr = next
        return prev

    def reverseList1(self, head):
        &quot;&quot;&quot;
        递归法

        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        if not head or not head.next:
            return head
        new_head = self.reverseList1(head.next)
        head.next.next = head
        head.next = None
        return new_head

    def reverseList2(self, head):
        &quot;&quot;&quot;
        头插法

        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        if not head:
            return head

        p = head

        reversed = ListNode()
        while p is not None:
            node = ListNode(p.val)
            node.next = reversed.next
            reversed.next = node

            p = p.next

        return reversed.next

    def create_linked_list(self, list):
        &quot;&quot;&quot;根据list中的所有元素构建单链表&quot;&quot;&quot;
        l = ListNode()  # 单链表头节点
        r = l  # 起始尾指针r指向头节点
        for e in list:
            node = ListNode(e)
            r.next = node
            r = r.next

        return l.next

    def print_linked_list(self, linked_list) -&gt; None:
        &quot;&quot;&quot;
        打印单链表中的所有元素

        :param linked_list: 单链表
        :return: 无
        &quot;&quot;&quot;
        print(&quot;----------------------------------------&quot;)
        pointer = linked_list
        while pointer is not None:
            print(pointer.val)
            pointer = pointer.next


if __name__ == &quot;__main__&quot;:
    slt = Solution()

    linked_list = slt.create_linked_list([1, 2, 3, 4, 5])

    slt.print_linked_list(linked_list)

    reversed_linked_list = slt.reverseList1(linked_list)

    slt.print_linked_list(reversed_linked_list)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 合并两个有序链表</title>
    <url>/2021/08/27/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21.合并两个有序链表"></a>21.合并两个有序链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>方法1：递归<br>如果 l1 或者 l2 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束。<br>方法2：迭代<br>当 l1 和 l2 都不是空链表时，判断 l1 和 l2 哪一个链表的头节点的值更小，将较小值的节点添加到结果里，当一个节点被添加到结果里之后，将对应链表中的节点向后移一位。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def mergeTwoLists(self, l1, l2):
        &quot;&quot;&quot;
        迭代法

        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        if l1 is None:
            return l2
        elif l2 is None:
            return l1
        else:
            p = l1
            q = l2
            l3 = ListNode()
            r = l3  # r表示l3单链表的尾指针

            while p and q:  # 注意：此处的循环判断条件为 p and q
                if p.val &lt;= q.val:  # p指针指向的元素小，将此元素并入结果链表
                    node = ListNode(p.val)

                    # 尾插法构建链表
                    r.next = node
                    r = r.next

                    # 工作指针指向当前链表中的下一个节点
                    p = p.next
                else:  # q指针指向的元素小，将此元素并入结果链表
                    node = ListNode(q.val)
                    r.next = node
                    r = r.next

                    q = q.next
            if p is not None:
                r.next = p
            elif q is not None:
                r.next = q

            return l3.next

    def mergeTwoLists1(self, l1, l2):  # 1 2 3   1 3 4
        &quot;&quot;&quot;
        递归法
        &quot;&quot;&quot;
        if l1 is None:
            return l2
        elif l2 is None:
            return l1
        elif l1.val &lt; l2.val:
            l1.next = self.mergeTwoLists1(l1.next, l2)
            return l1
        else:
            l2.next = self.mergeTwoLists1(l1, l2.next)
            return l2

    def len_linked_list(self, linked_list):
        &quot;&quot;&quot;
        返回单链表的长度
        :param linked_list:需要返回其长度的单链表
        :return:单链表的长度
        &quot;&quot;&quot;
        p = linked_list

        n = 0
        while p is not None:
            n += 1
            p = p.next

        return n

    def print_linked_list(self, linked_list) -&gt; None:
        &quot;&quot;&quot;
        打印单链表中的所有元素

        :param linked_list: 单链表
        :return: 无
        &quot;&quot;&quot;
        print(&quot;----------------------------------------&quot;)
        pointer = linked_list
        while pointer is not None:
            print(pointer.val)
            pointer = pointer.next

    def create_linked_list(self, list):
        &quot;&quot;&quot;根据list中的所有元素构建单链表&quot;&quot;&quot;
        l = ListNode()  # 单链表头节点
        r = l  # 起始尾指针r指向头节点
        for e in list:
            node = ListNode(e)
            r.next = node
            r = r.next

        return l.next


if __name__ == &quot;__main__&quot;:
    slt = Solution()

    l1 = slt.create_linked_list([1, 2, 4])
    l2 = slt.create_linked_list([1, 3, 4])

    slt.print_linked_list(l1)
    slt.print_linked_list(l2)

    l3 = slt.mergeTwoLists1(l1, l2)

    slt.print_linked_list(l3)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 吴恩达课后作业</title>
    <url>/2021/06/23/%E5%90%B4%E6%81%A9%E8%BE%BE%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<h1 id="吴恩达课后作业"><a href="#吴恩达课后作业" class="headerlink" title="吴恩达课后作业"></a>吴恩达课后作业</h1><p>这是在b站学习吴恩达深度学习课程时发现的课后作业实现，非常详细！！！点赞！！！</p>
<p><a href="https://blog.csdn.net/u013733326/article/details/79827273">链接：吴恩达深度学习课后作业</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>吴恩达</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 回文链表</title>
    <url>/2021/08/27/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234.回文链表"></a>234.回文链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.按照原链表构建一个反向链表，如果两个链表完全相同则为回文链表<br>2.将原链表中的所有节点的val顺序存储在数组中后使用双指针（array[::] == array[::-1]）<br>3.递归<br>4.快慢指针<br>将链表的后半部分反转，然后将前半部分和后半部分进行比较。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):

    def isPalindrome(self, head):
        &quot;&quot;&quot;
        按照原链表构建一个反向链表，如果两个链表完全相同则为回文链表
        :type head: ListNode
        :rtype: bool
        &quot;&quot;&quot;
        # p = head
        # reversed = ListNode()
        # while p is not None:
        #     node = ListNode(p.val)
        #     node.next = reversed.next
        #     reversed.next = node
        #
        #     p = p.next
        #
        # p1 = head
        # p2 = reversed.next
        # while p1 and p2:
        #     if p1.val == p2.val:
        #         p1 = p1.next
        #         p2 = p2.next
        #     else:
        #         break
        # if p1 is None and p2 is None:
        #     return True
        # else:
        #     return False

        reversed = self.reverseList(head)
        p1 = head
        p2 = reversed
        while p1 and p2:
            if p1.val == p2.val:
                p1 = p1.next
                p2 = p2.next
            else:
                break
        if p1 is None and p2 is None:
            return True
        else:
            return False

    def isPalindrome1(self, head):
        &quot;&quot;&quot;
        将原链表中的所有节点的val顺序存储在数组中后使用双指针
        :type head: ListNode
        :rtype: bool
        &quot;&quot;&quot;
        p = head
        vals = []
        while p:
            vals.append(p.val)
            p = p.next
        return vals[::] == vals[::-1]

    def isPalindrome2(self, head):
        &quot;&quot;&quot;
        递归法

        :type head: ListNode
        :rtype: bool
        &quot;&quot;&quot;
        self.front_pointer = head

        def recursively_check(current_node=head):
            if current_node is not None:
                if not recursively_check(current_node.next):
                    return False
                if self.front_pointer.val != current_node.val:
                    return False
                self.front_pointer = self.front_pointer.next

            return True

        return recursively_check()

    def isPalindrome3(self, head):
        &quot;&quot;&quot;
        快慢指针
        将链表的后半部分反转（修改链表结构），然后将前半部分和后半部分进行比较。

        :type head: ListNode
        :rtype: bool
        &quot;&quot;&quot;
        if head is None:
            return True

        # 找到前半部分链表的尾节点并反转后半部分链表
        first_half_end = self.end_of_first_half(head)
        second_half_start = self.reverseList(first_half_end.next)

        # 判断是否回文
        result = True
        first_position = head
        second_position =second_half_start

        while result and second_position is not None:
            if first_position.val != second_position.val:
                result = False
            first_position = first_position.next
            second_position = second_position.next

        # 还原链表并返回结果
        first_half_end.next = self.reverseList((second_half_start))
        return result

    def end_of_first_half(self, head):
        fast = head
        slow = head

        while fast.next is not None and fast.next.next is not None:
            fast = fast.next.next
            slow = slow.next

        return slow

    def reverseList(self, head):
        &quot;&quot;&quot;
        递归法反转链表

        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        if not head or not head.next:
            return head
        new_head = self.reverseList(head.next)
        head.next.next = head
        head.next = None
        return new_head

    def create_linked_list(self, list):
        &quot;&quot;&quot;根据list中的所有元素构建单链表&quot;&quot;&quot;
        l = ListNode()  # 单链表头节点
        r = l  # 起始尾指针r指向头节点
        for e in list:
            node = ListNode(e)
            r.next = node
            r = r.next

        return l.next

    def print_linked_list(self, linked_list) -&gt; None:
        &quot;&quot;&quot;
        打印单链表中的所有元素

        :param linked_list: 单链表
        :return: 无
        &quot;&quot;&quot;
        print(&quot;----------------------------------------&quot;)
        pointer = linked_list
        while pointer is not None:
            print(pointer.val)
            pointer = pointer.next


if __name__ == &quot;__main__&quot;:
    slt = Solution()

    linked_list = slt.create_linked_list([1, 2, 2, 1])

    slt.print_linked_list(linked_list)

    res = slt.isPalindrome3(linked_list)
    print(res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>python | 在python代码中使用c语言编写的函数</title>
    <url>/2020/10/16/%E5%9C%A8python%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%BD%BF%E7%94%A8c%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E7%9A%84%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="在python代码中使用c语言编写的函数-以输出Hello-World为例"><a href="#在python代码中使用c语言编写的函数-以输出Hello-World为例" class="headerlink" title="在python代码中使用c语言编写的函数-以输出Hello World为例"></a>在python代码中使用c语言编写的函数-以输出Hello World为例</h1><p><b style="color:red">linux环境下！！！</b></p>
<h2 id="Step-1-编写c语言代码-sayHello-c"><a href="#Step-1-编写c语言代码-sayHello-c" class="headerlink" title="Step 1:编写c语言代码-sayHello.c"></a>Step 1:编写c语言代码-sayHello.c</h2><pre><code>include&lt;stdio.h&gt;
void sayHello()
&#123;
    printf(&quot;Hello World!&quot;);
&#125;
</code></pre>
<h2 id="Step-2-把c语言文件编译成一个动态库"><a href="#Step-2-把c语言文件编译成一个动态库" class="headerlink" title="Step 2:把c语言文件编译成一个动态库"></a>Step 2:把c语言文件编译成一个动态库</h2><pre><code>gcc sayHello.c -shared -o lib-sayHello.so
</code></pre>
<h2 id="Step-3-编写python代码-main-py"><a href="#Step-3-编写python代码-main-py" class="headerlink" title="Step 3:编写python代码-main.py"></a>Step 3:编写python代码-main.py</h2><pre><code>from ctypes import *

#加载动态库
lib = cdll.LoadLibrary(&quot;./lib-sayHello.so&quot;)
#调用sayHello函数
lib.sayHello()
</code></pre>
<h2 id="Step-4-运行python代码"><a href="#Step-4-运行python代码" class="headerlink" title="Step 4:运行python代码"></a>Step 4:运行python代码</h2><pre><code>python3 main.py
</code></pre>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 在系统中查找重复文件</title>
    <url>/2021/09/05/%E5%9C%A8%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%9F%A5%E6%89%BE%E9%87%8D%E5%A4%8D%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="609-在系统中查找重复文件"><a href="#609-在系统中查找重复文件" class="headerlink" title="609.在系统中查找重复文件"></a>609.在系统中查找重复文件</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个目录信息列表，包括目录路径，以及该目录中的所有包含内容的文件，您需要找到文件系统中的所有重复文件组的路径。一组重复的文件至少包括二个具有完全相同内容的文件。<br>输入列表中的单个目录信息字符串的格式如下：<br>“root/d1/d2/…/dm f1.txt(f1_content) f2.txt(f2_content) … fn.txt(fn_content)”<br>这意味着有 n 个文件（f1.txt, f2.txt … fn.txt 的内容分别是 f1_content, f2_content … fn_content）在目录 root/d1/d2/…/dm 下。注意：n&gt;=1 且 m&gt;=0。如果 m=0，则表示该目录是根目录。<br>该输出是重复文件路径组的列表。对于每个组，它包含具有相同内容的文件的所有文件路径。文件路径是具有下列格式的字符串：<br>“directory_path/file_name.txt”</p>
<span id="more"></span>
<p>示例 1：<br>输入：<br>[“root/a 1.txt(abcd) 2.txt(efgh)”, “root/c 3.txt(abcd)”, “root/c/d 4.txt(efgh)”, “root 4.txt(efgh)”]<br>输出：<br>[[“root/a/2.txt”,”root/c/d/4.txt”,”root/4.txt”],[“root/a/1.txt”,”root/c/3.txt”]]</p>
<p><a href="https://leetcode-cn.com/problems/find-duplicate-file-in-system
">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.哈希表<br>首先我们通过字符串操作获取目录路径、文件名和文件内容。我们使用哈希映射（HashMap）来寻找重复文件，哈希映射中的键（key）是文件内容，值（value）是存储路径和文件名的列表。<br>我们遍历每一个文件，并把它加入哈希映射中。在这之后，我们遍历哈希映射，如果一个键对应的值列表的长度大于 1，说明我们找到了重复文件，可以把这个列表加入到答案中。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):
    def findDuplicate(self, paths):
        &quot;&quot;&quot;
        :type paths: List[str]
        :rtype: List[List[str]]
        &quot;&quot;&quot;
        map = &#123;&#125;
        for path in paths:
            values = path.split(&quot; &quot;)
            for i in range(1, len(values)):
                name_cont = values[i].split(&#39;(&#39;)[-1]
                name_cont = name_cont.replace(&#39;)&#39;, &#39;&#39;)
                value_list = map.get(name_cont, [])
                value_list.append(values[0] + &#39;/&#39; + values[i].split(&#39;(&#39;)[0])
                map[name_cont] = value_list
        res = []
        for key in map.keys():
            if len(map.get(key)) &gt; 1:
                res.append(map.get(key))

        return res


if __name__ == &#39;__main__&#39;:
    slt = Solution()
    result = slt.findDuplicate([&quot;root/a 1.txt(abcd) 2.txt(efgh)&quot;, &quot;root/c 3.txt(abcd)&quot;, &quot;root/c/d 4.txt(efgh)&quot;, &quot;root 4.txt(efgh)&quot;])
    print(result)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 外观数列</title>
    <url>/2021/08/28/%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<h1 id="38-外观数列"><a href="#38-外观数列" class="headerlink" title="38.外观数列"></a>38.外观数列</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个正整数 n ，输出外观数列的第 n 项。<br>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。</p>
<span id="more"></span>
<p>你可以将其视作是由递归公式定义的数字字符串序列：<br>    countAndSay(1) = “1”<br>    countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。<br>前五项如下：</p>
<ol>
<li><pre><code>1
</code></pre>
</li>
<li><pre><code>11
</code></pre>
</li>
<li><pre><code>21
</code></pre>
</li>
<li><pre><code>1211
</code></pre>
</li>
<li><pre><code>111221
</code></pre>
第一项是数字 1<br>描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 “11”<br>描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 “21”<br>描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 “1211”<br>描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 “111221”<br>要 描述 一个数字字符串，首先要将字符串分割为 最小 数量的组，每个组都由连续的最多 相同字符 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。</li>
</ol>
<p><a href="https://leetcode-cn.com/problems/count-and-say/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.递归<br>递归出口为n == 1时，返回”1”；<br>当n &gt; 1时，我们只需要计算countAndSay(n - 1)中每个数字的个数：<br>对于计算字符串中每个数字出现的个数，使用双指针i, j，其中i表示当前字符，j则是计数指针，向后移动判断；<br>以求n = 5，lastStr = countAndSay(4) = “1211”为例，answer = “”，一开始让i = 0, j = 1，此时’1’ != ‘2’，<br>故answer += (j - i) + lastStr.charAt(i)，ans = “11”；然后让i = j（第二个不同字符起始位置），<br>然后j++往后移动；此时i = j = 1，j = j + 1 = 2，又’2’ != ‘1’，<br>所以answer += (j - i) + lastStr.charAt(i),ans = “1112”,重复i = j = 2， j = ++j = 3；此时’1’ = ‘1’；<br>故直接j = ++j = 4 == lastStr.length()，所以跳出循环，然后把最后一次的字符个数字符加上，即执行：<br>answer += (j - i) + lastStr.charAt(i),ans = “111221”，即countAndSay(5) = “111221”。<br>2.正则表达式<br>用正则表达式匹配一个数字的重复序列和数字本身，然后将匹配的序列的长度加上数字本身替换原字符串中重复序列，…，以此类推。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def countAndSay(self, n: int) -&gt; str:
        &quot;&quot;&quot;
        递归法
        :param n:
        :return:
        &quot;&quot;&quot;
        if n == 1:  # 递归出口
            return &quot;1&quot;
        else:
            lastStr = self.countAndSay(n - 1)
            ans = &quot;&quot;
            i = 0
            j = 1

            while j &lt; len(lastStr):
                if lastStr[i] != lastStr[j]:
                    ans += str(j-i)
                    ans += str(lastStr[i])
                    i = j  # 下一个不同字符的起始位置

                j += 1

            ans += str(j - i)
            ans += str(lastStr[i])

            return str(ans)

    def countAndSay1(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: str
        &quot;&quot;&quot;
        import re

        s = &#39;1&#39;
        for _ in range(n - 1):
            s = re.sub(r&#39;(.)\1*&#39;, lambda a: str(len(a.group(0))) + a.group(1), s)  # sub(pattern, repl, string)
            # r&#39;(.)\1*&#39; (.)匹配一个任意字符作为一个分组 \1*匹配与第一个分组相同内容0次/多次
        return s


if __name__ == &#39;__main__&#39;:
    s = Solution()
    res = s.countAndSay1(5)
    print(res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>可视化 | 多个坐标轴可视化主要代码python</title>
    <url>/2021/03/11/%E5%A4%9A%E4%B8%AA%E5%9D%90%E6%A0%87%E8%BD%B4%E5%8F%AF%E8%A7%86%E5%8C%96%E4%B8%BB%E8%A6%81%E4%BB%A3%E7%A0%81python/</url>
    <content><![CDATA[<h1 id="多个坐标轴可视化主要代码"><a href="#多个坐标轴可视化主要代码" class="headerlink" title="多个坐标轴可视化主要代码"></a>多个坐标轴可视化主要代码</h1><p>在机器学习算法的使用中，我们需要使用多个坐标轴对一些过程数据/预测结果等进行可视化以便于进一步的分析，它的主要python代码如下：</p>
<span id="more"></span>

<pre><code>from matplotlib.font_manager import FontProperties  # be used to set the fonts
import matplotlib.pyplot as plt

font = FontProperties(fname=r&#39;c:\windows\fonts\simsun.ttc&#39;, size=14)

fig, axs = plt.subplots(nrows=&#39;number_of_rows&#39;, ncols=&#39;number_of_cols&#39;, sharex=&#39;False&#39;, sharey=&#39;False&#39;, figsize=(width, height))
axs[m][n].plot(x, y)  # m&lt;number_of_rows,n&lt;number_of_cols x,y:a list
title = axs[m][n].set_title(u&#39;&#39;,FontProperties=font)
ylabel = axs[m][n].set_ylabel(u&#39;&#39;,FontProperties=font)
xlabel = axs[m][n].set_xlabel(u&#39;&#39;,FontProperties=font)
plt.setp(title/xlabel/ylabel, size=&#39;&#39;, weight=&#39;&#39;, color=&#39;&#39;)
plt.show()  # show the figure
</code></pre>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>可视化(Visualization)</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程 | 多线程下载图片</title>
    <url>/2021/08/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h1 id="多线程下载图片"><a href="#多线程下载图片" class="headerlink" title="多线程下载图片"></a>多线程下载图片</h1><p>下面的代码是一个网络爬虫程序，可以定期下载图片。这个网络爬虫程序每隔一段时间都会执行一次下载图片任务，在下载任务完成后，休眠一段时间在执行。这样反复执行，知道爬虫程序停止。</p>
<p><strong>示例代码：</strong></p>
<pre><code># coding=utf-8

import time
import threading
import urllib.request as request

# 线程停止变量
isrunning = True


# 工作线程体函数
def workthread_body():
    while isrunning:
        # 线程开始工作
        print(&#39;工作线程执行下载任务...&#39;)
        download()
        # 线程休眠
        time.sleep(5)
    print(&#39;工作线程结束&#39;)


# 控制线程体函数
def controlthread_body():
    global isrunning
    while isrunning:
        # 从键盘输入停止指令exit
        command = input(&#39;请输入停止指令&#39;)
        if command == &#39;exit&#39;:
            isrunning = False
            print(&#39;控制线程结束。&#39;)


def download():
    url = &#39;https://victory-liao.github.io/images/avatar.jpg&#39;
    req = request.Request(url)
    with request.urlopen(req) as response:
        data = response.read()
        f_name = &#39;download.jpg&#39;
        with open(f_name, &#39;wb&#39;) as f:
            f.write(data)
            print(&#39;下载文件成功&#39;)


# 主线程
# 创建工作线程对象workthread
workthread = threading.Thread(target=workthread_body)
# 启动线程workthred
workthread.start()

# 创建控制线程对象controlthread
controlthread = threading.Thread(target=controlthread_body)
# 启动线程controlthread
controlthread.start()
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>内置模块</category>
        <category>threading</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>threading</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>系统编程 | 多进程拷贝文件</title>
    <url>/2020/10/14/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="多进程拷贝文件"><a href="#多进程拷贝文件" class="headerlink" title="多进程拷贝文件"></a>多进程拷贝文件</h1><h2 id="实现流程分析"><a href="#实现流程分析" class="headerlink" title="实现流程分析"></a>实现流程分析</h2><ol>
<li>获取要copy的文件夹的名字</li>
<li>创建一个文件夹</li>
<li>获取old文件夹中的所有的文件名字</li>
<li>使用多进程方式copy原文件夹中的所有文件到新的文件夹中</li>
</ol>

<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code>from multiprocessing import Pool,Manager
import os
import time

def copyFileTask(name,oldFolderName,newFolderName,queue):
    &quot;complete the function of coping a file&quot;
    fr = open(oldFolderName+&quot;/&quot;+name)
    fw = open(newFolderName+&quot;/&quot;+name,&quot;w&quot;)
    content = fr.read()
    fw.write(content)
    fr.close()
    fw.close()
    queue.put(name)

def main():
    #0.get the file name you want to copy
    oldFolderName = input(&quot;Please input the file name:&quot;)
    #1.create a file directory
    newFolderName = oldFolderName+&quot;-copy&quot;
    #pmrint(newFolderName)
    os.mkdir(newFolderName)
    #2.get all file name of old file directory
    fileNames = os.listdir(oldFolderName)
    #print(fileNames)
    #3.copy all file of old file directory to a new file directory
    pool = Pool(5)
    queue = Manager().Queue()
    for name in fileNames:
        pool.apply_async(copyFileTask,args=(name,oldFolderName,newFolderName,queue))
    num = 0
    allNum = len(fileNames)
    while num &lt; allNum:
        queue.get()
        num += 1
        copyRate = num/allNum
        print(&quot;\rcopy process:%.2f%% &quot;%(copyRate*100),end=&quot;&quot;)
        time.sleep(1)
    print(&#39;\ncompleted&#39;)
    pool.close()
    pool.join()
if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
]]></content>
      <categories>
        <category>系统编程</category>
      </categories>
      <tags>
        <tag>系统编程</tag>
        <tag>多进程</tag>
      </tags>
  </entry>
  <entry>
    <title>如何计算深度学习代码实践中的trainsteps</title>
    <url>/2021/08/02/%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E8%B7%B5%E4%B8%AD%E7%9A%84trainsteps/</url>
    <content><![CDATA[<h1 id="如何计算深度学习代码实践中的trainsteps"><a href="#如何计算深度学习代码实践中的trainsteps" class="headerlink" title="如何计算深度学习代码实践中的trainsteps?"></a>如何计算深度学习代码实践中的trainsteps?</h1><p>深度学习中已经有epoch参数了，为什么还要再定义steps参数？</p>
<p>epoch:全体训练数据过几遍</p>
<p>steps:模型会计算几次loss,即模型参数会更新几次梯度</p>
<p>当我们训练模型时，epoch变成了一个间接的关注对象，我们关系模型能更新多少次，这些才知道循环多少次，计算多少次loss。其实最主要的一点是训练步数与模型的参数会有相关关系，比如如果要采用自适应学习率，那每步都是有一个不同的学习率的。</p>
<p>train steps通常按以下公式进行计算：<br>train steps = len(data) // batch_size</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>train steps</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 字符串中的单词数</title>
    <url>/2021/09/01/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0/</url>
    <content><![CDATA[<h1 id="434-字符串中的单词数"><a href="#434-字符串中的单词数" class="headerlink" title="434.字符串中的单词数"></a>434.字符串中的单词数</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。<br>请注意，你可以假定字符串里不包括任何不可打印的字符。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/number-of-segments-in-a-string/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.使用语言内置函数split()<br>2.原地法<br>计算单词的数量，就等同于计数单词开始的下标个数。因此，只需要定义好下标的条件，就可以遍历整个字符串，检测每个下标。定义如下：若该下标前为空格（或者为初始下标），且自身不为空格，则其为单词开始的下标。该条件可以以常数时间检测。最后，返回满足条件的下标个数。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def countSegments(self, s: str) -&gt; int:
        list_s = s.split(&#39; &#39;)
        for i in range(list_s.count(&#39;&#39;)):
            list_s.remove(&#39;&#39;)
        if not list_s:
            return 0
        return len(list_s)

    def countSegments1(self, s):
        return len(s.split())

    def countSegments2(self, s):
        segment_count = 0

        for i in range(len(s)):
            if (i == 0 or s[i-1] == &#39; &#39;) and s[i] != &#39; &#39;:
                segment_count +=1

        return segment_count


if __name__ == &#39;__main__&#39;:
    slt = Solution()
    # s = &quot;      &quot;
    s = &quot;The one-hour drama series Westworld is a dark odyssey about the dawn of artificial consciousness and the evolution of sin. Set at the intersection of the near future and the reimagined past, it explores a world in which every human appetite, no matter how noble or depraved, can be indulged.&quot;
    res = slt.countSegments2(s)
    print(res)

    # 分割文本
    # s = &quot;The sky is very blue.&quot;
    # words = s.split(&quot; &quot;)
    # print(words)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 字符串相乘</title>
    <url>/2021/09/05/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</url>
    <content><![CDATA[<h1 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43.字符串相乘"></a>43.字符串相乘</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p>
<p>示例 1:<br>输入: num1 = “2”, num2 = “3”<br>输出: “6”</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/multiply-strings">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.将num1、num2两个字符串转为整数相乘，然后将结果转为字符串返回<br>2.使用python内置函数eval()执行num1 * num2表达式，将eval函数返回结果转为字符串返回<br>3.做加法（<a href="https://leetcode-cn.com/problems/multiply-strings/solution/zi-fu-chuan-xiang-cheng-by-leetcode-solution/">详细思路见leetcode题解</a>）<br>4.做乘法（<a href="https://leetcode-cn.com/problems/multiply-strings/solution/zi-fu-chuan-xiang-cheng-by-leetcode-solution/">详细思路见leetcode题解</a>）</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):
    def multiply(self, num1, num2):
        &quot;&quot;&quot;
        将num1、num2两个字符串转为整数相乘，然后将结果转为字符串返回

        :type num1: str
        :type num2: str
        :rtype: str
        &quot;&quot;&quot;
        return str(int(num1) * int(num2))

    def multiply1(self, num1: str, num2: str) -&gt; str:
        &quot;&quot;&quot;
        将num1、num2两个字符串转为整数相乘，然后将结果转为字符串返回
        :param num1:
        :param num2:
        :return:
        &quot;&quot;&quot;
        if num1 == &quot;0&quot; or num2 == &quot;0&quot;:
            return &quot;0&quot;

        num1_to_int = 0
        num2_to_int = 0

        t = 1
        for i in range(1, len(num1)+1):
            num1_to_int += int(num1[-i]) * t
            t = t * 10

        t = 1
        for i in range(1, len(num2)+1):
            num2_to_int += int(num2[-i]) * t
            t = t * 10

        return str(num1_to_int * num2_to_int)

    def multiply2(self, num1: str, num2: str) -&gt; str:
        &quot;&quot;&quot;使用python内置函数eval()执行num1 * num2表达式，将eval函数返回结果转为字符串返回&quot;&quot;&quot;
        if num1 == &quot;0&quot; or num2 == &quot;0&quot;:
            return &quot;0&quot;

        return str(eval(num1 + &#39;*&#39; + num2))  # eval() 函数用来执行一个字符串表达式，并返回表达式的值。

    def multiply3(self, num1: str, num2: str) -&gt; str:
        &quot;&quot;&quot;做加法&quot;&quot;&quot;
        if num1 == &quot;0&quot; or num2 == &quot;0&quot;:
            return &quot;0&quot;

        ans = &quot;0&quot;
        m, n = len(num1), len(num2)
        for i in range(n - 1, -1, -1):
            add = 0
            y = int(num2[i])
            curr = [&quot;0&quot;] * (n - i - 1)  # num2除了最低位以外，其余的每一位的运算结果都需要补0
            print(&quot;curr:&quot;, curr)
            for j in range(m - 1, -1, -1):
                product = int(num1[j]) * y + add
                curr.append(str(product % 10))
                add = product // 10
            if add &gt; 0:
                curr.append(str(add))
            curr = &quot;&quot;.join(curr[::-1])
            ans = self.addStrings(ans, curr)
        return ans

    def addStrings(self, num1: str, num2: str) -&gt; str:
        i, j = len(num1) - 1, len(num2) - 1
        add = 0
        ans = list()
        while i &gt;= 0 or j &gt;= 0 or add != 0:
            x = int(num1[i]) if i &gt;= 0 else 0
            y = int(num2[j]) if j &gt;= 0 else 0
            result = x + y + add
            ans.append(str(result % 10))
            add = result // 10
            i -= 1
            j -= 1
        return &#39;&#39;.join(ans[::-1])

    def multiply4(self, num1: str, num2: str) -&gt; str:
        &quot;&quot;&quot;做乘法&quot;&quot;&quot;
        if num1 == &quot;0&quot; or num2 == &quot;0&quot;:
            return &quot;0&quot;

        m, n = len(num1), len(num2)
        ansArr = [0] * (m + n)
        for i in range(m - 1, -1, -1):
            x = int(num1[i])
            for j in range(n - 1, -1, -1):
                ansArr[i + j + 1] += x * int(num2[j])

        for i in range(m + n - 1, 0, -1):
            ansArr[i-1] += ansArr[i] // 10
            ansArr[i] %= 10

        index = 1 if ansArr[0] == 0 else 0
        ans = &quot;&quot;.join(str(x) for x in ansArr[index:])
        return ans


if __name__ == &quot;__main__&quot;:
    slt = Solution()
    result = slt.multiply4(&quot;12&quot;, &quot;34&quot;)
    print(result)
    print(type(result))
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 学生出勤记录1</title>
    <url>/2021/09/02/%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E8%AE%B0%E5%BD%951/</url>
    <content><![CDATA[<h1 id="551-学生出勤记录1"><a href="#551-学生出勤记录1" class="headerlink" title="551.学生出勤记录1"></a>551.学生出勤记录1</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 s 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：<br>    ‘A’：Absent，缺勤<br>    ‘L’：Late，迟到<br>    ‘P’：Present，到场<br>如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：<br>    按 总出勤 计，学生缺勤（’A’）严格 少于两天。<br>    学生 不会 存在 连续 3 天或 连续 3 天以上的迟到（’L’）记录。<br>如果学生可以获得出勤奖励，返回 true ；否则，返回 false 。</p>
<span id="more"></span>
<p>示例 1：<br>输入：s = “PPALLP”<br>输出：true<br>解释：学生缺勤次数少于 2 次，且不存在 3 天或以上的连续迟到记录。</p>
<p><a href>题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.一次遍历<br>可奖励的出勤记录要求缺勤次数少于 2 和连续迟到次数少于 3。判断出勤记录是否可奖励，只需要遍历出勤记录，判断这两个条件是否同时满足即可。<br>遍历过程中，记录缺勤次数和连续迟到次数，根据遍历到的字符更新缺勤次数和连续迟到次数：<br>    如果遇到 ‘A’，即缺勤，则将缺勤次数加 1，否则缺勤次数不变；<br>    如果遇到 ‘L’，即迟到，则将连续迟到次数加 1，否则将连续迟到次数清零。<br>如果在更新缺勤次数和连续迟到次数之后，出现缺勤次数大于或等于 2 或者连续迟到次数大于或等于 3，则该出勤记录不满足可奖励的要求，返回 false。如果遍历结束时未出现出勤记录不满足可奖励的要求的情况，则返回 true。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def checkRecord(self, s: str) -&gt; bool:
        # 统计字符串中出现‘A’的的次数
        count_A = s.count(&#39;A&#39;)
        # 字符串中是否有连续3个以上的‘L&#39;
        for i in range(len(s)):
            if i + 2 &lt; len(s) and s[i] == &#39;L&#39; and s[i+1] == &#39;L&#39; and s[i+2] == &#39;L&#39;:
                    return False

        return True if count_A &lt; 2 else False

    def checkRecord1(self, s: str) -&gt; bool:
        absents = lates = 0
        for char in s:
            if char == &quot;A&quot;:
                absents += 1
                lates = 0
            elif char == &quot;L&quot;:
                lates += 1
            else:
                lates = 0

            if lates &gt;= 3 or absents &gt; 1:
                return False

        return True
        # absents = lates = 0
        # for i, c in enumerate(s):
        #     if c == &quot;A&quot;:
        #         absents += 1
        #         if absents &gt;= 2:
        #             return False
        #
        #     if c == &quot;L&quot;:
        #         lates += 1
        #         if lates &gt;= 3:
        #             return False
        #     else:
        #         lates = 0
        #
        # return True


if __name__ == &quot;__main__&quot;:
    slt = Solution()
    # res = slt.checkRecord2(&quot;PPALLL&quot;)
    res = slt.checkRecord2(&quot;PPALLP&quot;)
    print(res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Django | 安装mysql_python失败</title>
    <url>/2021/07/25/%E5%AE%89%E8%A3%85mysql-python%E5%A4%B1%E8%B4%A5/</url>
    <content><![CDATA[<h1 id="安装mysql-python失败"><a href="#安装mysql-python失败" class="headerlink" title="安装mysql_python失败"></a>安装mysql_python失败</h1><p><a href="https://blog.csdn.net/qq_37431752/article/details/87965695">解决办法！！！</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>框架</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>实现strStr方法</title>
    <url>/2021/08/27/%E5%AE%9E%E7%8E%B0strStr%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="28-实现strStr"><a href="#28-实现strStr" class="headerlink" title="28.实现strStr()"></a>28.实现strStr()</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>实现 strStr() 函数。<br>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。<br><a href="https://leetcode-cn.com/problems/implement-strstr/">题目链接</a></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.直接调用python内置方法<br>2.暴力匹配<br>让字符串 needle 与字符串 haystack 的所有长度为 m（needle字符串的长度） 的子串均匹配一次。<br>为了减少不必要的匹配，我们每次匹配失败即立刻停止当前子串的匹配，对下一个子串继续匹配。如果当前子串匹配成功，我们返回当前子串的开始位置即可。如果所有子串都匹配失败，则返回 −1-1−1。<br><strong style="color:red">3.kmp算法</strong><br>kmp算法的目的：为了避免不必要的指针回溯<br>主串指针i不回溯，模式串指针j的变化取决于模式串的结构是否有重复<br>pi数组值的计算：<br>pi数组的值为最长相同前后缀长度+1(串本身不能作为前后缀)<br>pi[1]=0,其他情况next[]=1.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    &quot;&quot;&quot;
    kmp算法的目的：为了避免不必要的指针回溯

    主串指针i不回溯，模式串指针j的变化取决于模式串的结构是否有重复

    pi数组值的计算：
    pi数组的值为最长相同前后缀长度+1(串本身不能作为前后缀)
    pi[1]=0,其他情况next[]=1.
    &quot;&quot;&quot;
    def strStr(self, haystack: str, needle: str) -&gt; int:
        # 获取主串和模式串的长度
        n = len(haystack)
        m = len(needle)

        # 如果模式串的长度为0，则返回0
        if m == 0:
            return 0

        pi = [0]*m

        # 求模式串的前缀函数值
        i = 1
        j = 0
        while i &lt; m:
            while j &gt; 0 and needle[i] != needle[j]:
                j = pi[j-1]  # 回溯

            if needle[i] == needle[j]:
                j += 1

            pi[i] = j

            i += 1

        print(&quot;模式串的前缀函数值:&quot;, pi)

        # kmp
        i = 0
        j = 0
        while i &lt; n:
            while j &gt; 0 and haystack[i] != needle[j]:
                j = pi[j-1]  # 回溯

            if haystack[i] == needle[j]:
                j += 1

            if j == m:
                return i - m + 1

            i += 1

        return -1

    def strStr1(self, haystack: str, needle: str) -&gt; int:
        &quot;&quot;&quot;调用内置方法&quot;&quot;&quot;
        # 方法1
        # return haystack.find(needle)

        # 方法2
        if not needle:
            return 0

        try:
            return haystack.index(needle)
        except ValueError:
            return -1

    def strStr2(self, haystack: str, needle: str) -&gt; int:
        &quot;&quot;&quot;暴力匹配&quot;&quot;&quot;
        n = len(haystack)
        m = len(needle)

        i = 0

        while i + m &lt;= n:
            flag = True

            j = 0
            while j &lt; m:
                if haystack[i + j] != needle[j]:
                    flag = False
                    break

                j += 1

            if flag:
                return i

            i += 1
        return -1


if __name__ == &quot;__main__&quot;:
    s = Solution()
    # print(s.strStr(&quot;mississippi&quot;, &quot;issip&quot;))  # [0, 0, 0, 1, 0]
    # print(s.strStr1(&quot;mississippi&quot;, &quot;issip&quot;))  # [0, 0, 0, 1, 0]
    print(s.strStr2(&quot;mississippi&quot;, &quot;issip&quot;))  # [0, 0, 0, 1, 0]
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>kmp算法</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程 | 实现线程体的两种方式</title>
    <url>/2021/08/05/%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E4%BD%93%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="实现线程体的两种方式"><a href="#实现线程体的两种方式" class="headerlink" title="实现线程体的两种方式"></a>实现线程体的两种方式</h1><p>实现线程体主要有以下两种方式：<br>1.自定义函数实现线程体<br>代码实例：</p>
<pre><code># coding=utf-8

import threading
import time


# 线程体函数
def thread_body():
    # 当前线程对象
    t = threading.current_thread()
    for n in range(5):
        # 当前线程名
        print(&#39;第&#123;0&#125;次执行线程&#123;1&#125;&#39;.format(n, t.name))
        # 线程休眠
        time.sleep(2)
    print(&#39;线程&#123;0&#125;执行完成！&#39;.format(t.name))


# 主线程
# 创建线程对象t1
t1 = threading.Thread(target=thread_body)
# 创建线程对象t2
t2 = threading.Thread(target=thread_body, name=&#39;MyThread&#39;)
# 启动线程t1
t1.start()
# 启动线程t2
t2.start()
</code></pre>
<p>2.自定义线程类实现线程体<br>代码实例：</p>
<pre><code># coding=utf-8

import time
import threading


class SmallThread(threading.Thread):
    def __init__(self, name=None):
        super().__init__(name=name)

    # 线程体函数
    def run(self):
        # 当前线程对象
        t = threading.current_thread()
        for n in range(5):
            # 当前线程名
            print(&#39;第&#123;0&#125;次执行线程&#123;1&#125;&#39;.format(n, t.name))
            # 线程休眠
            time.sleep(2)
        print(&#39;线程&#123;0&#125;执行完成&#39;.format(t.name))


# 主线程
# 创建线程对象t1
t1 = SmallThread()  # 通过自定义线程类，创建线程对象
# 创建线程对象t2
t2 = SmallThread(name=&#39;MyThread&#39;)
# 启动线程t1
t1.start()
# 启动线程t2
t2.start()
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>内置模块</category>
        <category>threading</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>threading</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>伪迹移除 | 小波变换</title>
    <url>/2021/02/23/%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="小波变换-Wavelet-Transform-WT"><a href="#小波变换-Wavelet-Transform-WT" class="headerlink" title="小波变换(Wavelet Transform,WT)"></a>小波变换(Wavelet Transform,WT)</h1><p>小波变化是一个时间尺度的表示方法，它把信号分解成时间和尺度的基函数(母小波基函数的扩展/变体)</p>
<h2 id="一些基于小波理论的技术"><a href="#一些基于小波理论的技术" class="headerlink" title="一些基于小波理论的技术"></a>一些基于小波理论的技术</h2><p>1.wavelet packets<br>2.wavelet approximation and decomposition<br>3.discrete and continuous wavelet transform<br>…<br>其中，最常用的技术是离散小波变换(Discrete Wavelet Transform);<br>离散小波变换是由离散输入的连续小波变换得到的；<br>离散小波变换将信号输入到低通滤波器中，得到低频分量，进入高通滤波器得到高频分量。</p>
<h2 id="离散小波变换进行2级分解的示例结构"><a href="#离散小波变换进行2级分解的示例结构" class="headerlink" title="离散小波变换进行2级分解的示例结构"></a>离散小波变换进行2级分解的示例结构</h2><p><img src="/2021/02/23/%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2/1.png"><br>where g[n] is a low pass filter and h[n] is a high pass filter</p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>伪迹移除</category>
      </categories>
      <tags>
        <tag>伪迹移除</tag>
        <tag>EEG</tag>
        <tag>小波变换</tag>
      </tags>
  </entry>
  <entry>
    <title>wxPython | 布局管理器嵌套</title>
    <url>/2021/08/03/%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8%E5%B5%8C%E5%A5%97/</url>
    <content><![CDATA[<h1 id="布局管理器嵌套"><a href="#布局管理器嵌套" class="headerlink" title="布局管理器嵌套"></a>布局管理器嵌套</h1><p><strong>实现效果：</strong><br>单击Button1按钮，显示“Button1单击”静态文本，单击Button2按钮，显示“Button2单击”静态文本。</p>
<p><strong>示例代码：</strong></p>
<h1 id="布局管理器嵌套-1"><a href="#布局管理器嵌套-1" class="headerlink" title="布局管理器嵌套"></a>布局管理器嵌套</h1><pre><code># coding=utf-8
import wx

class MyFrame(wx.Frame):
    def __init__(self):
        super().__init__(None, title=&quot;布局管理器嵌套&quot;, size=(300, 120))
        panel = wx.Panel(parent=self)
        self.static_text = wx.StaticText(parent=panel, label=&quot;请单击按钮&quot;)
        b1 = wx.Button(parent=panel, id=10, label=&#39;Button1&#39;)
        b2 = wx.Button(parent=panel, id=11, label=&#39;Button2&#39;)

        # 创建水平方向的盒子布局管理器hbox对象
        hbox = wx.BoxSizer(wx.HORIZONTAL)
        # 添加b1到hbox布局管理器
        hbox.Add(b1, proportion=1, flag=wx.EXPAND|wx.ALL, border=10)
        hbox.Add(b2, proportion=1, flag=wx.EXPAND|wx.ALL, border=10)

        # 创建垂直方向的盒子布局管理器对象vbox
        vbox = wx.BoxSizer(wx.VERTICAL)
        # 添加静态文本到vbox布局管理器
        vbox.Add(self.static_text, proportion=1, flag=wx.CENTER | wx.FIXED_MINSIZE | wx.TOP, border=10)
        # 将水平hbox布局管理器对象添加到垂直vbox布局管理器对象
        vbox.Add(hbox, proportion=1, flag=wx.CENTER)

        # 设置面板（panel）采用vbox布局管理器
        panel.SetSizer(vbox)

        # 将两个按钮（b1和b2）的单击事件绑定到self.on_click办法
        self.Bind(wx.EVT_BUTTON, self.on_click, id=10, id2=11)

    def on_click(self, event):
        event_id = event.GetId()
        print(event_id)
        if event_id == 10:
            self.static_text.SetLabelText(&#39;Button1单击&#39;)
        else:
            self.static_text.SetLabelText(&#39;Button2单击&#39;)


app = wx.App()  # 创建应用程序对象
frm = MyFrame()  # 创建窗口对象
frm.Show()  # 显示窗口
app.MainLoop()  # 进入主事件循环
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>wxPython</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>wxPython</tag>
      </tags>
  </entry>
  <entry>
    <title>入门指南 | 开发遇到问题怎么解决？</title>
    <url>/2021/02/20/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="开发遇到问题怎么解决？"><a href="#开发遇到问题怎么解决？" class="headerlink" title="开发遇到问题怎么解决？"></a>开发遇到问题怎么解决？</h1><p>我们在做开发的过程中常常会遇到这样、那样的问题，软件安装出错、配置出错、代码运行报错等等令人十分痛苦的问题，那么我们遇到问题时应该怎样去solve?<br><b>Answer:</b>我们在开发中遇到的百分之八九十的问题可以通过<br><b style="color:red">“官方文档+github+stack overflow”</b>去解决！</p>
]]></content>
      <categories>
        <category>入门指南</category>
      </categories>
  </entry>
  <entry>
    <title>基础知识 | 归一化</title>
    <url>/2021/02/21/%E5%BD%92%E4%B8%80%E5%8C%96/</url>
    <content><![CDATA[<h1 id="归一化-Normalization"><a href="#归一化-Normalization" class="headerlink" title="归一化(Normalization)"></a>归一化(Normalization)</h1><p>在使用机器学习算法进行分类工作时，有时候我们发现某个特征对计算结果的影响最大，然而本质上用于分类的几个特征是同等重要的，而某个特征对计算结果影响大这一现象的原因仅仅是因为这个特征的特征值值比其他特征值大。因此<b style="color:red">在处理这种不同范围的特征值时，我们通常采用的方法是将数值归一化</b>，如将取值范围处理为0到1/-1到1之间。<br><b>例</b>：将任意取值范围的特征值转化为0到1区间内的值:<br><b style="red">newValue = (oldValue - min)/(max-min)</b><br>其中min和max分别是数据集中的最小特征值和最大特征值<br><b>Note:改变数值范围增加了分类器的复杂度</b></p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>归一化</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 情绪识别想法与实践的起点</title>
    <url>/2021/07/02/%E6%83%85%E7%BB%AA%E8%AF%86%E5%88%AB%E6%83%B3%E6%B3%95%E4%B8%8E%E5%AE%9E%E8%B7%B5%E7%9A%84%E8%B5%B7%E7%82%B9/</url>
    <content><![CDATA[<h1 id="情绪识别想法与实践的起点"><a href="#情绪识别想法与实践的起点" class="headerlink" title="情绪识别想法与实践的起点"></a>情绪识别想法与实践的起点</h1><p>步入研一以来，about我的研究方向，一开始聚焦在脑电伪迹去除，大约看了10篇左右论文，后来在与给老师的汇报和交流中，关于研究方向<br>的keywords变成了：深度学习、脑电、分类、音乐、情绪识别，偶然我遇到了下面这篇论文，题目的每一个字都与我的research密切对应，<br>因此一场深度学习情绪分类的战役由此拉开。。。</p>
<p><b>Paper title:</b> Spatiotemporal Emotion Recognition using Deep CNN Based on EEG during Music Listening<br><a href="https://www.researchgate.net/publication/336736347_Spatiotemporal_Emotion_Recognition_using_Deep_CNN_Based_on_EEG_during_Music_Listening">论文地址</a></p>
<p>这篇论文的作者有几篇关于脑电情绪分类的研究文章，详细信息查看researchgate!<br><a href="https://www.researchgate.net/profile/Panayu-Keelawat">researcher researchgate site</a></p>
<h2 id="论文简要介绍"><a href="#论文简要介绍" class="headerlink" title="论文简要介绍"></a>论文简要介绍</h2><p><b>Considerations:</b><br>1.explore the model’s capabilities in varied window sizes and electrode orders<br>2.model’s complexity:(3conv ~ 6conv)</p>
<p><b>Results:</b><br>temporal information in distinct window sizes significantly affects recognition performance</p>
<p><b>Used Megthod:CNN</b><br>without mannually extracting features</p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>脑电分类</category>
        <category>CNN</category>
      </categories>
      <tags>
        <tag>脑电分类</tag>
        <tag>深度学习</tag>
        <tag>CNN</tag>
        <tag>EEG</tag>
        <tag>情绪识别</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 感知机</title>
    <url>/2021/06/24/%E6%84%9F%E7%9F%A5%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h1><p><a href="https://mp.weixin.qq.com/s/OKUCFdBLuwkJMxRz-gvthQ">点这里查看更多关于感知机的知识！！！</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>感知机</tag>
      </tags>
  </entry>
  <entry>
    <title>C# | 我的第一个CSharp程序</title>
    <url>/2021/07/03/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AACSharp%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="我的第一个CSharp程序"><a href="#我的第一个CSharp程序" class="headerlink" title="我的第一个CSharp程序"></a>我的第一个CSharp程序</h1><pre><code>using System;
/*包含 System 命名空间*/

/*声明命名空间*/
namespace project1
&#123;
    /*定义一个名为HelloWorld的类*/
    class HelloWorld
    &#123;
        /*我的第一个C#程序*/
        static void Main(String[] args)
        &#123;/*Main方法：C#程序的入口*/
            /*WriteLine 是一个定义在 System 命名空间中的 Console 类的一个方法*/
            Console.WriteLine(&quot;Hello World&quot;);
            Console.ReadKey();
        &#125;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 把隐藏层数量当做参数</title>
    <url>/2021/06/24/%E6%8A%8A%E9%9A%90%E8%97%8F%E5%B1%82%E6%95%B0%E9%87%8F%E5%BD%93%E5%81%9A%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h1 id="把隐藏层数量当做参数"><a href="#把隐藏层数量当做参数" class="headerlink" title="把隐藏层数量当做参数"></a>把隐藏层数量当做参数</h1><p>在搭建深度网络时，不一定非要使用很多隐藏层，在刚开始解决一个新问题时，通常可以从<br>logistic回归开始，再试试一到两个隐层，把隐藏层数量当做参数、超参数一样去调试，这样<br>去找比较合适的深度。</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithms | 折半查找</title>
    <url>/2021/05/24/%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h1 id="递归折半查找算法"><a href="#递归折半查找算法" class="headerlink" title="递归折半查找算法"></a>递归折半查找算法</h1><pre><code>def recursive_binary_search(arr, low, high, key):
        if low &lt;= high:
                mid = (low + high) // 2
            if arr[mid] == key:
                    return mid
            elif key &lt; arr[mid]:
                    return recursive_binary_search(arr, low, mid-1, key)
            else:
                    return recursive_binary_search(arr, mid+1, high, key)

        return -1
</code></pre>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>折半查找</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 括号生成</title>
    <url>/2021/09/05/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<h1 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22.括号生成"></a>22.括号生成</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。<br>有效括号组合需满足：左括号必须以正确的顺序闭合。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/generate-parentheses/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>1.暴力法</strong><br>可以生成所有 2^2n 个 ‘(‘ 和 ‘)’ 字符构成的序列，然后我们检查每一个是否有效即可。<br><strong>2.回溯法</strong><br>方法一还有改进的余地：我们可以只在序列仍然保持有效时才添加 ‘(‘ or ‘)’，而不是像 方法一 那样每次添加。我们可以通过跟踪到目前为止放置的左括号和右括号的数目来做到这一点，<br>如果左括号数量不大于 n，我们可以放一个左括号。如果右括号数量小于左括号的数量，我们可以放一个右括号。<br>3.按括号序列的长度递归</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>from functools import lru_cache

class Solution(object):
    def generateParenthesis(self, n):
        &quot;&quot;&quot;
        暴力法
        :type n: int
        :rtype: List[str]
        &quot;&quot;&quot;
        # 生成所有括号组合，然后判断是否是有效括号
        def generate(A):
            if len(A) == 2 * n:
                # print(A)
                if valid(A):
                    ans.append(&quot;&quot;.join(A))
            else:
                A.append(&#39;(&#39;)
                generate(A)
                A.pop()
                A.append(&#39;)&#39;)
                generate(A)
                A.pop()

        def valid(A):
            bal = 0  # 表示左括号的数量减去右括号的数量
            for c in A:
                if c == &#39;(&#39;:
                    bal += 1
                else:
                    bal -= 1

                if bal &lt; 0:
                    return False

            return bal == 0

        ans = []
        generate([])
        return ans

    def generateParenthesis1(self, n):
        &quot;&quot;&quot;
        回溯法

        对暴力解法的改进：
        只在序列仍然保持有效时才添加 &#39;(&#39; or &#39;)&#39;，而不是像 暴力解法 那样每次添加
        我们可以通过跟踪到目前为止放置的左括号和右括号的数目来做到这一点

        如果左括号数量不大于 n，我们可以放一个左括号
        如果右括号数量小于左括号的数量，我们可以放一个右括号
        &quot;&quot;&quot;
        def backtrack(S, left, right):
            if len(S) == 2 * n:
                ans.append(&#39;&#39;.join(S))
                return
            if left &lt; n:
                S.append(&#39;(&#39;)
                backtrack(S, left + 1, right)
                S.pop()
            if right &lt; left:
                S.append(&#39;)&#39;)
                backtrack(S, left, right + 1)
                S.pop()

        ans = []
        backtrack([], 0, 0)
        return ans


class Solution1:
    @lru_cache(None)
    def generateParenthesis(self, n: int):
        &quot;&quot;&quot;按括号序列的长度递归&quot;&quot;&quot;
        if n == 0:
            return [&#39;&#39;]
        ans = []
        for c in range(n):
            for left in self.generateParenthesis(c):
                for right in self.generateParenthesis(n-1-c):
                    ans.append(&#39;(&#123;&#125;)&#123;&#125;&#39;.format(left, right))
        return ans


if __name__ == &#39;__main__&#39;:
    slt = Solution1()
    parenthesis_list = slt.generateParenthesis(3)
    print(parenthesis_list)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>支持向量机</title>
    <url>/2021/03/20/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="支持向量机-Support-Vector-Machine-SVM"><a href="#支持向量机-Support-Vector-Machine-SVM" class="headerlink" title="支持向量机(Support Vector Machine,SVM)"></a>支持向量机(Support Vector Machine,SVM)</h1><p>支持向量机是我们用于分类的一种算法。</p>
<h2 id="小故事理解SVM"><a href="#小故事理解SVM" class="headerlink" title="小故事理解SVM:"></a>小故事理解SVM:</h2><p>当一个分类问题，数据是线性可分的，也就是用一根棍就可以将两种小球分开的时候，我们只要将棍的位置放在让小球距离棍的距离最大化的位置即可，寻找这个最大间隔的过程，就叫做最优化。但是，现实往往是很残酷的，一般的数据是线性不可分的，也就是找不到一个棍将两种小球很好的分类。这个时候，我们就需要像大侠一样，将小球拍起，用一张纸代替小棍将小球进行分类。想要让数据飞起，我们需要的东西就是核函数(kernel)，用于切分小球的纸，就是超平面。<br>问题是从线性可分延伸到线性不可分的</p>
<h2 id="线性SVM"><a href="#线性SVM" class="headerlink" title="线性SVM"></a>线性SVM</h2><p><img src="/2021/03/20/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/1.png"><br>上图中的(a)是已有的数据，红色和蓝色分别代表两个不同的类别。数据显然是线性可分的，但是将两类数据点分开的直线显然不止一条。上图的(b)和(c)分别给出了B、C两种不同的分类方案，其中黑色实线为分界线，术语称为“决策面”。每个决策面对应了一个线性分类器。虽然从分类结果上看，分类器A和分类器B的效果是相同的。但是他们的性能是有差距的，看下图：<br><img src="/2021/03/20/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/2.png"><br>在”决策面”不变的情况下，我又添加了一个红点。可以看到，分类器B依然能很好的分类结果，而分类器C则出现了分类错误。显然分类器B的”决策面”放置的位置优于分类器C的”决策面”放置的位置，SVM算法也是这么认为的，它的依据就是分类器B的分类间隔比分类器C的分类间隔大。这里涉及到第一个SVM独有的概念”分类间隔”。在保证决策面方向不变且不会出现错分样本的情况下移动决策面，会在原来的决策面两侧找到两个极限位置（越过该位置就会产生错分现象），如虚线所示。虚线的位置由决策面的方向和距离原决策面最近的几个样本的位置决定。而这两条平行虚线正中间的分界线就是在保持当前决策面方向不变的前提下的最优决策面。两条虚线之间的垂直距离就是这个最优决策面对应的分类间隔。显然每一个可能把数据集正确分开的方向都有一个最优决策面（有些方向无论如何移动决策面的位置也不可能将两类样本完全分开），而不同方向的最优决策面的分类间隔通常是不同的，那个具有“最大间隔”的决策面就是SVM要寻找的最优解。而这个真正的最优解对应的两侧虚线所穿过的样本点，就是SVM中的支持样本点，称为”支持向量”。</p>
<h2 id="数学建模"><a href="#数学建模" class="headerlink" title="数学建模"></a>数学建模</h2><p>决策面方程<br>分类间隔方程<br>约束条件</p>
<h2 id="最优化问题的两个基本因素："><a href="#最优化问题的两个基本因素：" class="headerlink" title="最优化问题的两个基本因素："></a>最优化问题的两个基本因素：</h2><p>1.目标函数 你希望什么东西的什么指标达到最好<br>2.优化对象 你期望通过改变哪些因素来使你的目标函数达到最优<br>Example:<br>在线性SVM算法中，目标函数就是分类间隔，优化对象就是决策面</p>
<h2 id="最优化问题的分类："><a href="#最优化问题的分类：" class="headerlink" title="最优化问题的分类："></a>最优化问题的分类：</h2><p>1.无约束优化问题 min f(x)<br>求解方法：费马大定理(求f(x)的导数，令其为0，求得候选最优值，再在这些候选值中验证；如果是凸函数，可以保证是最优解)<br>2.有等式约束的优化问题<br>min f(x)<br>s.t. hi(x)=0,i=1,2,…,n<br>求解方法：拉格朗日乘子法(把等式约束hi(x)用一个系数与f(x)写成一个式子，称为拉格朗日函数，而系数称为拉格朗日乘子。通过拉格朗日函数对各个变量求导，令其为0，求得候选值集合，然后验证求得最优值)<br>3.有不等式约束的优化问题<br>min f(x)<br>s.t. gi(x)&lt;=0,i=1,2,…,n<br>hj(x)=0,j=1,2,…,m<br>求解方法：拉格朗日+KKT条件 把所有的等式、不等式约束与f(x)写成一个式子，也叫拉格朗日函数，系数也称为拉格朗日乘子，通过一些条件可以求出最优值的必要条件，这个条件称为KKT条件。</p>
<p>KKT条件的全称是Karush-Kuhn-Tucker条件，KKT条件是说最优值条件必须满足以下条件：<br>条件一：经过拉格朗日函数处理之后的新目标函数L(w,b,α)对x求导为零：<br>条件二：h(x) = 0；<br>条件三：α*g(x) = 0；</p>
<p><b>使用拉格朗日方程的目的：</b><br>将约束条件放到目标函数中，将有约束优化问题转换为无约束优化问题（我们知道我们要求解的是最小化问题，所以一个直观的想法是如果我能够构造一个函数，使得该函数在可行解区域内与原目标函数完全一致，而在可行解区域外的数值非常大，甚至是无穷大，那么这个没有约束条件的新目标函数的优化问题就与原来有约束条件的原始目标函数的优化问题是等价的问题。）</p>
<p>使用拉格朗日获得的函数使用求导方法求解依然困难，进而需要对问题进行一次转换，即使用一个数学技巧：拉格朗日对偶(将最小值和最大值的计算位置交换)</p>
<p><b>拉个朗日优化问题的两个步骤：</b><br>1.将有约束的原始目标函数转换为无约束的新构造的拉格朗日目标函数<br>2.使用拉格朗日对偶性，将不易求解的优化问题转化为容易求解的优化问题</p>
<p><b>求解对偶问题的三个步骤：</b><br>1.首先要让L(w,b,α)关于w和b最小化<br>2.求对α的极大<br>3.利用SMO算法求解对偶问题中的拉格朗日乘子</p>
<h2 id="SMO算法"><a href="#SMO算法" class="headerlink" title="SMO算法"></a>SMO算法</h2><p>1996年，John Platt发布了一个称为SMO的强大算法，用于训练SVM。SMO表示序列最小化(Sequential Minimal Optimizaion)。Platt的SMO算法是将大优化问题分解为多个小优化问题来求解的。这些小优化问题往往很容易求解，并且对它们进行顺序求解的结果与将它们作为整体来求解的结果完全一致的。在结果完全相同的同时，SMO算法的求解时间短很多。</p>
<p><b>SMO算法的目标:</b><br>求出一系列alpha和b，一旦求出了这些alpha，就很容易计算出权重向量w并得到分隔超平面。</p>
<p><b>SMO算法的工作原理是：</b><br>每次循环中选择两个alpha进行优化处理。一旦找到了一对合适的alpha，那么就增大其中一个同时减小另一个。这里所谓的”合适”就是指两个alpha必须符合以下两个条件，条件之一就是两个alpha必须要在间隔边界之外，而且第二个条件则是这两个alpha还没有进行过区间化处理或者不在边界上。</p>
<p><b>注意：</b><br>实际上，对于目标函数，是存在一个假设(数据100%线性可分)的，但现实中的数据都不那么干净，这时我们就可以通过引入松弛变量ξ(slack variable)和惩罚参数C来允许有些数据点可以处于超平面的错误的一侧—&gt;约束条件的改变—&gt;目标函数的改变</p>
<h2 id="SMO算法优化"><a href="#SMO算法优化" class="headerlink" title="SMO算法优化"></a>SMO算法优化</h2><p>启发式选择第二个alpha值</p>
<h2 id="非线性SVM"><a href="#非线性SVM" class="headerlink" title="非线性SVM"></a>非线性SVM</h2><h3 id="核技巧"><a href="#核技巧" class="headerlink" title="核技巧"></a>核技巧</h3><p>对于非线性情况：SVM的处理方式是选择一个核函数。简而言之：在线性不可分的情况下，SVM通过某种事先选择的非线性映射（核函数）将输入变量映到一个高维特征空间，将其变成在高维空间线性可分，在这个高维空间中构造最优分类超平面。</p>
<h3 id="建立非线性学习器分为两步："><a href="#建立非线性学习器分为两步：" class="headerlink" title="建立非线性学习器分为两步："></a>建立非线性学习器分为两步：</h3><p>1.首先使用一个非线性映射将数据变换到一个特征空间F；<br>2.然后在特征空间使用线性学习器分类。</p>
<h3 id="核函数方法"><a href="#核函数方法" class="headerlink" title="核函数方法"></a>核函数方法</h3><p>在特征空间中直接计算内积 &lt;ϕ(xi),ϕ(x)&gt;的方法称为核函数方法</p>
<p>核是一个函数k，对所有x,z∈X，满足k(x,z)=&lt;ϕ(xi),ϕ(x)&gt;，这里ϕ(·)是从原始输入空间X到内积空间F的映射。</p>
<p>简而言之：如果不是用核技术，就会先计算线性映ϕ(x1)和ϕ(x2)，然后计算这它们的内积，使用了核技术之后，先把ϕ(x1)和ϕ(x2)的一般表达式&lt;ϕ(x1),ϕ(x2)&gt;=k(&lt;ϕ(x1),ϕ(x2) &gt;)计算出来，这里的&lt;·，·&gt;表示内积，k(·，·)就是对应的核函数</p>
<p>将内积替换成核函数的方式被称为核技巧(kernel trick)。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="SVM的优缺点"><a href="#SVM的优缺点" class="headerlink" title="SVM的优缺点"></a>SVM的优缺点</h3><p>优点：<br>1.可用于线性/非线性分类，也可以用于回归，泛化错误率低，也就是说具有良好的学习能力，且学到的结果具有很好的推广性。<br>2.可以解决小样本情况下的机器学习问题，可以解决高维问题，可以避免神经网络结构选择和局部极小点问题。<br>3.SVM是最好的现成的分类器，现成是指不加修改可直接使用。并且能够得到较低的错误率，SVM可以对训练集之外的数据点做很好的分类决策。</p>
<p>缺点：对参数调节和和函数的选择敏感。</p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>SVM</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>SVM</tag>
        <tag>支持向量机</tag>
      </tags>
  </entry>
  <entry>
    <title>数据中的缺失值的处理</title>
    <url>/2021/03/19/%E6%95%B0%E6%8D%AE%E4%B8%AD%E7%9A%84%E7%BC%BA%E5%A4%B1%E5%80%BC%E7%9A%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="数据中的缺失值的处理"><a href="#数据中的缺失值的处理" class="headerlink" title="数据中的缺失值的处理"></a>数据中的缺失值的处理</h1><p>1.使用可用特征的均值来填补缺失值；<br>2.使用特殊值来填补缺失值，如-1；<br>3.忽略有缺失值的样本；<br>4.使用相似样本的均值添补缺失值；<br>5.使用另外的机器学习算法预测缺失值。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>数据缺失值处理</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 旋转链表</title>
    <url>/2021/08/27/%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61.旋转链表"></a>61.旋转链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/rotate-list/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>方法一：</strong> 闭合为环<br>记给定链表的长度为 n，注意到当向右移动的次数 k≥n 时，我们仅需要向右移动 k mod n 次即可。因为每 n 次移动都会让链表变为原状。这样我们可以知道，新链表的最后一个节点为原链表的第 (n−1)−(k mod n) 个节点（从 0 开始计数）。<br>这样，我们可以先将给定的链表连接成环，然后将指定位置断开。<br>具体代码中，我们首先计算出链表的长度 n，并找到该链表的末尾节点，将其与头节点相连。这样就得到了闭合为环的链表。然后我们找到新链表的最后一个节点（即原链表的第 (n−1)−(k mod n) 个节点），将当前闭合为环的链表断开，即可得到我们所需要的结果。<br><strong>方法二：</strong> 将后k个节点移到前n-k个节点之前（n为链表长度）<br><strong>特别地，当链表长度不大于 1，或者 k 为 n 的倍数时，新链表将与原链表相同，我们无需进行任何处理。</strong></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def rotateRight(self, head, k):
        &quot;&quot;&quot;
        :type head: ListNode
        :type k: int
        :rtype: ListNode
        &quot;&quot;&quot;
        # 如果链表为空直接返回head
        # 如果右旋转的次数为0直接返回head
        if head is None or head.next is None or k == 0 :
            return head

        # 统计head链表的长度
        p1 = head
        count = 0
        while p1:
            count += 1
            p1 = p1.next

        # 如果链表只有一个节点，直接返回head
        # 如果右旋转次数除以链表长度的余数为0,直接返回head
        if k % count == 0:
            return head

        i = 0
        p2 = head
        k = k % count  # 去掉整圈的旋转
        while i &lt; count - k - 1:  # 找到后k个节点的前一个节点
            p2 = p2.next
            i += 1
        second = p2.next  # second为后k个节点组成的链表
        p2.next = None  # 将前count - k个节点的最后一个节点的next值置空

        p3 = second
        while p3.next is not None:  # 找到后k个节点组成的链表的最后一个节点
            p3 = p3.next

        p3.next = head  # 将后k个节点组成的链表与前count-k个节点组成的链表连接起来

        return second

    def rotateRight1(self, head, k):
        &quot;&quot;&quot;
        :type head: ListNode
        :type k: int
        :rtype: ListNode
        &quot;&quot;&quot;
        if k == 0 or not head or not head.next:
            return head

        # 求链表长度
        n = 1
        cur = head
        while cur.next:
            cur = cur.next
            n += 1

        add = n - k % n
        if add == n:
            return head

        # 链表闭合成环
        cur.next = head
        while add:
            cur = cur.next
            add -= 1

        ret = cur.next
        cur.next = None  # 将闭合为环的链表断开
        return ret

    def create_linked_list(self, list):
        &quot;&quot;&quot;根据list中的所有元素构建单链表&quot;&quot;&quot;
        l = ListNode()  # 单链表头节点
        r = l  # 起始尾指针r指向头节点
        for e in list:
            node = ListNode(e)
            r.next = node
            r = r.next

        return l.next

    def print_linked_list(self, linked_list) -&gt; None:
        &quot;&quot;&quot;
        打印单链表中的所有元素

        :param linked_list: 单链表
        :return: 无
        &quot;&quot;&quot;
        print(&quot;----------------------------------------&quot;)
        pointer = linked_list
        while pointer is not None:
            print(pointer.val)
            pointer = pointer.next


if __name__ == &quot;__main__&quot;:
    slt = Solution()

    linked_list = slt.create_linked_list([1, 2])

    slt.print_linked_list(linked_list)

    rotated_linked_list = slt.rotateRight1(linked_list, 2)

    slt.print_linked_list(rotated_linked_list)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 无重复字符的最长子串</title>
    <url>/2021/08/27/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a>3.无重复字符的最长子串</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>找出字符串中所有不包含重复字符的字串,返回长度最长的一个子串</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def lengthOfLongestSubstring(self, s: str) -&gt; int:
        &quot;&quot;&quot;找出字符串中所有不包含重复字符的字串,返回长度最长的一个子串&quot;&quot;&quot;
        s_list = list(s)  # 将字符串转化为列表
        max_length = 0  # 最大字串长度

        # 找出以字符串中的每个字母开头的不包含重复字符的字串
        for i in range(0, len(s_list)):
            sub_str_list = []
            sub_str_list.append(s_list[i])
            for j in range(i + 1, len(s_list)):
                if s_list[j] not in sub_str_list:
                    sub_str_list.append(s_list[j])
                else:  # 遇到字串中已有的字符,则结束当前子串的寻找
                    break
            # print(&quot;sub_str_list:&quot;, sub_str_list)

            if len(sub_str_list) &gt; max_length:
                max_length = len(sub_str_list)
                # print(&quot;max_length:&quot;, max_length)
                sub_str = &quot;&quot;
                for e in sub_str_list:
                    sub_str += e
                # print(&quot;sub_str:&quot;, sub_str)
                # print(&quot;long_sub_str:&quot;, sub_str)

        print(&quot;无重复字符的最长字串是&#123;&#125;,长度为&#123;&#125;&quot;.format(sub_str, max_length))

        return max_length

    def lengthOfLongestSubstring1(self, s: str) -&gt; int:
        # 哈希集合，记录每个字符是否出现过
        occ = set()
        n = len(s)
        # 右指针，初始值为-1，相当于我们在字符串的左边界的左侧，还没有开始移动
        rk, ans = -1, 0
        for i in range(n):
            if i != 0:
                # 左指针向右移动一格，移动一个字符
                occ.remove(s[i - 1])
            while rk + 1 &lt; n and s[rk + 1] not in occ:
                # 不断地移动右指针
                occ.add(s[rk + 1])
                rk += 1
            # 第i到rk个字符是一个极长的无重复字符字串
            ans = max(ans, rk - i + 1)
        return ans


if __name__ == &quot;__main__&quot;:
    s = &quot;pwwkew&quot;
    slt = Solution()
    len_long_sub_str = slt.lengthOfLongestSubstring1(s)
    print(len_long_sub_str)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>伪迹移除 | 时频表示</title>
    <url>/2021/02/23/%E6%97%B6%E9%A2%91%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<h1 id="时频表示-Time-Frequency-Representation"><a href="#时频表示-Time-Frequency-Representation" class="headerlink" title="时频表示(Time Frequency Representation)"></a>时频表示(Time Frequency Representation)</h1><p>时频表示基于短时傅里叶变换(Short-Time Fourier Transfrom,STFT)。</p>
<h2 id="同时使用时间、频率域分析的原因："><a href="#同时使用时间、频率域分析的原因：" class="headerlink" title="同时使用时间、频率域分析的原因："></a>同时使用时间、频率域分析的原因：</h2><p>脑电信号的非稳定特性</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>在所有的频率范围有统一的时频分辨率，然而我们感兴趣的脑电的频率通常小于30Hz,很多伪迹的频率小于10Hz，这就需要在低频范围有STFT(短时傅里叶变换)不能提供的高频分辨率。</p>
<h2 id="问题的解决"><a href="#问题的解决" class="headerlink" title="问题的解决"></a>问题的解决</h2><p>采用基于小波的方法-小波变换（适合为脑电信号的每一个频带提供相应的分辨率）</p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>伪迹移除</category>
      </categories>
      <tags>
        <tag>EEG</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 最小栈</title>
    <url>/2021/08/27/%E6%9C%80%E5%B0%8F%E6%A0%88/</url>
    <content><![CDATA[<h1 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155.最小栈"></a>155.最小栈</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。<br>    push(x) —— 将元素 x 推入栈中。<br>    pop() —— 删除栈顶的元素。<br>    top() —— 获取栈顶元素。<br>    getMin() —— 检索栈中的最小元素。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/min-stack/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>栈的性质：先进后出</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class MinStack(object):
    def __init__(self):
        &quot;&quot;&quot;
        initialize your data structure here.
        &quot;&quot;&quot;
        self.stack = list()

    def push(self, val):
        &quot;&quot;&quot;
        :type val: int
        :rtype: None
        &quot;&quot;&quot;
        self.stack.append(val)

    def pop(self):
        &quot;&quot;&quot;
        :rtype: None
        &quot;&quot;&quot;
        if len(self.stack) != 0:
            self.stack.pop()

    def top(self):
        &quot;&quot;&quot;
        :rtype: int
        &quot;&quot;&quot;
        if len(self.stack) != 0:
            return self.stack[-1]

    def getMin(self):
        &quot;&quot;&quot;
        :rtype: int
        &quot;&quot;&quot;
        if len(self.stack) != 0:
            return min(self.stack)

# Your MinStack object will be instantiated and called as such:
# obj = MinStack()
# obj.push(val)
# obj.pop()
# param_3 = obj.top()
# param_4 = obj.getMin()

import math

class MinStack1:
    &quot;&quot;&quot;辅助栈&quot;&quot;&quot;
    def __init__(self):
        self.stack = []
        self.min_stack = [math.inf]

    def push(self, x: int) -&gt; None:
        self.stack.append(x)
        self.min_stack.append(min(x, self.min_stack[-1]))

    def pop(self) -&gt; None:
        self.stack.pop()
        self.min_stack.pop()

    def top(self) -&gt; int:
        return self.stack[-1]

    def getMin(self) -&gt; int:
        return self.min_stack[-1]



if __name__ == &quot;__main__&quot;:
    # min_stack = MinStack()
    min_stack = MinStack1()
    min_stack.push(-2)
    min_stack.push(0)
    min_stack.push(-3)
    print(min_stack.getMin())
    min_stack.pop()
    print(min_stack.top())
    print(min_stack.getMin())
    print(math.inf)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 最简单的神经网络</title>
    <url>/2021/06/20/%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="最简单的神经网络"><a href="#最简单的神经网络" class="headerlink" title="最简单的神经网络"></a>最简单的神经网络</h1><p><img src="/2021/06/20/%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/1.png"></p>
<p>其中：X为神经网络的输入 Y为神经网络的输出<br>描述：输入X通过一个节点（一个单独的神经元），最终输出Y<br>例：把房屋的面积作为神经网络的输入，通过一个神经元，最终输出了房屋的价格</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 最长公共前缀</title>
    <url>/2021/08/27/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
    <content><![CDATA[<h1 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14.最长公共前缀"></a>14.最长公共前缀</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。<br>如果不存在公共前缀，返回空字符串 “”。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/longest-common-prefix/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.横向扫描<br>用 LCP(S1…Sn)\textit{LCP}(S_1 \ldots S_n)LCP(S1​…Sn​) 表示字符串 S1…SnS_1 \ldots S_nS1​…Sn​ 的最长公共前缀。<br>可以得到以下结论：<br>LCP(S1…Sn)=LCP(LCP(LCP(S1,S2),S3),…Sn)<br>基于该结论，可以得到一种查找字符串数组中的最长公共前缀的简单方法。依次遍历字符串数组中的每个字符串，对于每个遍历到的字符串，更新最长公共前缀，当遍历完所有的字符串以后，即可得到字符串数组中的最长公共前缀。<br>如果在尚未遍历完所有的字符串时，最长公共前缀已经是空串，则最长公共前缀一定是空串，因此不需要继续遍历剩下的字符串，直接返回空串即可。<br>2.纵向扫描<br>纵向扫描时，从前往后遍历所有字符串的每一列，比较相同列上的字符是否相同，如果相同则继续对下一列进行比较，如果不相同则当前列不再属于公共前缀，当前列之前的部分为最长公共前缀。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def longestCommonPrefix(self, strs) -&gt; str:
        if not strs:
            return &quot;&quot;

        prefix, count = strs[0], len(strs)
        for i in range(1, count):
            prefix = self.lcp(prefix, strs[i])
            if not prefix:
                break

        return prefix

    def lcp(self, str1, str2):
        length, index = min(len(str1), len(str2)), 0
        while index &lt; length and str1[index] == str2[index]:
            index += 1

        return str1[:index]

    def longestCommonPrefix1(self, strs) -&gt; str:
        if not strs:
            return &#39;&#39;

        length, count = len(strs[0]), len(strs)
        for i in range(length):
            c = strs[0][i]
            for j in range(1, count):
                if i == len(strs[j]) or strs[j][i] != c:
                    return strs[0][:i]

        return strs[0]


if __name__ == &quot;__main__&quot;:
    slt = Solution()

    # strs = [&quot;&quot;]
    # strs = [&quot;&quot;, &quot;&quot;]
    # strs = [&#39;ab&#39;, &#39;a&#39;]
    # strs = [&quot;dog&quot;, &quot;racecar&quot;, &quot;car&quot;]
    # strs = [&#39;abcd&#39;, &#39;abcf&#39;, &#39;abcde&#39;]
    strs = [&quot;flower&quot;, &quot;flow&quot;, &quot;flight&quot;]

    prefix = slt.longestCommonPrefix1(strs)
    print(&quot;当前&#123;&#125;个字符串的最长公共前缀为：&#123;&#125;&quot;.format(len(strs), prefix))
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 最长回文串</title>
    <url>/2021/09/03/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="5-最长回文串"><a href="#5-最长回文串" class="headerlink" title="5.最长回文串"></a>5.最长回文串</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 s，找到 s 中最长的回文子串。</p>
<span id="more"></span>
<p>示例 1：<br>输入：s = “babad”<br>输出：”bab”<br>解释：”aba” 同样是符合题意的答案。</p>
<p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.暴力解法<br><strong>2.动态规划</strong><br><strong>3.中心扩展算法</strong><br>4.Manacher 算法<br>注：算法详情请参考leetcode题解</p>
<p><a href="https://writings.sh/post/algorithm-longest-palindromic-substring">几种方法的总结！！！强烈推荐！！！</a></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def longestPalindrome(self, s: str) -&gt; str:
        &quot;&quot;&quot;暴力解法（超出时间限制）&quot;&quot;&quot;
        # max_len = 0
        # longest_palindrome = &quot;&quot;
        # for i in range(0, len(s)):
        #     for j in range(i+1, len(s)+1):
        #         string = s[i:j]
        #         # print(string)
        #         if self.isPalindrome(string):
        #             if len(string) &gt; max_len:
        #                 max_len = len(string)
        #                 longest_palindrome = string
        #
        # return longest_palindrome

        len_s = len(s)
        if len_s &lt; 2:
            return s

        max_len = 1
        begin = 0
        # 枚举所有长度严格大于1的字串
        for i in range(0, len_s-1):
            for j in range(i + 1, len_s):
                if j - i + 1 &gt; max_len and self.isPalindrome(s[i: j+1]):
                    max_len = j - i + 1
                    begin = i

        return s[begin:begin + max_len]

    def isPalindrome(self, s: str) -&gt; bool:
        &quot;&quot;&quot;
        筛选+判断（判断反转字符串是否与原字符串相同）
        &quot;&quot;&quot;
        new_s = &quot;&quot;.join(ch.lower() for ch in s if ch.isalnum())
        return new_s == new_s[::-1]

    def longestPalindrome1(self, s: str) -&gt; str:
        &quot;&quot;&quot;
        动态规划算法

        一个回文串去掉两头以后，剩下的部分依然是回文

        -状态：dp[i][j]表示字串s[i..j]是否为回文子串
        -得到状态转移方程：dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]
         边界条件：j - 1 - (i + 1) + 1 &lt; 2,整理得j - i &lt; 3 &lt;===&gt; j - i + 1 &lt; 4
         (s[i][j]长度为2或者3时，不用检查字串是否回文)
        -初始化：dp[i][i] = true
        -输出：在得到一个状态的值为true的时候，记录起始位置和长度，填表完成以后再截取

        状态转移方程：dp[i][j] = (s[i] == s[j]) and (j - i &lt; 3 or dp[i + 1][j - 1]
        &quot;&quot;&quot;
        n = len(s)
        if n &lt; 2:
            return s

        max_len = 1
        begin = 0

        # dp[i][j]表示s[i..j]是否是回文串
        dp = [[False] * n for _ in range(n)]
        for i in range(n):
            dp[i][i] = True

        # 注意：先填左下角
        for j in range(1, n):
            for i in range(0, j):
                if s[i] != s[j]:
                    dp[i][j] = False
                else:
                    if j - i &lt; 3:
                        dp[i][j] = True
                    else:
                        dp[i][j] = dp[i + 1][j-1]

                # 只要 dp[i][j] == true 成立，就表示子串 s[i..j] 是回文，此时记录回文长度和起始位置
                if dp[i][j] and j - i + 1 &gt; max_len:
                    max_len = j - i + 1
                    begin = i
        return s[begin:begin + max_len]

    def longestPalindrome2(self, s: str) -&gt; str:
        &quot;&quot;&quot;中心扩展算法&quot;&quot;&quot;
        start = 0  # 最长回文串的起始位置
        end = 0  # 最长回文串的结束位置
        for i in range(len(s)):
            left1, right1 = self.expandAroundCenter(s, i, i)  # 边界情况1：子串长度为1的情况
            left2, right2 = self.expandAroundCenter(s, i, i + 1)  # # 边界情况2：子串长度为2的情况
            if right1 - left1 &gt; end - start:  # 扩展的新回文串长度大于当前最长回文串
                start, end = left1, right1
            if right2 - left2 &gt; end - start:
                start, end = left2, right2
        return s[start:end + 1]

    def expandAroundCenter(self, s, left, right):
        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return left + 1, right - 1

    def expand(self, s, left, right):
        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return (right - left - 2) // 2

    def longestPalindrome3(self, s: str) -&gt; str:
        &quot;&quot;&quot;Manacher 算法&quot;&quot;&quot;
        end = -1
        start = 0
        s = &#39;#&#39; + &#39;#&#39;.join(list(s)) + &#39;#&#39;
        arm_len = []
        right = -1
        j = -1
        for i in range(len(s)):
            if right &gt;= i:
                i_sym = 2 * j - i
                min_arm_len = min(arm_len[i_sym], right - i)
                cur_arm_len = self.expand(s, i - min_arm_len, i + min_arm_len)
            else:
                cur_arm_len = self.expand(s, i, i)
            arm_len.append(cur_arm_len)
            if i + cur_arm_len &gt; right:
                j = i
                right = i + cur_arm_len
            if 2 * cur_arm_len + 1 &gt; end - start:
                start = i - cur_arm_len
                end = i + cur_arm_len
        return s[start + 1:end + 1:2]


if __name__ == &#39;__main__&#39;:
    slt = Solution()
    s = &quot;abad&quot;
    res = slt.longestPalindrome(s)
    print(&quot;最长的回文串为：&quot;, res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 最长特殊序列</title>
    <url>/2021/09/01/%E6%9C%80%E9%95%BF%E7%89%B9%E6%AE%8A%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="521-最长特殊序列"><a href="#521-最长特殊序列" class="headerlink" title="521.最长特殊序列"></a>521.最长特殊序列</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两个字符串，请你从这两个字符串中找出最长的特殊序列。<br>「最长特殊序列」定义如下：该序列为某字符串独有的最长子序列（即不能是其他字符串的子序列）。<br>子序列 可以通过删去字符串中的某些字符实现，但不能改变剩余字符的相对顺序。空序列为所有字符串的子序列，任何字符串为其自身的子序列。<br>输入为两个字符串，输出最长特殊序列的长度。如果不存在，则返回 -1。</p>
<span id="more"></span>
<p>刷到这道题目时我表示有点没看懂，然后就看了leetcode的评论，也有许多人没看懂，最后就看了题解。。。<br>我认为，本题按照leetcode官方题解解法二的解决方案容易理解。</p>
<p><a href="https://leetcode-cn.com/problems/longest-uncommon-subsequence-i/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>字符串 aaa 和 bbb 共有 3 种情况：<br>    a=b。如果两个字符串相同，则没有特殊子序列，返回 -1。<br>    length(a)=length(b) 且 a≠b。例如：abc 和 abd。这种情况下，一个字符串一定不会是另外一个字符串的子序列，因此可以将任意一个字符串看作是特殊子序列，返回 length(a) 或 length(b)。<br>    length(a)≠length(b)。例如：abcd 和 abc。这种情况下，长的字符串一定不会是短字符串的子序列，因此可以将长字符串看作是特殊子序列，返回 max(length(a),length(b))。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def findLUSlength(self, a: str, b: str) -&gt; int:
        if a == b:
            return -1

        return max(len(a), len(b))


if __name__ == &quot;__main__&quot;:
    slt = Solution()
    a = &quot;aaa&quot;
    b = &quot;bbb&quot;
    res = slt.findLUSlength(a, b)
    print(res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>有效的括号</title>
    <url>/2021/08/27/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。<br>有效字符串需满足：<br>    左括号必须用相同类型的右括号闭合。<br>    左括号必须以正确的顺序闭合。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/valid-parentheses/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>遍历字符串，遇到右括号将右括号入栈，遇到左括号判断此左括号是否与栈顶括号相同，若相同则将栈顶元素出栈，…，最后在遍历结束后判断栈是否为空，若为空则为有效括号。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):
    def isValid(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: bool
        &quot;&quot;&quot;
        if len(s) % 2 == 1:
            return False

        stack = []
        for ch in s:
            if ch == &#39;(&#39; or ch == &#39;[&#39; or ch == &#39;&#123;&#39;:
                stack.append(ch)
            elif ch == &#39;)&#39; and len(stack) != 0:
                    if stack[-1] == &#39;(&#39;:
                        stack.pop()
                    else:
                        return False
            elif ch == &#39;]&#39; and len(stack) != 0:
                    if stack[-1] == &#39;[&#39;:
                        stack.pop()
                    else:
                        return False
            elif ch == &#39;&#125;&#39; and len(stack) != 0:
                    if stack[-1] == &#39;&#123;&#39;:
                        stack.pop()
                    else:
                        return False
            else:
                return False

        if len(stack) == 0:
            return True
        else:
            return False

    def isValid1(self, s):
        if len(s) % 2 == 1:
            return False

        pairs = &#123;
            &quot;)&quot;: &quot;(&quot;,
            &quot;]&quot;: &quot;[&quot;,
            &quot;&#125;&quot;: &quot;&#123;&quot;
        &#125;
        stack = list()
        for ch in s:
            if ch in pairs:
                if not stack or stack[-1] != pairs[ch]:
                    return False
                stack.pop()
            else:
                stack.append(ch)

        return not stack




if __name__ == &quot;__main__&quot;:
    slt = Solution()
    # s = &quot;()&quot;
    # s = &quot;()[]&#123;&#125;&quot;
    # s = &quot;(]&quot;
    # s = &quot;([)]&quot;
    # s = &quot;&#123;[]&#125;&quot;
    s = &quot;]&quot;
    ret = slt.isValid1(s)
    print(ret)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>本地与服务器互传文件</title>
    <url>/2021/04/18/%E6%9C%AC%E5%9C%B0%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BA%92%E4%BC%A0%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="本地与服务器互传文件"><a href="#本地与服务器互传文件" class="headerlink" title="本地与服务器互传文件"></a>本地与服务器互传文件</h1><p>命令安装：yum install lrzsz</p>
<p>从服务器发送文件到客户端： sz filename</p>
<p>从客户端上传文件到服务端： rz</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习 | 朴素贝叶斯</title>
    <url>/2021/03/05/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/</url>
    <content><![CDATA[<h1 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h1><p>朴素贝叶斯算法(Naive Bayes)是<b>有监督(supervised)</b>的学习算法，解决的是<b>分类</b>问题(例如：客户是否流失、是否值得投资、信用等级评定等<b>多分类</b>问题)</p>
<span id="more"></span>
<h2 id="朴素贝叶斯理论"><a href="#朴素贝叶斯理论" class="headerlink" title="朴素贝叶斯理论"></a>朴素贝叶斯理论</h2><p><b style="color:red">朴素贝叶斯理论的核心思想：选择具有最高概率的决策</b></p>
<p>假设现在我们用p1(x,y)表示数据点(x,y)属于类别1的概率，用p2(x,y)表示数据点(x,y)属于类别2的概率，那么对于一个新的数据点，可以用以下规则来进行判断：</p>
<li>如果p1(x,y) > p2(x,y),那么类别为1</li>
<li>如果p1(x,y) < p2(x,y),那么类别为2</li>

<h2 id="条件概率-Conditional-probability"><a href="#条件概率-Conditional-probability" class="headerlink" title="条件概率(Conditional probability)"></a>条件概率(Conditional probability)</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>条件概率指在事件B发生的情况下，事件A发生的概率，用P(A|B)来表示。</p>
<h3 id="条件概率计算公式"><a href="#条件概率计算公式" class="headerlink" title="条件概率计算公式"></a>条件概率计算公式</h3><p><b style="color:red">P(A|B)=P(B|A)P(A)/P(B)</b></p>
<h2 id="全概率公式"><a href="#全概率公式" class="headerlink" title="全概率公式"></a>全概率公式</h2><p><img src="/2021/03/05/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/1.jpg"><br>全概率公式：<br><img src="/2021/03/05/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/2.jpg"><br>条件概率的另一种写法：<br><img src="/2021/03/05/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/3.jpg"></p>
<h2 id="贝叶斯推断"><a href="#贝叶斯推断" class="headerlink" title="贝叶斯推断"></a>贝叶斯推断</h2><p>对条件概率公式进行变形，得到：<br><img src="/2021/03/05/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/4.jpg"><br>其中，P(A)称为“<b>先验概率</b>”(Prior probability),即在B事件发生之前，我们对A事件概率的一个判断。<br><br>P(A|B)称为“<b>后验概率</b>”，即在B事件发生之后，我们对A事件概率的重新判断。<br><br>P(B|A)/P(B)称为“可能性函数”，即调整因子，使得预估概率更接近真实概率。可能性函数&gt;1：意味着先验概率被增强，事件A发生的可能性变大；可能性函数=1：意味着B事件无助于判断事件A的可能性；可能性函数&lt;1:意味着先验概率被削弱，事件A的可能性变小</p>
<p>因此，我们可以把条件概率理解成：<br><b>后验概率 = 先验概率 * 调整因子</b></p>
<p><b style="color:red">贝叶斯推断的含义：我们先预估一个“先验概率”，然后加入实验结果，看这个实验结果到底是增强还是削弱了“先验概率”，由此得到更接近事实的”后验概率”</b></p>
<h2 id="朴素贝叶斯推断"><a href="#朴素贝叶斯推断" class="headerlink" title="朴素贝叶斯推断"></a>朴素贝叶斯推断</h2><p>贝叶斯和朴素贝叶斯的概念是不同的，区别就在于“朴素”二字，朴素贝叶斯对条件概率分布做了条件独立性的假设。<br></p>
<p>假设有n个特征：<br><img src="/2021/03/05/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/5.jpg"><br>由于每个特征都是独立的，故：<br><img src="/2021/03/05/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/6.jpg"></p>
<h2 id="朴素贝叶斯改进之拉普拉斯平滑"><a href="#朴素贝叶斯改进之拉普拉斯平滑" class="headerlink" title="朴素贝叶斯改进之拉普拉斯平滑"></a>朴素贝叶斯改进之拉普拉斯平滑</h2><p>1.利用贝叶斯分类器进行分类时，要计算多个概率的乘积，如果其中有一个概率值为0，那么最后的结果为0。<br>solution:拉普拉斯平滑(Laplace Smoothing)-加一平滑(比较常用的平滑方法，可以解决0概率问题)<br>2.很多很小的数相乘，造成下溢出<br>solution:可以通过求对数避免下溢出或浮点数舍入导致的错误</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="朴素贝叶斯推断的一些优点："><a href="#朴素贝叶斯推断的一些优点：" class="headerlink" title="朴素贝叶斯推断的一些优点："></a>朴素贝叶斯推断的一些优点：</h3><li>生成式模型，通过计算概率来进行分类，可以用来处理<b>多分类问题</b></li>
<li>对小规模数据表现很好，适合<b>多分类任务</b>，适合增量式训练，算法也比较简单</li>
<li>简单易懂、学习效率高，在某些领域的分类问题中能够与决策树、神经网络相媲美</li>

<h3 id="朴素贝叶斯推断的一些缺点："><a href="#朴素贝叶斯推断的一些缺点：" class="headerlink" title="朴素贝叶斯推断的一些缺点："></a>朴素贝叶斯推断的一些缺点：</h3><li>对输入数据的表现形式敏感</li>
<li>由于朴素贝叶斯的“朴素”特点(算法以自变量之间的独立性(条件特征独立)和连续变量的正态性假设为前提)，所以会带来一些准确率上的损失</li>
<li>需要计算先验概率，分类决策存在错误率</li>

<p><a href="https://cuijiahua.com/blog/2017/11/ml_4_bayes_1.html">参考资源1</a><br><a href="https://cuijiahua.com/blog/2017/11/ml_5_bayes_2.html">参考资源2</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>Naive Bayes</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>朴素贝叶斯</tag>
        <tag>Naive Bayes</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 机器人能否返回原点</title>
    <url>/2021/09/03/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%83%BD%E5%90%A6%E8%BF%94%E5%9B%9E%E5%8E%9F%E7%82%B9/</url>
    <content><![CDATA[<h1 id="657-机器人能够返回原点"><a href="#657-机器人能够返回原点" class="headerlink" title="657.机器人能够返回原点"></a>657.机器人能够返回原点</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在二维平面上，有一个机器人从原点 (0, 0) 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 (0, 0) 处结束。<br>移动顺序由字符串表示。字符 move[i] 表示其第 i 次移动。机器人的有效动作有 R（右），L（左），U（上）和 D（下）。如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。<br>注意：机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。</p>
<span id="more"></span>

<p><a href="https://leetcode-cn.com/problems/robot-return-to-origin/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>起始时机器人的坐标为 (0,0)，在遍历完所有指令并对机器人进行移动之后，判断机器人的坐标是否为 (0,0) 即可。</p>
<p>具体来说，我们用两个变量 x 和 y 来表示机器人当前所在的坐标为 (x,y)，起始时 x=0，y=0。接下来我们遍历指令并更新机器人的坐标：<br>    如果指令是 U，则令 y=y−1<br>    如果指令是 D，则令 y=y+1<br>    如果指令是 L，则令 x=x−1<br>    如果指令是 R，则令 x=x+1<br>最后判断 (x,y) 是否为 (0,0) 即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def judgeCircle(self, moves: str) -&gt; bool:
        if len(moves) % 2 != 0:
            return False

        pos_x = 0
        pos_y = 0

        for move in moves:
            if move == &#39;U&#39;:
                pos_y += 1
            elif move == &#39;D&#39;:
                pos_y -= 1
            elif move == &#39;R&#39;:
                pos_x += 1
            elif move == &#39;L&#39;:
                pos_x -= 1

        if pos_x == 0 and pos_y == 0:
            return True
        else:
            return False

    def judgeCircle1(self, moves: str) -&gt; bool:
        if moves.count(&#39;L&#39;) == moves.count(&#39;R&#39;) and moves.count(&#39;U&#39;) == moves.count(&#39;D&#39;):
            return True
        else:
            return False


if __name__ == &quot;__main__&quot;:
    slt = Solution()
    res = slt.judgeCircle(&quot;UD&quot;)
    # res = slt.judgeCircle1(&quot;LLL&quot;)
    print(res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习 | 机器学习中分类标签次数统计代码模板</title>
    <url>/2021/02/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%88%86%E7%B1%BB%E6%A0%87%E7%AD%BE%E6%AC%A1%E6%95%B0%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="机器学习中分类标签次数统计代码模板"><a href="#机器学习中分类标签次数统计代码模板" class="headerlink" title="机器学习中分类标签次数统计代码模板"></a>机器学习中分类标签次数统计代码模板</h1><p>在使用机器学习的算法进行分类时，很多时候我们需要去统计各个分类标签在数据集中出现的次数，它的实现代码模板如下：</p>
<pre><code>def class_count(class_list):  # class_list:数据集数据的所有标签列表
    # 存放各个分类出现的次数
    class_counts = &#123;&#125;
    # 统计class_list中每个元素出现的次数
    for cla in class_list:
        if cla not in class_counts.keys():
            class_counts[cla] = 0
        class_counts[cla] += 1
    # 排序
    sorted_class_count = sorted(class_counts.items(), key=operator.itemgetter(1), reverse=True)
    return sorted_class_count
</code></pre>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习 | 机器学习分类的一般步骤</title>
    <url>/2021/05/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%88%86%E7%B1%BB%E7%9A%84%E4%B8%80%E8%88%AC%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<h1 id="机器学习分类的一般步骤"><a href="#机器学习分类的一般步骤" class="headerlink" title="机器学习分类的一般步骤"></a>机器学习分类的一般步骤</h1><p>1.get data from file<br>2.data preprocess<br>3.get data and label<br>4.design the model used here<br>5.train the model<br>6.validate the model<br>7.test the model<br>8.save the model with best accuracy<br>note: pay more attention on<br><b>1)how to deal with the source data that model can process.</b><br>In general,the size of the input of the model is [B, C, H, W],<br>where B is batch size,C is number of channels,H ans W is two dimension of the input data respectively.<br><b>2)how to calculate ‘in_features’ of the first fully connected layer</b>`</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习基础知识</title>
    <url>/2020/10/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1>机器学习（Machine Learning,ML）</h1>
<h2>机器是如何学习的？</h2>
<h3>1.什么是机器学习？</h3>
通过输入海量训练数据对模型进行训练，使模型掌握数据所蕴含的潜在规律，进而对新输入的数据进行准确的分类和预测。
Note:
1)计算机程序能够处理的只有数值和运算
2）要让一段程序了解客观世界变化万千的实物，则必须将这些实物数值化，将事物的变化和不同事物之间的关联转化为运算。
3）现实世界和计算机之间，概念<-->数值，关系<-->运算的映射，造就了机器可以自主学习实物规律的可能
<span id="more"></span>
<h3>2.机器学习的分类</h3>
有监督学习 通过标注进行学习（用于学习的数据包含样本和标签）
无监督学习 用于学习的数据只有样本没有标签


<h2>机器学习三要素</h2> 
数据、模型、算法（算法通过在数据上进行运算产生模型）
<h3>1.数据</h3>  <h3></h3>
原数据（图片/文字/声音（计算机能够处理的是数值））---->特征工程（1.确定用哪些特征来表示数据 2.确定用什么方式表达这些特征）--VSM(向量空间模型)--> vector ---->算法--算运-->模型
有标注数据（数据样本有标签）
无标注数据（数据样本无标签）
<h3>2.模型</h3>
模型是机器学习的结果，学习的过程称为训练
机器学习的两类问题
    回归（输出结果是一个数值）
    分类（输出结果是一个标签）
<h3>3.算法</h3>
损失函数 描述预测值与真实值之间的差别（针对一个训练数据）
代价函数 （针对所有的训练数据）
目标函数 最小化的代价函数
如何找到最小的参数？---->优化算法
优化算法
    梯度下降法（最常用）
    共轭梯度法
    牛顿法
    拟牛顿法
    模拟退火法
    ...

<h2>模型的获取和改进</h2>
<h3>1.获取模型的过程（-训练-将算法应用到数据上进行运算的过程）</h3>
数据+算法=模型
模型构建步骤
    Step1 数据准备
        Step1.1数据预处理 收集数据、清洗数据、标注数据
        Step1.2构建数据的VSM(将文本、图片、音频、视频等格式的数据转换为向量)
        Step1.3将构件号的VSM的数据分为训练集、验证集和测试集
    Step2 训练--将训练集输入给训练程序进行运算。训练程序的核心是算法，所有输入的向量化数据都会按该训练程序所以及的算法进行运算。训练程序输出的结果就是模型
        Step2.1编写训练程序
            Step2.1.1选择模型类型
            Step2.1.2选择优化算法
            Step2.1.3根据模型类型和算法编写程序
        Step2.2训练-->获得临时模型
        Step2.3在训练集上运行临时模型，获得训练集预测结果
        Step2.4在验证集上运行临时模型，获得验证集预测结果
        Step2.5综合参照Step2.3和step2.4的预测结果，改进模型
        Step2.6 Step2.2到Step2.5反复迭代，直至获得让我们满意，或者已经无法继续优化的模型
    Step3 测试--将测试机数据输入给训练获得的模型，得到预测结果；再将预测结果与这些数据原本预期的结果进行比较
Note:
    训练集：用来做训练的数据的集合
    验证集：用来在训练的过程中每个训练轮次结束后验证当前模型性能，为进一步优化模型提供参考的数据的集合
    测试集：用来做测试的数据的集合，用于检验最终得出的模型的性能
    每个集合都应当是独立的，和另外两个没有重叠
    训练集市训练过程的基础，而验证和测试集则是在不同阶段用来评价训练结果的
<h3>2.改进模型</h3>
数据
    大量的高质量训练数据，是提高模型质量的有效手段，但通常我们可以用来训练的数据量相当有限
    有限的数据---->归一化（Normalization）、正则化(Regularization)、Bootstrap、根据业务进行特征选取（从业务角度区分输入数据包含的特征，并理解这些特征对结果的贡献）
调参
    超参数需要模型训练者自己来设置和调整
选择合适的模型

<p>模型的质量和评判指标<br>分类模型评判指标<br>    精确率（Precision)<br>    召回率（Recall）<br>    F1Score(综合Precision和Recall)<br>一个机器学习模型的质量问题，从对训练集样本拟合程度的角度，可以分为两类：<br>欠拟合（Underfitting）模型在训练集上的预测结果不佳，指标偏低<br>    解决方法：选择更复杂的模型，增加特征<br>过拟合（Overfitting）模型在训练集上指标很好，而在验证或测绘集上指标偏低<br>    解决方法：选择更简单的模型，减少特征</p>
<p>模型<br>    线性回归 LinearRegression,LR<br>    逻辑回归 LogisticRegression<br>    朴素贝叶斯分类器 Naive Bayes Classifier,NB<br>    决策树 DecisionTree,DT<br>    支持向量机 Supporting Vector Machine,SVM<br>    支持向量回归机器 Support Vector Regressioon,SVR<br>    隐马尔科夫模型 Hiden Marcov Model,HMM<br>    条件随机场 Conditional Random Field,CRF<br>    K邻近 K Nearest Neighbor,KNN<br>    K均值 K Means</p>
</--></-->]]></content>
      <categories>
        <category>机器学习</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>脑电分类 | 机器学习实现脑电分类</title>
    <url>/2021/02/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E7%8E%B0%E8%84%91%E7%94%B5%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="机器学习实现脑电分类"><a href="#机器学习实现脑电分类" class="headerlink" title="机器学习实现脑电分类"></a>机器学习实现脑电分类</h1><p><img src="/2021/02/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E7%8E%B0%E8%84%91%E7%94%B5%E5%88%86%E7%B1%BB/1.jpg"></p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>脑电分类</category>
      </categories>
      <tags>
        <tag>脑电分类</tag>
        <tag>机器学习</tag>
        <tag>EEG</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习 | 机器学习常用的两种验证方法</title>
    <url>/2021/05/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E9%AA%8C%E8%AF%81%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="机器学习常用的两种验证方法"><a href="#机器学习常用的两种验证方法" class="headerlink" title="机器学习常用的两种验证方法"></a>机器学习常用的两种验证方法</h1><p>1.Leave One Subject Out<br>2.K Fold Cross Validation</p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>验证方法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 权重初始化</title>
    <url>/2021/06/22/%E6%9D%83%E9%87%8D%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<h1 id="权重初始化"><a href="#权重初始化" class="headerlink" title="权重初始化"></a>权重初始化</h1><p>在训练神经网络时，权重随机初始化是很重要的。</p>
<p>对于<strong>逻辑回归</strong>，把<strong>权重初始化为0</strong>当然也是可以的。但是对于一个<strong>神经网络</strong>，如果你把权重<br>或者参数都初始化为 0，那么<strong>梯度下降将不会起作用</strong>。</p>
<p>如果你<strong>把权重都初始化为 0，那么由于隐含单元开始计算同一个函数</strong>，所有的隐含单元就会对输出单元有同样的影响。<br>一次迭代后同样的表达式结果仍然是相同的，即<strong>隐含单元仍是对称的</strong>。通过推导，两次、三次、无论多少次迭代，不管你训练网络多长时间，<br>隐含单元仍然计算的是同样的函数。因此这种情况下超过 1 个隐含单元也没什么意义，因为他们计算同样的东西。如果你要初始化成 0，<br>由于所有的隐含单元都是对称的，无论你运行梯度下降多久，他们一直计算同样的函数。这没有任何帮助，因为你想要两个不同<br>的隐含单元计算不同的函数，这个问题的解决方法就是<b>随机初始化参数</b>。</p>
<p><a href="https://www.bilibili.com/video/BV1FT4y1E74V?p=35&spm_id_from=pageDriver">参考吴恩达深度学习视频</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Research and Paper | 查找论文代码的两个网站</title>
    <url>/2021/07/03/%E6%9F%A5%E6%89%BE%E8%AE%BA%E6%96%87%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h1 id="查找论文代码的两个网站"><a href="#查找论文代码的两个网站" class="headerlink" title="查找论文代码的两个网站"></a>查找论文代码的两个网站</h1><p><a href="https://www.paperswithcode.com/">网址1</a></p>
<p><a href="https://researchcode.com/">网址2</a></p>
]]></content>
      <categories>
        <category>Research and Paper</category>
      </categories>
      <tags>
        <tag>论文代码</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 检测大写字母</title>
    <url>/2021/09/01/%E6%A3%80%E6%B5%8B%E5%A4%A7%E5%86%99%E5%AD%97%E6%AF%8D/</url>
    <content><![CDATA[<h1 id="520-检测大写字母"><a href="#520-检测大写字母" class="headerlink" title="520.检测大写字母"></a>520.检测大写字母</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个单词，你需要判断单词的大写使用是否正确。<br>我们定义，在以下情况时，单词的大写用法是正确的：<br>    全部字母都是大写，比如”USA”。<br>    单词中所有字母都不是大写，比如”leetcode”。<br>    如果单词不只含有一个字母，只有首字母大写， 比如 “Google”。<br>否则，我们定义这个单词没有正确使用大写字母。</p>
<span id="more"></span>
<p>示例 1:<br>输入: “USA”<br>输出: True<br>示例 2:<br>输入: “FlaG”<br>输出: False<br>注意: 输入是由大写和小写拉丁字母组成的非空单词。</p>
<p><a href="https://leetcode-cn.com/problems/detect-capital/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>按照单词大写用法进行判断，满足返回True，不满足返回False</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def detectCapitalUse(self, word: str) -&gt; bool:
        if word.islower() or word.isupper():
            return True
        elif word[0].isupper() and word[1:].islower():
            return True
        else:
            return False


if __name__ == &quot;__main__&quot;:
    slt = Solution()
    # word = &quot;USA&quot;
    # word = &quot;leetcode&quot;
    # word = &quot;Google&quot;
    word = &quot;flaG&quot;
    res = slt.detectCapitalUse(word)
    print(res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>励志 | 活法</title>
    <url>/2021/07/22/%E6%B4%BB%E6%B3%95/</url>
    <content><![CDATA[<h1 id="活法"><a href="#活法" class="headerlink" title="活法"></a>活法</h1><p>读了稻盛和夫的活法，书中的每一字每一句都可以作为人生哲学和信条，下面记录了自己应该首先去学习、去执行的一些人生哲学：</p>
<span id="more"></span>

<h2 id="只有主动追求的东西才可能到手"><a href="#只有主动追求的东西才可能到手" class="headerlink" title="只有主动追求的东西才可能到手"></a>只有主动追求的东西才可能到手</h2><p>“心不唤物，物不至”，只有自己内心渴望的事情，才能将它呼唤到可能事先的射程之内。</p>
<h2 id="只要思考达到每个细节，目标就一定能实现"><a href="#只要思考达到每个细节，目标就一定能实现" class="headerlink" title="只要思考达到每个细节，目标就一定能实现"></a>只要思考达到每个细节，目标就一定能实现</h2><p>在我们的人生中，想要做成某件事，我们首先要描画它的理想状态，然后把实现它的过程在头脑中模拟演练，<br>一直到“看见”它的结果为止。你事先能“看见”的东西就能做成，“看不见”的东西就做不成。</p>
<h2 id="心态决定命运"><a href="#心态决定命运" class="headerlink" title="心态决定命运"></a>心态决定命运</h2><p>人的命运绝不是天定的，它不是在事先铺设好的轨道上运行的，根据我们的意志，命运既可以变好，也可以变坏。</p>
<h2 id="原理原则"><a href="#原理原则" class="headerlink" title="原理原则"></a>原理原则</h2><p>作为人，何为正确？</p>
<h2 id="人生方程式"><a href="#人生方程式" class="headerlink" title="人生方程式"></a>人生方程式</h2><p>人生·工作的结果 = 思维方式 x 热情 x 能力</p>
<h2 id="自己的人生之戏如何编演"><a href="#自己的人生之戏如何编演" class="headerlink" title="自己的人生之戏如何编演"></a>自己的人生之戏如何编演</h2><p>人生是一出戏，我们每个人都是戏里的主角。不仅如此，而且这戏剧的导演、编剧、主演都可由自己单肩独挑。其实这出戏也<br>只能自编自演，这就是我们的人生。</p>
<h2 id="不在现场流汗什么也学不到"><a href="#不在现场流汗什么也学不到" class="headerlink" title="不在现场流汗什么也学不到"></a>不在现场流汗什么也学不到</h2><p>体验重于知识，“知”未必等于“会”。进入信息社会，进入偏重知识的时代，认为“只要知道自然就会了”的人越来越多了。这种<br>看法大错特错。“会”和“知”中间有一条鸿沟，只有靠现场的经验才能填补。</p>
<h2 id="成为自我燃烧型的人"><a href="#成为自我燃烧型的人" class="headerlink" title="成为自我燃烧型的人"></a>成为自我燃烧型的人</h2><p>要成为自燃型的人，最好最有效的办法是“喜欢自己的工作”，能做成事情的人，他们不仅自我燃烧而且其能量还可与周围人分享。</p>
<h2 id="我正在干一件了不起的工作"><a href="#我正在干一件了不起的工作" class="headerlink" title="我正在干一件了不起的工作"></a>我正在干一件了不起的工作</h2><p>在你讨厌工作，觉得难以忍受时，你还是要多加忍耐，要决心朝前走，要发奋努力，这将改变你的人生。</p>
<h2 id="喜欢与投入"><a href="#喜欢与投入" class="headerlink" title="喜欢与投入"></a>喜欢与投入</h2><p>“喜欢”和“投入”是硬币的正反两面，两者之间是因果循环的关系：因为喜欢就会投入工作；在投入工作的过程中就会产生喜欢。</p>
<h2 id="看似复杂的现象，其实不过是简单事物的投影而已"><a href="#看似复杂的现象，其实不过是简单事物的投影而已" class="headerlink" title="看似复杂的现象，其实不过是简单事物的投影而已"></a>看似复杂的现象，其实不过是简单事物的投影而已</h2><h2 id="生存的意义和目的"><a href="#生存的意义和目的" class="headerlink" title="生存的意义和目的"></a>生存的意义和目的</h2><p>相对于浩瀚宇宙的历史长河，我们的人生不过是一闪而过。但正因为如此，在我们稍纵即逝的人生中，我们的灵魂在终结时的价值<br>必须高于降生时的价值，这才是我们生存的意义和目的。</p>
<h2 id="“六项精进”-磨炼心志的指针"><a href="#“六项精进”-磨炼心志的指针" class="headerlink" title="“六项精进”-磨炼心志的指针"></a>“六项精进”-磨炼心志的指针</h2><p>1.付出不亚于任何人的努力<br>2.谦虚戒骄<br>3.天天反省<br>4.活着就要感谢<br>5.积善行、思利他<br>6.不要有感性的烦恼</p>
<h2 id="率直之心"><a href="#率直之心" class="headerlink" title="率直之心"></a>率直之心</h2><p>所谓率直之心并不是别人要你向右转你就向右转，并不是盲目顺从，而是抱着谦虚的态度，如实承认自己的弱点和不足，然后不惜一切<br>努力奋斗。具备一对虚心聆听他人意见的大耳朵，具备一双真诚审视自己的大眼睛，耳聪目明，充分发挥耳朵、眼睛的作用。</p>
<p>把发自内心的喜悦之情、感恩之心直率地表达出来，可以成为一种动力，激励我们持续这种枯燥的研究和单调的工作。不管什么小事，<br>只要开心，只要赶集，就要率直地表达出来，不绕圈子，不装深沉。</p>
<h2 id="在做出结论之前，先设置一个“理性的缓冲器”"><a href="#在做出结论之前，先设置一个“理性的缓冲器”" class="headerlink" title="在做出结论之前，先设置一个“理性的缓冲器”"></a>在做出结论之前，先设置一个“理性的缓冲器”</h2><h2 id="喜悦从苦劳与艰辛中渗出，工作的乐趣潜藏在超越困难的过程之中"><a href="#喜悦从苦劳与艰辛中渗出，工作的乐趣潜藏在超越困难的过程之中" class="headerlink" title="喜悦从苦劳与艰辛中渗出，工作的乐趣潜藏在超越困难的过程之中"></a>喜悦从苦劳与艰辛中渗出，工作的乐趣潜藏在超越困难的过程之中</h2><h2 id="踏上社会，要转变角色，要为周围的人服务，要为团队、为企业做贡献"><a href="#踏上社会，要转变角色，要为周围的人服务，要为团队、为企业做贡献" class="headerlink" title="踏上社会，要转变角色，要为周围的人服务，要为团队、为企业做贡献"></a>踏上社会，要转变角色，要为周围的人服务，要为团队、为企业做贡献</h2><h2 id="养成在更大视野内观察事物的眼光，从更大的视角、以相对的观点来审视自己的行为"><a href="#养成在更大视野内观察事物的眼光，从更大的视角、以相对的观点来审视自己的行为" class="headerlink" title="养成在更大视野内观察事物的眼光，从更大的视角、以相对的观点来审视自己的行为"></a>养成在更大视野内观察事物的眼光，从更大的视角、以相对的观点来审视自己的行为</h2><h2 id="主宰人生的两只看不见的手"><a href="#主宰人生的两只看不见的手" class="headerlink" title="主宰人生的两只看不见的手"></a>主宰人生的两只看不见的手</h2><p>主宰人生的两只看不见的手，一只叫命运，一只叫因果报应法则。<br>我们身上发生的各种事情，都有其产生的原因。这原因不是别的，就是我们自己的思想和行为。你在想什么做什么，都成为因，而<br>必生其果，你对所生结果如何应对，又成为因，有必有所果。<br>人生超脱命运的轨迹，那是因为因果法则这个力量在发挥作用；而另一方面，善行有时并不立即产生善果，那是因为命运的力量在干扰。<br>在这里，因果报应法则要强于命运的法则。因此，由上苍决定的命运也可以用自己的力量加以改变。</p>
<h2 id="为善不见其益，如草里冬瓜自暗应长"><a href="#为善不见其益，如草里冬瓜自暗应长" class="headerlink" title="为善不见其益，如草里冬瓜自暗应长"></a>为善不见其益，如草里冬瓜自暗应长</h2><p>我们人生的意义是什么？人生的目的在哪里？<br>要带着一颗比降生是稍稍善良、稍稍美丽的心灵离开人世，从生至死都要尽力去思善行善，陶冶人格，使人生终点时灵魂的品格比起点时有所提升。</p>
<p>在此我定下一个目标，一定要在n年后重读此书，看看自己的感悟与此时此刻有何不同，自己有没有按照书中的“活法”去生活、工作、学习！</p>
]]></content>
      <categories>
        <category>书籍</category>
        <category>励志类</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>活法</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 深度学习中常用的几种激活函数</title>
    <url>/2021/06/22/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="深度学习中常用的几种激活函数"><a href="#深度学习中常用的几种激活函数" class="headerlink" title="深度学习中常用的几种激活函数"></a>深度学习中常用的几种激活函数</h1><p>使用一个神经网络时，需要决定使用哪种激活函数用隐藏层上，哪种用在输出节点上。<br><b style="color:red">在不同的神经网络层中，激活函数可以不同</b><br><b>几种常用的激活函数：</b><br><img src="/2021/06/22/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/1.png"></p>
<p><b>note:</b><br>1.tanh函数总体上优于sigmoid函数(因为tanh函数值值域在-1,1之间，其均值更接近0)</p>
<p>2.例外：在二分类的问题中，对于输出层，因为𝑦的值是 0 或 1，所以想让𝑦^的数<br>值介于 0 和 1 之间，而不是在-1 和+1 之间。所以需要使用 sigmoid 激活函数。</p>
<p>如果输出是 0、1 值（二分类问题），则输出层选择 sigmoid 函数，然后其它的所有单<br>元都选择 Relu 函数。</p>
<p>3.sigmoid 函数和 tanh 函数两者共同的缺点是，在𝑧特别大或者特别小的情况下，导数的<br>梯度或者函数的斜率会变得特别小，最后就会接近于 0，导致降低梯度下降的速度。</p>
<p><b>总结：</b><br>sigmoid 激活函数：除了输出层是一个二分类问题基本不会用它。<br>tanh 激活函数：tanh 是非常优秀的，几乎适合所有场合。<br>ReLu 激活函数：最常用的默认函数，，如果不确定用哪个激活函数，就使用 ReLu 或者<br>Leaky Relu</p>
<p><a href="https://mp.weixin.qq.com/s/9N-d8_D5rniJylDMLXdTPQ">点这里查看更多的激活函数，有更加详细的解释！</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>激活函数</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 环形链表</title>
    <url>/2021/08/27/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141.环形链表"></a>141.环形链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个链表，判断链表中是否有环。<br>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。<br>如果链表中存在环，则返回 true 。 否则，返回 false 。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/linked-list-cycle/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.哈希表<br>最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。<br>具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。<br>2.快慢指针<br>定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution:
    def hasCycle(self, head: ListNode) -&gt; bool:
        &quot;&quot;&quot;
        哈希表

        :param head:单链表头节点
        :return:True-linked list has cycle/False-linked list has not cycle
        &quot;&quot;&quot;
        seen = set()
        while head:
            if head in seen:
                return True
            seen.add(head)
            head = head.next
        return False

    def hasCycle1(self, head: ListNode) -&gt; bool:
        &quot;&quot;&quot;
        快慢指针

        :param head:单链表头节点
        :return:True-linked list has cycle/False-linked list has not cycle
        &quot;&quot;&quot;
        if not head or not head.next:  # 如果头节点为空，或者链表第一个节点为空，则链表没有环
            return False

        slow = head
        fast = head.next

        while slow != fast:
            if not fast or not fast.next:
                return False

            slow = slow.next
            fast = fast.next.next
        return True

    def create_linked_list(self):
        node4 = ListNode(-4)
        node3 = ListNode(0)
        node2 = ListNode(2)
        node1 = ListNode(3)
        node1.next = node2
        node2.next = node3
        node3.next = node4
        node4.next = node2

        return node1

    def print_linked_list(self, linked_list) -&gt; None:
        &quot;&quot;&quot;
        打印单链表中的所有元素

        :param linked_list: 单链表
        :return: 无
        &quot;&quot;&quot;
        print(&quot;----------------------------------------&quot;)
        pointer = linked_list
        while pointer is not None:
            print(pointer.val)
            pointer = pointer.next


if __name__ == &quot;__main__&quot;:
    slt = Solution()

    linked_list = slt.create_linked_list()

    print(slt.hasCycle1(linked_list))
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 用两个队列实现栈</title>
    <url>/2021/08/27/%E7%94%A8%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
    <content><![CDATA[<h1 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225.用队列实现栈"></a>225.用队列实现栈</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。<br>实现 MyStack 类：<br>    void push(int x) 将元素 x 压入栈顶。<br>    int pop() 移除并返回栈顶元素。<br>    int top() 返回栈顶元素。<br>    boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。</p>
<p>注意：<br>    你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。<br>    你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>1.使用两个队列实现栈</strong><br>使用两个队列实现栈的操作，其中 queue1 用于存储栈内的元素，queue2 作为入栈操作的辅助队列。<br>入栈操作时，首先将元素入队到 queue2，然后将 queue1 的全部元素依次出队并入队到 queue2，此时 queue2 的前端的元素即为新入栈的元素，再将 queue1 和 queue2 互换，则 queue1 的元素即为栈内的元素，queue1 的前端和后端分别对应栈顶和栈底。<br>由于每次入栈操作都确保 queue1 的前端元素为栈顶元素，因此出栈操作和获得栈顶元素操作都可以简单实现。出栈操作只需要移除 queue1 的前端元素并返回即可，获得栈顶元素操作只需要获得 queue1 的前端元素并返回即可（不移除元素）。<br>由于 queue1 用于存储栈内的元素，判断栈是否为空时，只需要判断 queue1 是否为空即可。<br><strong>2.使用一个队列实现栈</strong><br>使用一个队列时，为了满足栈的特性，即最后入栈的元素最先出栈，同样需要满足队列前端的元素是最后入栈的元素。<br>入栈操作时，首先获得入栈前的元素个数 n，然后将元素入队到队列，再将队列中的前 n 个元素（即除了新入栈的元素之外的全部元素）依次出队并入队到队列，此时队列的前端的元素即为新入栈的元素，且队列的前端和后端分别对应栈顶和栈底。<br>由于每次入栈操作都确保队列的前端元素为栈顶元素，因此出栈操作和获得栈顶元素操作都可以简单实现。出栈操作只需要移除队列的前端元素并返回即可，获得栈顶元素操作只需要获得队列的前端元素并返回即可（不移除元素）。<br>由于队列用于存储栈内的元素，判断栈是否为空时，只需要判断队列是否为空即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>import collections


class MyStack(object):
    &quot;&quot;&quot;使用两个队列实现栈&quot;&quot;&quot;
    def __init__(self):
        &quot;&quot;&quot;
        Initialize your data structure here.
        &quot;&quot;&quot;
        self.queue1 = collections.deque()
        self.queue2 = collections.deque()

    def push(self, x):
        &quot;&quot;&quot;
        Push element x onto stack.
        :type x: int
        :rtype: None
        &quot;&quot;&quot;
        self.queue2.append(x)
        while self.queue1:
            self.queue2.append(self.queue1.popleft())
        self.queue1, self.queue2 = self.queue2, self.queue1

    def pop(self):
        &quot;&quot;&quot;
        Removes the element on top of the stack and returns that element.
        :rtype: int
        &quot;&quot;&quot;
        return self.queue1.popleft()

    def top(self):
        &quot;&quot;&quot;
        Get the top element.
        :rtype: int
        &quot;&quot;&quot;
        return self.queue1[0]

    def empty(self):
        &quot;&quot;&quot;
        Returns whether the stack is empty.
        :rtype: bool
        &quot;&quot;&quot;
        return not self.queue1


class MyStack1(object):
    &quot;&quot;&quot;使用1个队列实现栈&quot;&quot;&quot;
    def __init__(self):
        &quot;&quot;&quot;
        Initialize your data structure here.
        &quot;&quot;&quot;
        self.queue = collections.deque()

    def push(self, x):
        &quot;&quot;&quot;
        Push element x onto stack.
        :type x: int
        :rtype: None
        &quot;&quot;&quot;
        n = len(self.queue)
        self.queue.append(x)
        for _ in range(n):
            self.queue.append(self.queue.popleft())

    def pop(self):
        &quot;&quot;&quot;
        Removes the element on top of the stack and returns that element.
        :rtype: int
        &quot;&quot;&quot;
        return self.queue.popleft()

    def top(self):
        &quot;&quot;&quot;
        Get the top element.
        :rtype: int
        &quot;&quot;&quot;
        return self.queue[0]

    def empty(self):
        &quot;&quot;&quot;
        Returns whether the stack is empty.
        :rtype: bool
        &quot;&quot;&quot;
        return not self.queue
# Your MyStack object will be instantiated and called as such:
# obj = MyStack()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.top()
# param_4 = obj.empty()


if __name__ == &quot;__main__&quot;:
    my_stack = MyStack()
    my_stack = MyStack1()
    my_stack.push(1)
    my_stack.push(2)
    print(&quot;当前栈顶元素为: &#123;&#125;&quot;.format(my_stack.top()))
    print(&quot;当前弹出的元素为: &#123;&#125;&quot;.format(my_stack.pop()))
    print(&quot;当前栈空：&#123;&#125;&quot;.format(&quot;yes&quot; if my_stack.empty() is True else &quot;no&quot;))
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 用栈实现队列</title>
    <url>/2021/08/27/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232.用栈实现队列"></a>232.用栈实现队列</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：<br>实现 MyQueue 类：<br>    void push(int x) 将元素 x 推到队列的末尾<br>    int pop() 从队列的开头移除并返回元素<br>    int peek() 返回队列开头的元素<br>    boolean empty() 如果队列为空，返回 true ；否则，返回 false<br>说明：<br>    你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。<br>    你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</p>
<span id="more"></span>

<p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用两个栈实现队列，一个栈作为输入栈（入队），一个对作为输出栈（出队/取队头元素）。<br>入队操作的实现：将元素压入输入栈<br>出队操作的实现：弹出输出栈栈顶元素，若输出栈为空，输入栈不为空，则将输入栈所有元素出栈并压入输出栈，接着再弹出输出栈栈顶元素。<br>队列判空：输入栈和输出栈同时为空时队列为空。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class MyQueue(object):
    &quot;&quot;&quot;用2个栈实现队列&quot;&quot;&quot;
    def __init__(self):
        &quot;&quot;&quot;
        Initialize your data structure here.
        &quot;&quot;&quot;
        self.stack1 = list()
        self.stack2 = list()

    def push(self, x):
        &quot;&quot;&quot;
        Push element x to the back of queue.
        :type x: int
        :rtype: None
        &quot;&quot;&quot;
        self.stack1.append(x)

    def pop(self):
        &quot;&quot;&quot;
        Removes the element from in front of queue and returns that element.
        :rtype: int
        &quot;&quot;&quot;
        if len(self.stack2) != 0:
            return self.stack2.pop()
        else:
            for _ in range(len(self.stack1)):
                self.stack2.append(self.stack1.pop())
            return self.stack2.pop()

    def peek(self):
        &quot;&quot;&quot;
        Get the front element.
        :rtype: int
        &quot;&quot;&quot;
        if len(self.stack2) != 0:
            return self.stack2[-1]
        else:
            for _ in range(len(self.stack1)):
                self.stack2.append(self.stack1.pop())
            return self.stack2[-1]


    def empty(self):
        &quot;&quot;&quot;
        Returns whether the queue is empty.
        :rtype: bool
        &quot;&quot;&quot;
        return not self.stack1 and not self.stack2


# Your MyQueue object will be instantiated and called as such:
# obj = MyQueue()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.peek()
# param_4 = obj.empty()


if __name__ == &quot;__main__&quot;:
    my_queue = MyQueue()
    my_queue.push(1)
    my_queue.push(2)
    print(&quot;当前队头元素为：&#123;&#125;&quot;.format(my_queue.peek()))
    print(&quot;当前出队元素为：&#123;&#125;&quot;.format(my_queue.pop()))
    print(&quot;当前队列空：&#123;&#125;&quot;.format(&quot;yes&quot; if my_queue.empty() is True else &quot;no&quot;))
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 电话号码的字母组合</title>
    <url>/2021/09/04/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h1 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17.电话号码的字母组合"></a>17.电话号码的字母组合</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。<br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.遍历并组合每一个数字对应的字母列表 –&gt; letterCombinations()<br><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/zhi-xing-yong-shi-ji-bai-9954nei-cun-xia-gwkb/">点击这里查看完整解题思路！！！</a><br>2.使用内置库 –&gt; letterCombinations1()<br><strong>3.回溯</strong> –&gt; letterCombinations2()<br><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/dian-hua-hao-ma-de-zi-mu-zu-he-by-leetcode-solutio/">回溯法和使用内置库思路见leetcode题解</a></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    num2ch = &#123;
        &#39;2&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],
        &#39;3&#39;: [&#39;d&#39;, &#39;e&#39;, &#39;f&#39;],
        &#39;4&#39;: [&#39;g&#39;, &#39;h&#39;, &#39;i&#39;],
        &#39;5&#39;: [&#39;j&#39;, &#39;k&#39;, &#39;l&#39;],
        &#39;6&#39;: [&#39;m&#39;, &#39;n&#39;, &#39;o&#39;],
        &#39;7&#39;: [&#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;],
        &#39;8&#39;: [&#39;t&#39;, &#39;u&#39;, &#39;v&#39;],
        &#39;9&#39;: [&#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;]
    &#125;

    def letterCombinations(self, digits: str) -&gt; list:
        if len(digits) == 0:
            return []

        list1 = []  # 用于存储digits数组中每个字符对应的字母列表
        for d in digits:
            list1.append(self.num2ch[d])

        i = 0
        j = 1
        while j &lt; len(list1):
            list1[j] = self.concat(list1[i], list1[j])
            i = j
            j += 1

        return list1[-1]

    def concat(self, list1, list2):
        res = []
        for e1 in list1:
            for e2 in list2:
                res.append(e1 + e2)
        return res

    def letterCombinations1(self, digits: str):
        if not digits:
            return list()

        phoneMap = &#123;
            &quot;2&quot;: &quot;abc&quot;,
            &quot;3&quot;: &quot;def&quot;,
            &quot;4&quot;: &quot;ghi&quot;,
            &quot;5&quot;: &quot;jkl&quot;,
            &quot;6&quot;: &quot;mno&quot;,
            &quot;7&quot;: &quot;pqrs&quot;,
            &quot;8&quot;: &quot;tuv&quot;,
            &quot;9&quot;: &quot;wxyz&quot;,
        &#125;

        groups = (phoneMap[digit] for digit in digits)

        import itertools
        return [&quot;&quot;.join(combination) for combination in itertools.product(*groups)]

    def letterCombinations2(self, digits: str):
        if not digits:
            return list()

        phoneMap = &#123;
            &quot;2&quot;: &quot;abc&quot;,
            &quot;3&quot;: &quot;def&quot;,
            &quot;4&quot;: &quot;ghi&quot;,
            &quot;5&quot;: &quot;jkl&quot;,
            &quot;6&quot;: &quot;mno&quot;,
            &quot;7&quot;: &quot;pqrs&quot;,
            &quot;8&quot;: &quot;tuv&quot;,
            &quot;9&quot;: &quot;wxyz&quot;,
        &#125;

        def backtrack(index: int):
            if index == len(digits):
                combinations.append(&#39;&#39;.join(combination))
            else:
                digit = digits[index]
                for letter in phoneMap[digit]:
                    combination.append(letter)
                    backtrack(index + 1)
                    combination.pop()

        combination = list()
        combinations = list()
        backtrack(0)
        return combinations


if __name__ == &#39;__main__&#39;:
    slt = Solution()
    digits = &quot;23&quot;
    res = slt.letterCombinations2(digits)
    print(res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>wxPython | 盒子布局管理器</title>
    <url>/2021/08/03/%E7%9B%92%E5%AD%90%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<h1 id="盒子布局管理器"><a href="#盒子布局管理器" class="headerlink" title="盒子布局管理器"></a>盒子布局管理器</h1><p>wxPython提供了布局管理器类帮助实现界面布局，主要分为两大类：盒子布局管理器（类似于CSS中的弹性布局）和网格布局管理器。</p>
<p>下面我们做一个盒子布局管理器（垂直方向布局）的例子：<br>1.代码</p>
<pre><code># coding=utf-8
import wx
class MyFrame(wx.Frame):
    def __init__(self):
        super().__init__(None, title=&quot;事件处理&quot;, size=(300, 180))
        panel = wx.Panel(parent=self)
        self.statictext = wx.StaticText(parent=panel, label=&quot;请单击OK按钮&quot;)
        b = wx.Button(parent=panel, label=&quot;OK&quot;)
        self.Bind(wx.EVT_BUTTON, self.on_click, b)

        # 创建垂直方向的盒子布局管理器对象vbox
        vbox = wx.BoxSizer(wx.VERTICAL)
        # 添加静态文本到vbox布局管理器
        vbox.Add(self.statictext, proportion=1, flag=wx.ALIGN_CENTER_HORIZONTAL | wx.FIXED_MINSIZE | wx.TOP, border=30)
        # 添加按钮b到vbox布局管理器
        vbox.Add(b, proportion=1, flag=wx.EXPAND | wx.BOTTOM, border=10)
        panel.SetSizer(vbox)

    def on_click(self, event):
        self.statictext.SetLabelText(&#39;Hello, World.&#39;)


app = wx.App()  # 创建应用程序对象
frm = MyFrame()  # 创建窗口对象
frm.Show()  # 显示窗口
app.MainLoop()  # 进入主事件循环
</code></pre>
<p>2.界面<br><img src="/2021/08/03/%E7%9B%92%E5%AD%90%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8/1.png"></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>wxPython</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>wxPython</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 盛最多水的容器</title>
    <url>/2021/08/27/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11.盛最多水的容器"></a>11.盛最多水的容器</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>说明：你不能倾斜容器。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/container-with-most-water/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>双指针法<br>height=[a1,a2,…,an]<br>起始两个指针l、r分别指向n个非负整数的两端，接着计算容器容积area = min(height[l], height[r]) * (r - l),然后移动l、r指针中指针指向元素较小的那个指针（向另一个指针所在的方向移动），再计算area,…,以此类推，然会最大的area</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):
    def maxArea(self, height):
        &quot;&quot;&quot;
        :type height: List[int]
        :rtype: int
        &quot;&quot;&quot;
        # 容器的高为height中每一对值中较小的
        # 容器的宽为每一对值的下标相减，后者下标减去前者下标
        # Area = H x W

        n = len(height)  # 输入数组的长度
        max = 0  # 最大容器容量
        for i in range(n):
            for j in range(i+1, n):
                h = min(height[i], height[j])
                w = j - i
                if h * w &gt; max:
                    max = h * w

        return max

    def maxArea1(self, height):
        l, r = 0, len(height) - 1
        ans = 0

        while l &lt; r:
            area = min(height[l], height[r]) * (r - l)
            ans = max(ans, area)
            if height[l] &lt;= height[r]:
                l += 1
            else:  # height[l] &gt;= height[r]
                r -= 1
        return ans


if __name__ == &quot;__main__&quot;:
    slt = Solution()
    height = [1, 8, 6, 2, 5, 4, 8, 3, 7]
    max_area = slt.maxArea(height)
    print(max_area)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>伪迹移除 | 盲源分离和独立成分分析</title>
    <url>/2021/02/21/%E7%9B%B2%E6%BA%90%E5%88%86%E7%A6%BB%E5%92%8C%E7%8B%AC%E7%AB%8B%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="盲源分离-BSS-和独立成分分析-ICA"><a href="#盲源分离-BSS-和独立成分分析-ICA" class="headerlink" title="盲源分离(BSS)和独立成分分析(ICA)"></a>盲源分离(BSS)和独立成分分析(ICA)</h1><h2 id="BSS"><a href="#BSS" class="headerlink" title="BSS"></a>BSS</h2><p>盲源分离是最流行的伪迹检测/移除方法之一，其目的是提取混合信号中独立的未知的源信号；同时尽可能在对源信号和混合通道没有或者有非常有限的了解下尽可能仅通过在每一个通道的输出观测到的混合信号来估计未知的混合通道。盲源分离包括ICA(独立成分分析)、CCA(典型成分分析)、MCA(形态成分分析)三种方法。</p>
<h3 id="数学表示式："><a href="#数学表示式：" class="headerlink" title="数学表示式："></a>数学表示式：</h3><p><b>X = AS + N</b><br><b>S’ = WX</b><br>其中,X表示观测到的信号(假设X为若干源信号和噪声信号的混合),N代表噪声信号，A为系数矩阵，W也为系数矩阵（需要对W矩阵进行估计），S’为S的估计<br><img src="/2021/02/21/%E7%9B%B2%E6%BA%90%E5%88%86%E7%A6%BB%E5%92%8C%E7%8B%AC%E7%AB%8B%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/bss.png"></p>
<h2 id="ICA"><a href="#ICA" class="headerlink" title="ICA"></a>ICA</h2><p>独立成分分析是盲源分离的一个特例，它假设组成观测信号的若干源信号是线性独立的。</p>
<h3 id="基于ICA的伪迹检测和去除方法存在的问题"><a href="#基于ICA的伪迹检测和去除方法存在的问题" class="headerlink" title="基于ICA的伪迹检测和去除方法存在的问题"></a>基于ICA的伪迹检测和去除方法存在的问题</h3><p>1.非自动的<br>2.需要人为介入去除观察到的伪迹</p>
<h3 id="基于ICA的伪迹检测和去除方法的自动化"><a href="#基于ICA的伪迹检测和去除方法的自动化" class="headerlink" title="基于ICA的伪迹检测和去除方法的自动化"></a>基于ICA的伪迹检测和去除方法的自动化</h3><p><b style="color:red">1.ICA+WT(Wavelet Transform,小波变换)<br>2.ICA+EMD(Empirical Mode Decomposition,经验模态分解)<br>3.使用分类器，例如SVM(Support Vector Machine,支持向量机-一种机器学习算法)<br>4.参考信号辅助</b></p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>1.伪迹独立成分仍然可能包含残余的神经信号导致神经信号的失真<br>2.不能用于单通道数据<br>3.不适合实时应用</p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>伪迹移除</category>
      </categories>
      <tags>
        <tag>ICA</tag>
        <tag>BSS</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 相交链表</title>
    <url>/2021/08/27/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="160-环形链表"><a href="#160-环形链表" class="headerlink" title="160.环形链表"></a>160.环形链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.哈希表<br>判断两个链表是否相交，可以使用哈希集合存储链表节点。<br>首先遍历链表 headA，并将链表 headA 中的每个节点加入哈希集合中。然后遍历链表 headB，对于遍历到的每个节点，判断该节点是否在哈希集合中：<br>    如果当前节点不在哈希集合中，则继续遍历下一个节点；<br>    如果当前节点在哈希集合中，则后面的节点都在哈希集合中，即从当前节点开始的所有节点都在两个链表的相交部分，因此在链表 headB 中遍历到的第一个在哈希集合中的节点就是两个链表相交的节点，返回该节点。<br>如果链表 headB 中的所有节点都不在哈希集合中，则两个链表不相交，返回 null。<br>2.双指针<br>只有当链表 headA 和 headB 都不为空时，两个链表才可能相交。因此首先判断链表 headA 和 headB 是否为空，如果其中至少有一个链表为空，则两个链表一定不相交，返回 null。<br>当链表 headA 和 headB 都不为空时，创建两个指针 pA 和 pB，初始时分别指向两个链表的头节点 headA 和 headB，然后将两个指针依次遍历两个链表的每个节点。具体做法如下：<br>    每步操作需要同时更新指针 pA 和 pB。<br>    如果指针 pA 不为空，则将指针 pA 移到下一个节点；如果指针 pB 不为空，则将指针 pB 移到下一个节点。<br>    如果指针 pA 为空，则将指针 pA 移到链表 headB 的头节点；如果指针 pB 为空，则将指针 pB 移到链表 headA 的头节点。<br>    当指针 pA 和 pB 指向同一个节点或者都为空时，返回它们指向的节点或者 null。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># Definition for singly-linked list.
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):
    def getIntersectionNode(self, headA, headB):
        &quot;&quot;&quot;
        哈希表

        :type head1, head1: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        if not headA or not headB:
            return None
        seen = set()
        p1 = headA
        p2 = headB
        while p1 is not None:
            seen.add(p1)
            p1 = p1.next

        while p2 is not None:
            if p2 in seen:
                return p2.val
            p2 = p2.next

        return None

    def getIntersectionNode1(self, headA, headB):
        &quot;&quot;&quot;
        双指针

        :param headA:
        :param headB:
        :return:
        &quot;&quot;&quot;
        if not headA or not headB:
            return None

        p_A = headA
        p_B = headB

        while p_A != p_B:
            p_A = headB if p_A is None else p_A.next
            p_B = headA if p_B is None else p_B.next

        return p_A


    def create_linked_list(self):
        &quot;&quot;&quot;
        创建两个相交的单链表
        :return:两个相交但表表的头指针
        &quot;&quot;&quot;
        a_node1 = ListNode(4)
        a_node2 = ListNode(1)

        b_node1 = ListNode(5)
        b_node2 = ListNode(0)
        b_node3 = ListNode(1)

        common_node1 = ListNode(8)
        common_node2 = ListNode(4)
        common_node3 = ListNode(5)

        a_node1.next = a_node2
        a_node2.next = common_node1
        common_node1.next = common_node2
        common_node2.next = common_node3

        b_node1.next = b_node2
        b_node2.next = b_node3
        b_node3.next = common_node1
        common_node1.next = common_node2
        common_node2.next = common_node3

        return a_node1, b_node2


if __name__ ==&quot;__main__&quot;:
    slt = Solution()

    head_a, head_b = slt.create_linked_list()

    intersected_node = slt.getIntersectionNode1(head_a, head_b)
    print(intersected_node.val)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 神经网络中的超参数</title>
    <url>/2021/06/30/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E8%B6%85%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h1 id="神经网络中的超参数"><a href="#神经网络中的超参数" class="headerlink" title="神经网络中的超参数"></a>神经网络中的超参数</h1><p><b>神经网络中常见的超参数：</b><br>1.隐藏层的大小n^[l](size of hidden layers)<br>2.学习率 alpha(learning rate)<br>3.迭代次数(number of iterations)<br>4.神经网络中的层数L(number of layers L in the neral network)</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>超参数</tag>
      </tags>
  </entry>
  <entry>
    <title>入门指南 | 程序员必备的8大学习网站</title>
    <url>/2021/02/20/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%E7%9A%848%E5%A4%A7%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h1 id="程序员必备的8大学习网站"><a href="#程序员必备的8大学习网站" class="headerlink" title="程序员必备的8大学习网站"></a>程序员必备的8大学习网站</h1><table>
<thead>
<tr>
<th>网站</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>github</td>
<td>代码托管平台</td>
</tr>
<tr>
<td>stackoverflow</td>
<td>技术问答</td>
</tr>
<tr>
<td>leetcode</td>
<td>刷题讨论 码不停题</td>
</tr>
<tr>
<td>bilibili</td>
<td>学习</td>
</tr>
<tr>
<td>牛客网</td>
<td>应届毕业生找工作的天堂</td>
</tr>
<tr>
<td>papers with code</td>
<td>论文+代码</td>
</tr>
<tr>
<td>菜鸟教程</td>
<td>技术手册</td>
</tr>
<tr>
<td>W3School</td>
<td>技术手册</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>入门指南</category>
      </categories>
      <tags>
        <tag>程序员必备的8大学习网站</tag>
      </tags>
  </entry>
  <entry>
    <title>小说 | 研究生第一本书-恶意</title>
    <url>/2020/10/08/%E7%AC%AC%E4%B8%80%E6%9C%AC%E4%B9%A6/</url>
    <content><![CDATA[<h1>研究生第一本书-恶意</h1>
“<strong style="color:red">这个世界上有两个东西不能直视，一个是太阳，一个是人心。</strong>”
<span id="more"></span>
晓燕老师在微博视频中提到一本书-恶意，开头这句活是这本书中一句特别经典的话：正是冲着这句话，我读完了恶意这本书。

<p>这本书是由日本著名作家-东野圭吾写的，书中主要说了一个人由于嫉妒一位朋友（这位朋友是他小时候的好朋友）的文学才华，<br>这恶意深不见底，于是最后杀害了自己的这位朋友；然而朋友的死亡任然不能了却他心中的仇恨、恶意，他精心谋划杀害并企图<br>让这位朋友身败名裂；</p>
<p>这本书中有这样一句话：“<strong style="color:red">在你的心中深藏着对他的恶意，这仇恨深的连你自己都无法解释<br></strong>”</p>
<p>别人对你的恶意是没有理由、没有原因的，因此我们能做的只有做自己。</p>
<p>因为“这个世界上有两个东西不能直视，一个是太阳，一个是人心。”这句话读这本书，从始至终我也试图在书中遇到这么一句话，<br>然我翻到书最后一页也没有见到这句话。后来在网上得知，这句话藏在东野圭吾写的另一个优秀作品-《白夜行》里面。</p>
<p><img src="/2020/10/08/%E7%AC%AC%E4%B8%80%E6%9C%AC%E4%B9%A6/%E6%81%B6%E6%84%8F.jpg" alt="恶意"></p>
]]></content>
      <categories>
        <category>书籍</category>
        <category>小说类</category>
      </categories>
      <tags>
        <tag>恶意</tag>
      </tags>
  </entry>
  <entry>
    <title>人生经历 | 第一次工作面试</title>
    <url>/2021/07/07/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="f14616c556d44103c9ff2b86aa1ee0f52f97227630385289e35a7db8f991ddee">5fa8d7dd4aaa9bde3945cea575f036350644f9a4f5c0b32d0d2de067b73e8ac8bf4e611e865e7ed9b29692f3df8d4b6a978e485acefe710776ac7f50bf5f51f7a4a99a71a01878e93d058395d5d93a2b9cc22097e99ae920538312efdd5e286a81da9d1b736a71d9a123f9d6ea25c731067e47d6f160862fa960c95bfdf6175be9186f5aaa2d2c5c897afbcb2b94c610c5512f72bf7617c6701cdca762cc3e7e837e37e4a1566f9780c15d0a8fa6d7bd65c49c7a981d3f38c3d20d8758aa6a4b8a1478761d32b4b5ae7de43a0a490b5a2c94ecf372831a19b4154eaa2711a71b3f0fec9d024b30616a94e4bf991657c3b4fd4482a97bd7478f591a0f30b9336aeede5ead853486506ad22a9c79140833e2390da1c4e4edc6834e3b14ce2c83277c21930fdf394ed5c39da49d30f37fee48548f5b0733d7527a9b8b9893617eee2090d644a477d0ec91f27c913af1d3000517258e15ef02b32fa87a40ae0d30cb58004073b3ca2f4f750f0438527390c2102cd4ea275d7d1a15cfec872e6c537efbfd6933a029493422463fde13170d18e7d42ac1b6cbfd9490883cc7c7701531c0623fea48fef6e6e5111aa1954f7117a3cbb1c8d856d8918d29083c4efd819e18db923205a73c27ab7a5f5dd635ff805bdd20f4170cef0d9e4cb38469d791b0728d4ecb84cbcad6ae4d92121d673a3e5ee8b12d1747aa94827da11c050dc938ccd35015545a3cdde889afd7a39515544219b7155b6b1108bd5bb882f40f319fd9d29584556ee7abb7ec7d88a76e4b0c3b63e9c96031b2e11724202acc9c3bc19e94023d8567f7bd82ffac553e52b25bbe489c2e31a91df601a6ef3191aef1053226c63ae66523dc5feec275a15baf05b553459c88410a6b10b61eb274d4e2756d1ff9e2e00e44214f597e6afc2c46cdf6b467b0464c70d534c285a2cd163cc534da9f600d56f5e6f5f1b85b148126f95bc3758acc01848f6f183788210c41559e055514df93a6e4271d5952cddf91fdbe7a9ab3752a7452ceb2b1907f5794fc92cb900dbbf392bd9b84b92627dc030d9995a4eafba8b8a7d0756760d6dc016c3697d619a906833e7128b0873dd0fee83eb49c2f21720faa8f1667766db7cb5efe92ceda0feaa256dc2ab09521d3d988173f8787bafe67fb36294ae9ac79f808d6cdf0467eabb97fedaaa0fa3007b322cdcf6190280dfed2392677b191a3db99cedc37550f5e7cd9d5cd2e196ce175ebce80c23b22b6b467290c8a8204b4d6eb4996a389ba7ebe20256bf80a1551ffdb51b490e62cac8534d2a237cbd65617601f8d2680cd9f90bd139c4325e15a151921c6022bb768fbb4e3a44b34056649b7edb2119e5dccc1804f29f32000cbc9a423ce92a11ef7599594af177e0c6f5c934e99b7098cd4a3e99ab9f59fe1958e676cba2626b63adbbdaf7d4c24e5bfe630ef64d56bc53109a5ced9a159ecefba9ef1f96952e6675bc39a24a773bb60ad4bb2f43ea7da2b6547665e110c260ab908f2c1cca89bd55143f4c60af93acaf42d6aaffdc087e491e75f976dce57670e07ca54e77eb62121386597978e80946c9d2ac381140526f8cc13bf2c8b4ce6d9e8a70552181a001a70e87f0ed20a3220c5263b5f440df845e771eae54b49fa433a5467a6a0d17d96131d21dee9695b0eb02455a94269d1d0c012ae2e8eb1a37fc1be0c53cc0532e1d4c7f3e070cfcc89b2037b2dce453c3c7e2b243d18ce10122d1aa4ec87a28a4917f870fef44c1c2a9befef260b684ddf9e430258e397a81c60756995567cf6d3fc3cb705f21078636f2b32a909f9afead9f0cd08cc0316c39231594546a7be17f3399fc6bdd643c1a6e38a36d7f69565d9df0e0fb5e43a88b6775f39cdc658b52e5810062ad1be66b4460059e32a376a33409caa4f94a9ac2edeb27dd855a886d5de400e40edcffaca468c906d8fbf180d43111956c13dff1ddbe4f4b8bdb2eba1a4e429efd7010f65c433d5481196a24b124fac4ebd75156e402ffc312cd5e65b94e8c225754d2841b31e2eae44524d7e7c1155b4ae502bd5311676a80b168ee125b8ee695d51d3600370205bf8bb82137740df4cdc526b634d97f6b41105580ddf0fed974101a65e570e3c2cc699e51cde9c3dd921b3466bc2d5a2928c0bdce3d4e462a47e8ed421d4a39981e9c5f18bdf2903d2c64a243d72ffc3745c74efe16b35417845de495d3bb5e09f9ccede446fa201967c58c9c82a99643e06f63841369903bcc9d5e98d0cc025e09b7b8ed0ce9960a80e0a34432a82992a9a5c863990561c0781c1a2e64999127f8507d3e315a047f42a57294f8723ae0e36f9a213bed96e0dc7272c1bcd944c45313a212e3d16d9b738006aac517e9364c4ad6f25cff848996ba28d94812e85509680dfdd3cc513ab7a971d1f00a486ca98f3b311c413d0bbc58cf6908eaef31ae5ca66d93b643322080918a11da928ad77e31bb8c9c6390ac3b7ca97c1f2bbce3a88b7cda4cdf2741068a22315ee7d4890d429759ef49df2f79526695f8d659e49aae30330027f15d73d19d70681343495908d97075dc74cafb0b2c700a4c0b835939d6a06eff598c601896992e7bb5a6a3dca92fb5c6fa7257287d11ffdbbd60ac640b4a54e9630507c2bc71a5bfd9d7a8254543efd696576e81446ba6a93b5126350d28f8eee8c42ebadb22ff1dd85949f37df5c848bf69b667f2f4d18139d022860a41bc03b03be947bed1c1fec906527588921c83228ffaca5ebe297294b8e9dd4570eba26d74c652889f75936616b6ae6c1707e72a2b29f254b62147577bbbf585e1db1462782844905b173eafcedb8319861daf37c3de30b89e2b9c146827b18ebcf41c3cf4824d00fa69fe86e060b994d7480c5e8dba591a12c97dd50ab8380edd716c6eb7a34c2d889cc712bb7e46215c4029e2446a7d124a2bf7ddd5b175c40029213348a0f8e8bbbec537cb1f50a06c73acc4559a5b1f13d22832d9c7437d5e44b4e948bba1730844abe0eb5f0ce1d8b3354375eaade88154089148d278b0cf9294c8a55e65ec619a1066284b5c46edbda77a6695eab1987ee9d482f2ec7e2a7a7d46a1e677b3ddc244fba2361d68a2f875aaa4ba5b6504a7d9c03925c0b7af814c1a127e2ac07c2458bea892d5c277f078f9c7717024aced6b2e3629286ecca0144632e73bd6f03a765396425b3fd8b8c043edb1f234bd40c6752ffedbaf8dbc2b1e587617053fb3da887679829e25c6cf7c82900d3aba440190090a5735ed0348cef10d25a2e0d5f7dea154e0aa2780f19c2d9282c8bed4d90e6072827d03404ab11f4be57be94cfc408a98f84c45716c3cd3f66835d8981f8601994289ee62b7f0f9dbbc2d64517aa4733b5d01c0eaa95c395476b884ebc1336a1dd7be1d5cef0b1909a07aa7e16b92d57a2ca8bf448784181123e4e546d5d95bc365698ca573d33945b3bd5bfeb8182cd9b62f5645a63a47c0e6f412ddbe5b99ba9a14c9ca17cb51ae7c2b46e85760e5e154321c205f212dee929ee0bc8d59389c306304f7987fe92d6fd41d09920782c31c189f86db261bdf1fed28cf8dc27354ca33ed1705c5ddae446388910199207b20787a439ab09b7c7d2c02ce323332bf9f3d5e8dce840cd2bdcca073f2d9d221b29436839514015983228ff2d0df2c5eaeaea601d66bc967659222cde4ca70157ece8c5987b687cd3e6555c9b095f0ac03a1a3185733bfae1f8bab7f1642d85b717ed4bad58757bf7289afe18ab6871a4aee9c6682d7514dfb1252bb84bb5532b998b99b8c561e69ef5955af46f0b9b14542fca37b65f093004be0cf329cc5325682f0431dccb512a1961303151a81d206ea7e8a9f2b24c8d3f0054af9d6033e315222d62d4689016dc4d5dd8e8515628ca5f8b691c52fcc3638da76bbd06ed3c544c0826656193894733114f0db965d0e9cecaec42c1272fcf92850aacd9e85607410dae688f61bc9bd48db6e968a376449336752a18635c4aaef648cd6204d43180491f8d1ca14ae65574294cc1d36dd39c41e5a74c5a55315e5cdd2ef517d9f39bdbe6b28ca29e5f1a137b3b0663b29c201a5b942d0d063c8f782f3891794c956ab6861aa9b1888acfda8fc4d5ef80849faa31ad44efdb258947fe595686a7c0e1c90d25192d007b3adcb4abd638d6c93f40ea26277382096110574c0f8c0dfb570799675e76e232e7424f8710919524b3e0cc552b5779512b55621eafe1d24009caf6ebac0b0943a758743972070743826c28bc61587b8ddb6d930c3e1ddce11ed6932b755e01cff4f32533af10f68cd78d559fdcd5668365732d0e6a59648dfe5a7c383597beb7061a16b1206df301389c2ecf3a0f820489cec622e50371e5f5e7f91c15f535dc67f7816407d2cbc25f135e8cefb40e247f8b59a246999c32253c8fbbb376dd4c293ff15591b538ec9591b8fc2c64018e17d2d47648e2434c8c1e6c9b98f4fefd180809f6681b6839ec608bcf3851d7ad1df7d92356ae71295aac44d930120108b5a069ca0482c0486d4ced50e24e0e73f89cc539ea5cf09a69e8852943171b713cb8549fa44a300fad9d610e07bcd21748711eb343f256c0d1364a4f819650451274921d5e2d603dd6f7de983383907104d4f795bee4f151c1a24cfa1c39817bd6072b8675e5922bb662c7f096e3f7b5d25148d1e40569d219b09c773e8871348f2221f53e3c932a21930af820398148f70485d3bb08c92c13a2bb298b690b260d22cb2999e7086e241f9c3f1b29ed3e83e31c4bc562d707c07a6ebd1067ea66289e16a2c784a8637ea203bd64e3bb08315bc9d597f2131602df234cf5bf7af8938d79ebfda8473897c1cde5e3739ba68198b81b0a20337aa78ada19dcf70c9f6830d2a20bad263eb440c3883710849673f3e9c733b06d0e9641ddc5a2f8454580e5af74fb24ed7c9937d90d4128e4bdaa3862f5c433130a0aaf3c0194dc45cc3500cb5be5968b0ffef55d9840991ababd9b92ecb1a26a7076cb3a7f78c293b60e27850ae7b42f556e8989ad1e4fbe1583489970fe0b111a43cf8a0077593d5a8cc24f886d06fd9056aee01c413ba5dd848e25a6eb08e59d7de5c19fdfe8d7e01d4e848fb7c6c254df14296ea5fdf799cb6a287d857d5f9f7d700bae210c24dc634cfdb522ee0d5cc260752b68c72f7f7d06fa96442156599ca72a4c5d271ce713eccb29b65d81b79d20593f65bcd7e16e946c16a85aba9adccac1c9ede154d372b9a334a6f7aea78bb1adb1c3c0a23e263e8c8cabf71190e29d91d5283d8a1d8173820bd5f8ac288174ed24484fa2996e4adef142c5f26f77477003037885b5b77ca31657132089d859416a06998f3ff3b3a6eec9289cfe183e806aed3f1c9642236029373ed5e3f39c9f19eac9769f5594b1517bee0f195f7a0a60dd5246e46d4d4cec7f47c81cd0ae8d5dd60d1f5ee580dae0577e6231e31a924009ee6405227f0f76e41a07c68263425d7537bcda044d5ea7cdfe04b5464cbbca064bb3d5c20ad0592bbaee16f4a08141ad269544f82703120744e5420c871306790d73b5f7c56fd9d323914e854d6afa80d86baba4606d223f1160545275372ad75716090ba94dedae83300bdb63036e12e2e40ee9b3205d60e239e51ad3873694769ea36007a4030fcbeb3af9808c516e360153a8d3c8b076f274e621c7e816d93f4fc49cca6a09f1e9b519f15d559af05d5bc4ae26fa673d482396b64ce79be4de5a3e77768d7c439493bc0b2d4a9cef624d8c0d61d066425df1283ec3adb6d46119f33348cc061922cb2182ee42841929438411c01f63c30976f2b6dc289a67ed5d5be6594a9f05b9ba7f52278a530709aa63eafeea0a90effe12f23bbce3f6250f25dc272f9a7f3c586d9b92f7a6cc92a7baa56ce491c16ede99e26295c839374fc9660dd00de279c86d4689b36ae569bb4fc14cac86e6532d8fd2e5b0e0cd37e860a09ec2b135e3ad2f0a042e08bb7e70d3f615555c70eba08d4c4ef948922a93d982f47fbaf237dfd71b5fc4cf14863cb5d365e310960cf1e63f751baca49697c383750ac3553f13f28f4ae81b6dd67b1a0c71ceffc99b3933e4505564ff1d70ddd834dc8c43c74ef4cf7dced6a87083ec0964e668e7383815c06df990b7f488ad0714348b7af4071ab78b97c73521ecf9015aa66e4a89c7ad42f121fafdb1f408718b05589a513cc0bcabc7d1bb837b2fcfa6e2d0a9f187743b7f8b3c61014ef4a0f83669bcd437db69283e4700bc3714728972b5f195ca5b7e0febc331aed2b6d8e4316b9c40c867ca166b69c3e5966378e4f59dfec81f39a9040beea458ba07ed1224ac616c223614327c44ad1b832842303e5eee0aca2036198a685cf7ae07f480a20047f421b4dd99e61953ea7c6ed05f58367776f33138a21db6c6dffa66c0bfd6d0c4cd5b3c272c33aa49f8a4595bbdafc5824deb2bd1846c8d0277653294911f3f483397fee7ff7617ea8c3ab3e300566b77d8cadad260703ed2d038cdf03d1482dbda9b03489b9c15c373da8f813021193440aa84c5a8d42df6eb9e0cb7649dfc00250dbe67df126d575b3123b5aa761a0762ea8d6c709260b4f1def3a8596339c2c19778fefcb448d8143485bf9f00f1e8c6ea7896c046489b9b95806c0f5eb0c1ef7ac9d0cd6a0a51cc3fcc1f0d0330725f94d2eaf63eeb0bc52f3c1ea92b77f916a26e9acb3df6cc5cfb3a7c035cfb660fe46dca4f254e80c9cf00eaafc7b7e6207636a5c6238b721c14ae319ca092bbffb8a23f661a1fb3e557e98c811a891ff7cac213b41ccb6ec7c998ce907c7610dd180e838947741993bc477dc384f33340d70872375d255a4ee3e324e96d6438ec5b2c12ff4739a12c3a7c6a3665411c74661f8e90b3ebbfbb18ef2a71ceed01b8b396084760ec7420ee3e0da2669d31abd36916257859481301c23cd7c357a889fd0e9bddc85b762640faa6caf8a222bcab326578b01ff14d9d8493682d3f3c8dc15ef26fdfd355019765f7fc55522a76be92b3e110f6dfd9a453cb43c3489b2bed2697b9b234aa2be55b76e2913611179c60e17094784af977dc3aa8b6e899e7fc72d4ea1955af0b8c3cc60200273465c4ef8b6a45639fc36c6101d751d0ac224f0f36f604c86cea28a647b35e165210ea2425615c739473c7cf8e5db1ad22fea646c2602b18a11faf5f18775eba48273048903e2d35382ea6095070879901992336dc6f392fcfe28ad5ac45a28ff64185aa780f287a3ca2f38afdd269098806dcf27d08f932f34d223e65c91f77460ff700eb372ba55ed9e78abbfa5e4898b3f6bb85420053589d8e141e374ec1d9c682f8c2e46ab5c4f599606ee7d90e045cd82f8087e0c467cfebe24d138aecdc08a2f70ed2e8628cee653c8be507e021b9f136a5152637bab5daadbe</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>人生经历</category>
        <category>工作</category>
      </categories>
      <tags>
        <tag>人生经历</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程 | 等待线程结束</title>
    <url>/2021/08/05/%E7%AD%89%E5%BE%85%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9D%9F/</url>
    <content><![CDATA[<h1 id="等待线程结束"><a href="#等待线程结束" class="headerlink" title="等待线程结束"></a>等待线程结束</h1><p><strong>等待线程结束：</strong> 一个线程（假设是主线程）需要等待另外一个线程（假设是t1子线程）执行结束才能继续执行。<br><strong>实现：</strong> 通过调用join(timeout=None)方法<br>参数timeout用来设置超时时间，单位为秒。如果没有设置timeout，则可以一直等待，知道结束。</p>
<span id="more"></span>
<p><strong>实例代码：</strong></p>
<pre><code># coding=utf-8

import time
import threading

# 共享变量
value = []  # 多个线程都可以访问的变量


# 线程体函数
def thread_body():
    # 当前线程对象
    print(&#39;t1子线程开始...&#39;)

    for n in range(2):
        print(&#39;t1子线程执行...&#39;)
        value.append(n)
        # 线程休眠
        time.sleep(2)

    print(&#39;t1子线程结束。&#39;)


# 主线程
print(&#39;主线程开始执行...&#39;)
# 创建线程对象t1
t1 = threading.Thread(target=thread_body)
# 启动线程t1
t1.start()
# 主线程阻塞，等待t1线程结束
t1.join()
print(&#39;value = &#123;0&#125;&#39;.format(value))
print(&#39;主线程继续执行...&#39;)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>内置模块</category>
        <category>threading</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>threading</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>C# | 简单计算器</title>
    <url>/2021/07/03/%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E5%99%A8/</url>
    <content><![CDATA[<h1 id="简单计算器-C-实现"><a href="#简单计算器-C-实现" class="headerlink" title="简单计算器(C#实现)"></a>简单计算器(C#实现)</h1><p>下面的代码实现了一个简单计算器的功能！</p>
<pre><code>using System;

namespace ConsoleApp1
&#123;
    class Calculator
    &#123;
        public int num1;
        public int num2;
        public int Add()
        &#123;
            return num1 + num2;
        &#125;
        public int Minus()
        &#123;
            return num1 - num2;
        &#125;

        public int Multiply()
        &#123;
            return num1 * num2;
        &#125;

        public int Divide()
        &#123;
            try
            &#123;
                return num1 / num2;
            &#125;
            catch(DivideByZeroException e)
            &#123;
                Console.WriteLine(&quot;DivideByZeroException: &#123;0&#125;&quot;, e.Message);
                return -1;
            &#125;
        &#125;
    &#125;

    class Execution
    &#123;
        static void Main(string[] args)
        &#123;
            char op;
            Calculator c = new Calculator();
            Console.WriteLine(&quot;请输入第一个操作数：&quot;);
            c.num1 = Convert.ToInt32(Console.ReadLine());
            Console.WriteLine(&quot;请输入第一个操作数：&quot;);
            c.num2 = Convert.ToInt32(Console.ReadLine());
            Console.WriteLine(&quot;请输入操作符：&quot;);
            op = Convert.ToChar(Console.ReadLine());

            switch (op)
            &#123;
                case &#39;+&#39;: Console.WriteLine(&quot;&#123;0&#125;&#123;1&#125;&#123;2&#125;=&#123;3&#125;&quot;, c.num1, op, c.num2, c.Add()); break;
                case &#39;-&#39;: Console.WriteLine(&quot;&#123;0&#125;&#123;1&#125;&#123;2&#125;=&#123;3&#125;&quot;, c.num1, op, c.num2, c.Minus()); break;
                case &#39;*&#39;: Console.WriteLine(&quot;&#123;0&#125;&#123;1&#125;&#123;2&#125;=&#123;3&#125;&quot;, c.num1, op, c.num2, c.Multiply()); break;
                case &#39;/&#39;: Console.WriteLine(&quot;&#123;0&#125;&#123;1&#125;&#123;2&#125;=&#123;3&#125;&quot;, c.num1, op, c.num2, c.Divide()); break;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程 | 线程停止</title>
    <url>/2021/08/05/%E7%BA%BF%E7%A8%8B%E5%81%9C%E6%AD%A2/</url>
    <content><![CDATA[<h1 id="线程停止"><a href="#线程停止" class="headerlink" title="线程停止"></a>线程停止</h1><p>在线程体结束时，线程就停止了。但在某些业务比较复杂时，会在线程体重执行一个“死循环”。线程体是够执行“死循环”是通过<br><strong>判断停止变量</strong>实现的，“死循环”结束则线程体结束，线程也就结束了。</p>
<p><strong>示例代码：</strong></p>
<pre><code># coding=utf-8

import time
import threading

# 线程停止变量
isrunning = True


# 工作线程体函数
def workthread_body():
    while isrunning:
        # 线程开始工作
        print(&#39;工作线程执行中...&#39;)
        # 线程休眠
        time.sleep(5)
    print(&#39;工作线程结束。&#39;)


# 控制线程体函数
def controlthread_body():
    global isrunning
    while isrunning:
        # 从键盘输入停止指令exit
        command = input(&#39;请输入停止指令：&#39;)
        if command == &#39;exit&#39;:
            isrunning = False
            print(&#39;控制线程结束&#39;)


# 主线程
# 创建工作线程对象workthread
workthread = threading.Thread(target=workthread_body)
# 启动线程workthread
workthread.start()

# 创建控制线程对象controlthread
controlthread = threading.Thread(target=controlthread_body)
# 启动线程controlthread
controlthread.start()
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>内置模块</category>
        <category>threading</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>threading</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>伪迹移除 | 经验模态分解</title>
    <url>/2021/02/23/%E7%BB%8F%E9%AA%8C%E6%A8%A1%E6%80%81%E5%88%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="EMD"><a href="#EMD" class="headerlink" title="EMD"></a>EMD</h1><p>EMD is an <b>empirical and data-driven method</b> developed to perform on <b>non-stationary</b>,<b>non-linear</b>, <b>stochastic</b> processes(it is ideally suitable for EEG signal analysis and processing)</p>
<h2 id="Disadvantages"><a href="#Disadvantages" class="headerlink" title="Disadvantages:"></a>Disadvantages:</h2><p>1.the <b>computational complexity</b> is quite heavy(not suitable for online application)<br>2.the <b>theory</b> behind EMD is still not complete and so far used in empirical studies(difficult to predict its robustness in all EEG recordings)</p>
<h2 id="EMD-Algorithm"><a href="#EMD-Algorithm" class="headerlink" title="EMD Algorithm"></a>EMD Algorithm</h2><p><b style="color: red">EMD algorithm decomposes a signal,s[n] into a sum of the band-limited components/functions,c[n] called intrinsic mode funciton(IMF) with well defined instantaneous frequencies.</b></p>
<h3 id="Two-Basic-Conditions-to-be-an-IMF"><a href="#Two-Basic-Conditions-to-be-an-IMF" class="headerlink" title="Two Basic Conditions to be an IMF"></a>Two Basic Conditions to be an IMF</h3><p>1.the numberof extrema must be equal(or at most may differ by one) to the number of zero crossings<br>2.any point,the mean value of the two envelopes defined by the local maxima and the local minima has to be zero</p>
<h3 id="The-General-Process-flow-of-EMD-Algorithm"><a href="#The-General-Process-flow-of-EMD-Algorithm" class="headerlink" title="The General Process flow of EMD Algorithm"></a>The General Process flow of EMD Algorithm</h3><p>Input: data sequence s[n]<br>1.Identify all the local extrema<br>2.Separately connect all the maxima and minima with natural cubic spline lines to form the upper,u[n],and lower,l[n],envelopes.<br>3.Find the mean of the envolopes as <b>z[n]=[u[n]+l[n]]/2</b><br>4.Take the difference between the data and the mean as the proto-IMF,<b>h[n]=s[n]-z[n]</b><br>5.Check the proto-IMF against the definition of IMF and the stoppage criterion to determine if it is an IMF<br>6.If the proto-IMF does not satisfy the definition,repeat step 1 to 5 on h[n] as many times as needed till it satisfies the definition<br>7.If the proto-IMF does satisfy the definition,assign the proto-IMF as an IMF component,c[n]<br>8.Repeat the operation step 1 to 7 on the residue,q[n]=s[n]-c[n],as the data<br>9.The operation ends when the residue contains no more than one extrema</p>
<h3 id="EEMD-enhanced-version-of-EMD"><a href="#EEMD-enhanced-version-of-EMD" class="headerlink" title="EEMD(enhanced version of EMD)"></a>EEMD(enhanced version of EMD)</h3><p>EEMD it inspired from the fact that <b>EMD is very sensitive to noise</b>,which often leads to mode mixing complication.<br>EEMD is proposed which uses an <b>average number of ensembles(IMFs) from EMD as the optimal IMFs</b> thus it provides a <b>noise-assisted data analysis method</b>.</p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>伪迹移除</category>
      </categories>
      <tags>
        <tag>EMD</tag>
        <tag>经验模态分解</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 结构化数据与非结构化数据</title>
    <url>/2021/06/21/%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE%E4%B8%8E%E9%9D%9E%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="结构化数据与非结构化数据"><a href="#结构化数据与非结构化数据" class="headerlink" title="结构化数据与非结构化数据"></a>结构化数据与非结构化数据</h1><p><img src="/2021/06/21/%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE%E4%B8%8E%E9%9D%9E%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE/1.png"></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>matplotlib | 绘制几个模型某性能指标在某个范围内的大小比较图</title>
    <url>/2021/10/12/%E7%BB%98%E5%88%B6%E5%87%A0%E4%B8%AA%E6%A8%A1%E5%9E%8B%E6%9F%90%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E5%9C%A8%E6%9F%90%E4%B8%AA%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%AF%94%E8%BE%83%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="绘制几个模型某性能指标在某个范围内的大小比较图"><a href="#绘制几个模型某性能指标在某个范围内的大小比较图" class="headerlink" title="绘制几个模型某性能指标在某个范围内的大小比较图"></a>绘制几个模型某性能指标在某个范围内的大小比较图</h1><p>我们在做深度学习实验时，很多时候会需要对几个模型的性能进行对比并进行可视化，从而清楚地展示模型性能的大小关系。</p>
<span id="more"></span>
<p>下面以几个模型的精确度大小比较为例：</p>
<p><strong>代码：</strong></p>
<pre><code>import matplotlib.pyplot as plt

CNNLSTM_valence_acc = [0.6885742, 0.690625, 0.69453126, 0.69277346, 0.69003904, 0.6965332, 0.6917969, 0.68652344, 0.6916992, 0.69140625, 0.6933594, 0.6972656, 0.69277346, 0.6941406, 0.69501954, 0.69257814, 0.6929687, 0.69208986, 0.6905273, 0.6930664, 0.69384766, 0.6856445, 0.6958984, 0.6929687, 0.693457, 0.69501954, 0.6893555, 0.7, 0.6904297, 0.69628906, 0.6921875, 0.6910156, 0.6988281, 0.69492185, 0.69541013, 0.69443357, 0.69257814, 0.6955078, 0.6942383, 0.69628906, 0.6933594, 0.6976563, 0.69267577, 0.6948242, 0.69277346, 0.6964844, 0.6923828, 0.6959961, 0.6993164, 0.6935547]
CNN3Conv_valence_acc = [0.53, 0.57, 0.52, 0.55, 0.57, 0.53, 0.54, 0.55, 0.5, 0.49, 0.53, 0.45, 0.55, 0.56, 0.54, 0.49, 0.54, 0.55, 0.57, 0.52, 0.49, 0.54, 0.5, 0.49, 0.56, 0.52, 0.52, 0.55, 0.55, 0.57, 0.5, 0.5, 0.52, 0.55, 0.54, 0.57, 0.53, 0.55, 0.51, 0.54, 0.54, 0.53, 0.56, 0.52, 0.53, 0.53, 0.54, 0.53, 0.5, 0.54]
CNN5Conv_valence_acc = [0.69, 0.6699999999999999, 0.6799999999999999, 0.66, 0.54, 0.57, 0.6699999999999999, 0.6699999999999999, 0.61, 0.61, 0.63, 0.62, 0.63, 0.62, 0.6699999999999999, 0.62, 0.66, 0.6699999999999999, 0.62, 0.58, 0.61, 0.66, 0.61, 0.65, 0.63, 0.62, 0.62, 0.59, 0.62, 0.63, 0.62, 0.63, 0.62, 0.62, 0.63, 0.61, 0.62, 0.62, 0.6699999999999999, 0.63, 0.64, 0.64, 0.65, 0.6699999999999999, 0.62, 0.69, 0.58, 0.59, 0.63, 0.61]

print(len(CNNLSTM_valence_acc))
print(len(CNN3Conv_valence_acc))
print(len(CNN5Conv_valence_acc))

x = range(len(CNN5Conv_valence_acc))
plt.plot(x, CNNLSTM_valence_acc, label=u&#39;CNN-LSTM&#39;)
plt.plot(x, CNN3Conv_valence_acc, label=u&#39;CNN3Conv&#39;)
plt.plot(x, CNN5Conv_valence_acc, label=u&#39;CNN5Conv&#39;)
plt.legend()
plt.xlabel(u&quot;epoch&quot;)
plt.ylabel(u&quot;accuracy&quot;)
plt.show()
</code></pre>
<p><strong>效果图：</strong><br><img src="/2021/10/12/%E7%BB%98%E5%88%B6%E5%87%A0%E4%B8%AA%E6%A8%A1%E5%9E%8B%E6%9F%90%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E5%9C%A8%E6%9F%90%E4%B8%AA%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%AF%94%E8%BE%83%E5%9B%BE/myplot.png"></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>matplotlib</category>
      </categories>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title>绝对路径和相对路径</title>
    <url>/2020/11/29/%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%92%8C%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h1><p><strong>绝对路径</strong>：相对于磁盘的位置定位文件的地址<br><strong>相对路径</strong>：相对于引用文件本身定位被引用文件的地址</p>
<p>Note:<br>./ 当前文件所在目录下<br>../ 当前文件所在目录的上一级目录</p>
]]></content>
      <tags>
        <tag>绝对路径</tag>
        <tag>相对路径</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程 | 网络中常见的协议以及术语</title>
    <url>/2020/10/22/%E7%BD%91%E7%BB%9C%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8D%8F%E8%AE%AE%E4%BB%A5%E5%8F%8A%E6%9C%AF%E8%AF%AD/</url>
    <content><![CDATA[<h1 id="几种常见tcp、ip协议以及常见术语"><a href="#几种常见tcp、ip协议以及常见术语" class="headerlink" title="几种常见tcp、ip协议以及常见术语"></a>几种常见tcp、ip协议以及常见术语</h1><p>ICMP(internet 控制报文协议)—&gt;使用ping命令时</p>
<p>ARP(地址解析协议)—&gt;根据IP地址找MAC地址</p>
<p>RARP(反向地址解析协议)—&gt;根据MAC地址找IP地址</p>
<p>MAC(媒体访问控制地址)—&gt;网卡的编号</p>
<p>IP:标记逻辑上的地址</p>
<p>mac：标记实际转发数据时的设备地址</p>
<p>DHCP(动态主机配置协议):发现当前局域网内没有IP的电脑，给这台电脑自动分配IP</p>
<p>netmask:和ip地址一起来确定网络号</p>
<p>默认网关：发送的ip不在同一个网段内，那么会把这个数据转发给默认网关<br><b>Note:</b><br>MAC地址在两个设备之间通信时在变化<br>IP地址在整个通信过程中都不会发生变化</p>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title>Chicken Soup for the Soul | 罗曼罗兰英雄主义</title>
    <url>/2021/10/12/%E7%BD%97%E6%9B%BC%E7%BD%97%E5%85%B0%E8%8B%B1%E9%9B%84%E4%B8%BB%E4%B9%89/</url>
    <content><![CDATA[<h1 id="Chicken-Soup"><a href="#Chicken-Soup" class="headerlink" title="Chicken Soup"></a>Chicken Soup</h1><p>人生当中成功只是一时的，失败却是主旋律，但是如何面对失败，却把人分成了不同的样子，有的人会被失败击垮，有的人能够不断地爬起来继续向前，我想真正的成熟，并不是追求完美，而是直面自己的缺憾，这才是生活的本质。罗曼罗兰说过：这个世上只有一种真正的英雄注意，那就是认清生活的真相，并且依然热爱它。</p>
<p>2021/10/13</p>
]]></content>
      <categories>
        <category>Chicken Soup for the Soul</category>
      </categories>
      <tags>
        <tag>Chicken Soup for the Soul</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 罗马数字转整数</title>
    <url>/2021/08/27/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<h1 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13.罗马数字转整数"></a>13.罗马数字转整数</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>
<p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000</p>
<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。<br>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：<br>    I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>    X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>    C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/roman-to-integer/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>通常情况下，罗马数字中小的数字在大的数字的右边。若输入的字符串满足该情况，那么可以将每个字符视作一个单独的值，累加每个字符对应的数值即可。<br>例如 XXVII 可视作 X+X+V+I+I=10+10+5+1+1=27。<br>若存在小的数字在大的数字的左边的情况，根据规则需要减去小的数字。对于这种情况，我们也可以将每个字符视作一个单独的值，若一个数字右侧的数字比它大，则将该数字的符号取反。<br>例如 XIV 可视作 X−I+V=10−1+5=14。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):
    def romanToInt(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: int
        &quot;&quot;&quot;
        # SYMBOL_VALUES = &#123;
        #     &#39;I&#39;: 1,
        #     &#39;V&#39;: 5,
        #     &#39;X&#39;: 10,
        #     &#39;L&#39;: 50,
        #     &#39;C&#39;: 100,
        #     &#39;D&#39;: 500,
        #     &#39;M&#39;: 1000,
        # &#125;
        # ans = 0
        # n = len(s)
        # for i, ch in enumerate(s):
        #     value = SYMBOL_VALUES[ch]
        #     if i &lt; n - 1 and value &lt; SYMBOL_VALUES[s[i+1]]:
        #         ans -= value
        #     else:
        #         ans += value
        # return ans

        roman2int = &#123;
            &#39;I&#39;: 1,
            &#39;V&#39;: 5,
            &#39;X&#39;: 10,
            &#39;L&#39;: 50,
            &#39;C&#39;: 100,
            &#39;D&#39;: 500,
            &#39;M&#39;: 1000,
        &#125;

        num = 0
        i = 0
        while i &lt; len(s):
            if s[i] == &#39;I&#39; and i+1 &lt; len(s) and (s[i+1] == &#39;V&#39; or s[i+1] == &#39;X&#39;):
                num += (roman2int[s[i+1]] - roman2int[s[i]])
                i += 2
            elif s[i] == &#39;X&#39; and i+1 &lt; len(s) and (s[i+1] == &#39;L&#39; or s[i+1] == &#39;C&#39;):
                num += (roman2int[s[i+1]] - roman2int[s[i]])
                i += 2
            elif s[i] == &#39;C&#39; and i+1 &lt; len(s) and (s[i+1] == &#39;D&#39; or s[i+1] == &#39;M&#39;):
                num += (roman2int[s[i+1]] - roman2int[s[i]])
                i += 2
            else:
                num += roman2int[s[i]]
                i += 1

        return num



if __name__ == &quot;__main__&quot;:
    slt = Solution()
    s = &quot;MCMXCIV&quot;
    int_num = slt.romanToInt(s)
    print(&quot;罗马数字 &#123;&#125; 对应的整数为 &#123;&#125; &quot;.format(s, int_num))
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>EEG | 脑电信号采用深度学习方法存在的问题</title>
    <url>/2020/11/10/%E8%84%91%E7%94%B5%E4%BF%A1%E5%8F%B7%E9%87%87%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="脑电信号采用深度学习方法存在的问题"><a href="#脑电信号采用深度学习方法存在的问题" class="headerlink" title="脑电信号采用深度学习方法存在的问题"></a>脑电信号采用深度学习方法存在的问题</h1><p>深度学习是一种构造多层神经网络的机器学习方法，具有发现数据中隐藏的分布式特征表示的能力。</p>
<h2 id="脑电信号特征提取方法："><a href="#脑电信号特征提取方法：" class="headerlink" title="脑电信号特征提取方法："></a>脑电信号特征提取方法：</h2><p>时域分析方法<br>频域分析方法<br>时频域分析犯法<br>非线性分析方法</p>
<h2 id="脑电信号采用深度学习方法目前存在的问题"><a href="#脑电信号采用深度学习方法目前存在的问题" class="headerlink" title="脑电信号采用深度学习方法目前存在的问题"></a>脑电信号采用深度学习方法目前存在的问题</h2><p>（1）<b style="color:red">深度神经网络层数的最优化，不是越多的网络层数就能得到最好的结果</b><br>（2）数据量也是造成深度学习方法无法深入的原因</p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>EEG</tag>
      </tags>
  </entry>
  <entry>
    <title>EEG | 脑电数据集下载网站</title>
    <url>/2021/04/17/%E8%84%91%E7%94%B5%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8B%E8%BD%BD%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h1 id="脑电数据集下载网站"><a href="#脑电数据集下载网站" class="headerlink" title="脑电数据集下载网站"></a>脑电数据集下载网站</h1><p><a href="www.physionet.org">网站1</a></p>
<p><a href="https://archive.ics.uci.edu/ml/datasets/EEG+Database">网站2</a></p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
      </categories>
      <tags>
        <tag>EEG</tag>
        <tag>数据集</tag>
      </tags>
  </entry>
  <entry>
    <title>伪迹移除 | 自适应滤波器</title>
    <url>/2021/02/23/%E8%87%AA%E9%80%82%E5%BA%94%E6%BB%A4%E6%B3%A2%E5%99%A8/</url>
    <content><![CDATA[<h1 id="Adaptive-Filter"><a href="#Adaptive-Filter" class="headerlink" title="Adaptive Filter"></a>Adaptive Filter</h1><p>Adaptive Filter is a system with a linear filter that has a transfer function controlled by variable parameters and a means to adjust those parameters according to an optimization algorithm.The filter weights can adapt based on the feedback from output of the system and it requires a reference input o compare the desired output with the observed output.</p>
<h2 id="The-use-of-adaptive-filter-for-EOG-artifact-removal"><a href="#The-use-of-adaptive-filter-for-EOG-artifact-removal" class="headerlink" title="The use of adaptive filter for EOG artifact removal"></a>The use of adaptive filter for EOG artifact removal</h2><p><img src="/2021/02/23/%E8%87%AA%E9%80%82%E5%BA%94%E6%BB%A4%E6%B3%A2%E5%99%A8/1.PNG"><br>where s[n] is observed signal,x[n] is original EEG,r[n] is artifact,x’[n] is artifact-free EEG.</p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>伪迹移除</category>
      </categories>
      <tags>
        <tag>自适应滤波器</tag>
      </tags>
  </entry>
  <entry>
    <title>urllib.request | 解码json数据</title>
    <url>/2021/08/05/%E8%A7%A3%E7%A0%81json%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="使用json提供的loads-str-函数进行JSON数据的解码"><a href="#使用json提供的loads-str-函数进行JSON数据的解码" class="headerlink" title="使用json提供的loads(str)函数进行JSON数据的解码"></a>使用json提供的loads(str)函数进行JSON数据的解码</h1><p><strong>函数说明：</strong><br>    str - JSON字符串<br>    返回值 - python数据<br><strong>示例代码：</strong></p>
<pre><code># coding=utf-8

import urllib.request
import json

# 使用json模块的loads(str)函数进行JSON数据的解码
url = &#39;http://localhost:8080/NoteWebService/note.do?action=query&amp;ID=10&#39;

req = urllib.request.Request(url)

with urllib.request.urlopen(req) as response:
    data = response.read()
    json_data = data.decode()
    print(&quot;JSON字符串：&quot;, json_data)

    py_dict = json.loads(json_data)  # 解码JSON字符串，返回字典
    print(&#39;备忘录ID：&#39;, py_dict[&#39;ID&#39;])
    print(&#39;备忘录日期：&#39;, py_dict[&#39;CDate&#39;])
    print(&#39;备忘录内容：&#39;, py_dict[&#39;Content&#39;])
    print(&#39;用户ID：&#39;, py_dict[&#39;UserID&#39;])
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>内置模块</category>
        <category>urllib</category>
      </categories>
      <tags>
        <tag>urllib</tag>
        <tag>python</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 计算图</title>
    <url>/2021/06/19/%E8%AE%A1%E7%AE%97%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h1><p>一个计算流程图，就是正向或者说从左到右的计算来计算成本函数𝐽，你可能<br>需要优化的函数，然后反向从右到左计算导数。<br><img src="/2021/06/19/%E8%AE%A1%E7%AE%97%E5%9B%BE/1.png"><br><b>参考吴恩达深度学习视频：</b><a href="https://www.bilibili.com/video/BV1FT4y1E74V?p=15&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV1FT4y1E74V?p=15&amp;spm_id_from=pageDriver</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>计算图</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 赎金信</title>
    <url>/2021/09/01/%E8%B5%8E%E9%87%91%E4%BF%A1/</url>
    <content><![CDATA[<h1 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383.赎金信"></a>383.赎金信</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。<br>(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/ransom-note/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>遍历ransomNote中的每一个元素，并查找这个元素是否在magazine中，如果没有查找到，则返回False，如果查找到了，则将这个元素在magazine中移除，以此类推，直到遍历完ransomNote中的每一个元素。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool:
        ransomNote = list(ransomNote)
        magazine = list(magazine)

        for i in range(len(ransomNote)):
            if ransomNote[i] in magazine:
                magazine.remove(ransomNote[i])
                print(ransomNote)
            else:
                return False

        if i == len(ransomNote)-1:
            return True


if __name__ == &#39;__main__&#39;:
    s = Solution()
    res = s.canConstruct(&#39;aa&#39;, &#39;aab&#39;)
    print(res)

    # list1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;]
    # list1.remove(&#39;a&#39;)
    # print(list1)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>软件架构 | 软件设计策略</title>
    <url>/2021/03/11/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h1 id="软件设计策略"><a href="#软件设计策略" class="headerlink" title="软件设计策略"></a>软件设计策略</h1><p>1.面向对象设计</p>
<p>2.面向功能设计(结构化)</p>
<p>3.面向主题设计</p>
<p>4.面向数据结构设计(数据库)</p>
]]></content>
      <categories>
        <category>SA</category>
      </categories>
      <tags>
        <tag>软件架构</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 逆波兰表达式求值</title>
    <url>/2021/08/27/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
    <content><![CDATA[<h1 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150.逆波兰表达式求值"></a>150.逆波兰表达式求值</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>根据 逆波兰表示法，求表达式的值。<br>有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。<br>说明：<br>    整数除法只保留整数部分。<br>    给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p>
<p>示例 1：<br>输入：tokens = [“2”,”1”,”+”,”3”,”*”]<br>输出：9<br>解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.栈<br>遍历逆波兰表达式中的每一个字符，遇到数字则将数字入栈，遇到运算符则将栈顶的两个操作数出栈作此运算符对应的运算，再将运算结果入栈，…，以此类推，直到遍历完整个表达式，栈中剩余的元素就是表达式的结果。<br>2.数组模拟栈<br>对于一个有效的逆波兰表达式，其长度 n 一定是奇数，且操作数的个数一定比运算符的个数多 1 个，即包含 (n+1)/2 个操作数和 (n-1)/2 个运算符。考虑遇到操作数和运算符时，栈内元素个数分别会如何变化：<br>    如果遇到操作数，则将操作数入栈，因此栈内元素增加 1 个；<br>    如果遇到运算符，则将两个操作数出栈，然后将一个新操作数入栈，因此栈内元素先减少 2 个再增加 1 个，结果是栈内元素减少 1 个。<br>由此可以得到操作数和运算符与栈内元素个数变化的关系：遇到操作数时，栈内元素增加 1 个；遇到运算符时，栈内元素减少 1 个。<br>最坏情况下，(n+1)/2 个操作数都在表达式的前面，(n-1)/2 个运算符都在表达式的后面，此时栈内元素最多为 (n+1)/2 个。在其余情况下，栈内元素总是少于 (n+1)/2 个。因此，在任何情况下，栈内元素最多可能有 (n+1)/2 个，将数组的长度定义为 (n+1)/2 即可。<br>具体实现方面，创建数组 stack 模拟栈，数组下标 0 的位置对应栈底，定义 index 表示栈顶元素的下标位置，初始时栈为空，index=−1。当遇到操作数和运算符时，进行如下操作：<br>    如果遇到操作数，则将 index 的值加 111，然后将操作数赋给 stack[index]；<br>    如果遇到运算符，则将 index 的值减 111，此时 stack[index] 和 stack[index+1] 的元素分别是左操作数和右操作数，使用运算符对两个操作数进行运算，将运算得到的新操作数赋给 stack[index]。<br>整个逆波兰表达式遍历完毕之后，栈内只有一个元素，因此 index=0，此时 stack[index] 即为逆波兰表达式的值。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):
    def evalRPN(self, tokens):
        &quot;&quot;&quot;
        使用栈进行表达式求值

        :type tokens: List[str]
        :rtype: int
        &quot;&quot;&quot;
        op_to_binary_fn = &#123;
            &quot;+&quot;: lambda x, y: x + y,
            &#39;-&#39;: lambda x, y: x - y,
            &#39;*&#39;: lambda x, y: x * y,
            &#39;/&#39;: lambda x, y: int(x / y),
        &#125;

        stack = list()
        for token in tokens:
            try:
                num = int(token)
            except ValueError:
                num2 = stack.pop()
                num1 = stack.pop()
                num = op_to_binary_fn[token](num1, num2)
            finally:
                stack.append(num)

        return stack[0]

    def evalRPN1(self, tokens):
        &quot;&quot;&quot;
        使用数组模拟栈进行表达式求值

        :type tokens: List[str]
        :rtype: int
        &quot;&quot;&quot;
        op_to_binary_fn = &#123;
            &quot;+&quot;: lambda x, y: x + y,
            &#39;-&#39;: lambda x, y: x - y,
            &#39;*&#39;: lambda x, y: x * y,
            &#39;/&#39;: lambda x, y: int(x / y),
        &#125;
        n = len(tokens)
        stack = [0] * ((n + 1) // 2)
        index = -1
        for token in tokens:
            try:
                num = int(token)
                index += 1
                stack[index] = num
            except ValueError:
                index -= 1
                stack[index] = op_to_binary_fn[token](stack[index], stack[index + 1])
        return stack[0]


if __name__ == &quot;__main__&quot;:
    slt = Solution()
    # tokens = [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]
    # tokens = [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]
    tokens = [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]
    print(&quot;表达式的值为：&#123;&#125;&quot;.format(slt.evalRPN1(tokens)))
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 防止模型过拟合的6种必备方法</title>
    <url>/2021/07/03/%E9%98%B2%E6%AD%A2%E6%A8%A1%E5%9E%8B%E8%BF%87%E6%8B%9F%E5%90%88%E7%9A%846%E7%A7%8D%E5%BF%85%E5%A4%87%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="防止模型过拟合的6种必备方法"><a href="#防止模型过拟合的6种必备方法" class="headerlink" title="防止模型过拟合的6种必备方法"></a>防止模型过拟合的6种必备方法</h1><p>在训练机器学习模型时常常会遇到模型过拟合的情况，即模型在训练集上的表现良好，但是在验证集或者<br>测试集上表现相对较差；<br><b>常见的防止过拟合的方法：</b><br>1.使用K重交叉验证方法或者留一验证方法<br>2.数据增强<br>3.正则化<br>4.早停<br>5.Dropout<br>6.移除特征<br><a href="https://mp.weixin.qq.com/s/RP9iFbyw-aNMKx-UAOe-aA">参考资料</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>过拟合</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 飞桨推出的深度学习资料一站式获取平台项目</title>
    <url>/2021/06/23/%E9%A3%9E%E6%A1%A8%E6%8E%A8%E5%87%BA%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E4%B8%80%E7%AB%99%E5%BC%8F%E8%8E%B7%E5%8F%96%E5%B9%B3%E5%8F%B0%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="飞桨推出的深度学习资料一站式获取平台项目"><a href="#飞桨推出的深度学习资料一站式获取平台项目" class="headerlink" title="飞桨推出的深度学习资料一站式获取平台项目"></a>飞桨推出的深度学习资料一站式获取平台项目</h1><p>这是飞桨推出的深度学习资料一站式获取平台项目，可以看看有没有符合自己的资料哈~~</p>
<p><a href="https://github.com/PaddlePaddle/awesome-DeepLearning">飞桨PaddlePaddle</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>飞桨</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 验证回文串</title>
    <url>/2021/08/28/%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125.验证回文串"></a>125.验证回文串</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。<br>说明：本题中，我们将空字符串定义为有效的回文串。</p>
<span id="more"></span>
<p>示例 1:<br>输入: “A man, a plan, a canal: Panama”<br>输出: true<br>解释：”amanaplanacanalpanama” 是回文串</p>
<p><a href="https://leetcode-cn.com/problems/count-and-say/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.判断第i(0 &lt; i &lt; len(new_s)//2)个字符与倒数第i个字符是否相等来确定字符串是否回文，其中new_s是去除了除数字字母外字符的字符串<br>2.判断反转字符串是否与原字符串相同<br>3.双指针（去除除数字字母外的其他字符）<br>初始时，左右指针分别指向字符串的两侧，随后我们不断地将这两个指针相向移动，每次移动一步，并判断这两个指针指向的字符是否相同。当这两个指针相遇时，就说明是回文串。<br>4.双指针（直接在原字符串上进行判断）<br>与3.相同</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def isPalindrome(self, s: str) -&gt; bool:
        import re
        new_s = re.sub(r&#39;\W|_&#39;, &#39;&#39;, s).lower()
        len_new_s = len(new_s)
        i = 0
        while i &lt; len_new_s // 2:
            if new_s[i] == new_s[len_new_s-i-1]:
                i += 1
            else:
                break
        if i == len_new_s // 2:
            return True
        else:
            return False

    def isPalindrome1(self, s: str) -&gt; bool:
        &quot;&quot;&quot;
        筛选+判断（判断反转字符串是否与原字符串相同）
        :param s:
        :return:
        &quot;&quot;&quot;
        new_s = &quot;&quot;.join(ch.lower() for ch in s if ch.isalnum())
        return new_s == new_s[::-1]

    def isPalindrome2(self, s: str) -&gt; bool:
        &quot;&quot;&quot;
        双指针
        &quot;&quot;&quot;
        new_s = &quot;&quot;.join(ch.lower() for ch in s if ch.isalnum())
        left, right = 0, len(new_s) - 1

        while left &lt; right:
            if new_s[left] != new_s[right]:
                return False

            left, right = left + 1, right - 1

        return True

    def isPalindrome3(self, s: str) -&gt; bool:
        &quot;&quot;&quot;在原字符串上直接判断&quot;&quot;&quot;
        n = len(s)
        left, right = 0, n - 1

        while left &lt; right:
            while left &lt; right and not s[left].isalnum():
                left += 1
            while left &lt; right and not s[right].isalnum():
                right -= 1
            if left &lt; right:
                if s[left].lower() != s[right].lower():
                    return False
                left, right = left + 1, right - 1

        return True


if __name__ == &quot;__main__&quot;:
    slt = Solution()
    string = &quot;abcb&quot;
    res = slt.isPalindrome(string)
    print(res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>ICA | 鸡尾酒宴会问题</title>
    <url>/2021/02/21/%E9%B8%A1%E5%B0%BE%E9%85%92%E5%AE%B4%E4%BC%9A%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="鸡尾酒宴会问题"><a href="#鸡尾酒宴会问题" class="headerlink" title="鸡尾酒宴会问题"></a>鸡尾酒宴会问题</h1><p>鸡尾酒宴会问题是独立成分分析(Indepen Compon Analysis)的经典问题。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>假设在party中有n个人，他们可以同时说话，我们也在房间中一些角落里共放置了n个声音接收器（Microphone）用来记录声音。宴会过后，我们从n个麦克风中得到了一组数据<br><img src="/2021/02/21/%E9%B8%A1%E5%B0%BE%E9%85%92%E5%AE%B4%E4%BC%9A%E9%97%AE%E9%A2%98/1.png"><br>，i表示采样的时间顺序，也就是说共得到了m组采样，每一组采样都是n维的。我们的目标是单单从这m组采样数据中分辨出每个人说话的信号。</p>
<p>将第二个问题细化一下，有n个信号源<br><img src="/2021/02/21/%E9%B8%A1%E5%B0%BE%E9%85%92%E5%AE%B4%E4%BC%9A%E9%97%AE%E9%A2%98/2.png"><br>,每一维都是一个人的声音信号，每个人发出的声音信号独立。A是一个未知的混合矩阵（mixing matrix），用来组合叠加信号s，那么<br>X = AS<br>X的意义在上文解释过，这里的x不是一个向量，是一个矩阵。其中每个列向量是<br><img src="/2021/02/21/%E9%B8%A1%E5%B0%BE%E9%85%92%E5%AE%B4%E4%BC%9A%E9%97%AE%E9%A2%98/3.png"><br>表示成图就是<br><img src="/2021/02/21/%E9%B8%A1%E5%B0%BE%E9%85%92%E5%AE%B4%E4%BC%9A%E9%97%AE%E9%A2%98/4.jpg"><br><img src="/2021/02/21/%E9%B8%A1%E5%B0%BE%E9%85%92%E5%AE%B4%E4%BC%9A%E9%97%AE%E9%A2%98/5.png"><br>x(i)的每个分量都由s(i)的分量线性表示。A和s都是未知的，x是已知的，我们要想办法根据x来推出s。这个过程也称作为盲信号分离。<br><img src="/2021/02/21/%E9%B8%A1%E5%B0%BE%E9%85%92%E5%AE%B4%E4%BC%9A%E9%97%AE%E9%A2%98/8.png"><br>将W表示成<br><img src="/2021/02/21/%E9%B8%A1%E5%B0%BE%E9%85%92%E5%AE%B4%E4%BC%9A%E9%97%AE%E9%A2%98/9.png"><br>其中<img src="/2021/02/21/%E9%B8%A1%E5%B0%BE%E9%85%92%E5%AE%B4%E4%BC%9A%E9%97%AE%E9%A2%98/10.png">,起始就是将wi携程行向量形式。那么得到：<br><img src="/2021/02/21/%E9%B8%A1%E5%B0%BE%E9%85%92%E5%AE%B4%E4%BC%9A%E9%97%AE%E9%A2%98/11.png"></p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>伪迹移除</category>
      </categories>
      <tags>
        <tag>ICA</tag>
        <tag>鸡尾酒宴会问题</tag>
      </tags>
  </entry>
</search>
