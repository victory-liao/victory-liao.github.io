<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>伪迹移除 | 1D-ResCNN model to remove artifact</title>
    <url>/2020/10/10/1D-ResCNN-model-to-remove-artifact/</url>
    <content><![CDATA[<h1 id="A-novel-end-to-end-1D-ResCNN-model-to-remove-artifact-from-EEG-signals"><a href="#A-novel-end-to-end-1D-ResCNN-model-to-remove-artifact-from-EEG-signals" class="headerlink" title="A novel end-to-end 1D-ResCNN model to remove artifact from EEG signals"></a>A novel end-to-end 1D-ResCNN model to remove artifact from EEG signals</h1><div>
<b>two stages of end-to-end manner:</b>
<ul>
<li>training stage:an objective function is often adopted to optimize the model parameters.</li>
<li>test stage:the trained 1D-ResCNN model is used as a filter to automatically remove noise from the contaminated EEG signal.</li>
</ul>
</div>
<span id="more"></span>

<div style="background-color:yellowgreen;">
<b backgroundclor="green">1D-ResCNN model‘s advantages:</b>
<ul>
<li>achieves smaller RMSE and better signal-to-noise ratio(SNR).</li>
<li>better noise suppression ability.</li>
<li>the nonlinear characteristics of EEG after denosing are significantly maintained(preserved).</li>
<li>the EEG denosing performance under unknown noise is further improved.</li>  
</ul>
</div>

]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>伪迹移除</category>
      </categories>
      <tags>
        <tag>1D-ResCNN</tag>
        <tag>伪迹移除</tag>
      </tags>
  </entry>
  <entry>
    <title>脑电分类 | 1D卷积和LSTM脑电信号识别</title>
    <url>/2021/07/03/1D%E5%8D%B7%E7%A7%AF%E5%92%8CLSTM%E8%84%91%E7%94%B5%E4%BF%A1%E5%8F%B7%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<h1 id="1D卷积和LSTM脑电信号识别"><a href="#1D卷积和LSTM脑电信号识别" class="headerlink" title="1D卷积和LSTM脑电信号识别"></a>1D卷积和LSTM脑电信号识别</h1><p>这是一个非常重要的文章！！！ This is a very important article!!!</p>
<table>
<thead>
<tr>
<th>模型</th>
<th>框架</th>
<th>准确率</th>
</tr>
</thead>
<tbody><tr>
<td>CNN+LSTM</td>
<td>TensorFlow</td>
<td>70%</td>
</tr>
</tbody></table>
<p><a href="https://blog.csdn.net/zyb228/article/details/109193128">参考资料</a></p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>脑电分类</category>
        <category>CNN+LSTM</category>
      </categories>
      <tags>
        <tag>脑电分类</tag>
        <tag>LSTM</tag>
        <tag>CNN+LSTM</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 | 23种设计模式总结</title>
    <url>/2021/03/11/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="23种设计模式总结-未完成"><a href="#23种设计模式总结-未完成" class="headerlink" title="23种设计模式总结(未完成)"></a>23种设计模式总结(未完成)</h1><p>以下内容对23中设计模式进行简单介绍：</p>
<span id="more"></span>

<p>1-12设计模式为创建型，13-23设计模式为行为型</p>
<h2 id="1-抽象工厂"><a href="#1-抽象工厂" class="headerlink" title="1.抽象工厂"></a>1.抽象工厂</h2><p>客户类和工厂类分离(判断逻辑和事务处理分开)</p>
<p>客户想抽象工厂请求，抽象工厂再向具体工厂请求生产具体的产品</p>
<p>example:出行方式</p>
<h2 id="2-生成器"><a href="#2-生成器" class="headerlink" title="2.生成器"></a>2.生成器</h2><p>将一个复杂的对象的<b>构建与它的表示分离</b>，使得同样的构建过程有不同的表示</p>
<h2 id="3-工厂方法"><a href="#3-工厂方法" class="headerlink" title="3.工厂方法"></a>3.工厂方法</h2><p>让子类决定实例化哪一个类</p>
<h2 id="4-原型"><a href="#4-原型" class="headerlink" title="4.原型"></a>4.原型</h2><p>example:范文</p>
<h2 id="5-单例"><a href="#5-单例" class="headerlink" title="5.单例"></a>5.单例</h2><p>保证一个类只有一个实力，提供一个访问它的全局访问点</p>
<h2 id="6-适配器"><a href="#6-适配器" class="headerlink" title="6.适配器"></a>6.适配器</h2><p>example:连接电源和笔记本的适配器</p>
<h2 id="7-桥"><a href="#7-桥" class="headerlink" title="7.桥"></a>7.桥</h2><p>抽象部分与实现部分分离</p>
<h2 id="8-组合"><a href="#8-组合" class="headerlink" title="8.组合"></a>8.组合</h2><p>整体-部分的关系，使用户对单个、组合对象的使用具有一致性<br>example:双击打开文件/文件夹</p>
<h2 id="9-装饰"><a href="#9-装饰" class="headerlink" title="9.装饰"></a>9.装饰</h2><p>动态地给一个对象(而不是整个类)添加一些额外的职责<br>example：生日蛋糕</p>
<h2 id="10-外观"><a href="#10-外观" class="headerlink" title="10.外观"></a>10.外观</h2><p>为子系统的一组接口，提供一个统一的接口<br>example: 陕师大主页-各学院网站</p>
<h2 id="11-享元"><a href="#11-享元" class="headerlink" title="11.享元"></a>11.享元</h2><p>以共享的方式高效的支持大量的细粒度对象</p>
<h2 id="12-代理"><a href="#12-代理" class="headerlink" title="12.代理"></a>12.代理</h2><p>example:中国驻美大使馆是中国政府在美国的代理</p>
<h2 id="13-责任链"><a href="#13-责任链" class="headerlink" title="13.责任链"></a>13.责任链</h2><p>example: 提问</p>
<h2 id="14-命令"><a href="#14-命令" class="headerlink" title="14.命令"></a>14.命令</h2><p>将一个请求封装成一个对象</p>
<h2 id="15-解释器"><a href="#15-解释器" class="headerlink" title="15.解释器"></a>15.解释器</h2><h2 id="16-迭代器"><a href="#16-迭代器" class="headerlink" title="16.迭代器"></a>16.迭代器</h2><p>可以顺序访问一个聚合对象中的元素，不必暴露对象的内部表示</p>
<h2 id="17-调停者-中介者"><a href="#17-调停者-中介者" class="headerlink" title="17.调停者/中介者"></a>17.调停者/中介者</h2><p>example:租房子-中介</p>
<h2 id="18-备忘录"><a href="#18-备忘录" class="headerlink" title="18.备忘录"></a>18.备忘录</h2><p>example:游戏记录、系统还原、任务迁移</p>
<h2 id="19-观察者"><a href="#19-观察者" class="headerlink" title="19.观察者"></a>19.观察者</h2><h2 id="20-状态"><a href="#20-状态" class="headerlink" title="20.状态"></a>20.状态</h2><p>允许一个对象在其内部状态改变的时候改变行为，这个对象看上去像是改变了它的类一样</p>
<h2 id="21-策略"><a href="#21-策略" class="headerlink" title="21.策略"></a>21.策略</h2><p>将每一个算法封装到具有共同接口的独立的类<br>example:御敌之策(兵来将挡、水来土掩)、出行方式</p>
<h2 id="22-模板方法"><a href="#22-模板方法" class="headerlink" title="22.模板方法"></a>22.模板方法</h2><p>定义一个算法中操作的股价，将一些步骤延迟到子类中</p>
<h2 id="23-访问者"><a href="#23-访问者" class="headerlink" title="23.访问者"></a>23.访问者</h2><p>数据结构与操作分离</p>
]]></content>
      <categories>
        <category>SA</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>python | 50条有趣的python一行代码</title>
    <url>/2021/10/16/50%E6%9D%A1%E6%9C%89%E8%B6%A3%E7%9A%84python%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h1 id="50条有趣的python一行代码！"><a href="#50条有趣的python一行代码！" class="headerlink" title="50条有趣的python一行代码！"></a>50条有趣的python一行代码！</h1><p><a href="https://mp.weixin.qq.com/s/LVEPw7QAPqfLvi151aproQ">50条有趣的python一行代码！</a></p>
<span id="more"></span>
<p>1.字母异位词</p>
<pre><code>from collections import Counter
# Counter: Elements are stored as dictionary keys and their counts are stored as dictionary values.

s1 = &#39;below&#39;
s2 = &#39;elbow&#39;
print(Counter(s1)) # Counter(&#123;&#39;b&#39;: 1, &#39;e&#39;: 1, &#39;l&#39;: 1, &#39;o&#39;: 1, &#39;w&#39;: 1&#125;)

print(&#39;anagram&#39;) if Counter(s1) == Counter(s2) else print(&#39;not an anagram&#39;)
</code></pre>
<p>2.二进制转十进制</p>
<pre><code>decimal = int(&quot;1010&quot;, 2)
print(decimal)
</code></pre>
<p>3.将字符串转换为小写</p>
<pre><code>print(&quot;Hi my name is XiaoF&quot;.lower())
# &#39;hi my name is xiaof&#39;
print(&quot;Hi my name is XiaoF&quot;.casefold())
# &#39;hi my name is xiaof&#39;
</code></pre>
<p>4.将字符串转换为大写</p>
<pre><code>print(&quot;hi my name is XiaoF&quot;.upper())
# &#39;HI MY NAME IS XIAOF&#39;
</code></pre>
<p>5.将字符串转换为字节</p>
<pre><code>print(&quot;convert string to bytes using encode method&quot;.encode())
print(type(&quot;convert string to bytes using encode method&quot;.encode()))
b&#39;convert string to bytes using encode method&#39;
</code></pre>
<p>6.拷贝文件</p>
<pre><code>import shutil
shutil.copyfile(&#39;source.txt&#39;, &#39;dest.txt&#39;)
</code></pre>
<p>7.快速排序</p>
<pre><code>qsort = lambda l: l if len(l) &lt;= 1 else qsort([x for x in l[1:] if x &lt; l[0]]) + [l[0]] + qsort([x for x in l[1:] if x &gt;= l[0]])
print(qsort([1]))
print(qsort([17, 29, 11, 97, 103, 5]))
</code></pre>
<p>8.n个连续数的和</p>
<pre><code>n = 10
print(sum(range(0, n+1)))
# 55
</code></pre>
<p>9.交换两个变量的值</p>
<pre><code>a = 1
b = 2
print(a, b)
a,b = b,a
print(a, b)
</code></pre>
<p>10.斐波纳契数列</p>
<pre><code>fib = lambda x: x if x&lt;=1 else fib(x-1) + fib(x-2)

def fib(x):
    if x &lt;= 1:
        return x
    else:
        return fib(x-1) + fib(x-2)
print(fib(20))
# 6765
</code></pre>
<p>11.将嵌套列表合并为一个列表</p>
<pre><code>main_list = [[0, 1, 2], [11, 12, 13], [52, 53, 54]]

result = [item for sublist in main_list for item in sublist]
print(result)
# [0, 1, 2, 11, 12, 13, 52, 53, 54]
</code></pre>
<p>12.运行一个HTTP服务器</p>
<pre><code>python3 -m http.server 8000
python2 -m SimpleHTTPServer
</code></pre>
<p>13.反转列表</p>
<pre><code>numbers = [0, 1, 2, 11, 12, 13, 52, 53, 54]
print(numbers[::-1])
# [54, 53, 52, 13, 12, 11, 2, 1, 0]
</code></pre>
<p>14.阶乘</p>
<pre><code>import math
fact_5 = math.factorial(5)
print(fact_5)
# 120
</code></pre>
<p>15.在列表推导式中使用for和if</p>
<pre><code>even_list = [number for number in [1, 2, 3, 4] if number % 2 == 0]
print(even_list)
# [2, 4]
</code></pre>
<p>16.列表中最长的字符串</p>
<pre><code>words = [&#39;This&#39;, &#39;is&#39;, &#39;a&#39;, &#39;list&#39;, &#39;of&#39;, &#39;words&#39;]
result = max(words, key=len)
print(result)
# &#39;words&#39;
</code></pre>
<p>17.列表推导式</p>
<pre><code>li = [num for num in range(0, 10)]
print(li)
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>18.集合推导式</p>
<pre><code>num_set = &#123;num for num in range(0, 10)&#125;
print(num_set)
# &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;
</code></pre>
<p>19.字典推导式</p>
<pre><code>dict_numbers = &#123;x: x*x for x in range(1, 5)&#125;
print(dict_numbers)
# &#123;1: 1, 2: 4, 3: 9, 4: 16&#125;
</code></pre>
<p>20.if-else</p>
<pre><code>print(&quot;even&quot;) if 4 % 2==0 else print(&quot;odd&quot;)
</code></pre>
<p>21.无限循环</p>
<pre><code>while 1:0
</code></pre>
<p>22.检查数据类型</p>
<pre><code>print(isinstance(2, int))
# True
print(isinstance(&quot;allwin&quot;, str))
# True
print(isinstance([3, 4, 1997], list))
# True
</code></pre>
<p>23.While循环</p>
<pre><code>a = 5

while a &gt; 0:
    a = a - 1

print(a)
# 0
</code></pre>
<p>24.使用print语句写入文件</p>
<pre><code>print(&quot;Hello, World!&quot;, file=open(&#39;file.txt&#39;, &#39;w&#39;))
# 既可打印出信息，还能将信息保存文件。
</code></pre>
<p>25.计算一个字符在字符串中出现的频率</p>
<pre><code>print(&quot;umbrella&quot;.count(&#39;l&#39;))
# 2
</code></pre>
<p>26.合并列表</p>
<pre><code>list1 = [1, 2, 4]
list2 = [&#39;XiaoF&#39;]
list1.extend(list2)
print(list1)
# [1, 2, 4, &#39;XiaoF&#39;]
</code></pre>
<p>27.合并字典</p>
<pre><code>dict1 = &#123;&#39;name&#39;: &#39;weiwei&#39;, &#39;age&#39;: 23&#125;
dict2 = &#123;&#39;city&#39;: &#39;Beijing&#39;&#125;
dict1.update(dict2)
print(dict1)
# &#123;&#39;name&#39;: &#39;weiwei&#39;, &#39;age&#39;: 23, &#39;city&#39;: &#39;Beijing&#39;&#125;
</code></pre>
<p>28.合并集合</p>
<pre><code>set1 = &#123;0, 1, 2&#125;
set2 = &#123;11, 12, 13&#125;
set1.update(set2)
print(set1)
# &#123;0, 1, 2, 11, 12, 13&#125;
</code></pre>
<p>29.时间戳</p>
<pre><code>import time
print(time.time())
</code></pre>
<p>30.列表中出现次数最多的元素</p>
<pre><code>test_list = [9, 4, 5, 4, 4, 5, 9, 5, 4]
most_frequent_element = max(set(test_list), key=test_list.count)
print(most_frequent_element)
# 4
</code></pre>
<p>31.嵌套列表</p>
<pre><code>numbers = [[num] for num in range(10)]
print(numbers)
# [[0], [1], [2], [3], [4], [5], [6], [7], [8], [9]]
</code></pre>
<p>32.八进制转十进制</p>
<pre><code>print(int(&#39;30&#39;, 8))
# 24
</code></pre>
<p>33.将键值对转换为字典</p>
<pre><code>result = dict(name=&#39;XiaoF&#39;, age=23)
print(result)
# &#123;&#39;name&#39;: &#39;XiaoF&#39;, &#39;age&#39;: 23&#125;
</code></pre>
<p>34.求商和余数</p>
<pre><code>quotient, remainder = divmod(4, 5)
print(quotient, remainder)
# 0 4
# divmod()函数返回当参数1除以参数2时，包含商和余数的元组。
</code></pre>
<p>35.删除列表中的重复项</p>
<pre><code>print(list(set([4, 4, 5, 5, 6])))
# [4, 5, 6]
</code></pre>
<p>36.按升序排序列表</p>
<pre><code>print(sorted([5, 2, 9, 1]))
# [1, 2, 5, 9]
</code></pre>
<p>37.按降序排序列表</p>
<pre><code>print(sorted([5, 2, 9, 1], reverse=True))
# [9, 5, 2, 1]
</code></pre>
<p>38.获取小写字母表</p>
<pre><code>import string
print(string.ascii_lowercase)
print(type(string.ascii_lowercase))
# abcdefghijklmnopqrstuvwxyz
</code></pre>
<p>39.获取大写字母表</p>
<pre><code>import string
print(string.ascii_uppercase)
# ABCDEFGHIJKLMNOPQRSTUVWXYZ
</code></pre>
<p>40.获取0到9字符串</p>
<pre><code>import string
print(string.digits)
# 0123456789
</code></pre>
<p>41.十六进制转十进制</p>
<pre><code>print(int(&#39;da9&#39;, 16))
# 3497
</code></pre>
<p>42.日期时间</p>
<pre><code>import time
print(time.ctime())
# Thu Aug 13 20:00:00 2021
</code></pre>
<p>43.将列表中的字符串转换为整数</p>
<pre><code>print(list(map(int, [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;])))
# [1, 2, 3]
</code></pre>
<p>44.用键对字典进行排序</p>
<pre><code>d = &#123;&#39;one&#39;: 1, &#39;four&#39;: 4, &#39;eight&#39;: 8&#125;
result = &#123;key: d[key] for key in sorted(d.keys())&#125;
print(result)
# &#123;&#39;eight&#39;: 8, &#39;four&#39;: 4, &#39;one&#39;: 1&#125;
</code></pre>
<p>45.用键值对字典进行排序</p>
<pre><code>x = &#123;1: 2, 3: 4, 4: 3, 2: 1, 0: 0&#125;
result = &#123;k: v for k, v in sorted(x.items(), key=lambda item: item[0])&#125;
print(result)
# &#123;0: 0, 2: 1, 1: 2, 4: 3, 3: 4&#125;
</code></pre>
<p>46.列表旋转</p>
<pre><code>li = [1, 2, 3, 4, 5]
# li[n:] + li[:n], 右变左
print(li[2:] + li[:2])
# [3, 4, 5, 1, 2]
# li[-n:] + li[:-n], 左变右
print(li[-1:] + li[:-1])
# [5, 1, 2, 3, 4]
</code></pre>
<p>47.将字符串中的数字移除</p>
<pre><code>message = &#39;&#39;.join(list(filter(lambda x: x.isalpha(), &#39;abc123def4fg56vcg2&#39;)))
print(message)
# abcdeffgvcg
</code></pre>
<p>48.矩阵变换</p>
<pre><code>old_list = [[1, 2, 3], [3, 4, 6], [5, 6, 7]]
result = list(list(x) for x in zip(*old_list))
print(result)
# [[1, 3, 5], [2, 4, 6], [3, 6, 7]]
</code></pre>
<p>49.列表过滤</p>
<pre><code>result = list(filter(lambda x: x % 2 == 0, [1, 2, 3, 4, 5, 6]))
print(result)
# [2, 4, 6]
</code></pre>
<p>50.解包</p>
<pre><code>a, *b, c = [1, 2, 3, 4, 5]
print(a)  # 1
print(b)  # [2, 3, 4]
print(c)  # 5
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python | 68个python内置函数详解</title>
    <url>/2021/10/16/68%E4%B8%AApython%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="68个python内置函数详解"><a href="#68个python内置函数详解" class="headerlink" title="68个python内置函数详解"></a>68个python内置函数详解</h1><p>内置函数就是Python给你提供的，拿来直接用的函数，比如print.，input等。<br>截止到python版本3.6.2 ，python一共提供了68个内置函数，具体如下👇</p>
<pre><code>abs()           dict()        help()         min()         setattr()
all()           dir()         hex()          next()        slice() 
any()           divmod()      id()           object()      sorted() 
ascii()         enumerate()   input()        oct()         staticmethod() 
bin()           eval()        int()          open()        str() 
bool()          exec()        isinstance()   ord()         sum() 
bytearray()     ﬁlter()       issubclass()   pow()         super() 
bytes()         ﬂoat()        iter()         print()       tuple() 
callable()      format()      len()          property()    type() 
chr()           frozenset()   list()         range()       vars() 
classmethod()   getattr()     locals()       repr()        zip() 
compile()       globals()     map()          reversed()    __import__() 
complex()       hasattr()     max()          round() 
delattr()       hash()        memoryview()   set()
</code></pre>
<span id="more"></span>
<p>本文将这68个内置函数综合整理为12大类，正在学习Python基础的读者一定不要错过，建议收藏学习！<br>和数字相关</p>
<ol>
<li>数据类型</li>
</ol>
<p>bool : 布尔型(True,False)<br>int : 整型(整数)<br>float : 浮点型(小数)<br>complex : 复数</p>
<ol start="2">
<li>进制转换</li>
</ol>
<p>bin() 将给的参数转换成二进制<br>otc() 将给的参数转换成八进制<br>hex() 将给的参数转换成十六进制</p>
<pre><code>print(bin(10))  # 二进制:0b1010
print(hex(10))  # 十六进制:0xa
print(oct(10))  # 八进制:0o12
</code></pre>
<ol start="3">
<li>数学运算</li>
</ol>
<p>abs() 返回绝对值<br>divmode() 返回商和余数<br>round() 四舍五入<br>pow(a, b) 求a的b次幂, 如果有三个参数. 则求完次幂后对第三个数取余<br>sum() 求和<br>min() 求最小值<br>max() 求最大值</p>
<pre><code>print(abs(-2))  # 绝对值:2
print(divmod(20,3)) # 求商和余数:(6,2)
print(round(4.50))   # 五舍六入:4
print(round(4.51))   #5
print(pow(10,2,3))  # 如果给了第三个参数. 表示最后取余:1
print(sum([1,2,3,4,5,6,7,8,9,10]))  # 求和:55
print(min(5,3,9,12,7,2))  #求最小值:2
print(max(7,3,15,9,4,13))  #求最大值:15
</code></pre>
<p>和数据结构相关</p>
<ol>
<li>序列</li>
</ol>
<p>（1）列表和元组</p>
<p>list() 将一个可迭代对象转换成列表<br>tuple() 将一个可迭代对象转换成元组</p>
<pre><code>print(list((1,2,3,4,5,6)))  #[1, 2, 3, 4, 5, 6]
print(tuple([1,2,3,4,5,6]))  #(1, 2, 3, 4, 5, 6)
</code></pre>
<p>（2）相关内置函数</p>
<p>reversed() 将一个序列翻转, 返回翻转序列的迭代器<br>slice() 列表的切片</p>
<pre><code>lst = &quot;你好啊&quot;
it = reversed(lst)   # 不会改变原列表. 返回一个迭代器, 设计上的一个规则
print(list(it))  #[&#39;啊&#39;, &#39;好&#39;, &#39;你&#39;]
lst = [1, 2, 3, 4, 5, 6, 7]
print(lst[1:3:1])  #[2,3]
s = slice(1, 3, 1)  #  切片用的
print(lst[s])  #[2,3]
</code></pre>
<p>（3）字符串</p>
<p>str() 将数据转化成字符串</p>
<pre><code>print(str(123)+&#39;456&#39;)  #123456
</code></pre>
<p>format() 与具体数据相关, 用于计算各种小数, 精算等.</p>
<pre><code>s = &quot;hello world!&quot;
print(format(s, &quot;^20&quot;))  #剧中
print(format(s, &quot;&lt;20&quot;))  #左对齐
print(format(s, &quot;&gt;20&quot;))  #右对齐
#     hello world!    
# hello world!        
#         hello world!
print(format(3, &#39;b&#39; ))    # 二进制:11
print(format(97, &#39;c&#39; ))   # 转换成unicode字符:a
print(format(11, &#39;d&#39; ))   # ⼗进制:11
print(format(11, &#39;o&#39; ))   # 八进制:13 
print(format(11, &#39;x&#39; ))   # 十六进制(⼩写字母):b
print(format(11, &#39;X&#39; ))   # 十六进制(大写字母):B
print(format(11, &#39;n&#39; ))   # 和d⼀样:11
print(format(11))         # 和d⼀样:11

print(format(123456789, &#39;e&#39; ))      # 科学计数法. 默认保留6位小数:1.234568e+08
print(format(123456789, &#39;0.2e&#39; ))   # 科学计数法. 保留2位小数(小写):1.23e+08
print(format(123456789, &#39;0.2E&#39; ))   # 科学计数法. 保留2位小数(大写):1.23E+08
print(format(1.23456789, &#39;f&#39; ))     # 小数点计数法. 保留6位小数:1.234568
print(format(1.23456789, &#39;0.2f&#39; ))  # 小数点计数法. 保留2位小数:1.23
print(format(1.23456789, &#39;0.10f&#39;))  # 小数点计数法. 保留10位小数:1.2345678900
print(format(1.23456789e+3, &#39;F&#39;))   # 小数点计数法. 很大的时候输出INF:1234.567890
</code></pre>
<p>bytes() 把字符串转化成bytes类型</p>
<pre><code>bs = bytes(&quot;今天吃饭了吗&quot;, encoding=&quot;utf-8&quot;)
print(bs)  #b&#39;\xe4\xbb\x8a\xe5\xa4\xa9\xe5\x90\x83\xe9\xa5\xad\xe4\xba\x86\xe5\x90\x97&#39;
</code></pre>
<p>bytearray()    返回一个新字节数组. 这个数字的元素是可变的, 并且每个元素的值得范围是[0,256)</p>
<pre><code>ret = bytearray(&quot;alex&quot; ,encoding =&#39;utf-8&#39;)
print(ret[0])  #97
print(ret)  #bytearray(b&#39;alex&#39;)
ret[0] = 65  #把65的位置A赋值给ret[0]
print(str(ret))  #bytearray(b&#39;Alex&#39;)
</code></pre>
<p>ord() 输入字符找带字符编码的位置<br>chr() 输入位置数字找出对应的字符<br>ascii() 是ascii码中的返回该值 不是就返回u</p>
<pre><code>print(ord(&#39;a&#39;))  # 字母a在编码表中的码位:97
print(ord(&#39;中&#39;))  # &#39;中&#39;字在编码表中的位置:20013

print(chr(65))  # 已知码位,求字符是什么:A
print(chr(19999))  #丟

for i in range(65536):  #打印出0到65535的字符
    print(chr(i), end=&quot; &quot;)

print(ascii(&quot;@&quot;))  #&#39;@&#39;
</code></pre>
<p>repr() 返回一个对象的string形式</p>
<pre><code>s = &quot;今天\n吃了%s顿\t饭&quot; % 3
print(s)#今天# 吃了3顿    饭
print(repr(s))   # 原样输出,过滤掉转义字符 \n \t \r 不管百分号%
#&#39;今天\n吃了3顿\t饭&#39;
</code></pre>
<ol start="2">
<li>数据集合</li>
</ol>
<p>字典：dict 创建一个字典</p>
<p>集合：set 创建一个集合</p>
<p>frozenset() 创建一个冻结的集合，冻结的集合不能进行添加和删除操作。<br>3. 相关内置函数</p>
<p>len() 返回一个对象中的元素的个数<br>sorted() 对可迭代对象进行排序操作 (lamda)</p>
<p>语法：sorted(Iterable, key=函数(排序规则), reverse=False)</p>
<p>Iterable: 可迭代对象<br>key: 排序规则(排序函数), 在sorted内部会将可迭代对象中的每一个元素传递给这个函数的参数. 根据函数运算的结果进行排序<br>reverse: 是否是倒叙. True: 倒叙, False: 正序</p>
<pre><code>lst = [5,7,6,12,1,13,9,18,5]
lst.sort()  # sort是list里面的一个方法
print(lst)  #[1, 5, 5, 6, 7, 9, 12, 13, 18]

ll = sorted(lst) # 内置函数. 返回给你一个新列表  新列表是被排序的
print(ll)  #[1, 5, 5, 6, 7, 9, 12, 13, 18]

l2 = sorted(lst,reverse=True)  #倒序
print(l2)  #[18, 13, 12, 9, 7, 6, 5, 5, 1]
</code></pre>
<p>#根据字符串长度给列表排序<br>    lst = [‘one’, ‘two’, ‘three’, ‘four’, ‘five’, ‘six’]<br>    def f(s):<br>        return len(s)<br>    l1 = sorted(lst, key=f, )<br>    print(l1)  #[‘one’, ‘two’, ‘six’, ‘four’, ‘five’, ‘three’]</p>
<p>enumerate() 获取集合的枚举对象</p>
<pre><code>lst = [&#39;one&#39;,&#39;two&#39;,&#39;three&#39;,&#39;four&#39;,&#39;five&#39;]
for index, el in enumerate(lst,1):    # 把索引和元素一起获取,索引默认从0开始. 可以更改
    print(index)
    print(el)
# 1
# one
# 2
# two
# 3
# three
# 4
# four
# 5
# five
</code></pre>
<p>all() 可迭代对象中全部是True, 结果才是True<br>any() 可迭代对象中有一个是True, 结果就是True</p>
<pre><code>print(all([1,&#39;hello&#39;,True,9]))  #True
print(any([0,0,0,False,1,&#39;good&#39;]))  #True
</code></pre>
<p>zip() 函数用于将可迭代的对象作为参数, 将对象中对应的元素打包成一个元组, 然后返回由这些元组组成的列表. 如果各个迭代器的元素个数不一致, 则返回列表长度与最短的对象相同</p>
<pre><code>lst1 = [1, 2, 3, 4, 5, 6]
lst2 = [&#39;醉乡民谣&#39;, &#39;驴得水&#39;, &#39;放牛班的春天&#39;, &#39;美丽人生&#39;, &#39;辩护人&#39;, &#39;被嫌弃的松子的一生&#39;]
lst3 = [&#39;美国&#39;, &#39;中国&#39;, &#39;法国&#39;, &#39;意大利&#39;, &#39;韩国&#39;, &#39;日本&#39;]
print(zip(lst1, lst1, lst3))  #&lt;zip object at 0x00000256CA6C7A88&gt;
for el in zip(lst1, lst2, lst3):
    print(el)
# (1, &#39;醉乡民谣&#39;, &#39;美国&#39;)
# (2, &#39;驴得水&#39;, &#39;中国&#39;)
# (3, &#39;放牛班的春天&#39;, &#39;法国&#39;)
# (4, &#39;美丽人生&#39;, &#39;意大利&#39;)
# (5, &#39;辩护人&#39;, &#39;韩国&#39;)
# (6, &#39;被嫌弃的松子的一生&#39;, &#39;日本&#39;)
</code></pre>
<p>fiter() 过滤 (lamda)</p>
<p>语法：fiter(function. Iterable)</p>
<p>function: 用来筛选的函数. 在ﬁlter中会自动的把iterable中的元素传递给function. 然后根据function返回的True或者False来判断是否保留留此项数据 , Iterable: 可迭代对象</p>
<pre><code>def func(i):    # 判断奇数
    return i % 2 == 1
    lst = [1,2,3,4,5,6,7,8,9]
l1 = filter(func, lst)  #l1是迭代器
print(l1)  #&lt;filter object at 0x000001CE3CA98AC8&gt;
print(list(l1))  #[1, 3, 5, 7, 9]
</code></pre>
<p>map() 会根据提供的函数对指定序列列做映射(lamda)</p>
<p>语法 : map(function, iterable)</p>
<p>可以对可迭代对象中的每一个元素进行映射. 分别去执行 function</p>
<pre><code>def f(i):    return i
lst = [1,2,3,4,5,6,7,]
it = map(f, lst) # 把可迭代对象中的每一个元素传递给前面的函数进行处理. 处理的结果会返回成迭代器print(list(it))  #[1, 2, 3, 4, 5, 6, 7]
</code></pre>
<p>和作用域相关</p>
<p>locals() 返回当前作用域中的名字<br>globals() 返回全局作用域中的名字</p>
<pre><code>def func():
    a = 10
    print(locals())  # 当前作用域中的内容
    print(globals())  # 全局作用域中的内容
    print(&quot;今天内容很多&quot;)
func()
# &#123;&#39;a&#39;: 10&#125;
# &#123;&#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None, &#39;__package__&#39;: None, &#39;__loader__&#39;: 
# &lt;_frozen_importlib_external.SourceFileLoader object at 0x0000026F8D566080&gt;, 
# &#39;__spec__&#39;: None, &#39;__annotations__&#39;: &#123;&#125;, &#39;__builtins__&#39;: &lt;module &#39;builtins&#39; 
# (built-in)&gt;, &#39;__file__&#39;: &#39;D:/pycharm/练习/week03/new14.py&#39;, &#39;__cached__&#39;: None,
#  &#39;func&#39;: &lt;function func at 0x0000026F8D6B97B8&gt;&#125;
# 今天内容很多
</code></pre>
<p>和迭代器生成器相关</p>
<p>range() 生成数据<br>next() 迭代器向下执行一次, 内部实际使⽤用了__ next__()⽅方法返回迭代器的下一个项目<br>iter() 获取迭代器, 内部实际使用的是__ iter__()⽅方法来获取迭代器</p>
<pre><code>for i in range(15,-1,-5):
    print(i)
# 15
# 10
# 5
# 0
lst = [1,2,3,4,5]
it = iter(lst)  #  __iter__()获得迭代器
print(it.__next__())  #1
print(next(it)) #2  __next__()  
print(next(it))  #3
print(next(it))  #4
</code></pre>
<p>字符串类型代码的执行</p>
<p>eval() 执行字符串类型的代码. 并返回最终结果<br>exec() 执行字符串类型的代码<br>compile() 将字符串类型的代码编码. 代码对象能够通过exec语句来执行或者eval()进行求值</p>
<pre><code>s1 = input(&quot;请输入a+b:&quot;)  #输入:8+9
print(eval(s1))  # 17 可以动态的执行代码. 代码必须有返回值
s2 = &quot;for i in range(5): print(i)&quot;
a = exec(s2) # exec 执行代码不返回任何内容

# 0
# 1
# 2
# 3
# 4
print(a)  #None

# 动态执行代码
exec(&quot;&quot;&quot;
def func():
    print(&quot; 我是周杰伦&quot;)
&quot;&quot;&quot; )
func()  #我是周杰伦

code1 = &quot;for i in range(3): print(i)&quot;
com = compile(code1, &quot;&quot;, mode=&quot;exec&quot;)   # compile并不会执行你的代码.只是编译
exec(com)   # 执行编译的结果
# 0
# 1
# 2

code2 = &quot;5+6+7&quot;
com2 = compile(code2, &quot;&quot;, mode=&quot;eval&quot;)
print(eval(com2))  # 18

code3 = &quot;name = input(&#39;请输入你的名字:&#39;)&quot;  #输入:hello
com3 = compile(code3, &quot;&quot;, mode=&quot;single&quot;)
exec(com3)
print(name)  #hello
</code></pre>
<p>输入输出</p>
<p>print() : 打印输出<br>input() : 获取用户输出的内容</p>
<pre><code>print(&quot;hello&quot;, &quot;world&quot;, sep=&quot;*&quot;, end=&quot;@&quot;) # sep:打印出的内容用什么连接,end:以什么为结尾
#hello*world@
</code></pre>
<p>内存相关</p>
<p>hash() : 获取到对象的哈希值(int, str, bool, tuple). hash算法:(1) 目的是唯一性 (2) dict 查找效率非常高, hash表.用空间换的时间 比较耗费内存</p>
<pre><code>s = &#39;alex&#39;print(hash(s))  #-168324845050430382lst = [1, 2, 3, 4, 5]print(hash(lst))  #报错,列表是不可哈希的  id() :  获取到对象的内存地址s = &#39;alex&#39;print(id(s))  #2278345368944
</code></pre>
<p>文件操作相关</p>
<p>open() : 用于打开一个文件, 创建一个文件句柄</p>
<pre><code>f = open(&#39;file&#39;,mode=&#39;r&#39;,encoding=&#39;utf-8&#39;)
f.read()
f.close()
</code></pre>
<p>模块相关</p>
<p>__ import__() : 用于动态加载类和函数</p>
<pre><code># 让用户输入一个要导入的模块
import os
name = input(&quot;请输入你要导入的模块:&quot;)
__import__(name)    # 可以动态导入模块
</code></pre>
<p>帮 助</p>
<p>help() : 函数用于查看函数或模块用途的详细说明</p>
<pre><code>print(help(str))  #查看字符串的用途
</code></pre>
<p>调用相关</p>
<p>callable() : 用于检查一个对象是否是可调用的. 如果返回True, object有可能调用失败, 但如果返回False. 那调用绝对不会成功</p>
<pre><code>a = 10
print(callable(a))  #False  变量a不能被调用
#
def f():
    print(&quot;hello&quot;)
    print(callable(f))   # True 函数是可以被调用的
</code></pre>
<p>查看内置属性</p>
<p>dir() : 查看对象的内置属性, 访问的是对象中的<strong>dir</strong>()方法</p>
<pre><code>print(dir(tuple))  #查看元组的方法
</code></pre>
<p><a href="https://mp.weixin.qq.com/s/RE07ReitUyQDwG2yYcugPQ">68个python内置函数详解!!!</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>内置函数</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习 | AdaBoost</title>
    <url>/2021/04/17/AdaBoost/</url>
    <content><![CDATA[<h1 id="AdaBoost"><a href="#AdaBoost" class="headerlink" title="AdaBoost"></a>AdaBoost</h1><h2 id="集成方法"><a href="#集成方法" class="headerlink" title="集成方法"></a>集成方法</h2><p>集成方法(ensemble method)/元算法(meta-algorithm):将不同的分类器组合起来的组合结果</p>
<p><b>集成方法的多种形式</b>：<br>1.不同算法的集成<br>2.同一种算法在不同设置下的集成<br>3.数据集不同部分分配给不同分类器之后的集成</p>
<p>基分类器一般采用的是弱可学习（weakly learnable）分类器，通过集成方法，组合成一个强可学习（strongly learnable）分类器</p>
<p><b>弱可学习：</b><br>是指学习的正确率仅略优于随机猜测的多项式学习算法</p>
<p><b>强可学习：</b><br>指正确率较高的多项式学习算法。</p>
<p>集成学习的泛化能力一般比单一的基分类器要好，这是因为大部分基分类器都分类错误的概率远低于单一基分类器的。</p>
<p><b>集成方法主要包括Bagging和Boosting两种方法</b>，Bagging和Boosting都是将已有的分类或回归算法通过一定方式组合起来，形成一个性能更加强大的分类器，更准确的说这是一种分类算法的组装方法，即<b>将弱分类器组装成强分类器</b>的方法。</p>
<h3 id="Bagging"><a href="#Bagging" class="headerlink" title="Bagging"></a>Bagging</h3><h3 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h3><h3 id="Bagging、boosting二者之间的区别"><a href="#Bagging、boosting二者之间的区别" class="headerlink" title="Bagging、boosting二者之间的区别"></a>Bagging、boosting二者之间的区别</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h2 id="AdaBoost-1"><a href="#AdaBoost-1" class="headerlink" title="AdaBoost"></a>AdaBoost</h2><h2 id="分类器性能评价"><a href="#分类器性能评价" class="headerlink" title="分类器性能评价"></a>分类器性能评价</h2><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2>]]></content>
      <categories>
        <category>机器学习</category>
        <category>AdaBoost</category>
      </categories>
      <tags>
        <tag>AdaBoost</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础 | 算法基础</title>
    <url>/2020/10/09/Algorithms-1/</url>
    <content><![CDATA[<h1 id="算法基础"><a href="#算法基础" class="headerlink" title="算法基础"></a>算法基础</h1><h2 id="算法定义"><a href="#算法定义" class="headerlink" title="算法定义"></a>算法定义</h2><p><strong>解决一个具体问题的<strong style="color:red">方法</strong>称为一个算法</strong></p>
<h2 id="算法的特征"><a href="#算法的特征" class="headerlink" title="算法的特征"></a>算法的特征</h2><p>1）确定性：组成算法的每条指令清晰、无歧义<br>2）有限性：算法中每条指令的执行次数有限<br>3）可行性：每条指令是简单的、具体的<br>4）输入：有零个或多个外部量作为算法的输入<br>5）输出：算法产生至少一个量作为输出</p>
<p><strong style="color:blue">算法是程序之灵魂</strong></p>
<span id="more"></span>
<h2 id="算法的优劣"><a href="#算法的优劣" class="headerlink" title="算法的优劣"></a>算法的优劣</h2><ul>
<li><blockquote>
<p>时间复杂度：算法运行所需要的<strong>运算步骤</strong></p>
<blockquote>
<p>通常表示为问题规模n的函数T(n)</p>
</blockquote>
</blockquote>
</li>
<li><blockquote>
<p>空间复杂度：算法运行所需要的<strong>内存单元</strong></p>
<blockquote>
<p>通常表示为问题规模n的函数S(n)</p>
</blockquote>
</blockquote>
</li>
<li><blockquote>
<p>时空特性</p>
</blockquote>
</li>
</ul>
<ul>
<li>稳定性</li>
<li>健壮性（鲁棒性）</li>
<li>可靠性</li>
<li>实现难度</li>
<li>模块化</li>
</ul>
<h2 id="算法的内容"><a href="#算法的内容" class="headerlink" title="算法的内容"></a>算法的内容</h2><ul>
<li><blockquote>
<p>算法设计</p>
<blockquote>
<p>针对具体问题，设计一个解决方案</p>
</blockquote>
</blockquote>
<ul>
<li>正确</li>
<li>步骤尽量少</li>
<li>占用空间尽量少</li>
<li>实现简单</li>
<li>其他</li>
</ul>
</li>
<li><blockquote>
<p>算法分析</p>
<blockquote>
<p>正确性分析-证明（归纳法）<br>  时空效率分析-计数<br>  时空特性分析-经验</p>
</blockquote>
</blockquote>
</li>
</ul>
<p>Example 1:时间效率分析-计数</p>
<pre><code>for(i=1;i&lt;=n;i=2*i)
&#123;
    for(j=1;j&lt;=i;j++)
    &#123;
        laugh++;
    &#125;
&#125;
</code></pre>
<p>result:1+2+…+2^ceil(log2 n) = <strong>2^(ceil(log2 n)+1) - 1</strong></p>
<p>Example 2:Horner 算法</p>
<pre><code>Horner(int a[n],real x)
&#123;
    real p = 0;
    for(i=0;i&lt;=n;i++)
    &#123;   
        p+=p*x*a[n-i];
    &#125;
    return p;
&#125;
</code></pre>
<h2 id="算法时间复杂度分析"><a href="#算法时间复杂度分析" class="headerlink" title="算法时间复杂度分析"></a>算法时间复杂度分析</h2><ul>
<li>最坏情况时间复杂度—T(n)表示算法对规模为n的任意输入所需要的<strong>最大步骤</strong></li>
<li>平均时间复杂度——T(n)表示算法对规模为n的所有<strong>输入所需的步骤的平均值</strong></li>
<li>最好情况时间复杂度—T(n)表示算法对规模为n的任意输入所需要的<strong>最小步骤</strong></li>
<li><blockquote>
<p><strong style="color:red">Big idea:</strong>渐进时间复杂度—当n增大时用T(n)的<strong>主要部分</strong>代替T(n)</p>
<blockquote>
<p>常用在理论分析中   理论分析与实际情况有可能不一致</p>
</blockquote>
</blockquote>
</li>
</ul>
<p>e.g. 对a1 a2 … an-1 an 进行排序<br>最好情况：1 2 … n<br>最坏情况：n n-1 ..1<br>2 1 3 …n n-1</p>
<h2 id="算法设计与分析的步骤"><a href="#算法设计与分析的步骤" class="headerlink" title="算法设计与分析的步骤"></a>算法设计与分析的步骤</h2><ol>
<li>问题的描述（Description）</li>
<li>数据结构的选择(Selection)</li>
<li>算法设计(Design)</li>
<li>算法分析(Analysis)</li>
<li>算法的实现(Implement)</li>
</ol>
<p>Example 3:isPrime </p>
<pre><code>isPrime(n)
&#123;
    for(i=2;i&lt;sqrt(n);i++)
    &#123;
        if(n%i==0) return false
    &#125;
    return true
&#125;
</code></pre>
<p>Example 4:euclid</p>
<pre><code>euclid(int a,int b)
&#123;
    if(b==0) return a;
    else return euclid(b,a%b);
&#125;
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
        <category>算法基础</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础 | 动态规划</title>
    <url>/2020/11/06/Algorithms-3/</url>
    <content><![CDATA[<h1 id="动态规划与分治"><a href="#动态规划与分治" class="headerlink" title="动态规划与分治"></a>动态规划与分治</h1><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>利用问题的解与其子问题的解之间的关系（动态规划方程），以<strong>自底向上</strong>的方式递归地从子问题的<strong>最优解</strong>逐步构造出整个问题的解的算法</p>
<h2 id="分治-Divide-and-Conquer"><a href="#分治-Divide-and-Conquer" class="headerlink" title="分治(Divide and Conquer)"></a>分治(Divide and Conquer)</h2><p>将一个问题<strong>分</strong>为若干个子问题，将这些子问题分别求解；将求出的小规模的子问题的解<strong>合并</strong>为一个更大规模的问题的解，自底向上求出原来问题的解</p>
<h2 id="核心思想：大问题—-gt-小问题"><a href="#核心思想：大问题—-gt-小问题" class="headerlink" title="核心思想：大问题—&gt;小问题"></a>核心思想：大问题—&gt;小问题</h2><h2 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h2><p>分治：自顶向下<br>动态规划：自底向上</p>
<h2 id="动态规划的基本步骤"><a href="#动态规划的基本步骤" class="headerlink" title="动态规划的基本步骤"></a>动态规划的基本步骤</h2><ul>
<li>找出最优解的性质，并刻画其结构特征</li>
<li>建立动态规划方程</li>
<li>以自底向上的方式解动态规划方程</li>
<li>根据计算最优质的时得到的信息构造最优解</li>
</ul> 

<h2 id="Pseudocode"><a href="#Pseudocode" class="headerlink" title="Pseudocode:"></a>Pseudocode:</h2><pre><code>dynamic-program(P)
&#123;
    for(i=1;i&lt;=n;i++)
    &#123;
        compute(solution of each Pi);//解规模为i的各子问题
        use(solution of each Pi) merge(solution of each Pi+1);
        //将规模为i的各子问题的解合并为规模为i+1的问题的解
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
        <category>算法基础</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>伪迹移除 | Artifact suppression using data adaptive time domain filtering</title>
    <url>/2020/10/10/Artifact-suppression-using-data-adaptive-time-domain-filtering/</url>
    <content><![CDATA[<h1 id="Artifact-suppression-from-EEG-signals-using-data-adaptive-time-domain-filtering"><a href="#Artifact-suppression-from-EEG-signals-using-data-adaptive-time-domain-filtering" class="headerlink" title="Artifact suppression from EEG signals using data adaptive time domain filtering"></a>Artifact suppression from EEG signals using data adaptive time domain filtering</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>This paper presents a <strong style="color:red">data adaptive filtering</strong> approach to separate the EOG artifact from the recorded EEG signal.</p>
<span id="more"></span>
<p><strong style="color:red">Empirical mode decomposition(EMD)</strong> technique is used to implement the <strong style="color:red">time domain filter</strong>.</p>
<p><strong style="color:red">Fractional Gaussian noise(fGn)</strong> is used here as the <strong style="color:red">reference signal</strong> to detect the distinguish feature of EOG signal to be used to separate from EEG.</p>
<p>EMD is applied to the raw EEG and fGn separately to produce a finite number band limited signals named <strong style="color:red">intrinsic mode functions(IMFs)</strong>.</p>
<p>The energies of individual IMFs of fGn and that of raw EEG are compared to derive the energy based threshold for the suppression of EOG effects. </p>
<p>The separation results using EMD based approach is also compared with wavelet thresholding technique. </p>
<p><strong style="color:red">The experimental results show that the data adaptive filtering technique performs better than the wavelet based approach.</strong></p>
<div style="background-color:yellowgreen;">
<b backgroundclor="green">proposed method's advantages</b>
<ul>
<li>efficiently separates the EOG artifact <b>without changing the amplitude and other necessary properties of the EEG signals</b></li>
<li><b>full data adaptive nature</b></li>
</ul>
</div>

<p><strong style="color:yellow"><i>Note:</i></strong></p>
<ul>
<li>Frequency analysis or filtering —–&gt; deal with single channel signal</li>
<li>Frequency regression analysis   —–&gt; suppress the eye-movement artifact</li>
<li>Time-invariant band-pass filtering or Fourier transform(FT) —–&gt; extract the target frequency component(specific frequency range)</li>
<li>classical time-frequency analyzers(FFT based filtering or short-time Fourier transform(STFT)) —–&gt; non-stationary signal<br>Note:will bring the spectral distrotion</li>
<li>PCA:extracts and sort out the principal components according to the influence on the overall data space.<br>Note:It requires some priori knowledge to identify the PC as the artifact</li>
<li>ICA:<br>key word:decompose<br>problem of using ICA:extracted components do not confirm the original scale and sequences.</li>
<li>main limitation of the filtering method:introduce some spectral distortion </li>
<li>EMD:<br>key benefit of using EMD: automatic decomposition and fully data adaptive<br>UEMD:<br>BEMD:suppress EOG artifacts<br>MEMD:multi-variate data analysis</li>
</ul>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>伪迹移除</category>
      </categories>
      <tags>
        <tag>伪迹移除</tag>
      </tags>
  </entry>
  <entry>
    <title>伪迹移除 | Automatic artifacts removal</title>
    <url>/2020/10/10/Automatic-removal-using-ICA-and-the-dipole-model/</url>
    <content><![CDATA[<h1 id="Automatic-removal-of-eye-movement-artifacts-from-the-EEG-using-ICA-and-the-dipole-model"><a href="#Automatic-removal-of-eye-movement-artifacts-from-the-EEG-using-ICA-and-the-dipole-model" class="headerlink" title="Automatic removal of eye movement artifacts from the EEG using ICA and the dipole model"></a>Automatic removal of eye movement artifacts from the EEG using ICA and the dipole model</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>In this study,we proposed and evaluated the use of <strong style="color:red"> Independent Component Analysis(ICA) combining the EEG dipole model</strong> to <strong style="color:red"> automatically remove</strong> eye movement artifacts from the EEG <strong style="color:red">without needing EOG as a reference</strong>.</p>
<span id="more"></span>

<p>We <strong>separated</strong> the EEG data into independent components using the ICA method,and <strong>determined</strong> the source localization of these independent components with a single dipole model.</p>
<p>The EEG signal was <strong>reconstructed</strong> by antomatically excluding those components localized within a preset eye model.</p>
<p>The <strong>experimental results</strong> indicate that the dipole model is very efficient at automatically<br>substracting the eye movement artifacts,while retaining the EEG slow waves and making their<br>interpretation easier.</p>
<h2 id="Methods-Comparison"><a href="#Methods-Comparison" class="headerlink" title="Methods Comparison"></a>Methods Comparison</h2><h3 id="other-methods’s-disadvantages-filter、recording-of-horizontal-and-vertical-EOG"><a href="#other-methods’s-disadvantages-filter、recording-of-horizontal-and-vertical-EOG" class="headerlink" title="other methods’s disadvantages:(filter、recording of horizontal and vertical EOG)"></a>other methods’s disadvantages:(filter、recording of horizontal and vertical EOG)</h3><ul>
<li>used a simple <strong>filtering concept</strong>,simply <strong>ignoring very low frequencies</strong>(below 1.5 or 2 Hz)</li>
<li>would not perform well in the context of a large amount of <strong>frontal slow waves</strong> (EOG recordingwould be contaminated by this slow wave activity)</li>
</ul>
<div style="background-color:yellowgreen;">
<b backgroundclor="green">ICA's advantages:</b>
<ul>
<li>The ICA algorithm is computationally efficient.</li>
<li>better noise suppression ability.</li>
<li>ICA can simultaneously separate the EEG and artifacts into independent components without relying on the availability of reference artifacts.</li>
<li>avoids the problem of mutual contamination between EEG and EOG channels that could not be solved with filters,regression and PCA.</li>  
<li>The corrected EEG can easily be derived by a combination of the components without artifacts.</li>
</ul>
</div>

<h3 id="A-crucial-step-for-ocular-artifact-correction-using-ICA-algorithms"><a href="#A-crucial-step-for-ocular-artifact-correction-using-ICA-algorithms" class="headerlink" title="A crucial step for ocular artifact correction using ICA algorithms:"></a>A crucial step for ocular artifact correction using ICA algorithms:</h3><p>to correctly identify the artifact components among the decomposed indepent components.</p>
<p>Manually identifying:</p>
<ul>
<li>subjective </li>
<li>inconvenient </li>
<li>time consuming</li>
</ul>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>伪迹移除</category>
      </categories>
      <tags>
        <tag>伪迹移除</tag>
        <tag>ICA</tag>
      </tags>
  </entry>
  <entry>
    <title>伪迹移除 | Artifacts reduction algorithms&#39;s two main ways</title>
    <url>/2020/10/11/Artifacts-reduction-algorithms-two-main-ways/</url>
    <content><![CDATA[<h1 id="Artifacts-reduction-algorithms’s-two-main-ways"><a href="#Artifacts-reduction-algorithms’s-two-main-ways" class="headerlink" title="Artifacts reduction algorithms’s two main ways"></a>Artifacts reduction algorithms’s two main ways</h1><div style>
    <h1 style="color:red">Regression and Filtering Methods</h1>
    <h2 style="color:purple">Regression</h2>
    The regression model use a function to fit the data to smooth the data.    <br>
    Disadvantages:<br>
    1.this method only works for reference channels that are available.<br>
    2.EEG signal being non-linear and non-stationary process,linear regression is not the best choice for analysis in such applications.<br>
    3.it can only be used to treat few particular types of artifact,not all types.
    <h2 style="color:purple">Filtering</h2>
    <h3 style="color:green">linear adaptive filters</h3>
    Note:too sensitive and unstable to adjust the parameters<br>
    <h3 style="color:green">non-linear adaptive filters(include Volterra filters and neural network based adptive filters)</h3>
    Note:stronger processing capabilities and complex calculation<br>
    Disadvantages:<br>
    filters may eliminate useful EEG signals during artifact deletion.<br>
</div>
<span id="more"></span>
<div style>
    <h1 style="color:red">Separate or Decompose EEG Data and Noise Data into Other Domains</h1>
    <h2 style="color:purple">EMD(Empiricla Mode Decomposition)</h2>
    decompose the input signals into multiple empirical modes according to IMF. <br>
    Note:EMD is an empirical and data-driven method<br>
    Disadvantages:<br>
    computationally complex<br>
    may not be suitable for online application<br>
    <h2 style="color:purple">ICA(developed from BSS)</h2>
    separate the ideal signal and noise included in the EEG signal as independent components<br> 
    Disadvantages:<br>
    1.not automatic<br>
    2.requiring human intervention makes results subjective and time 
    consuming<br>
    3.cannot operate on single-channel data<br>
    4.high computational complexity<br>
    <h2 style="color:purple">WT(wavelet transfrom)</h2>
    maps the signal to the wavelet domain.<br>
    According to the wavelet coefficients of signal and noise,they have different properties and mechanisms at different scales,eliminating the wavelet coefficients generated by noise and maximally retaining the coefficients fo real signals.
</div>
    ]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>伪迹移除</category>
      </categories>
      <tags>
        <tag>伪迹移除</tag>
        <tag>ICA</tag>
        <tag>EMD</tag>
      </tags>
  </entry>
  <entry>
    <title>C# | C#中的访问修饰符</title>
    <url>/2021/07/03/C-%E4%B8%AD%E7%9A%84%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="C-中的访问修饰符"><a href="#C-中的访问修饰符" class="headerlink" title="C#中的访问修饰符"></a>C#中的访问修饰符</h1><p><b>public:</b>任何公有成员可以被外部的类访问<br><b>Code:</b></p>
<pre><code>using System;

namespace ConsoleApp1
&#123;   
    class Rectangles
    &#123;
        //成员变量
        public double length;
        public double width;

        public double GetArea()
        &#123;
            return length * width;
        &#125;

        public void Display()
        &#123;
            Console.WriteLine(&quot;Length: &#123;0&#125;&quot;, length);
            Console.WriteLine(&quot;Width: &#123;0&#125;&quot;, width);
            Console.WriteLine(&quot;Area: &#123;0&#125;&quot;, GetArea());
        &#125;
    &#125;
    class PublicTest
    &#123;
        static void Main(string[] args)
        &#123;
            Rectangles r = new Rectangles();
            //另一个类中用internal修饰的变量在这里可以访问
            r.length = 4.5;
            r.width = 3.5;
            r.Display();
            Console.ReadLine();
        &#125;
    &#125;
&#125;
</code></pre>
<span id="more"></span>
<p><b>private:</b>只有同一个类中的函数可以访问它的私有成员<br><b>Code:</b></p>
<pre><code>using System;
using System.Collections.Generic;
using System.Text;

namespace ConsoleApp1
&#123;
    class Rectangle1
    &#123;
        private double length;
        private double width;

        public void AcceptDetails()
        &#123;
            Console.WriteLine(&quot;Please input length:&quot;);
            length = Convert.ToDouble(Console.ReadLine());
            Console.WriteLine(&quot;Please input Width:&quot;);
            width = Convert.ToDouble(Console.ReadLine());
        &#125;

        public double GetArea()
        &#123;
            return length * width;
        &#125;

        public void Display()
        &#123;
            Console.WriteLine(&quot;Length:&#123;0&#125;&quot;, length);
            Console.WriteLine(&quot;Width:&#123;0&#125;&quot;, width);
            Console.WriteLine(&quot;Area:&#123;0&#125;&quot;, GetArea());
        &#125;
    &#125;
    class PrivateTest
    &#123;
        static void Main(string[] args)
        &#123;
            Rectangle1 r = new Rectangle1();
            //另一个类中用private修饰的变量在这里不可以访问
            *//*r.length = 3.4;*//*
            r.AcceptDetails();
            r.Display();
            Console.ReadLine();

        &#125;
    &#125;
&#125;
</code></pre>
<p><b>internal:</b>带有 internal 访问修饰符的任何成员可以被定义在该<strong>成员所定义的应用程序内的任何类或方法访问</strong>。<br><b>Code:</b></p>
<pre><code>using System;
using System.Collections.Generic;
using System.Text;

namespace ConsoleApp1
&#123;
    class Rectangle2
    &#123;
        internal double length;
        internal double width;

        double GetArea()
        &#123;
            return length * width;
        &#125;

        public void Display()
        &#123;
            Console.WriteLine(&quot;长度： &#123;0&#125;&quot;, length);
            Console.WriteLine(&quot;宽度： &#123;0&#125;&quot;, width);
            Console.WriteLine(&quot;面积： &#123;0&#125;&quot;, GetArea());
        &#125;
    &#125;

    class InternalTest
    &#123;
        static void Main(string[] args)
        &#123;
            Rectangle2 r = new Rectangle2();
            //另一个类中用internal修饰的变量在这里可以访问
            r.length = 4.5;
            r.width = 3.5;
            r.Display();
            Console.ReadLine();
        &#125;
    &#125;
&#125;
</code></pre>
<p><b>protected:</b>Protected 访问修饰符允许子类访问它的基类的成员变量和成员函数<br><b>Code:</b></p>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>脑电分类 | CNNLSTM混合分类脑电信号</title>
    <url>/2021/07/01/CNNLSTM%E6%B7%B7%E5%90%88%E5%88%86%E7%B1%BB%E8%84%91%E7%94%B5%E4%BF%A1%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="使用CNN-LSTM混合深度学习分类基于MUSE采集的运动想象EEG信号"><a href="#使用CNN-LSTM混合深度学习分类基于MUSE采集的运动想象EEG信号" class="headerlink" title="使用CNN-LSTM混合深度学习分类基于MUSE采集的运动想象EEG信号"></a>使用CNN-LSTM混合深度学习分类基于MUSE采集的运动想象EEG信号</h1><table>
<thead>
<tr>
<th>模型</th>
<th>Epochs</th>
<th>训练集大小</th>
<th>验证集大小</th>
<th>训练集准确率</th>
<th>验证集准确率</th>
</tr>
</thead>
<tbody><tr>
<td>CNN+LSTM</td>
<td>300</td>
<td>90%</td>
<td>10%</td>
<td>98.6%</td>
<td>96.5%</td>
</tr>
</tbody></table>
<p><a href="https://blog.csdn.net/zyb228/article/details/109542063">参考资料 Click Here!</a><br><a href="https://ieeexplore.ieee.org/document/9155016">论文地址</a></p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>脑电分类</category>
        <category>CNN+LSTM</category>
      </categories>
      <tags>
        <tag>脑电分类</tag>
        <tag>LSTM</tag>
        <tag>CNN+LSTM</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | CPU or GPU?</title>
    <url>/2021/06/21/CPU-or-GPU/</url>
    <content><![CDATA[<h1 id="CPU-or-GPU"><a href="#CPU-or-GPU" class="headerlink" title="CPU or GPU?"></a>CPU or GPU?</h1><p>与CPU相比，GPU擅长SIMD(Single Instruction Multiple Data)计算.<br><a href="https://blog.csdn.net/luoyajingfeng2/article/details/90752019">参考资料</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>GPU | CPU和GPU的设计区别</title>
    <url>/2021/10/11/CPU%E5%92%8CGPU%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="CPU和GPU的设计区别"><a href="#CPU和GPU的设计区别" class="headerlink" title="CPU和GPU的设计区别"></a>CPU和GPU的设计区别</h1><p><a href="https://www.cnblogs.com/biglucky/p/4223565.html">点击链接查看CPU和GPU的设计区别！！！</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>GPU</category>
      </categories>
      <tags>
        <tag>GPU</tag>
        <tag>CPU</tag>
      </tags>
  </entry>
  <entry>
    <title>C# | CSharp参数传递</title>
    <url>/2021/07/03/CSharp%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<h1 id="CSharp参数传递"><a href="#CSharp参数传递" class="headerlink" title="CSharp参数传递"></a>CSharp参数传递</h1><p>1.按值传递参数<br>Code:</p>
<pre><code>using System;
namespace ConsoleApp1
&#123;
    class ValueParameterPassTest
    &#123;
        public void swap(int x, int y)
        &#123;
            int temp;

            temp = x;
            x = y;
            y = temp;
        &#125;

        /*static void Main()
        &#123;
            int a = 100;
            int b = 200;

            Console.WriteLine(&quot;在交换之前，a 的值： &#123;0&#125;&quot;, a);
            Console.WriteLine(&quot;在交换之前，b 的值： &#123;0&#125;&quot;, b);

            ValueParameterPassTest v = new ValueParameterPassTest();

            //按值传递参数
            //v.swap(a, b);

            Console.WriteLine(&quot;在交换之后，a 的值： &#123;0&#125;&quot;, a);
            Console.WriteLine(&quot;在交换之后，b 的值： &#123;0&#125;&quot;, b);

        &#125;*/
    &#125;
&#125;
</code></pre>
<span id="more"></span>
<p>2.按引用传递参数<br>Code:</p>
<pre><code>using System;

namespace ConsoleApp1
&#123;
    class ReferenceParameterPassTest
    &#123;
        public void swap(ref int x, ref int y)
        &#123;
            int temp;

            temp = x; /* 保存 x 的值 */
            x = y;    /* 把 y 赋值给 x */
            y = temp; /* 把 temp 赋值给 y */
        &#125;

        /*static void Main(string[] args)
        &#123;
            ReferenceParameterPassTest n = new ReferenceParameterPassTest();
            *//* 局部变量定义 *//*
            int a = 100;
            int b = 200;

            Console.WriteLine(&quot;在交换之前，a 的值： &#123;0&#125;&quot;, a);
            Console.WriteLine(&quot;在交换之前，b 的值： &#123;0&#125;&quot;, b);

            *//* 调用函数来交换值 *//*
            n.swap(ref a, ref b);

            Console.WriteLine(&quot;在交换之后，a 的值： &#123;0&#125;&quot;, a);
            Console.WriteLine(&quot;在交换之后，b 的值： &#123;0&#125;&quot;, b);

            Console.ReadLine();

        &#125;*/
    &#125;
&#125;
</code></pre>
<p>3.按输出传递参数<br>Code:</p>
<pre><code>using System;

namespace ConsoleApp1
&#123;
    /*class OutputParameterPassTest
    &#123;
        public void getValue(out int x)
        &#123;
            int temp = 5;
            x = temp;
        &#125;

        static void Main()
        &#123;
            OutputParameterPassTest o = new OutputParameterPassTest();
            int a = 100;

            Console.WriteLine(&quot;在方法调用之前，a的值:&#123;0&#125;&quot;, a);

            o.getValue(out a);

            Console.WriteLine(&quot;在方法调用之后，a的值:&#123;0&#125;&quot;, a);
            Console.ReadLine();
        &#125;
    &#125;*/


    class OutputParameterPassTest
    &#123;
        public void getValues(out int x, out int y)
        &#123;
            Console.WriteLine(&quot;Please input first value:&quot;);

            x = Convert.ToInt32(Console.ReadLine());

            Console.WriteLine(&quot;Please input second vale:&quot;);

            y = Convert.ToInt32(Console.ReadLine());
        &#125;

        static void Main()
        &#123;
            //提供给输出参数的变量不需要赋值。当需要从一个参数没有指
            //定初始值的方法中返回值时，输出参数特别有用
            OutputParameterPassTest o = new OutputParameterPassTest();
            int a, b;

            o.getValues(out a, out b);

            Console.WriteLine(&quot;在方法调用之后，a 的值： &#123;0&#125;&quot;, a);
            Console.WriteLine(&quot;在方法调用之后，b 的值： &#123;0&#125;&quot;, b);
            Console.ReadLine();
        &#125;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>Django | DTL中的url反向解析</title>
    <url>/2021/07/30/DTL%E4%B8%AD%E7%9A%84url%E5%8F%8D%E5%90%91%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="DTL中的url反向解析"><a href="#DTL中的url反向解析" class="headerlink" title="DTL中的url反向解析"></a>DTL中的url反向解析</h1><p><strong>反向解析：</strong> 根据配置的url来动态生成链接地址<br><strong>语法：</strong> { % url ‘namespace:name’ p1 p2 %}<br><strong>好处：</strong> 如果改变了url配置不需要再去改每一个链接地址</p>
<span id="more"></span>

<h2 id="反向解析举例"><a href="#反向解析举例" class="headerlink" title="反向解析举例"></a>反向解析举例</h2><p>1.注册应用(settings.py)</p>
<pre><code>INSTALLED_APPS = (
    &#39;django.contrib.admin&#39;,
    &#39;django.contrib.auth&#39;,
    &#39;django.contrib.contenttypes&#39;,
    &#39;django.contrib.sessions&#39;,
    &#39;django.contrib.messages&#39;,
    &#39;django.contrib.staticfiles&#39;,
    &#39;app_name&#39;
)
</code></pre>
<p>1.配置主url(project_name/urls.py project_name为项目文件夹)</p>
<pre><code>from django.conf.urls import include, url
from django.contrib import admin

urlpatterns = [
    url(r&#39;^admin/&#39;, include(admin.site.urls)),
    url(r&#39;^&#39;, include(&#39;app_name.urls&#39;, namespace=&#39;app_name&#39;))
]
/*
app_name:创建的应用名，为项目下的应用文件夹
app_name.urls:应用的urls，应用文件夹下的urls.py
*/
</code></pre>
<p>2.配置应用url(app_anme/urls.py)</p>
<pre><code>from django.conf.urls import url
import views

urlpatterns = [
    url(r&#39;^$&#39;, views.index, name=&#39;index&#39;),
    url(r&#39;^(\d+)/(\d+)$&#39;, views.show, name=&#39;show&#39;),
]
</code></pre>
<p>3.定义视图(app_name/views.py)<br>app_name/index.html处于project_name/templates/app_name/</p>
<pre><code>from django.shortcuts import render
from models import *


def index(request):
    context = &#123;&#125;

    return render(request, &#39;app_name/index.html&#39;, context)


def show(request, id1, id2):
    context = &#123;&#39;id1&#39;: id1, &#39;id2&#39;: id2&#125;
    return render(request, &#39;app_name/show.html&#39;, context)
</code></pre>
<p>4.定义模板<br>index.html</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;a href=&quot;&#123;% url 'app_name:show' '123' '456' %&#125;&quot;&gt;显示&lt;/a&gt;
&lt;hr&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>show.html</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&#123;&#123;id1&#125;&#125;
&#123;&#123;id2&#125;&#125;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>5.配置模板路径DIRS（settings.py）<br>模板文件夹templates在project_name文件夹下</p>
<pre><code>TEMPLATES = [
    &#123;
        &#39;BACKEND&#39;: &#39;django.template.backends.django.DjangoTemplates&#39;,
        &#39;DIRS&#39;: [os.path.join(BASE_DIR, &#39;templates&#39;)],
        &#39;APP_DIRS&#39;: True,
        &#39;OPTIONS&#39;: &#123;
            &#39;context_processors&#39;: [
                &#39;django.template.context_processors.debug&#39;,
                &#39;django.template.context_processors.request&#39;,
                &#39;django.contrib.auth.context_processors.auth&#39;,
                &#39;django.contrib.messages.context_processors.messages&#39;,
            ],
        &#125;,
    &#125;,
]
</code></pre>
<p>6.运行服务器，在浏览器地址栏输入 localhost:8000/123/456,请求服务器。</p>
]]></content>
      <categories>
        <category>python</category>
        <category>框架</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>DTL</tag>
      </tags>
  </entry>
  <entry>
    <title>Django | Django中使用MySQL数据库</title>
    <url>/2021/07/25/Django%E4%B8%AD%E4%BD%BF%E7%94%A8MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h1 id="Django中使用MySQL数据库"><a href="#Django中使用MySQL数据库" class="headerlink" title="Django中使用MySQL数据库"></a>Django中使用MySQL数据库</h1><p>1.在虚拟环境中安装mysql包</p>
<pre><code>pip install mysql-python
</code></pre>
<p>2.在mysql中创建数据库</p>
<pre><code>create databases database_name charset=utf8
</code></pre>
<p><b style="color:red">3.在settings.py中修改DATABASES项</b></p>
<pre><code>DATABASES = &#123;
    &#39;default&#39;: &#123;
        &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;,
        &#39;NAME&#39;: &#39;database_name&#39;,
        &#39;USER&#39;: &#39;root&#39;,
        &#39;PASSWORD&#39;: &#39;1234&#39;,
        &#39;HOST&#39;: &#39;localhost&#39;,
        &#39;PORT&#39;: &#39;3306&#39;,
    &#125;
&#125;
</code></pre>
<p>4.开发流程<br>1）在models.py中定义模型类(继承models.Model)</p>
<pre><code>class Example(models.Model):
    field1 = 
    field2 = 
    ...
</code></pre>
<p>2）把应用加入settings.py文件的installed_app项</p>
<pre><code>INSTALLED_APPS = (
    &#39;django.contrib.admin&#39;,
    &#39;django.contrib.auth&#39;,
    &#39;django.contrib.contenttypes&#39;,
    &#39;django.contrib.sessions&#39;,
    &#39;django.contrib.messages&#39;,
    &#39;django.contrib.staticfiles&#39;,
    &#39;app_name&#39;,
)
</code></pre>
<p>3）生成迁移文件</p>
<pre><code>python manage.py makemigrations
</code></pre>
<p>4）执行迁移生成表</p>
<pre><code>python manage.py migrate
</code></pre>
<p>5）使用模型类进行crud操作</p>
<p><strong>注：</strong><br>使用数据库生成模型类<br>python manage.py inspectdb &gt; app_name/models.py</p>
]]></content>
      <categories>
        <category>python</category>
        <category>框架</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django | Django模型查询</title>
    <url>/2021/07/26/Django%E6%A8%A1%E5%9E%8B%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h1 id="Django模型查询"><a href="#Django模型查询" class="headerlink" title="Django模型查询"></a>Django模型查询</h1><h2 id="查询集的两个特性："><a href="#查询集的两个特性：" class="headerlink" title="查询集的两个特性："></a>查询集的两个特性：</h2><p>1.<strong>惰性执行</strong><br>创建查询集不会带来任何数据库的访问，直到调用数据时，才会访问数据库<br>2.<strong>缓存</strong><br>case1:构成了两个查询集，无法重用缓存，每次查询都会与数据库进行一次交互</p>
<pre><code>print([e.attr for e in Entry.objects.all()])
print([e.attr for e in Entry.objects.all()])
</code></pre>
<p>case2:两次循环使用同一个查询集，第二次使用缓存中的数据</p>
<pre><code>querylist=ExampleModel.objects.all()
print([e.attr for e in querylist])
print([e.attr for e in querylist])
</code></pre>
<p>case3:何时查询集不会被缓存<br>对整个查询集的子集进行求值时不会缓存</p>
<pre><code>query=ExampleModel.objects.all()
for ... in query[0:10]
for ... in query[11:20]
</code></pre>
<h2 id="字段查询"><a href="#字段查询" class="headerlink" title="字段查询"></a>字段查询</h2><p>实现where子名，作为方法filter()、exclude()、get()的参数<br>语法：属性名称__比较运算符=值<br>举例：查询模型类中属性attr1包含1的对象<br>query_list = ExampleModel.objects.filter(attr1__contains=’1’)  </p>
<p><strong>比较运算符：</strong><br>exact、contains、startswith、endswith、isnull、isnotnull、gt、gte、lt、lte、year、<br>month、day、week_day、hour、minute、second<br>注：跨关联查询（语法：模型类名__属性名__比较运算符）</p>
<p><strong>聚合函数：</strong><br>aggregate(Avg()/Count/Max/Min/Sum)</p>
<h2 id="F对象和Q对象"><a href="#F对象和Q对象" class="headerlink" title="F对象和Q对象"></a>F对象和Q对象</h2><p>1.通过构造F对象来比较模型中的两个列<br>举例：query_list = ExampleModel.objects.filter(attr1=F(‘attr2’))<br>2.通过构造Q对象来实现or查询<br>举例：query_list = ExampleModel.objects.filter(Q(pk__lt=6) | Q(attr__gt=1))</p>
]]></content>
      <categories>
        <category>python</category>
        <category>框架</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>脑电基础知识 | 简单了解EEG</title>
    <url>/2020/10/11/EEG-introduction/</url>
    <content><![CDATA[<h1 id="简单了解EEG"><a href="#简单了解EEG" class="headerlink" title="简单了解EEG"></a>简单了解EEG</h1><h2 id="What"><a href="#What" class="headerlink" title="What?"></a>What?</h2><p>EEG is the electrical response of brain cells in the cerebral cortex.</p>
<h2 id="How-to-record"><a href="#How-to-record" class="headerlink" title="How to record?"></a>How to record?</h2><p>typically collected by an electrode collection system(10/20 system)placed on the head of the brain. </p>
<span id="more"></span>
<h2 id="characteristic"><a href="#characteristic" class="headerlink" title="characteristic"></a>characteristic</h2><ul>
<li>a highly random <b>nonlinear non-stationary signal</b></li>
<li>contains very <b>complex components</b></li>
<li>the signal amplitude is microvolts,and the <b>intensity is very weak</b>.</li>
<li>it is very <b>susceptible</b> to other <b>physiological signals</b> of the human body(<b>EOG/ECG/EMG</b>) or interference from non-physiological signals such as spatial electromagnetic noise.</li>
</ul>
<h2 id="Existed-problem"><a href="#Existed-problem" class="headerlink" title="Existed problem"></a>Existed problem</h2><p><b>Artifacts often mask the waveform characteristics of EEG</b>,which makes the reading of EEG signals more difficult<br>and bring great difficulties to the subsequent research and application of EEG signal.</p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>脑电基础知识</category>
      </categories>
      <tags>
        <tag>EEG</tag>
      </tags>
  </entry>
  <entry>
    <title>EEG | EEG Pathology Detection Based on Deep Learning</title>
    <url>/2020/11/05/EEG-Pathology-Detection-Based-on-Deep-Learning/</url>
    <content><![CDATA[<p>EEG Pathology Detection Based on Deep Learning</p>
<h1 id="Target-EEG-Pathology-Detection"><a href="#Target-EEG-Pathology-Detection" class="headerlink" title="Target: EEG Pathology Detection"></a>Target: EEG Pathology Detection</h1><h1 id="Proposed-Methonds"><a href="#Proposed-Methonds" class="headerlink" title="Proposed Methonds:"></a>Proposed Methonds:</h1><p>Method One:Shallow CNN Model<br>Method Two:Deep CNN Model(AlexNet)<br>Method Three:Fusion stategy based on a multiplayer perception<br>Fusion of CNN features of several distinct temporal segments of the EEG signal</p>
<p><b style="color:red">In future study:investigate different fusion strategies</b></p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
      </categories>
      <tags>
        <tag>CNN</tag>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title>urllib.request | GET请求</title>
    <url>/2021/08/05/GET%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<h1 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h1><p>使用urllib.request模块可以在python中访问互联网资源，以下是发送GET请求的示例代码。</p>
<pre><code># coding=utf-8

import urllib.request

# url中？后的内容是请求参数，多个参数之间以&amp;分割
url = &#39;http://localhost:8080/NoteWebService/note.do?action=query&amp;ID=10&#39;

# 创建Request对象，默认是GET请求
req = urllib.request.Request(url)

with urllib.request.urlopen(req) as response:
    data = response.read()  # 读取数据，为字节序列数据
    json_data = data.decode()  # 将字节序列数据转换为字符串
    print(json_data)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>内置模块</category>
        <category>urllib</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>urllib</tag>
      </tags>
  </entry>
  <entry>
    <title>GPU | GPU利用率低？</title>
    <url>/2021/10/09/GPU%E5%88%A9%E7%94%A8%E7%8E%87%E4%BD%8E%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="GPU利用率低？"><a href="#GPU利用率低？" class="headerlink" title="GPU利用率低？"></a>GPU利用率低？</h1><p><a href="https://blog.csdn.net/qq_32998593/article/details/92849585">GPU利用率低？</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>GPU</category>
      </categories>
      <tags>
        <tag>GPU</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP | HTTP请求方法</title>
    <url>/2020/11/09/HTTP%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h1><h2 id="常见的几种请求方式"><a href="#常见的几种请求方式" class="headerlink" title="常见的几种请求方式"></a>常见的几种请求方式</h2><table>
<thead>
<tr>
<th>Methods</th>
<th>Descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>获取数据 例如：获取指定的页面</td>
</tr>
<tr>
<td>POST</td>
<td>修改数据 例如：提交表单、上传文件</td>
</tr>
<tr>
<td>PUT</td>
<td>保存数据</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除 例如：删除指定页面</td>
</tr>
<tr>
<td>OPTION</td>
<td>询问服务器的某种支持特性</td>
</tr>
<tr>
<td>HEAD</td>
<td>用于获取报头</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程 | I/O密集型和计算密集型</title>
    <url>/2020/11/02/IO%E5%AF%86%E9%9B%86%E5%9E%8B%E5%92%8C%E8%AE%A1%E7%AE%97%E5%AF%86%E9%9B%86%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="I-O密集型和计算密集型"><a href="#I-O密集型和计算密集型" class="headerlink" title="I/O密集型和计算密集型"></a>I/O密集型和计算密集型</h1><p><strong>I/O密集型</strong>—&gt;需要网络功能，大量的时间都在等待网络数据的到来—&gt;通常使用多线程/协程</p>
<p><strong>计算密集型</strong>—&gt;需要占用大量的cpu资源—&gt;通常使用多进程</p>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习 | K近邻算法(KNN)</title>
    <url>/2021/02/21/K%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95-KNN/</url>
    <content><![CDATA[<h1 id="K近邻算法-KNN"><a href="#K近邻算法-KNN" class="headerlink" title="K近邻算法(KNN)"></a>K近邻算法(KNN)</h1><h2 id="KNN算法原理"><a href="#KNN算法原理" class="headerlink" title="KNN算法原理"></a>KNN算法原理</h2><p>k近邻法(k-nearest neighbor, k-NN)一种基本分类与回归方法。它的工作原理是：存在一个样本数据集合，也称作为训练样本集，并且样本集中每个数据都存在标签，即我们知道样本集中每一个数据与所属分类的对应关系。输入没有标签的新数据后，将新的数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本最相似数据(最近邻)的分类标签。一般来说，我们只选择样本数据集中前k个最相似的数据，这就是k-近邻算法中k的出处，通常k是不大于20的整数。最后，选择k个最相似数据中出现次数最多的分类，作为新数据的分类。</p>
<span id="more"></span>
<h2 id="距离度量"><a href="#距离度量" class="headerlink" title="距离度量"></a>距离度量</h2><p>我们已经知道k-近邻算法根据特征比较，然后提取样本集中特征最相似数据（最近邻）的分类标签，那么如何进行比较？KNN算法通过距离（欧式距离）度量进行判断。<br><b>Note:</b>距离度量方法还有切比雪夫距离、马氏距离、巴氏距离等；</p>
<h2 id="简单k-近邻算法步骤"><a href="#简单k-近邻算法步骤" class="headerlink" title="简单k-近邻算法步骤"></a>简单k-近邻算法步骤</h2><p>1.计算已知类别数据集中的点与当前点的距离<br>2.按照距离递增次序排序<br>3.选取与当前点距离最小的k个点<br>4.确定前k个点所在类别的出现频率<br>5.返回前k个点所出现频率最高的类别作为当前点的预测分类</p>
<h2 id="KNN的一般流程"><a href="#KNN的一般流程" class="headerlink" title="KNN的一般流程"></a>KNN的一般流程</h2><p>1.收集数据：爬虫/第三方提供的免费/收费数据。一般来讲，数据放在txt文本文件中，按照一定的格式进行存储，便于解析和处理。<br>2.准备数据：使用python解析、预处理数据<br>3.分析数据：可以使用很多方法对数据进行分析。例如使用Matplotlib将数据可视化<br>4.测试算法：计算错误率<br>5.使用算法：错误率在可接受范围内，就可以使用k-近邻算法进行分类</p>
<h2 id="KNN的优缺点"><a href="#KNN的优缺点" class="headerlink" title="KNN的优缺点"></a>KNN的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>1.简单好用，容易理解，精度高，理论成熟，既可以用来做<b>分类</b>也可以用来做<b>回归</b><br>2.可用于数值型数据和离散型数据<br>3.训练时间复杂度为O(n);无数据输入假定；<br>4.对异常值不敏感</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>1.<b>计算复杂性高</b>；空间复杂性高<br>2.样本不平衡问题（即有些类别的样本数量很多，而其他样本的数量很少）<br>3.<b>一般数值很大的时候不用这个，计算量太大。但是单个样本也不能太少，否则容易发生误分。</b><br>4.最大的缺点是无法给出数据的内在含义  </p>
<h2 id="实战代码地址"><a href="#实战代码地址" class="headerlink" title="实战代码地址"></a>实战代码地址</h2><p><a href="https://github.com/victory-liao/Machine-Learning">Click here to look up code</a></p>
<h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><p><a href="https://cuijiahua.com/blog/2017/11/ml_1_knn.html">KNN</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>KNN</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>KNN</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux | vim | vim常用命令及三种命令模式</title>
    <url>/2020/10/08/Linux-vim/</url>
    <content><![CDATA[<h1>vim常用命令</h1> 
yy:复制 光标所在的这一行
numyy:复制 光标所在行开始向下的num行<br><br>

<p>p:paste<br><br></p>
<p>dd:剪切 光标所在的这一行<br><br>numdd:剪切 光标所在行向下num行<br><br>D:从当前的光标开始剪切，一直到行末<br><br>d0:从单签光标开始剪切，一直到行首<br><br>x：删除当前的光标，每次只会删除一个<br><br>X：删除当前光标前面那个，每次只会删除一个<br><br></p>
<span id="more"></span>
<p>h：left j：down k：up l：right<br><br></p>
<p>H:当前屏幕的最上方<br><br>M:当前屏幕的中间<br><br>L:当前屏幕的下方<br><br></p>
<p>ctrl+f 向下翻一页<br><br>ctrl+b 向上翻一页<br><br></p>
<p>ctrl+u 向上翻半页<br><br>ctrl+d 向下翻半页<br><br></p>
<p>numG:快速定位到第num行代码<br><br>G:快速回到整个代码的最后一行<br><br>gg:快速回到整个代码的第一行<br><br></p>
<p>w:向后跳一个单词的长度<br><br>b：向前跳一个单词的长度<br><br></p>
<p>u:撤销刚刚的操作<br><br>ctrl+r：反撤销<br><br></p>
<p>选中一片代码<br><br>v:<br><br>V:<br><br>‘&gt;&gt;:向右移动代码<br><br>&lt;&lt;:向左移动代码<br><br></p>
<p>.:重复执行上一次的命令<br><br></p>
<p>r:替换一个字符<br><br>R:替换光标以及后边的字符<br><br></p>
<p>/string:查找 n:下一个 N：上一个<br><br></p>
<p>shift+zz==wq<br><br></p>
<p>末行模式：<br><br>w:保存<br><br>q:退出<br><br>wq:保存并退出<br><br><br>x:退出</p>
<h1>vim三种命令模式</h1>
![vim三种命令模式](./Linux-vim/vim.jpg)  





]]></content>
      <categories>
        <category>Linux</category>
        <category>vim</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习 | Logistic回归</title>
    <url>/2021/03/06/Logistic%E5%9B%9E%E5%BD%92/</url>
    <content><![CDATA[<h1 id="Logistic回归"><a href="#Logistic回归" class="headerlink" title="Logistic回归"></a>Logistic回归</h1><p>Logistic回归是一种<b>分类</b>算法，通常用于<b>二分类</b>问题(例如：明天是否会下雨)，但也可以用于多分类问题。</p>
<span id="more"></span>
<h2 id="Logistic回归与梯度上升算法"><a href="#Logistic回归与梯度上升算法" class="headerlink" title="Logistic回归与梯度上升算法"></a>Logistic回归与梯度上升算法</h2><h3 id="Logistic回归-1"><a href="#Logistic回归-1" class="headerlink" title="Logistic回归"></a>Logistic回归</h3><p><b>回归：</b>利用一条直线对一些数据点进行拟合的过程。</p>
<p>Logistic回归是分类方法，它利用的是Sigmoid函数阈值在[0,1]这个特性。</p>
<p><b>Logistic回归进行分类的主要思想：</b>根据现有数据对分类边界线建立回归公式，以此进行分类</p>
<p>其实，Logistic回归本质上是一个基于条件概率的判别模型(Discriminative Model)。</p>
<p><b>Sigmoid函数(Logistic函数)：</b><br><img src="/2021/03/06/Logistic%E5%9B%9E%E5%BD%92/1.png"><br><img src="/2021/03/06/Logistic%E5%9B%9E%E5%BD%92/2.jpg"><br><img src="/2021/03/06/Logistic%E5%9B%9E%E5%BD%92/3.png"><br>整合成一个公式：<br><img src="/2021/03/06/Logistic%E5%9B%9E%E5%BD%92/5.jpg"></p>
<p><b>Sigmoid函数的图像：</b><br><img src="/2021/03/06/Logistic%E5%9B%9E%E5%BD%92/6.png"><br>z是一个矩阵，θ是参数列向量(要求解的)，x是样本列向量(给定的数据集)。θ^T表示θ的转置。g(z)函数实现了任意实数到[0,1]的映射，这样我们的数据集([x0,x1,…,xn])，不管是大于1或者小于0，都可以映射到[0,1]区间进行分类。hθ(x)给出了输出为1的概率。比如当hθ(x)=0.7，那么说明有70%的概率输出为1。输出为0的概率是输出为1的补集，也就是30%。</p>
<p>如果我们有合适的参数列向量θ([θ0,θ1,…θn]^T)，以及样本列向量x([x0,x1,…,xn])，那么我们对样本x分类就可以通过上述公式计算出一个概率，如果这个概率大于0.5，我们就可以说样本是正样本，否则样本是负样本。</p>
<p><b>如何得到合适的参数向量θ？</b><br>根据sigmoid函数的特性，我们可以做出如下的假设：<br><img src="/2021/03/06/Logistic%E5%9B%9E%E5%BD%92/7.jpg"><br>两个概率公式合而为一：(损失函数-Loss Function)<br><img src="/2021/03/06/Logistic%E5%9B%9E%E5%BD%92/8.jpg"><br>取对数：<br><img src="/2021/03/06/Logistic%E5%9B%9E%E5%BD%92/9.jpg"><br>这个损失函数，是对于一个样本而言的。给定一个样本，我们就可以通过这个损失函数求出，样本所属类别的概率，而这个概率越大越好，所以也就是求解这个损失函数的最大值。既然概率出来了，那么最大似然估计也该出场了。假定样本与样本之间相互独立，那么整个样本集生成的概率即为所有样本生成概率的乘积，再将公式对数化，便可得到如下公式：<br><img src="/2021/03/06/Logistic%E5%9B%9E%E5%BD%92/10.png"><br>其中，m为样本的总数，y(i)表示第i个样本的类别，x(i)表示第i个样本，需要注意的是θ是多维向量，x(i)也是多维向量。</p>
<p>综上所述，满足J(θ)的最大的θ值即是我们需要求解的模型。</p>
<p>怎么求解使J(θ)最大的θ值呢？因为是<b>求最大值</b>，所以我们需要使用<b>梯度上升算法</b>。如果面对的问题是求解使J(θ)<b>最小</b>的θ值，那么我们就需要使用<b>梯度下降算法</b>。面对我们这个问题，如果使<b>J(θ) := -J(θ)</b>，那么问题就从求极大值转换成求极小值了，使用的算法就从梯度上升算法变成了梯度下降算法，它们的思想都是相同的，学会其一，就也会了另一个。</p>
<h3 id="梯度上升算法"><a href="#梯度上升算法" class="headerlink" title="梯度上升算法"></a>梯度上升算法</h3><p>爬坡这个动作用数学公式表达即为：<br><img src="/2021/03/06/Logistic%E5%9B%9E%E5%BD%92/11.png"><br>其中，α为步长，也就是学习速率，控制更新的幅度。<br>梯度上升迭代公式：<br><img src="/2021/03/06/Logistic%E5%9B%9E%E5%BD%92/12.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><b>Logistic回归的一般过程：</b><br>1.收集数据：采用任意方法收集数据。<br>2.准备数据：由于需要进行距离计算，因此要求数据类型为数值型。另外，结构化数据格式则最佳。<br>3.分析数据：采用任意方法对数据进行分析。<br>4.训练算法：大部分时间将用于训练，训练的目的是为了找到最佳的分类回归系数。<br>5.测试算法：一旦训练步骤完成，分类将会很快。<br>6.使用算法：首先，我们需要输入一些数据，并将其转换成对应的结构化数值；接着，基于训练好的回归系数，就可以对这些数值进行简单的回归计算，判定它们属于哪个类别；在这之后，我们就可以在输出的类别上做一些其他分析工作。</p>
<p><b>Logistic回归的优缺点</b><br>优点：实现简单，易于理解和实现；计算代价不高，速度很快，存储资源低。<br>缺点：容易欠拟合，分类精度可能不高。</p>
<p><b>其他</b><br>1.Logistic回归的目的是寻找一个非线性函数Sigmoid的最佳拟合参数，求解过程可以由最优化算法完成。<br><br>2.改进的一些最优化算法，比如sag。它可以在新数据到来时就完成参数更新，而不需要重新读取整个数据集来进行批量处理。<br><br>机器学习的一个重要问题就是如何处理缺失数据。这个问题没有标准答案，取决于实际应用中的需求。现有一些解决方案，每种方案都各有优缺点。<br><br>3.我们需要根据数据的情况，这是Sklearn的参数，以期达到更好的分类效果。</p>
<p><a href="https://cuijiahua.com/blog/2017/11/ml_6_logistic_1.html">参考资料1</a><br><a href="https://cuijiahua.com/blog/2017/11/ml_7_logistic_2.html">参考资料2</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>Logistic Regression</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>逻辑回归</tag>
      </tags>
  </entry>
  <entry>
    <title>可视化 | Logistic回归可视化主要代码</title>
    <url>/2021/03/11/Logistic%E5%9B%9E%E5%BD%92%E5%8F%AF%E8%A7%86%E5%8C%96%E4%B8%BB%E8%A6%81%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h1 id="Logistic回归可视化主要代码"><a href="#Logistic回归可视化主要代码" class="headerlink" title="Logistic回归可视化主要代码"></a>Logistic回归可视化主要代码</h1><pre><code>import matplotlib.pyplot as plt

fig = plt.figure()
ax = fig.add_subplot(111)
ax.scatter(xcord1,ycord1,s=20,c=&#39;red&#39;,marker=&#39;s&#39;,alpha=0.5)
ax.plot(x,y)
plt.title()
plt.xlabel()
plt.ylabel()
plt.show()
</code></pre>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>可视化(Visualization)</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>逻辑回归</tag>
      </tags>
  </entry>
  <entry>
    <title>GPU | NVIDIAGeForceGTX1650驱动安装</title>
    <url>/2021/10/09/NVIDIAGeForceGTX1650%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="NVIDIAGeForceGTX1650驱动安装"><a href="#NVIDIAGeForceGTX1650驱动安装" class="headerlink" title="NVIDIAGeForceGTX1650驱动安装"></a>NVIDIAGeForceGTX1650驱动安装</h1><p>当我们想使用GPU（可以用来加速）来跑深度学习代码前，需要进行显卡驱动安装，我的显卡是NVIDIA GeForce GTX 1650。</p>
<p><strong>需要安装：</strong><br>1.Cuda<br>2.CuDNN<br><strong>下载地址：</strong><br><a href="https://developer.nvidia.com/cuda-toolkit">Cuda</a><br><a href=" https://developer.nvidia.com/cudnn">CuDNN</a><br><strong>我的显卡使用的Cuda、CuDNN版本：</strong><br>1.Cuda-10.1<br>2.CuDNN-7.6<br>3.Tensorflow-gpu-1.15.0(可选，在这里我是想用来加速Tensorflow代码的训练)</p>
<p><strong>注意：深度学习框架、python、Cuda、CuDNN版本的对应以及Cuda与自己显卡的兼容性</strong><br><a href="https://blog.csdn.net/s_hikki/article/details/106107778">NVIDIA GeForce GTX 1650驱动安装</a><br><a href="https://tensorflow.google.cn/install/source_windows#configuration_options">版本对应参考资料</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>GPU</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>GPU</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL | MySQL常见的表操作语句</title>
    <url>/2021/10/14/MySQL%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A1%A8%E6%93%8D%E4%BD%9C%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h1 id="MySQL常见的表操作语句"><a href="#MySQL常见的表操作语句" class="headerlink" title="MySQL常见的表操作语句"></a>MySQL常见的表操作语句</h1><p>1.表的创建</p>
<pre><code>create table table_name(
id int auto_increment primary key not null,
name varchar(11) not null
);
</code></pre>
<p>2.增加记录</p>
<pre><code>insert into table_name values()
insert into table_name values(),(),()
insert into table_name() values()
insert into table_name() values(),(),()
</code></pre>
<p>3.修改记录</p>
<pre><code>update table_name set attr=val where...
</code></pre>
<p>4.删除记录</p>
<pre><code>delete from table_name where...
</code></pre>
<p>5.表查询</p>
<pre><code>条件：select * from table_name where...
聚合：select count(*)|min()|max()|avg() from table_name
分组：select gender,count(*) from table_name group by gender having....
排序：select * from table_name order by...
分页：select * from table_name limit start,count
</code></pre>
<p>连接查询：<a href="https://blog.csdn.net/zjt980452483/article/details/82945663">点击此处，查看更多关于连接查询！！！</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>urllib.request | POST请求</title>
    <url>/2021/08/05/POST%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<h1 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h1><p>使用urllib.request模块可以在python中访问互联网资源，以下是发送POST请求的示例代码。</p>
<pre><code># coding=utf-8

import urllib.request

url = &#39;http://localhost:8080/NoteWebService/note.do&#39;

# 准备HTTP参数
params_dict = &#123;&#39;action&#39;: &#39;query&#39;, &#39;ID&#39;: &#39;10&#39;&#125;  # 准备将参数放到字典中
params_str = urllib.parse.urlencode(params_dict)  # 将字典参数转换为字符串，形式为action=query&amp;ID=10

# 字符串转换为字节序列对象
params_bytes = params_str.encode()  # 发送POST请求时的参数要以字节序列形式发送

req = urllib.request.Request(url, data=params_bytes)  # 发送POST请求
with urllib.request.urlopen(req) as response:
    data = response.read()
    json_data = data.decode()
    print(json_data)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>内置模块</category>
        <category>urllib</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>urllib</tag>
      </tags>
  </entry>
  <entry>
    <title>Anaconda | ProxyError</title>
    <url>/2021/07/08/ProxyError/</url>
    <content><![CDATA[<p>在使用Anaconda创建虚拟环境时出错： ProxyError: Conda cannot proceed due to an error in your proxy configuration</p>
<p><a href="https://blog.csdn.net/littlehaes/article/details/103518285">解决办法！！！</a></p>
]]></content>
      <categories>
        <category>Anaconda</category>
      </categories>
      <tags>
        <tag>Anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title>python | Python变量单前下划线与双前下划线的区别</title>
    <url>/2020/11/29/Python%E5%8F%98%E9%87%8F%E5%8D%95%E5%89%8D%E4%B8%8B%E5%88%92%E7%BA%BF%E4%B8%8E%E5%8F%8C%E5%89%8D%E4%B8%8B%E5%88%92%E7%BA%BF%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="Python变量单前下划线与双前下划线的区别"><a href="#Python变量单前下划线与双前下划线的区别" class="headerlink" title="Python变量单前下划线与双前下划线的区别"></a>Python变量单前下划线与双前下划线的区别</h1><h2 id="variable"><a href="#variable" class="headerlink" title="_variable"></a>_variable</h2><p>表面上为私有，实际在外部可以访问</p>
<h2 id="variable-1"><a href="#variable-1" class="headerlink" title="__variable"></a>__variable</h2><p>实际上的私有，只能在内部访问，不能在外部访问（报错）</p>
<h2 id="variable-2"><a href="#variable-2" class="headerlink" title="_ variable _"></a>_ <em>variable</em> _</h2><p>魔法方法（magic method）/ 特殊方法</p>
<h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><pre><code>class TestPrivacy(object):
    _name = &#39;hello&#39; 
    __name = &#39;world&#39;
    
print(TestPrivacy._name) # Output:&#39;hello&#39;
print(TestPrivacy.__name) # Output: AttributeError: type object &#39;TestPrivacy&#39; has no attribute &#39;__name&#39;
</code></pre>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python-docx | Python检查word文件中的特殊标记词是否与文件名中的一致</title>
    <url>/2021/10/29/Python%E6%A3%80%E6%9F%A5word%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E6%A0%87%E8%AE%B0%E8%AF%8D%E6%98%AF%E5%90%A6%E4%B8%8E%E6%96%87%E4%BB%B6%E5%90%8D%E4%B8%AD%E7%9A%84%E4%B8%80%E8%87%B4/</url>
    <content><![CDATA[<h1 id="Python检查word文件中的特殊标记词是否与文件名中的一致"><a href="#Python检查word文件中的特殊标记词是否与文件名中的一致" class="headerlink" title="Python检查word文件中的特殊标记词是否与文件名中的一致"></a>Python检查word文件中的特殊标记词是否与文件名中的一致</h1><p>公司的部分文件分为“内部”和“外部”。正常情况下，这个标识在文件名及文件首页左上角都有标注。然鹅，有时候操作一下，忘记改了，或者忘记标注了。就需要回头去一个一个地整理，非常麻烦。这种重复的，繁杂的操作，尽快冲Python来，人类还是应该多做做其它更有意思的事。</p>
<p>代码：</p>
<pre><code>import os
from win32com import client as wc  # 导入模块
import docx
from docx.shared import Pt  # 用于设定字体大小（磅值）
from docx.oxml.ns import qn  # 用于应用中文字体

# 将文件夹内的所有doc转存为docx文件
path = os.getcwd() + &quot;\\文件\\&quot;  # 文件夹绝对路径
files = []
for file in os.listdir(path):
    if file.endswith(&quot;.doc&quot;):  # 排除文件夹内的其他干扰文件，只获取&quot;.doc&quot;后缀的word文件
        files.append(path+file)

word = wc.Dispatch(&quot;Word.Application&quot;)  # 打开word应用程序
for file in files:
    doc = word.Document(file)  # 打开word文件
    doc.SaveAs(&quot;&#123;&#125;x&quot;.format(file), 12)  # 另存为后缀为&quot;.docx&quot;的文件，其中参数12指docx文件
    doc.Close()  # 关闭原来word文件
word.Quit()

for file in files:  # 删除doc文件
    os.remove(file)

# 获取所有docx文件路径
docx_files = []
for file in os.listdir(path):  # 排除文件夹内的其它干扰文件，只获取&quot;.doc&quot;后缀的word文件
    if file.endswith(&quot;.docx&quot;):
        docx_files.append(path+file)

counter = 0  # 计数器，用于记录有多少文件没被处理

for file in docx_files:
    file_head = file.split(&#39;.&#39;)[0].rstrip()  # 文件名头，类似这样的“C:\\Users\\文件\\测试”
    file_tail = file.split(&#39;\\&#39;)[-1]  # 文件名尾，类似这样“测试.docx”
    mark_words = [&quot;公开&quot;, &quot;内部&quot;]
    mark_fileName = file_head[-3:-1]  # 文件名中倒数第2,3个文字

    doc = docx.Document(file)
    mark_doc = doc.paragraphs[0].text  # 文件中首段文字
    # 比对标记词
    if mark_doc in mark_words:  # 判断文件中有无标记
        if mark_fileName in mark_words:  # 判断文件名中有无标记
            if mark_doc == mark_fileName:  # 如果二者标记相同
                counter += 1
                pass
            else:  # 二者标记不同
                os.rename(file, file.replace(mark_fileName, mark_doc))  # 重命名文件
                print(f&quot;【&#123;file_tail&#125;】文件名重命名标识为【&#123;mark_doc&#125;】&quot;)
        else:
            os.rename(file, f&quot;&#123;file_head&#125;（&#123;mark_doc&#125;）.docx&quot;)  # 文件名中无标记，则加标记
            print(f&quot;【&#123;file_tail&#125;】文件名增加标识为【&#123;mark_doc&#125;】&quot;)
    else:
        # 文中无标记，则在首段前插入一段，写入标记
        p = doc.paragraphs[0]
        pNew = p.insert_paragraph_before()
        run = pNew.add_run(mark_words[0])  # 写为“公开”
        # 字体设置
        run.font.size = Pt(16)
        run.font.name = &quot;黑体&quot;
        r = run._element.rPr.rFonts
        r.set(qn(&quot;w:eastAsia&quot;), &quot;黑体&quot;)

        doc.save(file)
        print(f&quot;【&#123;file_tail&#125;】内容增加标识为【&#123;mark_words[0]&#125;】&quot;)

        if mark_fileName in mark_words:  # 查看文件名中是否有标记
            if mark_fileName == mark_words[0]:  # 标记是否为“公开”
                pass
            else:  # 标记不是“公开”则替换
                os.rename(file, file.replace(mark_fileName, mark_words[0]))  # 重命名文件
                print(f&quot;【&#123;file_tail&#125;】文件名重命名标识为【&#123;mark_words[0]&#125;】&quot;)
        else:
            os.rename(file, f&quot;&#123;file_head&#125;（&#123;mark_words[0]&#125;）.docx&quot;)  # 文件名中无标记，则加标记
            print(f&quot;【&#123;file_tail&#125;】文件名增加标识为【&#123;mark_words[0]&#125;】&quot;)

print(f&quot;完成！共检查&#123;len(docx_files)&#125;个文件,处理了 &#123;len(docx_files) - counter&#125; 个文件。&quot;)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>python-docx</category>
      </categories>
      <tags>
        <tag>os</tag>
        <tag>win32com</tag>
        <tag>python-docx</tag>
      </tags>
  </entry>
  <entry>
    <title>xlrd | Python汇总各单位Excel档领料记录并加总每日领用次数</title>
    <url>/2021/10/29/Python%E6%B1%87%E6%80%BB%E5%90%84%E5%8D%95%E4%BD%8DExcel%E6%A1%A3%E9%A2%86%E6%96%99%E8%AE%B0%E5%BD%95%E5%B9%B6%E5%8A%A0%E6%80%BB%E6%AF%8F%E6%97%A5%E9%A2%86%E7%94%A8%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h1 id="Python汇总各单位Excel档领料记录并加总每日领用次数"><a href="#Python汇总各单位Excel档领料记录并加总每日领用次数" class="headerlink" title="Python汇总各单位Excel档领料记录并加总每日领用次数"></a>Python汇总各单位Excel档领料记录并加总每日领用次数</h1><p><a href="https://www.cnblogs.com/insane-Mr-Li/p/9092619.html">xlrd详解</a><br>代码：</p>
<pre><code>import time
import xlrd
import datetime


# 读取xls文件中的数据
def Get_data(file):
    wb = xlrd.open_workbook(file)  # 读取工作簿
    ws = wb.sheets()[0]  # 选第一个工作表
    data = &#123;&#125;

    for row in range(7, ws.nrows - 2):
        dept = ws.cell(2, 16).value  # 部门
        dept_id = ws.cell(3, 16).value  # 部门编号
        dt = ws.cell(row, 0).value  # 时间
        if type(dt) is float:
            date_time = xlrd.xldate.xldate_as_datetime(dt, 0)
        else:
            date_time = datetime.datetime.strptime(dt, &#39;%Y-%m-%d %H:%M:%S&#39;)
        business = ws.cell(row, 2).value  # 业务类型
        model = ws.cell(row, 3).value  # 品种
        qty = ws.cell(row, 4).value  # 数量
        unit_price = ws.cell(row, 6).value  # 单价
        price = ws.cell(row, 8).value  # 总价
        reward = ws.cell(row, 9).value  # 额外值
        discount = ws.cell(row, 11).value  # 调整
        balance = ws.cell(row, 13).value  # 剩余
        location = str(ws.cell(row, 15).value).strip()  # 库位
        operator = ws.cell(row, 17).value  # 操作员
        date = date_time.date()  # 日期
        time = date_time.time()  # 时间
        info_list = [dept, dept_id, date_time, business, model, qty, unit_price, price, reward, discount,
                     balance, location, operator, date, time]
        data.setdefault(date, [])  # 以日期为键
        if info_list[3] != &quot;备注&quot;:  # 不要业务类型为“备注”的数据
            data[date].append(info_list)

    # 增加当日领取次数
    for key in data.keys():
        for i in data[key]:
            i.append(len(data[key]))

    return data


import os  # 用于获取目标文件所在路径

path = os.getcwd() + &quot;\\记录\\&quot;  # 文件夹绝对路径
files = []
for file in os.listdir(path):
    if file.endswith(&quot;.xls&quot;):  # 只获取&quot;.xls&quot;后缀的文件
        files.append(path + file)
# print(files)

# Get_data(files[0])


def Get_current_time():
    time_stamp = time.time()  # 当前时间的时间戳
    local_time = time.localtime(time_stamp)  #
    str_time = time.strftime(&#39;%Y-%m-%d %H.%M.%S&#39;, local_time)
    return str_time


# print(Get_current_time())

# 汇总数据到主文件
from openpyxl import Workbook
from openpyxl.styles import Border, Side, PatternFill, Font, GradientFill, Alignment  # 设置单元格格式

thin = Side(border_style=&quot;thin&quot;, color=&quot;000000&quot;)  # 定义边框粗细及颜色
title = [&#39;部门&#39;, &#39;部门编号&#39;, &#39;时间&#39;, &#39;业务类型&#39;, &#39;品种&#39;, &#39;数量&#39;, &#39;单价&#39;, &#39;金额&#39;, &#39;额外值&#39;,
         &#39;调整&#39;, &#39;剩余&#39;, &#39;库位&#39;, &#39;操作员&#39;, &#39;领取日期&#39;, &#39;领取时间&#39;, &#39;领取次数&#39;]

wb = Workbook()
ws = wb.active
ws.merge_cells(&quot;A1:P1&quot;)  # 合并首行单元格
ws.cell(1, 1).value = &quot;领料明细汇总表&quot;
ws.cell(1, 1).font = Font(name=u&#39;黑体&#39;, bold=True, size=18)
ws.row_dimensions[1].height = 22.2  # 设置首行行高
ws.cell(1, 1).alignment = Alignment(horizontal=&quot;center&quot;, vertical=&quot;center&quot;)  # 设置对齐
ws.append(title)  # 写入字段行

# 写入各部门领料的数据
for file in files:
    data = Get_data(file)
    for key in data.keys():
        for i in data[key]:
            ws.append(i)

# 设置字号，对齐，缩小字体填充，加边框
# Font(bold=True)可加粗字体
for row_number in range(2, ws.max_row + 1):
    for col_number in range(1, 17):
        c = ws.cell(row=row_number, column=col_number)
        c.font = Font(size=9)
        c.border = Border(top=thin, left=thin, right=thin, bottom=thin)
        c.alignment = Alignment(horizontal=&quot;left&quot;, vertical=&quot;center&quot;)

# 设置列宽
col_name = list(&quot;ABCDEFGHIJKLMNOP&quot;)
col_width = [8, 8, 16, 8, 16, 8, 8, 9.8, 8, 8, 8, 11, 8.3, 9, 8, 8]
for i in range(len(col_name)):
    ws.column_dimensions[col_name[i]].width = col_width[i]

# 分组隐藏列
ws.column_dimensions.group(&#39;I&#39;, &#39;K&#39;, hidden=True)
ws.column_dimensions.group(&#39;N&#39;, &#39;O&#39;, hidden=True)

wb.save(f&quot;领料明细汇总表&#123;Get_current_time()&#125;.xlsx&quot;)
</code></pre>
<p>记录：<br><a href="工程部领料明细.xls">工程部领料明细.xls</a><br><a href="生产部领料明细.xls">生产部领料明细.xls</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>xlrd</category>
      </categories>
      <tags>
        <tag>openpyxl</tag>
        <tag>xlrd</tag>
      </tags>
  </entry>
  <entry>
    <title>requests | Python爬取博客的所有文章并存为带目录的word文档</title>
    <url>/2021/10/31/Python%E7%88%AC%E5%8F%96%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E7%AB%A0%E5%B9%B6%E5%AD%98%E4%B8%BA%E5%B8%A6%E7%9B%AE%E5%BD%95%E7%9A%84word%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h1 id="Python爬取博客的所有文章并存为带目录的word文档"><a href="#Python爬取博客的所有文章并存为带目录的word文档" class="headerlink" title="Python爬取博客的所有文章并存为带目录的word文档"></a>Python爬取博客的所有文章并存为带目录的word文档</h1><p>Python爬取博客的所有文章并存为带目录的word文档,结果非常美丽！从此阅读博客文章轻松多了！！！</p>
<span id="more"></span>
<p>实现代码：</p>
<pre><code>import requests
from bs4 import BeautifulSoup

url = f&#39;http://blog.sina.com.cn/s/articlelist_5119330124_0_1.html&#39;
wb_data = requests.get(url)

soup = BeautifulSoup(wb_data.content)

# 获取当页所有文章的标题和链接
# print(soup.select(&#39;.atc_title&#39;))

# 获取当页所有文章的发表时间
# print(soup.select(&#39;.atc_tm&#39;))

# print(soup.select(&#39;.atc_title&#39;)[0].select(&#39;a&#39;))
# [&lt;a href=&quot;http://blog.sina.com.cn/s/blog_13122c74c0102zdsy.html&quot; target=&quot;_blank&quot; title=&quot;&quot;&gt;投资难在慢成毁于速成&lt;/a&gt;]
# print(soup.select(&#39;.atc_title&#39;)[0].select(&#39;a&#39;)[0].get(&quot;href&quot;))
# http://blog.sina.com.cn/s/blog_13122c74c0102zdsy.html
# print(soup.select(&#39;.atc_title&#39;)[0].select(&#39;a&#39;)[0].text)

# print(soup.select(&#39;.atc_tm&#39;)[0].text)

# 获取所有博客文章的链接
import requests
from bs4 import BeautifulSoup

all_links = &#123;&#125;
for i in range(1, 6):
    url = f&#39;http://blog.sina.com.cn/s/articlelist_5119330124_0_&#123;i&#125;.html&#39;
    wb_data = requests.get(url)
    soup = BeautifulSoup(wb_data.content)
    links = soup.select(&#39;.atc_title&#39;)
    times = soup.select(&#39;.atc_tm&#39;)
    for i in range(len(links)):
        http_link = links[i].select(&#39;a&#39;)[0].get(&#39;href&#39;)
        title = links[i].text.strip()
        time = times[i].text
        all_links[title] = [http_link, time]

# print(len(all_links))

# 获取单篇文章中的文字
url = &#39;http://blog.sina.com.cn/s/blog_13122c74c0102zbt3.html&#39;
wb_data = requests.get(url)
soup = BeautifulSoup(wb_data.content)
article = soup.select(&quot;.articalContent.newfont_family&quot;)
# print(article)
# print(article[0].text)
# print(article[0].text.replace(&quot;\xa0&quot;, &quot;&quot;))

# 获取单篇文章中的图片链接
url = &#39;http://blog.sina.com.cn/s/blog_13122c74c0102zbud.html&#39;
wb_data = requests.get(url)
soup = BeautifulSoup(wb_data.content)
img_link = soup.select(&quot;.articalContent.newfont_family&quot;)[0].find_all(&quot;img&quot;)[0].get(&quot;real_src&quot;)


# 图片下载函数
def downloadImg(img_url, file_path):
    req = requests.get(url=img_url)
    with open(file_path, &#39;wb&#39;) as f:
        f.write(req.content)


downloadImg(r&#39;http://s8.sinaimg.cn/middle/005AsbCIzy7vEfdM1M599&#39;,
            r&#39;..\实例67_Python爬取博客的所有文章并存为带目录的word文档\1.jpg&#39;)

# 写入标题，内容到word文件
import docx
from docx.oxml.ns import qn  # 用于应用中文字体


def to_word(all_links):
    header = &#123;
        &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) &quot;
                      &quot;Chrome/49.0.2623.221 Safari/537.36 SE 2.X MetaSr 1.0&quot;&#125;
    doc = docx.Document()  # 新建word文档
    doc.styles[&#39;Normal&#39;].font.name = u&#39;宋体&#39;
    doc.styles[&#39;Normal&#39;]._element.rPr.rFonts.set(qn(&#39;w:eastAsia&#39;), u&#39;宋体&#39;)

    counter = 0  # 计数器，用于记录写入word的文章数
    for title in all_links.keys():
        doc.add_heading(title, 1)
        date = all_links[title][1][:10]  # 只取日期，不要时间
        doc.add_paragraph(date)
        wb_data = requests.get(all_links[title][0], headers=header)
        soup = BeautifulSoup(wb_data.content)
        article = soup.select(&quot;.articalContent.newfont_family&quot;)
        # 有些文章被加密，获取不到内容，此时article为空，所以加个if语句判断
        if article:
            text = article[0].text.replace(&quot;\xa0&quot;, &quot;&quot;)
            doc.add_paragraph(text)
            print(f&quot;写入文章 &#123;title&#125; 。&quot;)
            counter += 1
    print(f&quot;共写入 &#123;counter&#125; 篇文章。&quot;)
    doc.save(&quot;新浪微博文章.docx&quot;)


to_word(all_links)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>requests</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>requests</tag>
        <tag>BeautifulSoup</tag>
      </tags>
  </entry>
  <entry>
    <title>tkinter | Tkinter制作python程序的图形化界面</title>
    <url>/2021/10/30/Tkinter%E5%88%B6%E4%BD%9Cpython%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2/</url>
    <content><![CDATA[<h1 id="Tkinter制作python程序的图形化界面"><a href="#Tkinter制作python程序的图形化界面" class="headerlink" title="Tkinter制作python程序的图形化界面"></a>Tkinter制作python程序的图形化界面</h1><p>代码：</p>
<pre><code>from os import listdir, getcwd
from xlrd import open_workbook, xldate
from datetime import datetime
from time import time, localtime, strftime
from openpyxl import Workbook
from openpyxl.styles import Border, Side, PatternFill, Font, GradientFill, Alignment
from tkinter import Tk, Entry, Button, Listbox, X, Y, END, Scrollbar, RIGHT, BOTTOM, HORIZONTAL
from tkinter.filedialog import askdirectory


class MainGUI():
    def __init__(self):
        myWindow = Tk()
        myWindow.title(&quot;领料记录汇总&quot;)
        # 设置窗口大小
        myWindow.geometry(&#39;590x400&#39;)
        myWindow.iconbitmap(getcwd() + &quot;\\PO.ico&quot;)
        # 增加文本框
        self.input_entry = Entry(myWindow, highlightcolor=&#39;red&#39;, highlightthickness=1)
        self.input_entry.place(x=10, y=10, width=480, height=30)
        self.btn_in = Button(myWindow, text=&#39;输入文件目录&#39;, command=self.select_dir1, width=10, height=1)
        self.btn_in.place(x=500, y=10)

        self.output_entry = Entry(myWindow, highlightcolor=&#39;blue&#39;, highlightthickness=1)
        self.output_entry.place(x=10, y=50, width=480, height=30)
        self.btn_out = Button(myWindow, text=&#39;输出文件目录&#39;, command=self.select_dir2, width=10, height=1)
        self.btn_out.place(x=500, y=50)

        self.btn_run = Button(myWindow, text=&#39;执行汇总&#39;, width=10, height=1, command=self.Summary_data)
        self.btn_run.place(x=500, y=90)
        # 增加列表框
        self.result_show = Listbox(myWindow, bg=&#39;DarkSeaGreen&#39;)  # yscrollcommand = scroll_bar,
        self.result_show.place(x=10, y=130, width=570, height=260)
        self.sbY = Scrollbar(self.result_show, command=self.result_show.yview)  # 在列表框中增加Y轴滚动条
        self.sbY.pack(side=RIGHT, fill=Y)
        self.result_show.config(yscrollcommand=self.sbY.set)
        self.sbX = Scrollbar(self.result_show, command=self.result_show.xview, orient=HORIZONTAL)  # 在列表框中增加X轴滚动条
        self.sbX.pack(side=BOTTOM, fill=X)
        self.result_show.config(xscrollcommand=self.sbX.set)

        myWindow.mainloop()

    def select_dir1(self):
        self.input_entry.delete(0, END)
        self.input_entry.insert(0, askdirectory(initialdir=&quot;D:\\&quot;))

    def select_dir2(self):
        self.output_entry.delete(0, END)
        self.output_entry.insert(0, askdirectory(initialdir=&quot;D:\\&quot;))

    # 读取xls文件中的数据
    def Get_data(self, file):
        wb = open_workbook(file)  # 读取工作簿
        ws = wb.sheets()[0]  # 选第一个工作表
        data = &#123;&#125;
        for row in range(7, ws.nrows - 2):
            dept = ws.cell(2, 16).value  # 部门
            dept_id = ws.cell(3, 16).value  # 部门编号
            dt = ws.cell(row, 0).value  # 时间
            if type(dt) is float:
                date_time = xldate.xldate_as_datetime(dt, 0)
            else:
                date_time = datetime.strptime(dt, &#39;%Y-%m-%d %H:%M:%S&#39;)
            business = ws.cell(row, 2).value  # 业务类型
            model = ws.cell(row, 3).value  # 品种
            qty = ws.cell(row, 4).value  # 数量
            unit_price = ws.cell(row, 6).value  # 单价
            price = ws.cell(row, 8).value  # 总价
            reward = ws.cell(row, 9).value  # 额外值
            discount = ws.cell(row, 11).value  # 调整
            balance = ws.cell(row, 13).value  # 剩余
            location = str(ws.cell(row, 15).value).strip()  # 库位
            operator = ws.cell(row, 17).value  # 操作员
            date = date_time.date()  # 日期
            time = date_time.time()  # 时间
            info_list = [dept, dept_id, date_time, business, model, qty, unit_price, price, reward, discount,
                         balance, location, operator, date, time]
            data.setdefault(date, [])  # 以日期为键
            if info_list[3] != &quot;备注&quot;:  # 不要业务类型为“备注”的数据
                data[date].append(info_list)
        # 增加当日领取次数
        for key in data.keys():
            for i in data[key]:
                i.append(len(data[key]))

        return data

    def Get_file_path(self, path):
        files = []
        for file in listdir(path):
            if file.endswith(&quot;.xls&quot;):  # 排除文件夹内的其它干扰文件
                files.append(path + &quot;\\&quot; + file)
        return files

    def Get_current_time(self):
        time_stamp = time()  # 当前时间的时间戳
        local_time = localtime(time_stamp)  #
        str_time = strftime(&#39;%Y-%m-%d %H.%M.%S&#39;, local_time)
        return str_time

    def Summary_data(self):
        thin = Side(border_style=&quot;thin&quot;, color=&quot;000000&quot;)  # 定义边框粗细及颜色
        title = [&#39;部门&#39;, &#39;部门编号&#39;, &#39;时间&#39;, &#39;业务类型&#39;, &#39;品种&#39;, &#39;数量&#39;, &#39;单价&#39;, &#39;金额&#39;, &#39;额外值&#39;,
                 &#39;调整&#39;, &#39;剩余&#39;, &#39;库位&#39;, &#39;操作员&#39;, &#39;领取日期&#39;, &#39;领取时间&#39;, &#39;领取次数&#39;]

        wb = Workbook()
        ws = wb.active

        ws.merge_cells(&quot;A1:P1&quot;)
        ws.cell(1, 1).value = &quot;领料明细汇总表&quot;
        ws.cell(1, 1).font = Font(name=u&#39;黑体&#39;, bold=True, size=18)
        ws.row_dimensions[1].height = 22.2
        ws.cell(1, 1).alignment = Alignment(horizontal=&quot;center&quot;, vertical=&quot;center&quot;)
        ws.append(title)

        # 插入数据
        files = self.Get_file_path(self.input_entry.get())  # get()获取文本编辑框中的输入文件目录，并获取目录下的xls文件
        for file in files:
            data = self.Get_data(file)
            for key in data.keys():
                for i in data[key]:
                    ws.append(i)
            f = f&quot;&#123;file&#125; 的内容已加入总表.&quot;  # 创建一个显示项
            self.result_show.insert(&quot;end&quot;, f)  # 将结果添加到列表框中

        # 设置字号，对齐，缩小字体填充，加边框
        # Font(bold=True)可加粗字体
        for row_number in range(2, ws.max_row + 1):
            for col_number in range(1, 17):
                c = ws.cell(row=row_number, column=col_number)
                c.font = Font(size=9)
                c.border = Border(top=thin, left=thin, right=thin, bottom=thin)
                c.alignment = Alignment(horizontal=&quot;left&quot;, vertical=&quot;center&quot;)

        col_name = list(&quot;ABCDEFGHIJKLMNOP&quot;)
        col_width = [8, 8, 16, 8, 16, 8, 8, 9.8, 8, 8, 8, 11, 8.3, 9, 8, 8]
        for i in range(len(col_name)):
            ws.column_dimensions[col_name[i]].width = col_width[i]

        ws.column_dimensions.group(&#39;I&#39;, &#39;K&#39;, hidden=True)
        ws.column_dimensions.group(&#39;N&#39;, &#39;O&#39;, hidden=True)

        wb.save(f&quot;&#123;self.output_entry.get()&#125;\\领料明细汇总表&#123;self.Get_current_time()&#125;.xlsx&quot;)
        f = &quot;-&quot; * 100  # 创建分割线
        self.result_show.insert(&quot;end&quot;, f)  # 将分割线添加到列表框
        f = f&quot;领料明细汇总表&#123;self.Get_current_time()&#125;.xlsx 已生成，请去输出文件夹查看.&quot;  # 创建一个显示项
        self.result_show.insert(&quot;end&quot;, f)  # 将结果添加到列表框
        f = &quot; &quot; * 100
        self.result_show.insert(&quot;end&quot;, f)  # 将以上空格添加到列表框


if __name__ == &quot;__main__&quot;:
    MainGUI()
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>tkinter</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>tkinter</tag>
      </tags>
  </entry>
  <entry>
    <title>UML | UML中的事物分类</title>
    <url>/2021/05/23/UML%E4%B8%AD%E7%9A%84%E4%BA%8B%E7%89%A9%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="UML中的事物分类"><a href="#UML中的事物分类" class="headerlink" title="UML中的事物分类"></a>UML中的事物分类</h1><p>1.结构事物<br>模型的<strong>静态部分</strong>，是UML模型中的名词，描述概念或物理元素。<br><strong>包括</strong>：类(class),(接口)interface,协作(collaboration),用例(use case),主动类(active class),构件(component),节点(node)</p>
<p>2.行为事物<br>模型的<strong>动态部分</strong>，描述了跨越时间和空间的行为。<br><strong>包括</strong>：交互(interaction)，状态机(state machine)</p>
<p><strong>交互</strong>：由在特定语境中共同完成一定任务的一组对象之间交换的<strong>消息</strong>组成，描述一个对象群体的行为或单个操作的行为</p>
<p><strong>状态机</strong>：描述了一个对象或一个交互在<strong>生命期内响应事件</strong>所经历的<strong>状态序列</strong></p>
<p>3.分组事物<br>分组事物是一些由<strong>模型分解成的组织部分</strong>，最主要的是<strong>包</strong></p>
<p>4.注释事物<br>用来描述、说明和标注模型的任何元素，主要是<strong>注解</strong></p>
]]></content>
      <categories>
        <category>UML</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>Web服务器</title>
    <url>/2020/11/09/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h1 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h1><p><strong>Web服务器是可以向发出请求的浏览器提供文档的程序。</strong></p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><pre><code># coding:utf-8
import socket
import re

from multiprocessing import Process

# 设置静态文件根目录
HTML_ROOT_DIR = &quot;./html&quot;


def handle_client(client_socket):
    &quot;&quot;&quot;处理客户端请求&quot;&quot;&quot;
    # 获取客户端请求数据
    request_data = client_socket.recv(1024)
    print(&quot;request data:&quot;,request_data)
    request_lines = request_data.splitlines()
    for line in request_lines:
        print(line)

    # 解析请求报文
    # &#39;GET / HTTP/1.1&#39;
    request_start_line = request_lines[0]
    #提取用户请求的文件名
    file_name = re.match(r&quot;\w+ +(/[^ ]*) &quot;,request_start_line.decode(&quot;utf-8&quot;)).group(1)

    if &quot;/&quot; == file_name:
        file_name = &quot;/index.html&quot;
    # 打开文件，读取内容
    try:
        file = open(HTML_ROOT_DIR + file_name,&quot;rb&quot;)
    except IOError:
        response_start_line = &quot;HTTP/1.1 404 Not Found\r\n&quot;
        response_headers = &quot;Server: My server\r\n&quot;
        response_body = &quot;the file is not found&quot;
    else:
        file_data = file.read()
        file.close()

        # 构造响应数据
        response_start_line = &quot;HTTP/1.1 200 OK\r\n&quot;
        response_headers = &quot;Server: My server\r\n&quot;
        response_body = file_data.decode(&quot;utf-8&quot;)

    response = response_start_line + response_headers + &quot;\r\n&quot; + response_body
    print(&quot;response:&quot;,response)

    # 向客户端返回响应数据
    client_socket.send(bytes(response,&quot;utf-8&quot;))

    #关闭客户端链接
    client_socket.close()

def main():
    server_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
    #SOL_SOCKET:设置选项级别为SOCKET
    #SO_REUSEADDR:1
    server_socket.bind((&quot;&quot;,7788))
    server_socket.listen(128)

    while True:
        client_socket,client_address= server_socket.accept()
        print(&quot;[%s,%s]用户连接上了&quot;%(client_address))
        handle_client_process = Process(target=handle_client,args=(client_socket,))
        handle_client_process.start()
        client_socket.close()

if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
<h2 id="访问Web服务器"><a href="#访问Web服务器" class="headerlink" title="访问Web服务器"></a>访问Web服务器</h2><p>在浏览器地址栏输入 127.0.0.1:7788或127.0.0.1:7788/index.html</p>
<h2 id="项目文件结构"><a href="#项目文件结构" class="headerlink" title="项目文件结构"></a>项目文件结构</h2><p><img src="/2020/11/09/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.JPG" alt="文件结构"></p>
]]></content>
      <tags>
        <tag>Web服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础 | 递归与分治</title>
    <url>/2020/10/16/algorithms-2/</url>
    <content><![CDATA[<h1 id="递归与分治策略"><a href="#递归与分治策略" class="headerlink" title="递归与分治策略"></a>递归与分治策略</h1><p><b style="color:red">分治与递归经常同时应用在算法设计中</b></p>
<h2 id="递归（Recursion）"><a href="#递归（Recursion）" class="headerlink" title="递归（Recursion）"></a>递归（Recursion）</h2><p>递归算法—<b>直接或间接地调用自身</b>的较小模式的算法<br>递归函数—用函数自身的较小模式给出其定义的函数</p>
<span id="more"></span>
<h3 id="example1-Fibonacci-Series"><a href="#example1-Fibonacci-Series" class="headerlink" title="example1:Fibonacci Series"></a>example1:Fibonacci Series</h3><p>Code1:</p>
<pre><code>fibonacci(int n)
&#123;
    if(n&lt;=1) return 1;//递归边界
    else return fibonacci(n-1)+fibonacci(n-2);//递归方程
&#125;
</code></pre>
<p>时间复杂度:T(n)=sqrt(2)^n<br>时间复杂度过高的原因：存在很多重复的计算</p>
<p>Code2:</p>
<pre><code>fibonacci(int n)
&#123;
    int f[3]=&#123;1,1&#125;;
    
    for(i=0;i&lt;=n;i++)
    &#123;
        f[2]=f[0]+f[1]; f[0]=f[1]; f[1]=f[2];
    &#125;
    
    return f[2];
&#125;
</code></pre>
<p>时间复杂度：O(n)</p>
<p><b style="color:red">设计更快的算法！！！</b></p>
<h3 id="example2-Hanoi塔"><a href="#example2-Hanoi塔" class="headerlink" title="example2:Hanoi塔"></a>example2:Hanoi塔</h3><p>Code:</p>
<pre><code>hanoi(int n,char a,char b,char c)//T(n)=O(2^n)
&#123;//将塔座a上的盘子移到塔座b上，塔座c为辅助塔座
    if(n&gt;0)
    &#123;
        hanoi(n-1,a,c,b);
        move(a,b);
        hanoi(n-1,c,b,a);
    &#125;
&#125;
</code></pre>
<h3 id="递归小结"><a href="#递归小结" class="headerlink" title="递归小结"></a>递归小结</h3><p>优点：结构清晰、可读性强—&gt;设计算法、调试程序比较方便<br>缺点：程序运行效率低</p>
<h2 id="分治-Divide-and-Conquer"><a href="#分治-Divide-and-Conquer" class="headerlink" title="分治(Divide and Conquer)"></a>分治(Divide and Conquer)</h2><h3 id="适用条件："><a href="#适用条件：" class="headerlink" title="适用条件："></a>适用条件：</h3><ol>
<li>该问题的规模缩小到一定程度就可以容易地解决</li>
<li>该问题<b>可以分解为若干个规模较小的相同问题</b>，即该问题具有最优子结构性质</li>
<li>该问题分解出的子问题的解可以<b>合并</b>为该问题的解</li>
<li>该问题分解出的各个子问题是相互独立的（<b>子问题之间不包含公共的子问题</b>）</li>
</ol>

<h3 id="基本步骤："><a href="#基本步骤：" class="headerlink" title="基本步骤："></a>基本步骤：</h3><pre><code>divide-and-conquer(p)
&#123;
    if(|p|&lt;=n0) naive(p);//解决朴素问题
    divide p into smaller p1,p2...pa//分解问题
    for(i=1;i&lt;=a;i++)
    &#123;
        yi=divide-and-conquer(pi);//递归的解各子问题
    &#125;
    return merge(y1,y2...ya);将子问题的解合并为原问题解
&#125;
</code></pre>
<p><b style="color:yellow">Note:</b><br>在用分治法设计算法时，最好使子问题的规模大致相同(将一个问题分为大小相等的a个子问题的处理方法是行之有效的)。<br>这种做法出自<strong>平衡子问题</strong>的思想</p>
<h3 id="example1-Binary-Search-Algorithm"><a href="#example1-Binary-Search-Algorithm" class="headerlink" title="example1:Binary Search Algorithm"></a>example1:Binary Search Algorithm</h3><p>Code:</p>
<pre><code>binarySearch(int a[],int x)//T(n) = O(logn)
&#123;
    int n = sizeof(a),left = 0,right = n-1;
    
    while (left&lt;=right)
    &#123;
        int middle = (left+right)/2;
        if(x == a[middle]) return middle;
        if(x&gt;a[middle]) left = middle + 1;
        else right = middle-1;
    &#125;
    
    return -1;//x not found
&#125;
</code></pre>
<h3 id="example2-Powering-a-number"><a href="#example2-Powering-a-number" class="headerlink" title="example2:Powering a number"></a>example2:Powering a number</h3><p><b>Problem:</b>Compute a^n,where n is subjected to N.<br><b>Naive algorithm:</b>O(n)<br><b>Divide-and-conquer algorithm:</b><br>Code:</p>
<pre><code>power(int a,int n)//T(n)=O(logn)
&#123;
    if(n==1) return a;
    else if(n%2==0) return power(a,n/2)*power(a,n/2);
    else return power(a,(n-1)/2*power(a,(n-1)/2*a);
&#125;
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
        <category>算法基础</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>cookie | cookie</title>
    <url>/2021/07/29/cookie/</url>
    <content><![CDATA[<p>在基于HTTP的请求当中，客户端发送请求到服务器端，服务器端响应请求返回一些信息（包含cookie）。<br>1.cookie是什么？<br>cookie:存储在浏览器当中的文本信息，存储格式：键值对，一旦你访问某个网站，存储了这个键值对，后面再次请求这个服务器时，cookie会自动加到请求报文的头里面发送到服务器。<br><img src="/2021/07/29/cookie/cookie1.png"><br>2.cookie是怎么来的？<br>我们在服务器端设置（set_cookie()）的，通过response返回到浏览器，浏览器将cookie存储下来<br><strong>注：cookie是区别于域名的，跨域名不能共享cookie信息</strong><br>3.一种常见的场景<br>假设我们在淘宝网站浏览了运动鞋商品，在我们浏览其他网站时会看到与我们之前浏览的运动鞋类似的商品推荐，<br>“cookie是区别于域名的”，这句话似乎错了？？<br>答：此时的现象并不是其他网站读取了淘宝网站的cookie，而是在其他网站内嵌了淘宝网站，即此时的运动鞋商品<br>推荐的信息是从淘宝网站本身读取到的，原理如下图所示：<br><img src="/2021/07/29/cookie/cookie.png"></p>
]]></content>
      <categories>
        <category>cookie</category>
      </categories>
      <tags>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title>Django | django中两种模板目录设置</title>
    <url>/2021/07/30/django%E4%B8%AD%E4%B8%A4%E7%A7%8D%E6%A8%A1%E6%9D%BF%E7%9B%AE%E5%BD%95%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="django中两种模板目录设置"><a href="#django中两种模板目录设置" class="headerlink" title="django中两种模板目录设置"></a>django中两种模板目录设置</h1><p>在进行django项目开发中，我们需要创建一个用于存放模板的文件夹，模板文件夹通常放在以下两个位置之一。<br>第一种的项目目录为蓝色框所框选的目录，第二种的项目目录为红色框所框选的目录。<br><img src="/2021/07/30/django%E4%B8%AD%E4%B8%A4%E7%A7%8D%E6%A8%A1%E6%9D%BF%E7%9B%AE%E5%BD%95%E8%AE%BE%E7%BD%AE/content.png"></p>
<h2 id="位置（1）的优缺点："><a href="#位置（1）的优缺点：" class="headerlink" title="位置（1）的优缺点："></a>位置（1）的优缺点：</h2><p><strong>优点：</strong> 便于移植（首次开发完application应用，可将application应用移植到其他项目）<br><strong>缺点：</strong> 项目下的每个应用都有一个templates文件夹，不便于管理</p>
<h2 id="位置（2）的优缺点："><a href="#位置（2）的优缺点：" class="headerlink" title="位置（2）的优缺点："></a>位置（2）的优缺点：</h2><p><strong>优点：</strong> 便于管理模板文件<br><strong>缺点：</strong> 不方便移植到其他项目中</p>
]]></content>
      <categories>
        <category>python</category>
        <category>框架</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>伪迹移除 | comparison of methods of artifacts removal</title>
    <url>/2021/02/09/comparison-of-methods-of-artifacts-removal/</url>
    <content><![CDATA[<h1 id="Comparison-of-Methods-of-Artifacts-Removal"><a href="#Comparison-of-Methods-of-Artifacts-Removal" class="headerlink" title="Comparison of Methods of Artifacts Removal"></a>Comparison of Methods of Artifacts Removal</h1><div style>
    <h1 style="color: red">Regression Methods</h1>
    <p>
        Regression methods often assume that the scal potential is a <em>linear combination</em> of brain and other potentials(EOG、ECG、EMG).By subtracting propagated EOG/ECG/EMG from EEG recordings,EEG signals can be recovered.
    </p>
    <p>
        Regression can also be done in frequency domain based on the concept that <em>subtraction in the frequency domain is equivalent to filtering in the time domain</em>.By eliminating spectral estimates of EOG/EMG/ECG from EEG recordings,it is possible to recover the non-contaminated EEG.
    </p>
    <p style>
        <b>Disadvantages:</b>
        Both types of regression methods are <em>off-line and rely on EOG/ECG/EMG recordings</em>,which are however,not always available.
    </p>
</div>
<hr>
<span id="more"></span>

<div style>
    <h1 style="color: red">PCA(Principle Component Analysis)</h1>
    <p>
        This method assumes that each <em>EEG channel recording is simultaneously generated by multiple sources</em> across the scalp. By decomposing multiple channel EEG data into principle components using PCA,the artifactual sources can be identified and removed.
    </p>
    <p style>
        <b>Disadvantages:</b>
        PCA methods usually <em>failed to completely separate artifacts</em> from cerebral activities,and the <em>orthogonal assumption</em> fro data components,which is always required while using PCA,is <em>hardly satisfied</em>.
    </p>
</div>
<hr>

<div style>
    <h1 style="color:red">ICA(Independent Component Analysis)</h1>
    <p>
        ICA was originally developed fro blind source separation(<em>BSS</em>)
    </p>
    <p style>
        <b>Disadvantages:</b>
        ICA usually requires a large amount of data and visual inspection to eliminate noisy independent components,making the method <em>time-consuming and not suitable for real-time applications</em>.        
    </p>
</div>
<hr>

<div style>
    <h1 style="color:red">Wavelet Analysis</h1>
    <p>
        It is effective to mesure and manipulate <em>non-stationary signals</em>.In wavelet-based methods,the wavelet thresholding techniques have received significant attention.For this class of methods,wavelet coefficitents at low-frequency sub-bands are corrected by some thresholding functions before signal reconstruction.
    </p>
    <p style>
        <b>Advantages:</b>
        As an online artifact removal method,the most important advantage of using this method for EEG correction is that <em>it does not rely on either the reference signal or visual inspection.
    </em></p>
    <p style>
        <b>Disadvantages:</b>
        It performance is not consistent because the method is sensitive to the selections of wavelet basis and thresholding functions.
    </p>
</div>






]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>伪迹移除</category>
      </categories>
      <tags>
        <tag>ICA</tag>
        <tag>PCA</tag>
        <tag>小波变换</tag>
      </tags>
  </entry>
  <entry>
    <title>Django | django中模板文件中的链接地址怎么写</title>
    <url>/2021/07/28/django%E4%B8%AD%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80%E6%80%8E%E4%B9%88%E5%86%99/</url>
    <content><![CDATA[<h1 id="django中模板文件中的链接地址怎么写"><a href="#django中模板文件中的链接地址怎么写" class="headerlink" title="django中模板文件中的链接地址怎么写?"></a>django中模板文件中的链接地址怎么写?</h1><p>在进行django项目开发中，通常会遇到一个场景：我们在当前页面点击一个链接，跳转到其他的页面，<br>那么在当前页面中的这个标签中的地址我们应该如何去写？</p>
<span id="more"></span>

<p><img src="/2021/07/28/django%E4%B8%AD%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80%E6%80%8E%E4%B9%88%E5%86%99/1.png"><br>假定我们当前处于 <a href="http://www.xxx.com/doc/a.html">www.xxx.com/doc/a.html</a> ,我们需要跳转到 b.html，那么我们可以这样写标签中的url,<br><a href="/b.html">,在这里url中的第一个斜杠代表的是根目录（www.xxx.com），之后浏览器将会把这个url<br>解析为 www.xxx.com/b.html。</a></p>
<p>另一种情况：<br>假设我们将标签中的url写为 <a href="b.html"></a>,浏览器将会把此url地址解析为 <a href="http://www.xxx.com/doc/b.html">www.xxx.com/doc/b.html</a> ,<br>前面没有斜杠即从为当前目录。</p>
]]></content>
      <categories>
        <category>python</category>
        <category>框架</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django | django开发流程</title>
    <url>/2021/04/15/django%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="django开发流程"><a href="#django开发流程" class="headerlink" title="django开发流程"></a>django开发流程</h1><p>1.安装虚拟环境<br>conda create -n python27 python==2.7<br>2..安装django<br>pip install django==1.8.2<br>3.创建项目<br>django-adming startproject project_name<br>4.创建应用<br>python manage.py startapp app_name<br>5.将app应用加入到installed_apps中<br>6.app_name/models.py中定义模型类<br>6.数据库配置(settings.py-DATABASES)<br>7.生成迁移文件<br>python manage.py makemigrations<br>8.执行迁移<br>python manage.py migrate<br>9.开启服务器<br>python manage.py runserver ip:port<br>10.创建管理员用户<br>python manage.py createsuperuser，按提示输入用户名、邮箱、密码<br>11.向admin注册app_name的模型<br>app_name/admin.py<br>admin.site.register(BookInfo)</p>
<p>注：<br>python shell—python manage.py shell</p>
]]></content>
      <categories>
        <category>python</category>
        <category>框架</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django | django自定义错误页面</title>
    <url>/2021/07/28/django%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[<h1 id="django自定义错误页面"><a href="#django自定义错误页面" class="headerlink" title="django自定义错误页面"></a>django自定义错误页面</h1><p>在进行django项目开发时，如果用户请求一个不存在的页面，将会显示以下界面：<br><img src="/2021/07/28/django%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2/1.png"><br>我们可以自定义一个错误页面来展示提示信息。</p>
<p>django版本：1.8.2</p>
<p><strong>步骤：</strong><br>1.修改settings.py</p>
<pre><code>DEBUG = False
ALLOWED_HOSTS = [&#39;*&#39;]
</code></pre>
<p>2.在templates文件夹下创建404.html页面</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
找不到了
&lt;hr/&gt;
&#123;&#123; request_path &#125;&#125;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>3.运行服务器，访问一个不存在的页面，将显示自定义的错误页面<br><img src="/2021/07/28/django%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2/2.png"></p>
]]></content>
      <categories>
        <category>python</category>
        <category>框架</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>脑电基础知识 | five major brain waves</title>
    <url>/2020/12/07/five-major-brain-waves/</url>
    <content><![CDATA[<h1 id="Five-Major-Brain-Waves"><a href="#Five-Major-Brain-Waves" class="headerlink" title="Five Major Brain Waves"></a>Five Major Brain Waves</h1><p>Five major brain waves can be distinguished by their frequency ranges:</p>
<table>
<thead>
<tr>
<th>frequency band</th>
<th>frequency range</th>
</tr>
</thead>
<tbody><tr>
<td>delta</td>
<td>0.5-4Hz</td>
</tr>
<tr>
<td>theta</td>
<td>4-8Hz</td>
</tr>
<tr>
<td>alpha</td>
<td>8-13Hz</td>
</tr>
<tr>
<td>beta</td>
<td>13-30Hz</td>
</tr>
<tr>
<td>gamma</td>
<td>30-50Hz</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>脑电基础知识</category>
      </categories>
      <tags>
        <tag>EEG</tag>
      </tags>
  </entry>
  <entry>
    <title>论文框架与写作技巧 | 论文框架</title>
    <url>/2021/02/10/framework-of-paper/</url>
    <content><![CDATA[<h1 id="Framework-of-Paper"><a href="#Framework-of-Paper" class="headerlink" title="Framework of Paper"></a>Framework of Paper</h1><div id="div1" style>
    <em>How to write a paper?</em><br>
    In fact,we need to write as follows:<br>
    Problem X is important<br>
    Previous works A, B, and C have been done<br>
    A, B, and C have their weakness<br>
    Your work D<br>
    Theoretical analysis<br>
    Experimental comparison against A, B, and C<br>
    Why D is better<br>
    Strength and weakness of D<br>
    Future work on D<br>
    So there is a framework of paper as folllows! 
    <span id="more"></span>
</div>


<div style>
    <h1 style="color: red">Title</h1>
    <h2 style="color: red">Abstract---Summarize your contributions</h2>
    What is the problem<br>
    What is your work<br>  
    Features of your work<br>  
    Advantages of your work<br>  
    Results<br>  
    <h2 style="color: red">Introduction---Background and organization of the paper</h2>
    Problem X is important<br>  
    A, B, and C have been done<br>  
    A, B, and C have their weakness<br>
    Our work D<br>
    Features and advantages of D<br>
    Results<br>
    Organization of the paper<br>
    <h2 style="color: red">Previous work---Why your work,the differences</h2>
    Categorization of previous works<br>
    One or two sentences for a work(Strength,Weakness)<br>
    <h2 style="color: red">Your contribution---Introduce your work</h2>
    Motivation<br>
    Definition,notation<br>
    Algorithm(Pseudocode,Diagram,Explanations)<br>
    <h2 style="color: red">Theoretical analysis---Theoretical support to your work</h2>
    Definition,notation<br>
    Lemma<br>
    Theorem<br>
    Proof<br>
    <h2 style="color: red">Experiments---Experimental to your work</h2>
    Experimental design<br>
    Comparison<br>
    Discussion<br>
    <h2 style="color: red">Discussion---The relationship between your work and some very related works</h2>
    Work A:<br>
    Why it is very related<br>
    Difference to your work<br>
    Work B:<br>
    Why it is very related<br>
    Difference to your work<br>
    <h2 style="color: red">Conclusion---summary and future work</h2>
    Summary<br>
    Future work<br>
    <h2 style="color: red">Acknowledgement</h2>
    <h2 style="color: red">Reference</h2>
    <h2 style="color: red">Appendix</h2>
</div>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>论文框架与写作技巧</category>
      </categories>
      <tags>
        <tag>论文</tag>
        <tag>论文框架</tag>
      </tags>
  </entry>
  <entry>
    <title>python | getattr()函数</title>
    <url>/2021/05/20/getattr-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="python-getattr-函数"><a href="#python-getattr-函数" class="headerlink" title="python getattr()函数"></a>python getattr()函数</h1><p>描述：getattr()函数用于返回一个对象属性值</p>
<p>参数：<br>object – 对象<br>name – 对象属性(字符串)<br>default – 默认返回值(如果不提供该参数，在没有对应属性时，将触发AttributeError)</p>
<p>实例：<br>class A(object):<br>    bar = 1</p>
<p>a = A()<br>print(getattr(a, ‘bar’))  # 获取属性bar值 result:1<br>print(getattr(a, ‘bar2’))  # 属性bar2不存在，触发异常<br>print(getattr(a, ‘bar2’, 3)  # result:3</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo | hexo博客上传PDF、PPT、EXCEL等资源</title>
    <url>/2021/10/18/hexo%E5%8D%9A%E5%AE%A2%E4%B8%8A%E4%BC%A0PdfPptExcel%E7%AD%89%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<h1 id="hexo博客上传PDF、PPT、EXCEL等资源"><a href="#hexo博客上传PDF、PPT、EXCEL等资源" class="headerlink" title="hexo博客上传PDF、PPT、EXCEL等资源"></a>hexo博客上传PDF、PPT、EXCEL等资源</h1><p><a href="https://benpaodewoniu.github.io/2020/04/28/hexo27/">hexo博客上传PDF、PPT、EXCEL等资源</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo | hexo博客换电脑了怎么办</title>
    <url>/2021/08/30/hexo%E5%8D%9A%E5%AE%A2%E6%8D%A2%E7%94%B5%E8%84%91%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E/</url>
    <content><![CDATA[<h1 id="hexo博客换电脑了怎么办"><a href="#hexo博客换电脑了怎么办" class="headerlink" title="hexo博客换电脑了怎么办"></a>hexo博客换电脑了怎么办</h1><p>我们搭建的hexo博客在更换电脑之后，如果重新搭建博客比较费时费力，可以按照以下资料快速在新的电脑上使用hexo博客发布内容。</p>
<p><a href="https://www.cnblogs.com/study-everyday/p/8902136.html">参考资料1</a><br><a href="https://www.cnblogs.com/study-everyday/p/8902136.html">参考资料2</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>os | os.listdir()和os.walk()</title>
    <url>/2021/10/29/listdir%E5%92%8Cwalk/</url>
    <content><![CDATA[<h1 id="os-listdir-和os-walk"><a href="#os-listdir-和os-walk" class="headerlink" title="os.listdir()和os.walk()"></a>os.listdir()和os.walk()</h1><p><a href="https://www.jianshu.com/p/5c3b45d672d5">os.listdir()和os.walk()</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>内置模块</category>
        <category>os</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>matplotlib | 绘制双柱状图</title>
    <url>/2021/10/24/matplotlib%E7%BB%98%E5%88%B6%E5%8F%8C%E6%9F%B1%E7%8A%B6%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="使用matplotlib绘制双柱状图"><a href="#使用matplotlib绘制双柱状图" class="headerlink" title="使用matplotlib绘制双柱状图"></a>使用matplotlib绘制双柱状图</h1><p>实现代码：</p>
<pre><code>import matplotlib.pyplot as plt


# 定义函数来显示柱状上的数值
def autolabel(rects):
    for rect in rects:
        height = rect.get_height()
        plt.text(rect.get_x() + rect.get_width() / 2. - 0.2, 1.03 * height, &#39;%s&#39; % float(height))


if __name__ == &#39;__main__&#39;:
    l1 = [75, 57, 59, 60, 60]
    l2 = [68.39, 58, 54, 58, 55]

    # l1 = [68.50, 53.13, 53.04, 52.64, 56.32]
    # l2 = [66.31, 53.57, 50.54, 55.54, 47.72]
    name = [&#39;CNN-LSTM&#39;, &#39;CNN3Conv&#39;, &#39;CNN5Conv&#39;, &#39;LeNet&#39;, &#39;EEGNet&#39;]
    total_width, n = 0.8, 2
    width = total_width / n
    x = [0, 1, 2, 3, 4]
    plt.rc(&#39;font&#39;, family=&#39;SimHei&#39;, size=12)  # 设置中文显示，否则出现乱码！
    a = plt.bar(x, l1, width=width, label=&#39;Valence&#39;, fc=&#39;y&#39;)
    for i in range(len(x)):
        x[i] = x[i] + width
    b = plt.bar(x, l2, width=width, label=&#39;Arousal&#39;, tick_label=name, fc=&#39;r&#39;)
    autolabel(a)
    autolabel(b)
    plt.xlabel(&#39;Models&#39;)
    plt.ylabel(&#39;Accuracy&#39;)
    plt.title(&#39;Valence Accuracy and Arousal Accuracy&#39;)
    plt.legend()
    plt.show()
    plt.savefig(&#39;accuracy.png&#39;)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>matplotlib</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>matplotlib</tag>
        <tag>双柱状图</tag>
      </tags>
  </entry>
  <entry>
    <title>pandas | pandas提取指定数据并保存在原Excel工作簿中</title>
    <url>/2021/10/29/pandas%E6%8F%90%E5%8F%96%E6%8C%87%E5%AE%9A%E6%95%B0%E6%8D%AE%E5%B9%B6%E4%BF%9D%E5%AD%98%E5%9C%A8%E5%8E%9FExcel%E5%B7%A5%E4%BD%9C%E7%B0%BF%E4%B8%AD/</url>
    <content><![CDATA[<h1 id="pandas提取指定数据并保存在原Excel工作簿中"><a href="#pandas提取指定数据并保存在原Excel工作簿中" class="headerlink" title="pandas提取指定数据并保存在原Excel工作簿中"></a>pandas提取指定数据并保存在原Excel工作簿中</h1><p>实现代码：</p>
<pre><code>import pandas as pd

df = pd.read_excel(&quot;物料表.xlsx&quot;, header=2)
# print(df)

df500 = df[df[&quot;数量&quot;] &gt; 500]
# print(df500)

with pd.ExcelWriter(&#39;物料表.xlsx&#39;, mode=&#39;a&#39;, engine=&#39;openpyxl&#39;,
                    datetime_format=&#39;YYYY-MM-DD&#39;) as writer:
    df500.to_excel(writer, sheet_name=&#39;数量大于500&#39;, index=False)

from openpyxl import load_workbook
from openpyxl.styles import Border, Side, PatternFill, Font, GradientFill, Alignment

thin = Side(border_style=&quot;thin&quot;, color=&quot;000000&quot;)  # 定义边框粗细及颜色

wb = load_workbook(&quot;物料表.xlsx&quot;)
ws = wb[&quot;数量大于500&quot;]

# 调整列宽
ws.column_dimensions[&#39;A&#39;].width = 12
ws.column_dimensions[&#39;C&#39;].width = 15.5
ws.column_dimensions[&#39;G&#39;].width = 10

# 设置字号，对齐，缩小字体填充，加边框
for row_number in range(2, ws.max_row + 1):
    for col_number in range(1, ws.max_column + 1):
        c = ws.cell(row=row_number, column=col_number)
        c.font = Font(size=10)
        c.border = Border(top=thin, left=thin, right=thin, bottom=thin)
        c.alignment = Alignment(horizontal=&quot;left&quot;, vertical=&quot;center&quot;)
wb.save(&quot;物料表.xlsx&quot;)
</code></pre>
<p><a href="物料表.xlsx">物料表.xlsx</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>pandas</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>openpyxl</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>python | pip安装出现Cannot fetch index base URL http://pypi.python.org/simple/解决方法</title>
    <url>/2021/01/28/pip%E5%AE%89%E8%A3%85%E5%87%BA%E7%8E%B0Cannot-fetch-index-base-URL-http-pypi-python-org-simple-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="pip安装出现Cannot-fetch-index-base-URL-http-pypi-python-org-simple-解决方法"><a href="#pip安装出现Cannot-fetch-index-base-URL-http-pypi-python-org-simple-解决方法" class="headerlink" title="pip安装出现Cannot fetch index base URL http://pypi.python.org/simple/解决方法"></a>pip安装出现Cannot fetch index base URL <a href="http://pypi.python.org/simple/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95">http://pypi.python.org/simple/解决方法</a></h1><p>1.sudo vi .pip/pip.conf<br>2.添加以下内容<br>[global]<br>index-url=<a href="http://pypi.doubanio.com/simple/">http://pypi.doubanio.com/simple/</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>itertools | product</title>
    <url>/2021/09/04/product/</url>
    <content><![CDATA[<h1 id="itertools-product"><a href="#itertools-product" class="headerlink" title="itertools.product()"></a>itertools.product()</h1><p>使用product()前需要导入itertools库<br><strong>用法1：</strong></p>
<pre><code>print(list(itertools.product(‘a&#39;, repeat=4)))   # 等价于 print(list(itertools.product(&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;)))

a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
print(list(itertools.product(a, repeat=2)))  # s等价于 print(list(itertools.product(a, a)))
</code></pre>
<p><strong>用法2：</strong></p>
<pre><code>print(list(itertools.product(a, b)))  # 等价于 print(list((x, y) for x in a for y in b))
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>内置模块</category>
        <category>itertools</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>itertools</tag>
      </tags>
  </entry>
  <entry>
    <title>pycharm同步代码到远程服务器</title>
    <url>/2021/04/18/pycharm%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%88%B0%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h1 id="pycharm同步代码到远程服务器"><a href="#pycharm同步代码到远程服务器" class="headerlink" title="pycharm同步代码到远程服务器"></a>pycharm同步代码到远程服务器</h1><p>1.在pycharm菜单栏点Tools–&gt;Deployment–&gt;Configuration<br>如果显示Please add a web server to configure,点+增加一个要配置的web服务器，传输协议选择SFTP，并输入新服务器的名称。<br>2.在connection选项中选择或输入对应信息<br>Type:SFTP<br>Host:服务器ip地址 Port:22(默认为22)<br>Username:<br>Authentication:Password<br>Password:<br>3.点Test Connection测试是否成功连接服务器<br>4.在Mappings选项中选择 Deployment path(将项目/文件部署到服务器的哪个路径下)<br>5.Tools–&gt;start SSH session<br>6.Tools–&gt;Deployment–&gt;upload to 刚刚输入的新服务器名称</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>pygame最小开发框架</title>
    <url>/2021/05/21/pygame%E6%9C%80%E5%B0%8F%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="pygame最小开发框架"><a href="#pygame最小开发框架" class="headerlink" title="pygame最小开发框架"></a>pygame最小开发框架</h1><pre><code>import pygame, sys

pygame.init()
screen = pygame.display.set_mode((1206, 780))
pygame.display.set_caption(&quot;Pygame&quot;)

while True:
        for event in pygame.event.get():
                if event.type == pygame.QUIT:
                        sys.exit()

        pygame.display.update()
</code></pre>
<p><img src="/2021/05/21/pygame%E6%9C%80%E5%B0%8F%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/pygame.jpg" alt="pygame最小开发框架"></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>pygame</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pygame</tag>
      </tags>
  </entry>
  <entry>
    <title>python | python @property</title>
    <url>/2021/05/20/python-property/</url>
    <content><![CDATA[<h1 id="python-property"><a href="#python-property" class="headerlink" title="python property"></a>python property</h1><pre><code>class Test(object):
        def __init__(self):
            self.__num = 100

           # def getNum(self):
           #     return self.__num
            #
        # def setNum(self,newNum):
            #     self.__num = newNum

        @property
        def num(self):
                return self.__num

        @num.setter
        def num(self,newNum):
                self.__num = newNum


t = Test()
t.num = 50
print(t.num)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python | python str 对象</title>
    <url>/2021/05/15/python-str-%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="python中的str对象"><a href="#python中的str对象" class="headerlink" title="python中的str对象"></a>python中的str对象</h1><p>python中的str对象是不可变对象，因此不存在修改字符串这一说法。<br>即：在s = ‘test’后写 s = ‘test1’</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python | python zip()函数</title>
    <url>/2021/05/20/python-zip-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="python-zip-函数"><a href="#python-zip-函数" class="headerlink" title="python zip()函数"></a>python zip()函数</h1><p>example:<br>1.zip() 压缩(zip)<br>case 1:<br>list1 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]<br>print([row for row in zip(list1)]) # ([1, 2, 3],), ([4, 5, 6],), ([7, 8, 9],)</p>
<p>case 2:<br>list1 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]<br>list2 = [[7, 8, 9], [4, 5, 6], [1, 2, 3]]<br>print([row for row in zip(list1, list2)])  # [([1, 2, 3], [7, 8, 9]), ([4, 5, 6], [4, 5, 6]), ([7, 8, 9], [1, 2, 3])]</p>
<p>2.zip(*) 解压(unzip)<br>list1 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]<br>print([row for row in zip(*list1)])  # [(1, 4, 7), (2, 5, 8), (3, 6, 9)]</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python | python 广播</title>
    <url>/2021/06/21/python-%E5%B9%BF%E6%92%AD/</url>
    <content><![CDATA[<h1 id="python-广播"><a href="#python-广播" class="headerlink" title="python 广播"></a>python 广播</h1><pre><code>&quot;&quot;&quot;
Calories from Carbs,Proteins,Fats in 100g of different foods:

           Apples        Beef        Eggs        Potatoes
   
Carb    [94.91525424  0.          2.83140283 88.42652796]
Protein [ 2.03389831 43.51464435 33.46203346 10.40312094]
Fat     [ 3.05084746 56.48535565 63.70656371  1.17035111]
 
Q:Calculate % of calories from Carbs,Proteins,Fats.Can you do this without
explicit for-loop?
&quot;&quot;&quot;

import numpy as np

A = np.array([[56.0,0.0,4.4,68.0],
             [1.2,104.0,52.0,8.0],
             [1.8,135.0,99.0,0.9]])
print(A)
cal = A.sum(axis=0)
print(cal)
percentage = 100*A/cal.reshape(1,4)
print(percentage)
</code></pre>
<p><a href="https://www.bilibili.com/video/BV1FT4y1E74V?p=21">参考吴恩达深度学习视频</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python | python 翻转列表</title>
    <url>/2021/05/20/python-%E7%BF%BB%E8%BD%AC%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="python-翻转列表"><a href="#python-翻转列表" class="headerlink" title="python 翻转列表"></a>python 翻转列表</h1><p>list1 = [1, 2, 3]<br>print(list1[::-1])  # [3, 2, 1]</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python | python中如何实现函数重载的效果</title>
    <url>/2021/08/02/python%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%9A%84%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<h1 id="python中如何实现函数重载的效果"><a href="#python中如何实现函数重载的效果" class="headerlink" title="python中如何实现函数重载的效果"></a>python中如何实现函数重载的效果</h1><h2 id="什么是函数重载？"><a href="#什么是函数重载？" class="headerlink" title="什么是函数重载？"></a>什么是函数重载？</h2><p>函数重载，即可以定义多个同名函数，但是参数列表不同，这样在调用时可以传递不同的实参。</p>
<h2 id="python中没有函数重载的概念"><a href="#python中没有函数重载的概念" class="headerlink" title="python中没有函数重载的概念"></a>python中没有函数重载的概念</h2><p>函数重载会增加代码量，所以在python中没有函数重载的概念，而是<strong>为函数的参数提供默认值</strong>实现的。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><pre><code># coding=utf-8

def make_coffee(name=&#39;卡布奇诺&#39;)：
    return &quot;制作一杯&#123;&#125;&quot;.format(name)
    
coffee1 = make_coffee(&#39;拿铁&#39;)  # 提供参数
coffee2 = make_coffee()  # 没有提供参数，使用默认值
print(coffee1)
print(coffee2)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python | python中的filter函数和map函数</title>
    <url>/2021/08/02/python%E4%B8%AD%E7%9A%84filter%E5%87%BD%E6%95%B0%E5%92%8Cmap%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="python中的filter函数和map函数"><a href="#python中的filter函数和map函数" class="headerlink" title="python中的filter函数和map函数"></a>python中的filter函数和map函数</h1><h2 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h2><p>filter()用于对容器中的元素进行过滤处理</p>
<pre><code># coding=utf-8
# 提供过滤条件函数
def f1(x):
    return x &gt; 50
    
data1 = [66, 15, 91, 28, 98, 50, 7, 90, 99]
filtered = filter(f1, data1)
data2 = list(filtered)
print(data2)


# lambda实现
data1 = [66, 15, 91, 28, 98, 50, 7, 90, 99]
filtered = filter(lambda x : (x &gt; 50), data1)
data2 = list(filtered)
print(data2)
</code></pre>
<h2 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h2><p>map()用于对容器中的元素进行映射或变换</p>
<pre><code># coding=utf-8
# 提供变换规则的函数
def f1(x):
    return x * 2

data1 = [66, 15, 91, 28, 98, 50, 7, 90, 99]
mapped = map(f1, data1)
data2 = list(mapped)
print(data2)


# lambda实现
data1 = [66, 15, 91, 28, 98, 50, 7, 90, 99]
mapped = map(lambda x : (x * 2), data1)
data2 = list(mapped)
print(data2)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python | python中的iter()与next()</title>
    <url>/2021/02/26/python%E4%B8%AD%E7%9A%84iter-%E4%B8%8Enext/</url>
    <content><![CDATA[<h1 id="python中的iter-与next"><a href="#python中的iter-与next" class="headerlink" title="python中的iter()与next()"></a>python中的iter()与next()</h1><p>可迭代对象(Iterable)：可以直接作用于for循环的对象</p>
<p>分类：<br>1.集合数据类型 list、tuple、dict、set、str<br>2.generator(包括生成器和带yield的generator function)<br>Note:生成器不但可以作用于 for 循环，还可以被 next() 函数不断调用并返回下一个值</p>
<p>生成器都是Iterator,但list、tuple、dict、str、set虽然是Iterable,却不是Iterator，可以使用iter()函数把list…Iterable编程Iterator</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>random | python为每个学生出不一样的题</title>
    <url>/2021/10/29/python%E4%B8%BA%E6%AF%8F%E4%B8%AA%E5%AD%A6%E7%94%9F%E5%87%BA%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E9%A2%98/</url>
    <content><![CDATA[<h1 id="python为每个学生出不一样的题"><a href="#python为每个学生出不一样的题" class="headerlink" title="python为每个学生出不一样的题"></a>python为每个学生出不一样的题</h1><p>实现代码：</p>
<pre><code>import random


# 不重复随机整数生成函数
def Random_num(num_max, num_qty):
    &#39;&#39;&#39;
    num_max:最大数
    num_qty:生成随机数的个数
    &#39;&#39;&#39;
    num_list = []  # 储存生成的随机数
    while len(num_list) &lt; num_qty:  # 控制随机数的个数
        num = random.randint(2, num_max)  # 设定在此范围内取数
        if num in num_list:  # 判断随机数是否重复
            continue  # 若重复，则重新生成
        else:
            num_list.append(num)  # 将不重复的随机数放入列表
    return num_list  # 生成完成后返回随机数列表


# 定义函数，按随机数在题库中抽取对应编号的题目
from openpyxl import load_workbook


def Question(que_type, numbers):
    &#39;&#39;&#39;
    que_type:试题类型（&quot;单选题&quot;,&quot;多选题&quot;,&quot;判断题&quot;,&quot;填空题&quot;）
    numbers:需要抽取的试题编号
    &#39;&#39;&#39;
    questions = []  # 储存抽取的题目
    wb = load_workbook(&quot;题库.xlsx&quot;)  # 载入题库
    if que_type == &quot;单选题&quot;:
        ws = wb[que_type]
        for i in numbers:  # 按随机生成的编号抽题
            question = ws[&quot;B&quot; + str(i)].value  # 问题在B列
            answerA = &quot;A：\t&quot; + str(ws[&quot;C&quot; + str(i)].value)  # 选项A在C列，&quot;\t&quot;相当于按一下tab键，在字符间产生间隔
            answerB = &quot;B：\t&quot; + str(ws[&quot;D&quot; + str(i)].value)  # 选项B在D列
            answerC = &quot;C：\t&quot; + str(ws[&quot;E&quot; + str(i)].value)  # 选项C在E列
            answerD = &quot;D：\t&quot; + str(ws[&quot;F&quot; + str(i)].value)  # 选项D在F列
            right_answer = ws[&quot;G&quot; + str(i)].value  # 正确答案在G列
            single_question = [question, answerA, answerB, answerC, answerD, right_answer]  # 每行的数据存入列表
            questions.append(single_question)  # 每个题目的数据存入总列表
    elif que_type == &quot;多选题&quot;:
        ws = wb[que_type]
        for i in numbers:
            question = ws[&quot;B&quot; + str(i)].value
            answerA = &quot;A：\t&quot; + str(ws[&quot;C&quot; + str(i)].value)
            answerB = &quot;B：\t&quot; + str(ws[&quot;D&quot; + str(i)].value)
            answerC = &quot;C：\t&quot; + str(ws[&quot;E&quot; + str(i)].value)
            answerD = &quot;D：\t&quot; + str(ws[&quot;F&quot; + str(i)].value)
            right_answer = ws[&quot;H&quot; + str(i)].value
            single_question = [question, answerA, answerB, answerC, answerD, right_answer]
            if ws[&quot;G&quot; + str(i)].value:  # 有些题有E选项，有些没有，因此需要判断一下是否有E选项
                answerE = &quot;E：\t&quot; + str(ws[&quot;G&quot; + str(i)].value)
                single_question.insert(-1, answerE)  # 将E选项插入到答案前面，保持答案是最后一个元素
            questions.append(single_question)
    else:  # 判断题和填空题，内容只取题干和答案
        ws = wb[que_type]
        for i in numbers:
            question = ws[&quot;B&quot; + str(i)].value
            right_answer = ws[&quot;C&quot; + str(i)].value
            single_question = [question, right_answer]
            questions.append(single_question)

    return questions


# 写入考试题到word文件
from docx import Document
from docx.shared import Pt  # 用于设定字体大小（磅值）
from docx.oxml.ns import qn  # 用于应用中文字体


def To_word(number, questions_data):
    doc = Document(&quot;试题-模板.docx&quot;)

    # 写入单选题
    title1 = &quot;一、单项选择题（共40题，每题1分）&quot;
    p = doc.add_paragraph()  # 插入段落
    r = p.add_run(title1)  # 插入文字块
    r.bold = True  # 字体加粗
    r.font.size = Pt(12)  # 字号设为12磅
    for index, i in enumerate(questions_data[&quot;单选题&quot;], start=1):  # 给题目从1开始编号
        doc.add_paragraph(f&quot;&#123;index&#125;. &#123;i[0]&#125;&quot;)  # 题干部分在单独一段
        doc.add_paragraph(f&quot;\t&#123;i[1]&#125;\t\t&#123;i[2]&#125;&quot;)  # 选项A和选项B在同一段落
        doc.add_paragraph(f&quot;\t&#123;i[3]&#125;\t\t&#123;i[4]&#125;&quot;)  # 选项C和选项D在同一段落

    # 写入多选题
    title2 = &quot;二、多项选择题（共20题，每题2分）&quot;
    p = doc.add_paragraph()
    r = p.add_run(title2)
    r.bold = True
    r.font.size = Pt(12)
    for index, i in enumerate(questions_data[&quot;多选题&quot;], start=1):
        doc.add_paragraph(f&quot;&#123;index&#125;. &#123;i[0]&#125;&quot;)
        doc.add_paragraph(f&quot;\t&#123;i[1]&#125;\t\t&#123;i[2]&#125;&quot;)
        doc.add_paragraph(f&quot;\t&#123;i[3]&#125;\t\t&#123;i[4]&#125;&quot;)
        if len(i) == 7:  # 判断是否有E选项，若有，则新建一段落写入
            doc.add_paragraph(f&quot;\t&#123;i[5]&#125;&quot;)

    # 写入判断题
    title3 = &quot;三、判断题（共10题，每题1分）&quot;
    p = doc.add_paragraph()
    r = p.add_run(title3)
    r.bold = True
    r.font.size = Pt(12)
    for index, i in enumerate(questions_data[&quot;判断题&quot;], start=1):
        doc.add_paragraph(f&quot;\t&#123;index&#125;. &#123;i[0]&#125;&quot;)

    # 写入填空题
    title4 = &quot;四、填空题（共10题，每题1分）&quot;
    p = doc.add_paragraph()
    r = p.add_run(title4)
    r.bold = True
    r.font.size = Pt(12)
    for index, i in enumerate(questions_data[&quot;填空题&quot;], start=1):
        doc.add_paragraph(f&quot;\t&#123;index&#125;. &#123;i[0]&#125;&quot;)

    doc.save(f&quot;试卷及答案\\考试题&#123;number&#125;.docx&quot;)


# 写入答案
from docx import Document
from docx.shared import Pt  # 用于设定字体大小（磅值）
from docx.oxml.ns import qn  # 用于应用中文字体


def Answer(number, questions_data):
    doc = Document()
    # 全局字体设为“宋体”
    doc.styles[&#39;Normal&#39;].font.name = u&#39;宋体&#39;
    doc.styles[&#39;Normal&#39;]._element.rPr.rFonts.set(qn(&#39;w:eastAsia&#39;), u&#39;宋体&#39;)

    title = &quot;计算机系2020第二学期期末考试题(答案)&quot;
    p = doc.add_paragraph()
    r = p.add_run(title)
    r.bold = True
    r.font.size = Pt(20)
    # 写入单选题答案
    title1 = &quot;一、单项选择题答案（共40题，每题1分）&quot;
    p = doc.add_paragraph()
    r = p.add_run(title1)
    r.bold = True
    r.font.size = Pt(12)

    p = doc.add_paragraph()
    for index, i in enumerate(questions_data[&quot;单选题&quot;], start=1):
        p.add_run(f&quot;&#123;index&#125;. &#123;i[-1]&#125;\t&quot;)
        if index % 10 == 0:  # 每段只显示10个答案
            p = doc.add_paragraph()  # 满10个，则新建段落

    # 写入多选题答案
    title2 = &quot;二、多项选择题答案（共20题，每题2分）&quot;
    p = doc.add_paragraph()
    r = p.add_run(title2)
    r.bold = True
    r.font.size = Pt(12)
    p = doc.add_paragraph()
    for index, i in enumerate(questions_data[&quot;多选题&quot;], start=1):
        p.add_run(f&quot;&#123;index&#125;. &#123;i[-1]&#125;\t&quot;)
        if index % 3 == 0:
            p = doc.add_paragraph()

            # 写入判断题答案
    title3 = &quot;三、判断题答案（共10题，每题1分）&quot;
    p = doc.add_paragraph()
    r = p.add_run(title3)
    r.bold = True
    r.font.size = Pt(12)
    p = doc.add_paragraph()
    for index, i in enumerate(questions_data[&quot;判断题&quot;], start=1):
        p.add_run(f&quot;&#123;index&#125;. &#123;i[-1]&#125;\t&quot;)
        if index % 5 == 0:  # 每段只显示5个答案
            p = doc.add_paragraph()  # 满5个，则新建段落

    # 写入填空题
    title4 = &quot;四、填空题答案（共10题，每题1分）&quot;
    p = doc.add_paragraph()
    r = p.add_run(title4)
    r.bold = True
    r.font.size = Pt(12)
    p = doc.add_paragraph()
    for index, i in enumerate(questions_data[&quot;填空题&quot;], start=1):
        p.add_run(f&quot;&#123;index&#125;. &#123;i[-1]&#125;\t\t&quot;)
        if index % 2 == 0:  # 每段只显示2个答案
            p = doc.add_paragraph()  # 满2个，则新建段落

    doc.save(f&quot;试卷及答案\\考试题&#123;number&#125;答案.docx&quot;)


# 主函数
for number in range(1, 21):  # 不同的试卷数量，此处为20套
    # 生成随机题目编号
    num_single_choice = Random_num(566, 40)
    num_mult_choice = Random_num(196, 20)
    num_judgment = Random_num(418, 10)
    num_completion = Random_num(190, 10)
    # 将生成的编号存入字典`question_num`
    question_num = &#123;&quot;单选题号&quot;: num_single_choice,
                    &quot;多选题号&quot;: num_mult_choice,
                    &quot;判断题号&quot;: num_judgment,
                    &quot;填空题号&quot;: num_completion
                    &#125;
    # 根据随机生成的题目编号去题库选题，并存入`questions_data`
    questions_data = &#123;
        &quot;单选题&quot;: Question(&quot;单选题&quot;, question_num[&quot;单选题号&quot;]),
        &quot;多选题&quot;: Question(&quot;多选题&quot;, question_num[&quot;多选题号&quot;]),
        &quot;判断题&quot;: Question(&quot;判断题&quot;, question_num[&quot;判断题号&quot;]),
        &quot;填空题&quot;: Question(&quot;填空题&quot;, question_num[&quot;填空题号&quot;])
    &#125;
    # 将试题写入word文档，并保存
    To_word(number, questions_data)
    # 将试题答案写入word文档，并保存
    Answer(number, questions_data)
    print(f&quot;试卷&#123;number&#125;及答案完成！&quot;)
</code></pre>
<p><a href="试题-模板.docx">试题-模板.docx</a><br><a href="题库.xlsx">题库.xlsx</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>内置模块</category>
        <category>random</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python-docx</tag>
        <tag>openpyxl</tag>
        <tag>random</tag>
      </tags>
  </entry>
  <entry>
    <title>random | python出数学练习题</title>
    <url>/2021/10/29/python%E5%87%BA%E6%95%B0%E5%AD%A6%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<h1 id="python出数学练习题"><a href="#python出数学练习题" class="headerlink" title="python出数学练习题"></a>python出数学练习题</h1><p>实现代码：</p>
<pre><code># import random
#
# for i in range(5):
#     num1 = random.randint(1, 9)
#     num2 = random.randint(1, 9)
#     print(f&quot;&#123;num1&#125; + &#123;num2&#125; = &quot;)


# 加法、乘法题
import random
data = []  # 储存题目的列表
group = []  # 中转列表
while len(data) &lt; 20:  # 题目个数，20行x4列共80个题，刚好放入word文档中的1页
    num1 = random.randint(0, 9)  # 随机整数1，从0-9中选取
    num2 = random.randint(0, 9)  # 随机整数2，从0-9中选取
    group.append(f&quot;&#123;num1&#125; + &#123;num2&#125; = &quot;)  # 数据放入中转列表
    if len(group) == 4:  # 按四道题分一组
        data.append(group)  # 数据放入总列表
        group = []  # 清空中转列表
print(data)

# # 减法题
# import random
#
# data = []
# group = []
# while len(data) &lt; 20:
#     num1 = random.randint(1, 9)
#     num2 = random.randint(1, 9)
#     if num1 &gt; num2:
#         group.append(f&quot;&#123;num1&#125; - &#123;num2&#125; = &quot;)
#         if len(group) == 4:
#             data.append(group)
#             group = []
#
# # print(data)

# # 除法题
# import random
#
# data = []  # 储存题目的列表
# group = []  # 中转列表
# while len(data) &lt; 20:
#     num1 = random.randint(1, 19)
#     num2 = random.randint(1, 19)
#     if num1 &gt;= num2 and num1 % num2 == 0:
#         group.append(f&quot;&#123;num1&#125; ÷ &#123;num2&#125; = &quot;)  # 数据放入中转列表
#         if len(group) == 4:  # 按四道题分一组
#             data.append(group)  # 数据放入总列表
#             group = []  # 清空中转列表
#
# print(data)

# 输出到word文件
def To_word(data, file_name):
    &quot;&quot;&quot;
    data:需要传入的列表
    file_name:word文件的文件名
    &quot;&quot;&quot;
    from docx import Document
    from docx.shared import Pt  # 用于设定字体大小（磅值）

    doc = Document()
    for i in data:
        # print(i)
        row = &quot;\t\t&quot;.join(i)
        # print(row)
        doc.add_paragraph(row)
    # 设置字号
    for para in doc.paragraphs:
        for run in para.runs:
            run.font.size = Pt(16)  # 文字大小磅值
    doc.save(f&quot;&#123;file_name&#125;.docx&quot;)

To_word(data, &quot;加法题&quot;)
# To_word(data, &quot;减法题&quot;)
# To_word(data, &quot;乘法题&quot;)
# To_word(data, &quot;除法题&quot;)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>内置模块</category>
        <category>random</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python-docx</tag>
        <tag>random</tag>
      </tags>
  </entry>
  <entry>
    <title>python | 分块拆分txt文件中的数据</title>
    <url>/2021/10/30/python%E5%88%86%E5%9D%97%E6%8B%86%E5%88%86txt%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="分块拆分txt文件中的数据"><a href="#分块拆分txt文件中的数据" class="headerlink" title="分块拆分txt文件中的数据"></a>分块拆分txt文件中的数据</h1><p>代码：</p>
<pre><code># -*- coding:utf-8 -*-
# 读取txt文件中的数据
file = open(&quot;数据.txt&quot;)
lines = file.readlines()
# print(lines[:5])

data = &#123;&#125;  # 储存分割的数据
line_list = []  # 中转列表
last_id = &quot;start&quot;  # 数据分块标识
for line in lines:
    row_data = line.split(&quot; &quot;)  # 将一行数据按空格分隔
    ID = row_data[0]  # 获得ID
    if last_id == &quot;start&quot;:  # 用于处理数据第一行
        line_list.append(line)  # 将第一行数据放入中转列表
    else:  # 不是第一行数据，则按如下执行
        if ID != last_id:  # 如果出现新的数据块
            if last_id in data:  # 新的数据块的ID已存在字典data中
                data[last_id].append(line_list)  # 将中转列表的数据添加到对应的ID中
            else:  # 新的数据快的ID不在字典data中
                data[last_id] = [line_list]  # 将上一个数据块加入对应的ID
            line_list = [line]  # 将中转列表清空，并放入新数据快的第一行数据
        else:  # 没出现新的数据块
            line_list.append(line)  # 将数据继续加入中转列表
    last_id = ID  # 每处理一行，将分块标识last_id更行为最新的ID

# 将最后一个文字块的数据放入字典
if last_id in data:
    data[last_id].append(line_list)
else:
    data[last_id] = [line_list]

# print(data[&#39;89031&#39;])

# for i in data.keys():
#     for block in data[i]:
#         print(block)
#         print(&quot;- -&quot;*50)


# 写入数据函数
def to_txt(filename, data_list):  # filename为写入文件的名字，data为要写入数据列表
    file = open(&quot;分块\\&quot; + filename + &#39;.txt&#39;, &#39;a&#39;)
    for i in range(len(data_list)):
        file.write(data_list[i])
    file.close()  # 保存数据并关闭


# 批量写入数据
for ID in data.keys():
    for i in range(len(data[ID])):
        to_txt(f&quot;&#123;ID&#125;_&#123;i+1&#125;&quot;, data[ID][i])
        
</code></pre>
<p><a href="数据.txt">数据.txt</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>PyQt5 | python制作图形用户界面让操作可视化</title>
    <url>/2021/10/29/python%E5%88%B6%E4%BD%9C%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E8%AE%A9%E6%93%8D%E4%BD%9C%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<h1 id="python制作图形用户界面让操作可视化"><a href="#python制作图形用户界面让操作可视化" class="headerlink" title="python制作图形用户界面让操作可视化"></a>python制作图形用户界面让操作可视化</h1><p>代码：</p>
<pre><code>import sys
import os
from PyQt5 import QtWidgets
from PyQt5.QtGui import QIcon
import xlrd
import datetime
import time
from openpyxl import Workbook
from openpyxl.styles import Border, Side, PatternFill, Font, GradientFill, Alignment


class MainGUI(QtWidgets.QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle(&quot;领料明细汇总&quot;)
        self.resize(800, 400)
        self.main_widget = QtWidgets.QWidget()
        self.main_widget_layout = QtWidgets.QGridLayout()
        self.main_widget.setLayout(self.main_widget_layout)

        self.input = QtWidgets.QLineEdit()
        self.input_btn = QtWidgets.QPushButton(&quot;选择输入文件夹&quot;)
        self.output = QtWidgets.QLineEdit()
        self.output_btn = QtWidgets.QPushButton(&quot;选择输出文件夹&quot;)
        self.show_result = QtWidgets.QListWidget()
        self.run = QtWidgets.QPushButton(&quot;执行汇总&quot;)

        self.main_widget_layout.addWidget(self.input, 0, 0, 1, 2)
        self.main_widget_layout.addWidget(self.input_btn, 0, 2, 1, 1)
        self.main_widget_layout.addWidget(self.output, 1, 0, 1, 2)
        self.main_widget_layout.addWidget(self.output_btn, 1, 2, 1, 1)
        self.main_widget_layout.addWidget(self.run, 2, 2, 1, 1)
        self.main_widget_layout.addWidget(self.show_result, 3, 0, 3, 3)

        self.setCentralWidget(self.main_widget)

        self.input_btn.clicked.connect(self.Choice_dir_input)  # 将&quot;选择输入文件夹&quot;按钮绑定Choice_dir_input函数
        self.output_btn.clicked.connect(self.Choice_dir_output)  # 将&quot;选择输出文件夹&quot;按钮绑定Choice_dir_output函数
        self.run.clicked.connect(self.Summary_data)  # “执行汇总”按钮绑定Summary_data函数

    def Choice_dir_input(self):
        # 选择目录操作
        dir_path = QtWidgets.QFileDialog.getExistingDirectory(self, &quot;请选择文件夹路径&quot;, &quot;D:\\&quot;)
        # 将选择的目录显示在文本编辑框中
        self.input.setText(dir_path)

    def Choice_dir_output(self):
        dir_path = QtWidgets.QFileDialog.getExistingDirectory(self, &quot;请选择文件夹路径&quot;, &quot;D:\\&quot;)
        self.output.setText(dir_path)

    def Get_data(self, file):
        &#39;&#39;&#39;获取单个Excel文件中的资料&#39;&#39;&#39;
        wb = xlrd.open_workbook(file)
        ws = wb.sheets()[0]
        data = &#123;&#125;
        for row in range(7, ws.nrows - 2):
            card_id = ws.cell(2, 16).value
            car = ws.cell(3, 16).value
            dt = ws.cell(row, 0).value
            if type(dt) is float:
                date_time = xlrd.xldate.xldate_as_datetime(dt, 0)
            else:
                date_time = datetime.datetime.strptime(dt, &#39;%Y-%m-%d %H:%M:%S&#39;)
            business = ws.cell(row, 2).value
            model = ws.cell(row, 3).value
            qty = ws.cell(row, 4).value
            unit_price = ws.cell(row, 6).value
            price = ws.cell(row, 8).value
            reward = ws.cell(row, 9).value
            discount = ws.cell(row, 11).value
            balance = ws.cell(row, 13).value
            location = str(ws.cell(row, 15).value).strip()
            operator = ws.cell(row, 17).value
            date = date_time.date()
            time = date_time.time()
            info_list = [card_id, car, date_time, business, model, qty, unit_price, price, reward, discount,
                         balance, location, operator, date, time]
            data.setdefault(date, [])
            if info_list[3] != &quot;备注&quot;:
                data[date].append(info_list)
        # 增加当日加油次数
        for key in data.keys():
            for i in data[key]:
                i.append(len(data[key]))
        return data

    def Get_file_path(self, path):
        files = []
        for file in os.listdir(path):
            if file.endswith(&quot;.xls&quot;):  # 排除文件夹内的其它干扰文件
                files.append(path + &quot;\\&quot; + file)
        return files

    def Get_current_time(self):
        time_stamp = time.time()  # 当前时间的时间戳
        local_time = time.localtime(time_stamp)  #
        str_time = time.strftime(&#39;%Y-%m-%d %H.%M.%S&#39;, local_time)
        return str_time

    def Summary_data(self, files):
        thin = Side(border_style=&quot;thin&quot;, color=&quot;000000&quot;)  # 定义边框粗细及颜色
        title = [&#39;部门&#39;, &#39;部门编号&#39;, &#39;时间&#39;, &#39;业务类型&#39;, &#39;品种&#39;, &#39;数量&#39;, &#39;单价&#39;, &#39;金额&#39;, &#39;额外值&#39;,
                 &#39;调整&#39;, &#39;剩余&#39;, &#39;库位&#39;, &#39;操作员&#39;, &#39;领取日期&#39;, &#39;领取时间&#39;, &#39;领取次数&#39;]

        wb = Workbook()
        ws = wb.active
        ws.merge_cells(&quot;A1:P1&quot;)
        ws.cell(1, 1).value = &quot;领料明细汇总表&quot;
        ws.cell(1, 1).font = Font(name=u&#39;黑体&#39;, bold=True, size=18)
        ws.row_dimensions[1].height = 22.2
        ws.cell(1, 1).alignment = Alignment(horizontal=&quot;center&quot;, vertical=&quot;center&quot;)
        ws.append(title)

        # 插入数据
        files = self.Get_file_path(self.input.text())  # 获取文本编辑框中的输入文件目录，并获取目录下的xls文件
        for file in files:
            data = self.Get_data(file)
            for key in data.keys():
                for i in data[key]:
                    ws.append(i)
            f = QtWidgets.QListWidgetItem(f&quot;&#123;file&#125; 的内容已加入总表.&quot;)  # 创建一个显示项
            self.show_result.addItem(f)  # 将结果添加到部件中

        # 设置字号，对齐，缩小字体填充，加边框
        # Font(bold=True)可加粗字体
        for row_number in range(2, ws.max_row + 1):
            for col_number in range(1, 17):
                c = ws.cell(row=row_number, column=col_number)
                c.font = Font(size=9)
                c.border = Border(top=thin, left=thin, right=thin, bottom=thin)
                c.alignment = Alignment(horizontal=&quot;left&quot;, vertical=&quot;center&quot;)

        col_name = list(&quot;ABCDEFGHIJKLMNOP&quot;)
        col_width = [8, 8, 16, 8, 16, 8, 8, 9.8, 8, 8, 8, 11, 8.3, 9, 8, 8]
        for i in range(len(col_name)):
            ws.column_dimensions[col_name[i]].width = col_width[i]

        ws.column_dimensions.group(&#39;I&#39;, &#39;K&#39;, hidden=True)
        ws.column_dimensions.group(&#39;N&#39;, &#39;O&#39;, hidden=True)

        wb.save(f&quot;&#123;self.output.text()&#125;\\领料明细汇总表&#123;self.Get_current_time()&#125;.xlsx&quot;)
        f = QtWidgets.QListWidgetItem(f&quot;\n领料明细汇总表&#123;self.Get_current_time()&#125;.xlsx 已生成，请去输出文件夹查看.&quot;)  # 创建一个显示项
        self.show_result.addItem(f)  # 将结果添加到部件中


def main():
    app = QtWidgets.QApplication(sys.argv)
    app.setWindowIcon(QIcon(&quot;PO.ico&quot;))  # 设置界面左上角图标
    gui = MainGUI()
    gui.show()
    sys.exit(app.exec_())


if __name__ == &#39;__main__&#39;:
    main()
    
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>PyQt5</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>openpyxl</tag>
        <tag>PyQt5</tag>
      </tags>
  </entry>
  <entry>
    <title>python | python可变参数</title>
    <url>/2021/08/02/python%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h1 id="python可变参数"><a href="#python可变参数" class="headerlink" title="python可变参数"></a>python可变参数</h1><p>python中的函数可以定义<strong>接受不确定数量的参数</strong>，这种参数被称为<strong>可变参数</strong>。</p>
<p>可变参数有两种：1）参数前加*  2）参数前加**<br>*可变参数在函数中被组装成一个元组<br>**可变参数在函数中被组装成一个字典、</p>
<p>代码示例：</p>
<pre><code># *可变参数
def sum(*numbers):
    total = 0.0
    
    for number in numbers:
        total += number
        
    return total
    
print(sum(100.0, 20.0, 30.0))  # 150
print(sum(30.0, 80.0))  # 110

# **可变参数
# coding=utf-8

def show_info(**info):
    print(&#39;-----show_info-----&#39;)
    for key,value in info.items():
        print(&quot;&#123;0&#125; - &#123;1&#125;&quot;.format(key, value)
        
show_info(name=&#39;Tony&#39;, age=18, sex=True)
show_info(student_name=&#39;Tony&#39;, student_no=&#39;1000&#39;)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>itchat | python微信轰炸</title>
    <url>/2021/10/16/python%E5%BE%AE%E4%BF%A1%E8%BD%B0%E7%82%B8/</url>
    <content><![CDATA[<h1 id="python微信轰炸"><a href="#python微信轰炸" class="headerlink" title="python微信轰炸"></a>python微信轰炸</h1><p><a href="https://www.bilibili.com/read/cv11064085/">python微信轰炸</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>itchat</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>itchat</tag>
        <tag>微信轰炸</tag>
      </tags>
  </entry>
  <entry>
    <title>os | python批量重命名文件</title>
    <url>/2021/10/27/python%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="python批量重命名文件"><a href="#python批量重命名文件" class="headerlink" title="python批量重命名文件"></a>python批量重命名文件</h1><p>程序将’文件’文件夹下的所有文件重命名。</p>
<span id="more"></span>
<p>实现代码：</p>
<pre><code>import os


def Get_modify_time(file):
    return os.path.getmtime(file)  # 获取文件修改时间


path = &#39;文件&#39;  # 文件所在文件夹
files = [path + &quot;\\&quot; + i for i in os.listdir(path)]  # 获取文件夹下的文件名,并拼接完整路径
files.sort(key=Get_modify_time)  # 以文件修改时间为依据升序排序
seq = 1  # 计数器，从1开始
for file in files:
    os.rename(file, os.path.join(path, str(seq) + &quot;. &quot; + file.split(&quot;\\&quot;)[-1]))  # 重命名文件
    seq += 1
</code></pre>
<p>‘文件’文件夹包括以下文件：<br><a href="说明.docx">说明.docx</a><br><a href="文档.txt">文档.txt</a><br><a href="演示文稿 - v1.pptx">演示文稿 - v1.pptx</a><br><a href="演示文稿.pptx">演示文稿.pptx</a><br><a href="资料.xlsx">资料.xlsx</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>内置模块</category>
        <category>os</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>文档 | python文档</title>
    <url>/2021/10/27/python%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h1 id="python文档"><a href="#python文档" class="headerlink" title="python文档"></a>python文档</h1><p><a href="https://www.bookstack.cn/read/explore-python/SUMMARY.md">这是一个不错的python文档！！！</a><br><a href="https://github.com/ethan-funny/explore-python">github地址</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>文档</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python文档</tag>
      </tags>
  </entry>
  <entry>
    <title>python-docx | python替换word文档中的文字</title>
    <url>/2021/10/28/python%E6%9B%BF%E6%8D%A2word%E6%96%87%E6%A1%A3%E4%B8%AD%E7%9A%84%E6%96%87%E5%AD%97/</url>
    <content><![CDATA[<h1 id="python替换word文档中的文字"><a href="#python替换word文档中的文字" class="headerlink" title="python替换word文档中的文字"></a>python替换word文档中的文字</h1><p>实现代码：</p>
<pre><code># -*- coding:utf-8 -*-
import docx


# # 定义函数替换文字块中的字符
# def info_update(doc, old_info, new_info):
#     for para in doc.paragraphs:  # 遍历段落
#         for run in para.runs:  # 遍历文字块
#             # run.text = run.text.replace(old_info, new_info)  # 替换
#             print(run.text)
#
#
# doc = docx.Document(&#39;替换前.docx&#39;)
# info_update(doc, &#39;第四次&#39;, &#39;第五次&#39;)
# info_update(doc, &#39;2019&#39;, &#39;2020&#39;)
# info_update(doc, &#39;18&#39;, &#39;10&#39;)
# doc.save(&#39;替换后.docx&#39;)

# doc = docx.Document(&#39;替换前.docx&#39;)
# for para in doc.paragraphs:  # 遍历段落
#     for run in para.runs:  # 遍历文字块
#         # run.text = run.text.replace(old_info, new_info)  # 替换
#         print(run.text)

# # 按段落查看文字
# doc = docx.Document(&#39;替换前.docx&#39;)
# for para in doc.paragraphs:
#     print(para.text)

import docx
from docx.shared import Pt  # 用于设定字体大小(磅值)
from docx.oxml.ns import qn  # 用于应用中文字体


def info_update(doc, old_info, new_info):
    for para in doc.paragraphs:
        para.text = para.text.replace(old_info, new_info)

    # 设置第一段（标题）的文字格式
    for run in doc.paragraphs[0].runs:
        run.font.size = Pt(14)  # 文字大小磅值
        run.bold = True  # 加粗
        run.font.name = &quot;微软雅黑&quot;  # 字体选择
        # 中文字体应用，固定写法
        r = run._element.rPr.rFonts  # 字体，固定写法
        r.set(qn(&quot;w:eastAsia&quot;), &quot;微软雅黑&quot;)  # 字体

    # 设置第二及后续段落的文字格式
    for para in doc.paragraphs[1:]:
        for run in para.runs:
            run.font.size = Pt(12)  # 文字大小
            run.bold = False  # 不加粗
            run.font.name = &quot;微软雅黑&quot;  # 字体选择
            # 中文字体应用，固定写法
            r = run._element.rPr.rFonts
            r.set(qn(&quot;w:eastAsia&quot;), &quot;微软雅黑&quot;)


doc = docx.Document(&#39;替换前.docx&#39;)
info_update(doc, &quot;第四次&quot;, &quot;第五次&quot;)
info_update(doc, &quot;2019&quot;, &quot;2020&quot;)
info_update(doc, &quot;18&quot;, &quot;10&quot;)
doc.save(&#39;替换后_设置格式.docx&#39;)
</code></pre>
<p><a href="替换前.docx">替换前.docx</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>python-docx</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python-docx</tag>
      </tags>
  </entry>
  <entry>
    <title>requests | python爬虫爬取会计师网站的指定文章</title>
    <url>/2021/10/29/python%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96%E4%BC%9A%E8%AE%A1%E5%B8%88%E7%BD%91%E7%AB%99%E7%9A%84%E6%8C%87%E5%AE%9A%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="python爬虫爬取会计师网站的指定文章"><a href="#python爬虫爬取会计师网站的指定文章" class="headerlink" title="python爬虫爬取会计师网站的指定文章"></a>python爬虫爬取会计师网站的指定文章</h1><p>还没学习爬虫，没看懂！有缘再见！后会有期！</p>
<p>贴上代码：</p>
<pre><code>import requests
import os
import json


print(&quot;开始爬取文章......&quot;)
header = &#123;
    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.75 &#39;
                  &#39;Safari/537.36&#39;&#125;

form_data = &#123;&#39;_q&#39;: &#39;Article.list&#39;,
             &#39;siteId&#39;: &#39;7e0b3b27-2622-4aa7-b6f8-abfe5c5df922&#39;,
             &#39;catalogId&#39;: &#39;34f92da3-d6d0-4e96-899f-d7f581c18162&#39;,
             &#39;pub&#39;: &#39;true&#39;,
             &#39;limit&#39;: 5000,
             &#39;start&#39;: 1&#125;

# 这是异步加载，请求方法是POST
url = &quot;http://www.bicpa.org.cn/dtzj/zxgg/getArticles.action&quot;
res = requests.post(url, data=form_data, headers=header)

article_data0 = res.text.split(&quot;&#123;success:true,datas:&quot;)[1]  # 去掉字符串前面的无用信息“&#123;success:true,datas:”
article_data = article_data0.split(&quot;,total:&quot;)[0]  # 去掉字符串后面的无用信息“,total:4946&#125;”

obj = json.loads(article_data)
# 获取标题含有“委员会专家提示”的文章的标题，发布时间和链接
path = r&quot;http://www.bicpa.org.cn&quot;
articles = []
for info in obj:
    if &quot;委员会专家提示&quot; in info[&#39;title&#39;]:
        article = &#123;
            &quot;标题&quot;: info[&#39;title&#39;].strip(),  # strip()去除首尾空格
            &quot;发布时间&quot;: info[&#39;publishDate&#39;],
            &quot;链接&quot;: path + info[&#39;url&#39;] + info[&#39;primaryKey&#39;] + &quot;.html&quot;
        &#125;
        articles.append(article)


import requests
from bs4 import BeautifulSoup
import docx
from docx.shared import Pt  # 用于设定字体大小（磅值）
from docx.oxml.ns import qn  # 用于应用中文字体
import random
import time


# 获取想要的文章并批量写入word文件
def Get_article_to_word(url, date):
    user_agent_list = [
        &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36&quot;,
        &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&quot;,
        &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36&quot;,
        &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.62 Safari/537.36&quot;,
        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36&quot;,
        &quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)&quot;,
        &quot;Mozilla/5.0 (Macintosh; U; PPC Mac OS X 10.5; en-US; rv:1.9.2.15) Gecko/20110303 Firefox/3.6.15&quot;
    ]
    header = &#123;&#39;User-Agent&#39;: random.choice(user_agent_list)&#125;
    wb_data = requests.get(url, headers=header)
    soup = BeautifulSoup(wb_data.content)
    title = soup.select(&#39;.headword&#39;)[0].text.strip()  # 获得标题
    content1 = soup.select(&quot;.MsoNormal&quot;)  # 针对正文布局为 class = &quot;MsoNormal&quot;
    content2 = soup.select(&quot;#art_content&quot;)  # 针对正文布局为 id = &quot;art_content&quot;

    doc = docx.Document()  # 新建空白word文档
    # 设定全局字体
    doc.styles[&#39;Normal&#39;].font.name = u&#39;宋体&#39;
    doc.styles[&#39;Normal&#39;]._element.rPr.rFonts.set(qn(&#39;w:eastAsia&#39;), u&#39;宋体&#39;)

    # 写入标题行，并设置字体格式
    p = doc.add_paragraph()
    r = p.add_run(title)
    r.bold = True
    r.font.size = Pt(18)

    doc.add_paragraph(date)  # 写入日期
    doc.add_paragraph(url)  # 写入文章链接

    dirs = os.getcwd() + &quot;\\文章&quot;
    if not os.path.exists(dirs):
        os.makedirs(dirs)

    # 写入正文
    for i in content2:
        doc.add_paragraph(i.text)
    for i in content1:
        doc.add_paragraph(i.text)
    doc.save(f&quot;&#123;dirs&#125;\\&#123;title&#125;.docx&quot;)


# 遍历所有文章的链接，调用以上函数执行
for art in articles:
    Get_article_to_word(art[&quot;链接&quot;], art[&quot;发布时间&quot;])
    print(&quot;&#123;&#125; 下载完成。&quot;.format(art[&#39;标题&#39;]))
    if articles.index(art) % 30 == 29:  # 每获取30篇文章，暂停5秒，避免频繁请求被服务器切断连接
        time.sleep(5)

print(f&quot;共下载 &#123;len(articles)&#125; 篇文章。&quot;)
print(&quot;程序运行完成，关闭窗口退出.&quot;)
input()
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>requests</category>
      </categories>
      <tags>
        <tag>os</tag>
        <tag>python-docx</tag>
        <tag>requests</tag>
        <tag>random</tag>
        <tag>json</tag>
        <tag>BeautifulSoup4</tag>
        <tag>time</tag>
      </tags>
  </entry>
  <entry>
    <title>pyinstaller | python程序打包</title>
    <url>/2021/10/29/python%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<h1 id="python程序打包"><a href="#python程序打包" class="headerlink" title="python程序打包"></a>python程序打包</h1><p>通常情况我们在pycharm中写的python程序只能在安装了python的电脑上运行，那么如何移植到其他电脑上也能运行呢？<br>我们可以将py文件打包成可执行程序(exe文件).</p>
<h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><h3 id="1-pyinstaller库安装"><a href="#1-pyinstaller库安装" class="headerlink" title="1. pyinstaller库安装"></a>1. pyinstaller库安装</h3><pre><code>pip install pyinstaller -i https://pypi.doubanio.com/simple/
</code></pre>
<h3 id="2-打包"><a href="#2-打包" class="headerlink" title="2.打包"></a>2.打包</h3><pre><code>pyinstaller -D program.py ---&gt; 打包成一个文件夹（默认操作）
pyinstaller -F program.py ---&gt; 打包成单个可执行文件
</code></pre>
<p>程序运行后，会在目录生成一个文件：<br>1.program.spec(打包规则)<br>三个文件夹：<br>1.__pycache __(Python版本信息)<br>2.build(存储日志文件)<br>3.dist(储存可执行文件即相关的文件夹)<br><strong>注：打包完成后，除了dist文件夹，其它都可以删除，没什么用。</strong></p>
<h3 id="3-将打包好的文件制作成一个安装文件"><a href="#3-将打包好的文件制作成一个安装文件" class="headerlink" title="3.将打包好的文件制作成一个安装文件"></a>3.将打包好的文件制作成一个安装文件</h3><p>使用NSIS文件夹压缩器来制作安装文件。</p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>pyinstaller</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pyinstaller</tag>
        <tag>程序打包</tag>
      </tags>
  </entry>
  <entry>
    <title>jieba | python词频分析</title>
    <url>/2021/10/27/python%E8%AF%8D%E9%A2%91%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="python词频分析"><a href="#python词频分析" class="headerlink" title="python词频分析"></a>python词频分析</h1><p>程序分析了”主要业务”文件夹的所有文件中的文本信息的词频(分别存储在”词频”文件夹中)</p>
<span id="more"></span>

<p>实现代码：</p>
<pre><code>import os
import jieba
import pandas as pd

path = &#39;主要业务&#39;  # 文件所在文件夹
files = [path + &quot;\\&quot; + i for i in os.listdir(path)]  # 获取文件夹下的文件名,并拼接完整路径

for file in files:
    txt = open(file, &quot;r&quot;, encoding=&quot;utf-8&quot;).read()
    words = jieba.lcut(txt)
    wordsDict = &#123;&#125;  # 新建字典用于储存词及词频
    for word in words:
        if len(word) == 1:  # 单个的字符不作为词放入字典
            continue
        else:
            wordsDict.setdefault(word, 0)  # 设置词的初始出现次数为0
            wordsDict[word] += 1  # 对于重复出现的词，每出现一次，次数增加1

    stopWords = [&quot;2019&quot;, &quot;不断&quot;, &quot;持续&quot;, &quot;主要&quot;, &quot;企业&quot;, &quot;产品&quot;, &quot;业务&quot;, &quot;公司&quot;, &quot;行业&quot;, &quot;000&quot;, &quot;用于&quot;, &quot;情况&quot;, &quot;方面&quot;, &quot;一种&quot;, &quot;要求&quot;, &quot;对于&quot;,
                 &quot;进行&quot;, &quot;一般&quot;, &quot;212&quot;, &quot;实现&quot;, &quot;处理&quot;, &quot;通过&quot;, &quot;投入&quot;, &quot;随着&quot;]
    for word in stopWords:
        if word in wordsDict:
            del wordsDict[word]

    wordsDict_seq = sorted(wordsDict.items(), key=lambda x: x[1], reverse=True)  # 按字典的值降序排序

    df = pd.DataFrame(wordsDict_seq, columns=[&#39;词&#39;, &#39;次数&#39;])
    df.to_excel(&quot;词频//&#123;&#125;.xlsx&quot;.format(file.split(&quot;\\&quot;)[1][:-4]), index=False)  # 存为Excel时去掉index索引列
  
</code></pre>
<p>“主要业务”文件夹的所有文件:<br><a href="东旭蓝天：2019年年度报告.txt">东旭蓝天：2019年年度报告.txt</a><br><a href="保利地产：2018年年度报告.txt">保利地产：2018年年度报告.txt</a><br><a href="共达电声：2019年年度报告（更新后）.txt">共达电声：2019年年度报告（更新后）.txt</a><br><a href="华特气体：2019年年度报告（修订版）.txt">华特气体：2019年年度报告（修订版）.txt</a><br><a href="吉峰科技：2019年年度报告（更新后）.txt">吉峰科技：2019年年度报告（更新后）.txt</a><br><a href="引力传媒：2019年年度报告（修订版）.txt">引力传媒：2019年年度报告（修订版）.txt</a><br><a href="方正科技：2019年年度报告.txt">方正科技：2019年年度报告.txt</a><br><a href="湖北宜化：2019年年度报告（更新后）.txt">湖北宜化：2019年年度报告（更新后）.txt</a><br><a href="联创股份：2019年年度报告（更新后）.txt">联创股份：2019年年度报告（更新后）.txt</a><br><a href="高乐股份：2019年年度报告.txt">高乐股份：2019年年度报告.txt</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>jieba</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>os</tag>
        <tag>pandas</tag>
        <tag>jieba</tag>
      </tags>
  </entry>
  <entry>
    <title>baidu-aip | python调用人工智能识别表格</title>
    <url>/2021/10/27/python%E8%B0%83%E7%94%A8%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%AF%86%E5%88%AB%E8%A1%A8%E6%A0%BC/</url>
    <content><![CDATA[<h1 id="python调用人工智能识别表格"><a href="#python调用人工智能识别表格" class="headerlink" title="python调用人工智能识别表格"></a>python调用人工智能识别表格</h1><p>使用百度的OCR API识别表格中的文字。<br><a href="https://blog.csdn.net/weixin_39932611/article/details/112354147">参考资料1</a><br><a href="https://blog.csdn.net/weixin_44298740/article/details/117560495">参考资料2</a></p>
<span id="more"></span>

<pre><code># coding:utf-8
# 获取路径下所有图片文件，并存入列表
import os

work_path = &quot;图片\\&quot;
pictures = []  # 存储文件夹内所有文件的路径（包括子目录内的文件）
for root, dirs, files in os.walk(work_path):
    path = [os.path.join(root, name) for name in files]
    pictures.extend(path)

from aip import AipOcr  # 导入AipOcr模块，用于做文字识别
import time  # 时间模块
import requests  # 用于HTTP请求

APP_ID = &#39;25067363&#39;
API_KEY = &#39;0PRCHim4nzLcDNEYR1hcSGGG&#39;
SECRET_KEY = &#39;DFGtcTbhpD829q9GOUbjPYameEty7C6i&#39;
client = AipOcr(APP_ID, API_KEY, SECRET_KEY)

# 提交识别请求，并储存所有请求ID
for picture in pictures:
    pic = open(picture, &#39;rb&#39;)  # 以二进制方式打开图片
    img = pic.read()  # 读取
    table = client.tableRecognitionAsync(img)  # 调用表格识别模块
    print(table)
    # request_id = table[&#39;result&#39;][0][&#39;request_id&#39;]
    #
    # # 判断识别是否完成，直到完成才根据请求ID获取Excel下载路径
    # result = client.getTableRecognitionResult(request_id)  # 通过ID获取识别结果
    # while result[&#39;result&#39;][&#39;ret_msg&#39;] != &#39;已完成&#39;:  # 如果状态是“已完成”，才能获取下载地址
    #     time.sleep(2)  # 暂停2秒再刷新
    #     result = client.getTableRecognitionResult(request_id)  # 持续刷新，直到满足条件
    #
    # download_path = result[&#39;result&#39;][&#39;result_data&#39;]
    #
    # # 下载并将Excel文件名设为图片名
    # excel_name = picture.split(&quot;.&quot;)[0] + &quot;.xls&quot;  # 让excel文件的名字与图片相同
    # excel = requests.get(download_path)  # 抓取下载链接
    # file = open(excel_name, &#39;wb&#39;)  # 新建excel文件
    # file.write(excel.content)  # 写入excel文件并保存
    
</code></pre>
<p><a href="论文.jpg">论文.jpg</a><br><a href="收货表.jpg">收货表.jpg</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>baidu-aip</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>os</tag>
        <tag>requests</tag>
        <tag>time</tag>
        <tag>baidu-aip</tag>
      </tags>
  </entry>
  <entry>
    <title>python资源大全</title>
    <url>/2021/07/03/python%E8%B5%84%E6%BA%90%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<p>awesome-python 是 vinta 发起维护的 Python 资源列表，内容包括：Web 框架、网络爬虫、网络内容提取、模板引擎、数据库、数据可视化、图片处理、文本处理、自然语言处理、机器学习、日志、代码分析等。<br><a href="http://jobbole.github.io/awesome-python-cn/">python资源大全中文版</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python | re.match与re.search的区别</title>
    <url>/2020/11/08/re-match%E4%B8%8Ere-search%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="re-match与re-search的区别"><a href="#re-match与re-search的区别" class="headerlink" title="re.match与re.search的区别"></a>re.match与re.search的区别</h1><p>re.match从字符串的起始位置匹配一个模式，如果字符串开始不符合正则表达式，则匹配失败。<br>re.search匹配整个字符串，直到找到一个匹配</p>
<h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><pre><code>s = &quot;Cats are smarter than dogs&quot;
re.match(r&quot;dogs&quot;,s)#匹配失败
re.search(r&quot;dogs&quot;,s)#匹配成功
</code></pre>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python | re sub的使用方法</title>
    <url>/2021/08/27/re-sub%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="re-sub的使用方法"><a href="#re-sub的使用方法" class="headerlink" title="re.sub的使用方法"></a>re.sub的使用方法</h1><p>re.sub()实现相对复杂的替换</p>
<p><a href="https://www.jianshu.com/p/8c1d1a38f9b9">使用方法</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>内置模块</category>
        <category>re</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>re</tag>
      </tags>
  </entry>
  <entry>
    <title>matplotlib | recorded EEG visualization</title>
    <url>/2021/10/12/recorded-EEG-visualization/</url>
    <content><![CDATA[<h1 id="recorded-EEG-visualization"><a href="#recorded-EEG-visualization" class="headerlink" title="recorded EEG visualization"></a>recorded EEG visualization</h1><p>在做脑电（EEG）的相关研究时,通常我们需要使用公开的脑电数据集合，公开数据集包含了以及采集好的脑电数据。<br>我们可以使用python的第三方库matplotlib将数据集中的脑电数据进行可视化。</p>
<span id="more"></span>

<p>下面以绘制8个通道的脑电数据为例对脑电数据进行可视化：<br>注意：实例中使用公开数据集DEAP,详细信息可参考<a href="http://www.eecs.qmul.ac.uk/mmv/datasets/deap/">DEAP 官网</a></p>
<p><strong>示例代码：</strong></p>
<pre><code>import os
import glob
import pickle
import matplotlib.pyplot as plt

# 参数设置
window_size = 1
sampling_rate = 500


# 获取数据文件列表并划分(训练文件/测试文件)
data_dir = &quot;data_preprocessed_python/&quot;
file_list = glob.glob(os.path.join(data_dir, &quot;*&quot;))  # 整个数据集包含32个subject的样本数据
print(&quot;len(file_list):&quot;, len(file_list))


def get_data_and_label(file_list):
    &quot;&quot;&quot;
    获得固定窗口大小的数据和对应的标签

    Arrray name         Array shape         Array contents
    ---------------------------------------------------------------------------------------------
    data                40 x 40 x 8064      video/trial x channel x data
    labels              40 x 4              videl/trial x label(valence,arousal,dominance,liking)
    ---------------------------------------------------------------------------------------------
    &quot;&quot;&quot;
    data = []
    valence_labels = []
    arousal_labels = []

    for file in file_list:
        x = pickle.load(open(file, &#39;rb&#39;), encoding=&#39;latin1&#39;)  # type(x):dict &#123;&#39;labels&#39;:array(),&#39;data&#39;:array()&#125;

        labels = x[&#39;labels&#39;]
        valence_labels.extend(labels[:, 0])
        arousal_labels.extend(labels[:, 1])

        dat = x[&#39;data&#39;]
        data.extend(dat[:, :, :window_size * sampling_rate])

    return data

print(&quot;开始获取脑电波数据...&quot;)
data = get_data_and_label(file_list)
print(&quot;脑电波数据已获取，开始绘制脑电波...&quot;)
x = range(sampling_rate)
fig, ax = plt.subplots(3, 3)
ax[0][0].plot(x, list(data[0][0]))
ax[0][0].set_title(&#39;Fp1&#39;)
ax[0][1].plot(x, list(data[0][1]))
ax[0][1].set_title(&#39;AF3&#39;)
ax[0][2].plot(x, list(data[0][2]))
ax[0][2].set_title(&#39;F3&#39;)
ax[1][0].plot(x, list(data[0][3]))
ax[1][0].set_title(&#39;F7&#39;)
ax[1][1].plot(x, list(data[0][4]))
ax[1][1].set_title(&#39;FC5&#39;)
ax[1][2].plot(x, list(data[0][5]))
ax[1][2].set_title(&#39;FC1&#39;)
ax[2][0].plot(x, list(data[0][6]))
ax[2][0].set_title(&#39;C3&#39;)
ax[2][1].plot(x, list(data[0][7]))
ax[2][1].set_title(&#39;T7&#39;)
ax[2][2].plot(x, list(data[0][8]))
ax[2][2].set_title(&#39;CP5&#39;)
plt.show()
print(&quot;脑电波绘制完成！&quot;)
</code></pre>
<p><strong>绘制的脑电波：</strong></p>
<p><img src="/2021/10/12/recorded-EEG-visualization/500_brainwave.png"></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>matplotlib</category>
      </categories>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL | Access denied for user &#39;root&#39;@&#39;localhost&#39;</title>
    <url>/2021/04/18/root-localhost/</url>
    <content><![CDATA[<h1 id="ERROR-Access-denied-for-user-‘root’-’localhost’"><a href="#ERROR-Access-denied-for-user-‘root’-’localhost’" class="headerlink" title="ERROR: Access denied for user ‘root’@’localhost’"></a>ERROR: Access denied for user ‘root’@’localhost’</h1><p>在安装mysql时，安装过程中没有提示输入密码，安装完成之后，在终端输入mysql报错Access denied for ‘root’@’localhost’,但是使用sudo mysql可以进入。</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h2><p>1.在终端输：sudo mysql 进入mysql<br>2.mysql&gt; use mysql<br>3.mysql&gt; alter user ‘root’@’localhost’ identified with mysql_native_password by ‘your password’</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Movies | sacrifice</title>
    <url>/2020/10/29/sacrifice/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="79e80760dd3d238a6e9a15b5be6ada3d11c39cf7b5591ebe4ef6d0374ab585ab">06cac7a4498bdc1ba84f9a7c2df89776a693a413eda0c1b32a74d9891b7b55a7901574726315dcdbc8314bb123e764c805202b86c9e30f9ce1445163b5696416a3bf9fda41bf13ed75c625bf6d79fbbbe96455d4c695063426ae736fb1ea1800bebd246813a28203ca22c1a7fe1305c347e97942718e0f945446f1363c99c5acca82179441369cf4493a004544c59043b24c113d8724aa6ceecbc5e1aedda601d321f50df2f2d0db5577cac7472095493d561a9bffa6b0448cf9cdc05d6447cf0e275a47a08ac48c0be83e0483b9c4a0ed3a5c7a7a22020d536f97a2a7903aa177d9d4d1d8bec07a9496b1d99fdfbe1aa89e08bd98e1b26fcf9a8efddd565e98688bc0af5133dd2b3261fbed6718c7f74b12064a0ce4270ea3523f42b3c93843946a1a9542a7796eb9b8af85fc6b23a26fc32d05b0f7e182d152c1e1410379d7fe2fe64c585e71bea30c4b37b35c322556c5a1034dbcf25bb987f524ff2610802740b1b797a7b9f9589fcabeb5650e98dc2807708ce8e9150c79e880ac3850d65677a0f0fe5920963a4a0af0a6921d2ec83a36ad47f861443a4fb718aa779b624d8fa2aab326c71a0fc6e1964a222fa6a4eac6e1d7db09c6e4858af318953ce0ad7a685ad5e9b454b2fde24126b5a03e88a28f4b490c6a0723fc6cee8b166c7200372465ff06793ce6f43f8a0a6734333e62a33b9fe5cc5fab81c188708bfdd9711f2a1ea07c8ac3bbc7124e4580d0518d1505c7843119484ed8c627324c6d6c270178efc5812df6fe6edfd521c83aaa54fa7a8cb7312435570206e91c1372684e0406d8c9e805702a1d4aec50cd7936c9e6b225f8cf5c5d672a4d09360c2cf2a7c61e20762521bc43b3b42cb1b1d4401efaf77060a368f90c05d89a932d3acb201d78bab5b05f7173ae28a5f888f13f37d5b6c3bc35fc4035c278f1dfecbf333bfb8067d48f07dea05cb0696f50e8e4008ba6f3ed72a475b95a06249c6a951689927c8a1e911906fecd41a47e5a51f3b5d68aa2f9184a590cd2306cce891770a161575ef050ca37761518ec408c7e3a14a76af47d1e78583a9ddd915c4524704afbeb4d0b26bb55df64d2a37a29755916adf48fd38f06e7c0615a98537e70397d5b94f99534b6cc71126c9ae55ab8bb49ff40f09a7eaf1946e323a0ed080e2e2aea3aacabbedaba2bebe989536d10480269727690f20dde3228e18c35ffdd7c848aa9907af197f8aca420bb6ba417dc3565140e6d31b081475d4c2d23b3551be1ef18fc654d21d227bd4a4e88c9db6e02773080ad3ca5ef83d995cebab3cd935e0faba541fb168190f23acbd6577cb3f858e57e366268bb4c6a9648f27b3073c1626707a0194eea8e3f6d181bc5b8069f472ecd256d80040e822c5689333db495b87c1be67ecbd591457d2b3e1ded7971a93c4dbce535e3128b8a7a77e29bfe3956a3f1802bb066bdae0bd1e2f8642d1eafdcce584e23e2eceffd4977a1f0eb5989bdd4ffc5132fa5b5cb5252b12a53f6b690e7aa28fe3926ab645671cf10452cab9a8c19f61c68a22bcaa3c9e92339f6ec3e9ecfe32f93d18058eb7ad76e59cfcbd69ff698b7ade19404ba67152bc5283191262e79804bb5637b4ba77773ffc3cd4cd618d9a094f288f15b8b9423664a503dc9d3d7528b73f6026a544617f9a0e2d0980f5ae6fbe6502535a3aa33cc4014e3decb8fe27fb3bf41053478846a731a02d6717d0effdde3e7d787de370f2bdd61ca46057e3bded549473f79f5b8563d3d940eae0f730ae31fbf75e52ecb10995fc1c7b51d93e3ce4f7b7d2a5b6252920816c48f97a720b16707fb33919da891fb3660ca999f168e272244004786f5f412b17c00950deec7c3e4970fc68f3cfce80218a5eae3c16c746fdd412b75fe4e767bcf63dd1933895cc249ab73456010f667a81411e0dfaf01fbb20ccee4f89ee8a30d2381e86daefa6f2a4eb43003fae18fa7663c1eec27929229a60c05da989796453d61dfb634d749e8084b9cbbb4e5a8ad388edf011464c87edad762ce5a821b4cc232d376c1b3e411b8dde670d787da6676777d4284cfb8f250e90f8745543cabdd62a8b95c687fa7bee4b99a7aed560f31d18f3cb2a93828ec8b923d6947aca01dd3ff9723d8e2896bd59324fe69cfc29714683ffcafb7a3b6fef802f931b3b6ecdcbd0ad4fa24fd2222ccd1e68018c0b5e22a9b37d94d7555bc5610c3a65bb92eb57dd53e0dc3fd3ee5abf738197958b86c11238a50d265ab71d6971e8c7fc5cb92ab9b4cecc89a621554d2b726b10a1c21078a044ad5246314e42c2225ab359d06710b5407a6ac2204fe87fb762493dd47237adcd67ad3350627fb4bda29b61743949b1f72113fea8a5df815ff5cde7de64e03c4ff88aeb22675</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Movies</category>
      </categories>
      <tags>
        <tag>金刚川</tag>
      </tags>
  </entry>
  <entry>
    <title>Django | session实现用户登录</title>
    <url>/2021/07/29/session%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<h1 id="session实现用户登录"><a href="#session实现用户登录" class="headerlink" title="session实现用户登录"></a>session实现用户登录</h1><p>下面将使用session实现用户登录，如下图所示效果：<br><img src="/2021/07/29/session%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95/login.gif"></p>
<h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><p>1.在views.py文件中创建视图(假定我们创建了一个名为booktest的应用)</p>
<pre><code>def index(request):
    uname = request.session.get(&#39;myname&#39;, default=&#39;未登录&#39;)
    context = &#123;&#39;uname&#39;: uname&#125;
    return render(request, &#39;booktest/index.html&#39;, context)


def login(request):
    return render(request, &#39;booktest/login.html&#39;)


def login_handle(request):
    uname = request.POST[&#39;uname&#39;]
    request.session[&#39;myname&#39;] = uname
    return redirect(&#39;/booktest/index/&#39;)


def logout(request):
    # del request.session[&#39;myname&#39;]  # 删除会话
    # request.session.clear()  # 清除所有会话
    request.session.flush()  # 删除当前的会话数据并删除会话的Cookie
    return redirect(&#39;/booktest/index/&#39;)
</code></pre>
<p>2.配置url</p>
<pre><code>主url:
from django.conf.urls import include, url
from django.contrib import admin

urlpatterns = [
    url(r&#39;^booktest/&#39;, include(&quot;booktest.urls&quot;, namespace=&#39;booktest&#39;)),
]
应用url:
from django.conf.urls import include, url
import views


urlpatterns = [
    url(r&#39;^index/$&#39;, views.index),
    url(r&#39;^login/$&#39;, views.login),
    url(r&#39;^login_handle/$&#39;, views.login_handle),
    url(r&#39;^logout/$&#39;, views.logout3),

]
</code></pre>
<p>3.创建模板</p>
<pre><code>index.html

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
你好：&#123;&#123; uname &#125;&#125;
&lt;br&gt;
&lt;a href=&quot;/booktest/session2/&quot;&gt;登录&lt;/a&gt;
&lt;br&gt;
&lt;a href=&quot;/booktest/session3/&quot;&gt;退出&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;

login.html

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form method=&quot;post&quot; action=&quot;/booktest/session2_handle/&quot;&gt;
    &lt;input type=&quot;text&quot; name=&quot;uname&quot;&gt;
    &lt;input type=&quot;submit&quot; name=&quot;登录&quot;&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>4.配置模板路径DIRS<br>注：templates为和应用同级的文件夹，本应用的模板存在templates/booktest/下</p>
<pre><code>TEMPLATES = [
    &#123;
        &#39;BACKEND&#39;: &#39;django.template.backends.django.DjangoTemplates&#39;,
        &#39;DIRS&#39;: [os.path.join(BASE_DIR, &#39;templates&#39;)],
        &#39;APP_DIRS&#39;: True,
        &#39;OPTIONS&#39;: &#123;
            &#39;context_processors&#39;: [
                &#39;django.template.context_processors.debug&#39;,
                &#39;django.template.context_processors.request&#39;,
                &#39;django.contrib.auth.context_processors.auth&#39;,
                &#39;django.contrib.messages.context_processors.messages&#39;,
            ],
        &#125;,
    &#125;,
]
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>框架</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | sigmoid or tanh</title>
    <url>/2021/06/24/sigmoid-or-tanh/</url>
    <content><![CDATA[<h1 id="sigmoid-or-tanh？"><a href="#sigmoid-or-tanh？" class="headerlink" title="sigmoid or tanh？"></a>sigmoid or tanh？</h1><p>Sigmoid outputs a value between 0 and 1 which makes it a very good choice for binary classification.<br>You can classify as 0 if the output is less than 0.5 and classify as 1 if the output is more than 0.5.<br>It can be done with tanh as well but it is less convenient as the output is between -1 and 1.(Sigmoid<br>输出的值介于 0 和 1 之间，这使其成为二元分类的一个非常好的选择。 如果输出小于 0.5，则可以将其归类为 0，如果输出<br>大于 0.5，则归类为 1。 它也可以用 tanh 来完成，但是它不太方便，因为输出在<br>-1 和 1 之间。)</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>激活函数</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | sqrt</title>
    <url>/2021/10/27/sqrt/</url>
    <content><![CDATA[<h1 id="69-sqrt-x"><a href="#69-sqrt-x" class="headerlink" title="69.sqrt(x)"></a>69.sqrt(x)</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个非负整数 x ，计算并返回 x 的 算术平方根 。<br>由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。<br>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</p>
<p><a href="https://leetcode-cn.com/problems/sqrtx/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.二分法</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):
    @staticmethod
    def my_sqrt1(a):
        &quot;&quot;&quot;二分法开根号&quot;&quot;&quot;
        # 初始化左右边界
        left, right = 0, a
        while left &lt;= right:
            mid = (left + right) // 2
            if mid ** 2 == a:
                return mid
            elif mid ** 2 &gt; a:
                right = mid - 1
            else:
                left = mid + 1
        return right


if __name__ == &quot;__main__&quot;:
    a = 3
    s = Solution()
    sqrt_a = s.my_sqrt1(a)
    print(sqrt_a)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程 | tcp三次握手四次挥手</title>
    <url>/2020/10/26/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    <content><![CDATA[<h1 id="使用tcp协议进行通信过程中的三次握手和四次挥手"><a href="#使用tcp协议进行通信过程中的三次握手和四次挥手" class="headerlink" title="使用tcp协议进行通信过程中的三次握手和四次挥手"></a>使用tcp协议进行通信过程中的三次握手和四次挥手</h1><p>TCP在真正的读写操作之前，server与client之间必须建立一个连接。<br>当读写操作完成后，双方不再需要这个连接时它们可以释放这个连接。<br>连接的<strong>建立</strong>通过<strong>三次握手</strong>，<strong>释放</strong>则需要<strong>四次挥手</strong><br><img src="/2020/10/26/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/tcp.JPG" alt="tcp三次握手和四次挥手"></p>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>三次握手</tag>
        <tag>四次挥手</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程 | tcp与udp的稳定性</title>
    <url>/2020/10/26/tcp%E4%B8%8Eudp%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7/</url>
    <content><![CDATA[<h1 id="tcp稳定而udp不稳定的原因"><a href="#tcp稳定而udp不稳定的原因" class="headerlink" title="tcp稳定而udp不稳定的原因"></a>tcp稳定而udp不稳定的原因</h1><p><b style="color:red">在tcp中，如果有一方收到了对方的数据，一定会发送ack确认包给发送方，而在udp中，没有这个过程，因此导致了tcp稳定，而udp不稳定。</b></p>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>TCP</tag>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程 | tcp的客户端/服务器端代码编写</title>
    <url>/2020/10/22/tcp%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99/</url>
    <content><![CDATA[<h1 id="tcp的客户端-服务器端代码编写"><a href="#tcp的客户端-服务器端代码编写" class="headerlink" title="tcp的客户端/服务器端代码编写"></a>tcp的客户端/服务器端代码编写</h1><h2 id="tcp服务器端代码编写"><a href="#tcp服务器端代码编写" class="headerlink" title="tcp服务器端代码编写"></a>tcp服务器端代码编写</h2><pre><code>#coding=utf-8
from socket import *

# 创建socket
tcpSerSocket = socket(AF_INET, SOCK_STREAM)

# 绑定本地信息
address = (&#39;&#39;, 7788)
tcpSerSocket.bind(address)

# 使用socket创建的套接字默认的属性是主动的，使用listen将其变为被动的，这样就可以接收别人的链接了
tcpSerSocket.listen(5)

# 如果有新的客户端来链接服务器，那么就产生一个新的套接字专门为这个客户端服务器
# newSocket用来为这个客户端服务
# tcpSerSocket就可以省下来专门等待其他新客户端的链接
newSocket, clientAddr = tcpSerSocket.accept()

# 接收对方发送过来的数据，最大接收1024个字节
recvData = newSocket.recv(1024)
print(&#39;接收到的数据为:%s&#39;%recvData)

# 发送一些数据到客户端
newSocket.send(&quot;thank you !&quot;)

# 关闭为这个客户端服务的套接字，只要关闭了，就意味着为不能再为这个客户端服务了，如果还需要服务，只能再次重新连接
newSocket.close()

# 关闭监听套接字，只要这个套接字关闭了，就意味着整个程序不能再接收任何新的客户端的连接
tcpSerSocket.close()
</code></pre>
<span id="more"></span>
<h2 id="tcp客户端代码编写"><a href="#tcp客户端代码编写" class="headerlink" title="tcp客户端代码编写"></a>tcp客户端代码编写</h2><pre><code>#coding=utf-8
from socket import *

# 创建socket
tcpClientSocket = socket(AF_INET, SOCK_STREAM)

# 链接服务器
serAddr = (&#39;192.168.1.102&#39;, 7788)
tcpClientSocket.connect(serAddr)

# 提示用户输入数据
sendData = input(&quot;请输入要发送的数据：&quot;)

tcpClientSocket.send(sendData)

# 接收对方发送过来的数据，最大接收1024个字节
recvData = tcpClientSocket.recv(1024)
print(&#39;接收到的数据为:%s&#39;%recvData)

# 关闭套接字
tcpClientSocket.close()
</code></pre>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>tcp客户端</tag>
        <tag>tcp服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>软件架构 | ten things every architect should know</title>
    <url>/2021/03/11/ten-things-every-architect-should-know/</url>
    <content><![CDATA[<h1 id="Ten-Things-Every-Architect-Should-Know"><a href="#Ten-Things-Every-Architect-Should-Know" class="headerlink" title="Ten Things Every Architect Should Know"></a>Ten Things Every Architect Should Know</h1><p>1.<b>People</b> are the platform</p>
<p>2.All solutions are obsolete</p>
<p>3.<b>Data</b> is forever</p>
<p>4.Flexibility breeds complexity</p>
<p>5.Nothing works as expected</p>
<p>6.<b>Documentation</b> is the universal source code</p>
<p>7.Know the <b>business</b></p>
<p>8.Maintain the <b>version</b></p>
<p>9.Software architext should also be coders</p>
<p>10.There is no substitute for <b>experiences</b></p>
]]></content>
      <categories>
        <category>SA</category>
      </categories>
      <tags>
        <tag>软件架构</tag>
      </tags>
  </entry>
  <entry>
    <title>python | tensorflow安装遇到问题</title>
    <url>/2021/05/13/tensorflow%E5%AE%89%E8%A3%85%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="Python中解决ModuleNotFoundError-No-module-named-‘tensorflow-api’问题"><a href="#Python中解决ModuleNotFoundError-No-module-named-‘tensorflow-api’问题" class="headerlink" title="Python中解决ModuleNotFoundError: No module named ‘tensorflow._api’问题"></a>Python中解决ModuleNotFoundError: No module named ‘tensorflow._api’问题</h1><p><a href="https://blog.csdn.net/u012270544/article/details/96424907">点击这里查看问题解决方法</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>python | ubuntu下虚拟环境的安装与配置</title>
    <url>/2021/01/28/ubuntu%E4%B8%8B%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="ubuntu下虚拟环境的安装与配置"><a href="#ubuntu下虚拟环境的安装与配置" class="headerlink" title="ubuntu下虚拟环境的安装与配置"></a>ubuntu下虚拟环境的安装与配置</h1><h2 id="为什么要搭建虚拟环境"><a href="#为什么要搭建虚拟环境" class="headerlink" title="为什么要搭建虚拟环境?"></a>为什么要搭建虚拟环境?</h2><pre><code>如果在一台电脑上, 有不同项目, 需要用到同一个包的不同版本, 新版本会覆盖以前的版本, 其它的项目就可能无法正常运行了.。
解决方法：虚拟环境
    作用：虚拟环境可以搭建独立的python运行环境`, 使得单个项目的运行环境与其它项目互不影响。
    所有的虚拟环境都位于/home/用户名下的隐藏目录.virtualenvs下。
</code></pre>
<h2 id="如何搭建虚拟环境"><a href="#如何搭建虚拟环境" class="headerlink" title="如何搭建虚拟环境?"></a>如何搭建虚拟环境?</h2><pre><code>安装虚拟环境的命令：
sudo pip install virtualenvo
sudo pip install virtualenvwrapper

安装完虚拟环境后，如果提示找不到mkvirtualenv命令，须配置环境变量：

# 1、创建目录用来存放虚拟环境
mkdir \$HOME/.virtualenvs
# 2、打开~/.bashrc文件，并添加如下：
export WORKON_HOME=$HOME/.virtualenvs
source /usr/local/bin/virtualenvwrapper.sh
# 3、运行
source ~/.bashrc

创建虚拟环境的命令 :
在python3中，创建虚拟环境

mkvirtualenv -p python3 虚拟环境名称
例 ：
mkvirtualenv -p python3 django_py3
</code></pre>
<p>创建成功后会自动工作在这个虚拟环境上,工作在虚拟环境上, 提示符最前面会出现 “虚拟环境名称”。<br>如何使用虚拟环境?</p>
<pre><code>查看虚拟环境的命令 :

workon 两次tab键 或者 回车

使用虚拟环境的命令：

workon 虚拟环境名称
例 ：使用名为django_py3的虚拟环境
workon django_py3

退出虚拟环境的命令 :

deactivate

删除虚拟环境的命令 :

rmvirtualenv 虚拟环境名称
例 ：删除虚拟环境django_py3
先退出：deactivate
再删除：rmvirtualenv django_py3
</code></pre>
<h2 id="如何在虚拟环境中安装工具包"><a href="#如何在虚拟环境中安装工具包" class="headerlink" title="如何在虚拟环境中安装工具包"></a>如何在虚拟环境中安装工具包</h2><p>workon进入虚拟环境后，再使用pip进行包的安装，其安装方法和普通的安装方式一样。</p>
<pre><code>安装指定Django版本示例:

pip install django==1.11.11

python3下的安装路径：

~/.virtualenvs/django_py3/lib/python3.5/site-packages/
</code></pre>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>虚拟环境</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程 | udp+多线程模拟QQ</title>
    <url>/2020/10/17/udp-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E6%8B%9FQQ/</url>
    <content><![CDATA[<h1 id="在linux环境下使用-udp-多线程-模拟QQ"><a href="#在linux环境下使用-udp-多线程-模拟QQ" class="headerlink" title="在linux环境下使用 udp+多线程 模拟QQ"></a>在linux环境下使用 <b>udp+多线程</b> 模拟QQ</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><strong>程序主要的两个功能</strong>：</p>
<ul>
<li>发送数据（Send Data） </li>
<li>接收数据（Reveive Data）</li>
</ul>
<p><strong>使用多线程的原因</strong><br>不使用多线程的情况下，在程序暂停等待发送方输入发送内容时，若发送方不输入内容，则程序一直卡在这里；此时另外一放发送数据由于程序暂时等待输入内容也不能打印消息。<br>使用了多线程，接收数据、发送数据的程序分别由一个线程来处理，且两个线程互不影响，发送方不输入内容时，另一方发送消息发送方就能接收到。<br><b>Note:通信的两台计算机必须在同一个局域网！！！</b></p>
<span id="more"></span>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code># coding=utf-8
# 1.receive data then print out
from threading import Thread
from socket import *

def recvData():
    while True:
        recvInfo = udpSocket.recvfrom(1024)
        print(&quot;&gt;&gt;%s:%s\n&lt;&lt;&quot;%(str(recvInfo[1]),recvInfo[0]),end=&quot;&quot;)

# 2.detect the keyboard and send the data
def sendData():
    print(&quot;&lt;&lt;&quot;,end=&quot;&quot;)
    while True:
        sendInfo =  input(&quot;&quot;)
        udpSocket.sendto(sendInfo.encode(&#39;gb2312&#39;),(destIp,destPort))

udpSocket = None
destIp = &quot;&quot;
destPort = 0 

def main():
    global udpSocket
    global destIp
    global destPort

    destIp = input(&quot;Destination ip:&quot;)
    destPort = int(input(&quot;Destination port:&quot;))

    udpSocket = socket(AF_INET,SOCK_DGRAM)
    udpSocket.bind((&quot;&quot;,4567))

    tr = Thread(target=recvData)
    ts = Thread(target=sendData)
    
    tr.start()
    ts.start()

    tr.join()
    ts.join()

if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<h2 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h2><p><img src="/2020/10/17/udp-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E6%8B%9FQQ/udp.jpg" alt="udp"></p>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>UDP</tag>
        <tag>SOCKET</tag>
      </tags>
  </entry>
  <entry>
    <title>wxPython | wxPython控件</title>
    <url>/2021/08/03/wxPython%E6%8E%A7%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="wxPython控件"><a href="#wxPython控件" class="headerlink" title="wxPython控件"></a>wxPython控件</h1><p>1.实现三个文本输入空间和三个静态文本<br>1.1界面效果<br><img src="/2021/08/03/wxPython%E6%8E%A7%E4%BB%B6/1.png"><br>1.2示例代码</p>
<pre><code>class MyFrame(wx.Frame):
    def __init__(self):
        super().__init__(None, title=&quot;文本输入控件&quot;, size=(300, 260))
        panel = wx.Panel(parent=self)
        tc1 = wx.TextCtrl(panel)
        tc2 = wx.TextCtrl(panel, style=wx.TE_PASSWORD)
        tc3 = wx.TextCtrl(panel, style=wx.TE_MULTILINE)

        userid = wx.StaticText(panel, label=&quot;用户ID：&quot;)
        pwd = wx.StaticText(panel, label=&quot;密码：&quot;)
        content = wx.StaticText(panel, label=&quot;多行文本：&quot;)

        # 创建垂直方向的盒子布局管理器对象
        vbox = wx.BoxSizer(wx.VERTICAL)

        # 添加控件到vbox布局管理器
        vbox.Add(userid, flag=wx.EXPAND | wx.LEFT, border=10)
        vbox.Add(tc1, flag=wx.EXPAND | wx.ALL, border=10)
        vbox.Add(pwd, flag=wx.EXPAND | wx.LEFT, border=10)
        vbox.Add(tc2, flag=wx.EXPAND | wx.ALL, border=10)
        vbox.Add(content, flag=wx.EXPAND | wx.LEFT, border=10)
        vbox.Add(tc3, flag=wx.EXPAND | wx.ALL, border=10)

        # 设置面板采用vbox布局管理器
        panel.SetSizer(vbox)

        # 设置tc1初始值
        tc1.SetValue(&#39;tony&#39;)
        # 获取tc1值
        print(&#39;读取用户ID：&#123;0&#125;&#39;.format(tc1.GetValue()))

        tc2.SetValue(&#39;123&#39;)

        tc3.SetValue(&#39;这是一个多行文本！这是一个多行文本！这是一个多行文本！这是一个多行文本！这是一个多行文本！这是一个多行文本！&#39;)


app = wx.App()
frm = MyFrame()
frm.Show()
app.MainLoop()
</code></pre>
<span id="more"></span>

<p>2.实现一组复选框和一组单选按钮<br>2.1界面效果<br><img src="/2021/08/03/wxPython%E6%8E%A7%E4%BB%B6/2.png"><br>2.2示例代码</p>
<pre><code>class MyFrame(wx.Frame):
    def __init__(self):
        super().__init__(None, title=&quot;复选框和单选按钮&quot;, size=(330, 120))
        panel = wx.Panel(parent=self)

        st1 = wx.StaticText(panel, label=&quot;选择你喜欢的编程语言：&quot;)
        cb1 = wx.CheckBox(panel, id=1, label=&#39;Python&#39;)
        cb2 = wx.CheckBox(panel, id=2, label=&#39;Java&#39;)
        cb2.SetValue(True)
        cb3 = wx.CheckBox(panel, id=3, label=&#39;C++&#39;)
        self.Bind(wx.EVT_CHECKBOX, self.on_checkbox_click, id=1, id2=3)

        st2 = wx.StaticText(panel, label=&quot;选择性别：&quot;)
        radio1 = wx.RadioButton(panel, id=4, label=&#39;男&#39;, style=wx.RB_GROUP)
        radio2 = wx.RadioButton(panel, id=5, label=&#39;女&#39;)
        self.Bind(wx.EVT_RADIOBUTTON, self.on_radio1_click, id=4, id2=5)

        st3 = wx.StaticText(panel, label=&quot;是否婚配：&quot;)
        radio3 = wx.RadioButton(panel, id=6, label=&#39;Yes&#39;, style=wx.RB_GROUP)
        radio4 = wx.RadioButton(panel, id=7, label=&#39;No&#39;)
        self.Bind(wx.EVT_RADIOBUTTON, self.on_radio2_click, id=6, id2=7)

        hbox1 = wx.BoxSizer(wx.HORIZONTAL)
        hbox1.Add(st1, flag=wx.LEFT | wx.RIGHT, border=5)
        hbox1.Add(cb1)
        hbox1.Add(cb2)
        hbox1.Add(cb3)

        hbox2 = wx.BoxSizer(wx.HORIZONTAL)
        hbox2.Add(st2, flag=wx.LEFT | wx.RIGHT, border=5)
        hbox2.Add(radio1)
        hbox2.Add(radio2)

        hbox3 = wx.BoxSizer(wx.HORIZONTAL)
        hbox3.Add(st3, flag=wx.LEFT | wx.RIGHT, border=5)
        hbox3.Add(radio3)
        hbox3.Add(radio4)

        vbox = wx.BoxSizer(wx.VERTICAL)
        vbox.Add(hbox1, flag=wx.ALL, border=10)
        vbox.Add(hbox2, flag=wx.ALL, border=10)
        vbox.Add(hbox3, flag=wx.ALL, border=10)

        panel.SetSizer(vbox)

    def on_checkbox_click(self, event):
        cb = event.GetEventObject()
        print(&#39;选择&#123;0&#125;,状态&#123;1&#125;&#39;.format(cb.GetLabel(), event.IsChecked()))

    def on_radio1_click(self, event):
        rb = event.GetEventObject()
        print(&#39;第一组&#123;0&#125;被选中&#39;.format(rb.GetLabel()))

    def on_radio2_click(self, event):
        rb = event.GetEventObject()
        print(&#39;第二组&#123;0&#125;被选中&#39;.format(rb.GetLabel()))


app = wx.App()
frm = MyFrame()
frm.Show()
app.MainLoop()  
</code></pre>
<p>3.单选列表和多选列表<br>3.1界面效果<br><img src="/2021/08/03/wxPython%E6%8E%A7%E4%BB%B6/3.png"><br>3.2示例代码</p>
<pre><code>class MyFrame(wx.Frame):
    def __init__(self):
        super().__init__(None, title=&quot;列表&quot;, size=(350, 175))
        panel = wx.Panel(parent=self)

        st1 = wx.StaticText(parent=panel, label=&quot;选择你喜欢的编程语言：&quot;)
        list1 = [&#39;Python&#39;, &#39;C++&#39;, &#39;Java&#39;]
        # 创建列表控件，参数choices用于设置列表选项；参数style用于设置列表风格样式，wx.LB_SINGLE指单选列表控件
        lb1 = wx.ListBox(parent=panel, choices=list1, style=wx.LB_SINGLE)
        self.Bind(wx.EVT_LISTBOX, self.on_listbox1, lb1)

        st2 = wx.StaticText(parent=panel, label=&quot;选择你喜欢吃的水果：&quot;)
        list2 = [&#39;苹果&#39;, &#39;橘子&#39;, &#39;香蕉&#39;]
        lb2 = wx.ListBox(parent=panel, choices=list2, style=wx.LB_EXTENDED)  # style=wx.LB_EXTENDED表示创建多选列表控件
        self.Bind(wx.EVT_LISTBOX, self.on_listbox2, lb2)

        hbox1 = wx.BoxSizer(wx.HORIZONTAL)
        hbox1.Add(st1, proportion=1, flag=wx.LEFT | wx.RIGHT, border=5)
        hbox1.Add(lb1, proportion=1)

        hbox2 = wx.BoxSizer(wx.HORIZONTAL)
        hbox2.Add(st2, proportion=1, flag=wx.LEFT | wx.RIGHT, border=5)
        hbox2.Add(lb2, proportion=1)

        vbox = wx.BoxSizer(wx.VERTICAL)
        vbox.Add(hbox1, flag=wx.ALL | wx.EXPAND, border=5)
        vbox.Add(hbox2, flag=wx.ALL | wx.EXPAND, border=5)

        panel.SetSizer(vbox)

    def on_listbox1(self, event):
        listbox = event.GetEventObject()
        print(&#39;选择 &#123;0&#125;&#39;.format(listbox.GetSelection()))

    def on_listbox2(self, event):
        listbox = event.GetEventObject()
        print(&#39;选择 &#123;0&#125;&#39;.format(listbox.GetSelections()))


app = wx.App()
frm = MyFrame()
frm.Show()
app.MainLoop()
</code></pre>
<p>4.静态图片控件<br>4.1界面效果<br><img src="/2021/08/03/wxPython%E6%8E%A7%E4%BB%B6/4.png"><br>4.2示例代码</p>
<pre><code>class MyFrame(wx.Frame):
    def __init__(self):
        super().__init__(None, title=&#39;静态图片控件&#39;, size=(300, 300))
        self.panel = wx.Panel(parent=self)

        # 创建wx.Bitmap图片对象的列表
        self.bmps = [wx.Bitmap(&#39;images/1.jpg&#39;, wx.BITMAP_TYPE_JPEG),
                     wx.Bitmap(&#39;images/2.jpg&#39;, wx.BITMAP_TYPE_JPEG),
                     wx.Bitmap(&#39;images/3.jpg&#39;, wx.BITMAP_TYPE_JPEG)]

        b1 = wx.Button(self.panel, id=1, label=&#39;Button1&#39;)
        b2 = wx.Button(self.panel, id=2, label=&#39;Button2&#39;)
        self.Bind(wx.EVT_BUTTON, self.on_click, id=1, id2=2)

        self.image = wx.StaticBitmap(self.panel, bitmap=self.bmps[0])

        # 创建垂直方向的布局管理器对象vbox
        vbox = wx.BoxSizer(wx.VERTICAL)
        # 添加控件到布局管理器对象vbox
        vbox.Add(b1, proportion=1, flag=wx.EXPAND)
        vbox.Add(b2, proportion=1, flag=wx.EXPAND)
        vbox.Add(self.image, proportion=3, flag=wx.EXPAND)

        self.panel.SetSizer(vbox)

    def on_click(self, event):
        event_id = event.GetId()
        if event_id == 1:
            self.image.SetBitmap(self.bmps[1])
        else:
            self.image.SetBitmap(self.bmps[2])

        self.panel.Layout()  # 重新设置panel面板布局


app = wx.App()
frm = MyFrame()
frm.Show()
app.MainLoop()
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>wxPython</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>wxPython</tag>
      </tags>
  </entry>
  <entry>
    <title>电脑使用小技巧 | windows关闭弹框广告</title>
    <url>/2021/01/28/windows%E5%85%B3%E9%97%AD%E5%BC%B9%E6%A1%86%E5%B9%BF%E5%91%8A/</url>
    <content><![CDATA[<h1 id="如何关闭烦人的桌面广告弹框"><a href="#如何关闭烦人的桌面广告弹框" class="headerlink" title="如何关闭烦人的桌面广告弹框"></a>如何关闭烦人的桌面广告弹框</h1><p>1.打开“控制面板”<br><img src="/2021/01/28/windows%E5%85%B3%E9%97%AD%E5%BC%B9%E6%A1%86%E5%B9%BF%E5%91%8A/1.png"><br>2.进入“网络和Internet”<br><img src="/2021/01/28/windows%E5%85%B3%E9%97%AD%E5%BC%B9%E6%A1%86%E5%B9%BF%E5%91%8A/2.png"><br>3.进入“Internet选项”<br><img src="/2021/01/28/windows%E5%85%B3%E9%97%AD%E5%BC%B9%E6%A1%86%E5%B9%BF%E5%91%8A/3.png"><br>4.选择“隐私”选项卡，勾选“启用弹出窗口阻止程序”，然后点“设置”<br><img src="/2021/01/28/windows%E5%85%B3%E9%97%AD%E5%BC%B9%E6%A1%86%E5%B9%BF%E5%91%8A/4.png"><br>5.阻止级别选“高”，点击“关闭”<br><img src="/2021/01/28/windows%E5%85%B3%E9%97%AD%E5%BC%B9%E6%A1%86%E5%B9%BF%E5%91%8A/5.png"><br>6.重启电脑</p>
]]></content>
      <categories>
        <category>电脑使用小技巧</category>
      </categories>
  </entry>
  <entry>
    <title>CNN | 卷积神经网络(一维卷积、二维卷积、三维卷积)</title>
    <url>/2021/10/26/%E4%B8%80%E7%BB%B4%E5%8D%B7%E7%A7%AF%E4%BA%8C%E7%BB%B4%E5%8D%B7%E7%A7%AF%E4%B8%89%E7%BB%B4%E5%8D%B7%E7%A7%AF/</url>
    <content><![CDATA[<h1 id="卷积神经网络-一维卷积、二维卷积、三维卷积"><a href="#卷积神经网络-一维卷积、二维卷积、三维卷积" class="headerlink" title="卷积神经网络(一维卷积、二维卷积、三维卷积)"></a>卷积神经网络(一维卷积、二维卷积、三维卷积)</h1><p><a href="https://www.cnblogs.com/szxspark/p/8445406.html">一维卷积、二维卷积、三维卷积</a><br><a href="https://blog.csdn.net/weixin_44378513/article/details/112307989?spm=1001.2101.3001.6650.17&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-17.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-17.no_search_link">1D CNN+2D CNN+3D CNN</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
        <category>CNN</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>一维卷积</tag>
        <tag>二维卷积</tag>
        <tag>三维卷积</tag>
      </tags>
  </entry>
  <entry>
    <title>pdfplumber | 一键提取PDF中的表格到Excel</title>
    <url>/2021/10/28/%E4%B8%80%E9%94%AE%E6%8F%90%E5%8F%96PDF%E4%B8%AD%E7%9A%84%E8%A1%A8%E6%A0%BC%E5%88%B0Excel/</url>
    <content><![CDATA[<h1 id="一键提取PDF中的表格到Excel"><a href="#一键提取PDF中的表格到Excel" class="headerlink" title="一键提取PDF中的表格到Excel"></a>一键提取PDF中的表格到Excel</h1><p>实现代码：</p>
<pre><code>import os
import pdfplumber
from openpyxl import Workbook

path = &#39;PDF&#39;  # 文件所在文件夹
files = [path + &quot;\\&quot; + i for i in os.listdir(path)]  # 获取文件夹下的文件名,并拼接完整路径
key_words = &quot;主要会计数据&quot;

for file in files:
    with pdfplumber.open(file) as p:
        wb = Workbook()  # 新建excel工作簿
        wb.remove(wb.worksheets[0])  # 删除工作簿自带的工作表

        # 获取关键词所在页及下一页的页码
        pages_wanted = []
        for index, page in enumerate(p.pages):  # 从0开始给所有页编号
            if key_words in page.extract_text():
                pages_wanted.append(index)
                pages_wanted.append(index + 1)
                break

        # 提取指定页码里的表格
        for i in pages_wanted:
            page = p.pages[i]
            tables = page.extract_tables()  # 读取表格
            if tables:  # 判断是否存在表格，若不存在，则不执行下面的语句
                ws = wb.create_sheet(f&quot;Sheet&#123;i + 1&#125;&quot;)  # 新建工作表，表名的编号与表在PDF中的页码一致
                for table in tables:  # 遍历所有列表
                    for row in table:  # 遍历列表中的所有子列表，里面保存着行数据
                        ws.append(row)  # 写入excel表
        wb.save(&quot;Excel\\&#123;&#125;.xlsx&quot;.format(file.split(&quot;\\&quot;)[1].split(&quot;.&quot;)[0]))
</code></pre>
<p>PDF:<br><a href="东旭蓝天：2019年年度报告.PDF">东旭蓝天：2019年年度报告.PDF</a><br><a href="华特气体：2019年年度报告（修订版）.PDF">华特气体：2019年年度报告（修订版）.PDF</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>pdfplumber</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>openpyxl</tag>
        <tag>pdfplumber</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 下一个更大元素</title>
    <url>/2021/08/27/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="496-下一个更大元素"><a href="#496-下一个更大元素" class="headerlink" title="496.下一个更大元素"></a>496.下一个更大元素</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。<br>请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。<br>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/next-greater-element-i/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.暴力解法<br>对于每一个 nums1[i] 中的元素，先在 nums2 中找到它，然后向右遍历找到第 1 个大于 nums1[i] 的元素。<br>2.单调栈<br>步骤：<br>1）使用单调栈先对 nums2 中的每一个元素，求出它的右边第一个更大的元素；<br>2）将上一步的对应关系放入哈希表（HashMap）中；<br>3）再遍历数组 nums1，根据哈希表找出答案。<br>维护单调栈：<br>我们维护的栈恰好保证了单调性：栈中的元素从栈顶到栈底是单调不降的。<br>当我们遇到一个新的元素 nums2[i] 时，我们判断栈顶元素是否小于 nums2[i]，<br>如果是，那么栈顶元素的下一个更大元素即为 nums2[i]，我们将栈顶元素出栈。<br>重复这一操作，直到栈为空或者栈顶元素大于 nums2[i]。此时我们将 nums2[i] 入栈，<br>保持栈的单调性，并对接下来的 nums2[i + 1], nums2[i + 2] … 执行同样的操作。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):
    def nextGreaterElement(self, nums1, nums2):
        &quot;&quot;&quot;
        暴力解法
        对于每一个 nums1[i] 中的元素，先在 nums2 中找到它，然后向右遍历找到第 1 个大于 nums1[i] 的元素。

        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: List[int]
        &quot;&quot;&quot;
        # 使用内置方法list.index()/list.append()
        # next_greater_index = []  # 存储下一个更大元素下标的列表
        #
        # if len(nums1) &lt; 1:
        #     return next_greater_index
        #
        # for num in nums1:  # 遍历nums1中的每一个元素
        #     index = nums2.index(num)  # 定位nums1中的元素在nums2中的下标
        #     for i in range(index+1, len(nums2)):  # 遍历nums1中元素在nums2中所在位置之后的元素
        #         if nums2[i] &gt; num:  # 如果找到比nums1中元素更大的元素，则将下标加入下标列表
        #             next_greater_index.append(nums2[i])
        #             break
        #     else:
        #         next_greater_index.append(-1)
        #
        # return next_greater_index

        # 不使用内置方法list.index()/list.append()
        len1 = len(nums1)
        len2 = len(nums2)

        res = list()

        if len1 &lt; 1:
            return res

        for i in range(len1):
            cur_val = nums1[i]
            j = 0
            while j &lt; len2 and nums2[j] != cur_val:
                j += 1

            # nums2[j] = nums1[i]
            j += 1
            while j &lt; len2 and nums2[j] &lt; cur_val:
                j += 1

            if j == len2:
                res[i] = -1
                continue

            res[i] = nums2[j]
        return res

    def nextGreaterElement1(self, nums1, nums2):
        &quot;&quot;&quot;
        栈（单调栈）

        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: List[int]
        &quot;&quot;&quot;
        stack = list()
        map = &#123;&#125;
        # 对nums2中的每一个元素，求出它的右边第一个更大的元素；
        # 将对应关系放入哈希表（HashMap）中
        for i in range(len(nums2)):
            while len(stack) != 0 and stack[-1] &lt; nums2[i]:
                map[stack.pop()] = nums2[i]

            stack.append(nums2[i])

        # 遍历数组nums1，根据哈希表找出答案
        res = list()
        for j in range(len(nums1)):
            res.append(map.get(nums1[j], -1))

        return res


if __name__ == &quot;__main__&quot;:
    slt = Solution()

    res_list = slt.nextGreaterElement1([4, 1, 2], [1, 3, 4, 2])

    print(res_list)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>urllib.request | 下载图片</title>
    <url>/2021/08/05/%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h1 id="使用urllib-request库从互联网上下载图片"><a href="#使用urllib-request库从互联网上下载图片" class="headerlink" title="使用urllib.request库从互联网上下载图片"></a>使用urllib.request库从互联网上下载图片</h1><pre><code># coding=utf-8

import urllib.request as request

url = &#39;http://localhost:8080/NoteWebService/logo.png&#39;

with request.urlopen(url) as response:
    data = response.read()
    f_name = &#39;download.png&#39;
    with open(f_name, &#39;wb&#39;) as f:
        f.write(data)
        print(&#39;下载文件成功&#39;)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>内置模块</category>
        <category>urllib</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>urllib</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 两数之和</title>
    <url>/2021/08/27/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="1-两数相加"><a href="#1-两数相加" class="headerlink" title="1.两数相加"></a>1.两数相加</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。<br>你可以按任意顺序返回答案。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/two-sum/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.暴力枚举法<br>枚举数组中的每一个数x，寻找数组中是否存在target-x<br>2.哈希表<br>改进了方法1中寻找数组中是否存在target-x的过程</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):
    def twoSum(self, nums, target):  # O(N^2)
        &quot;&quot;&quot;
        暴力枚举法

        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        &quot;&quot;&quot;
        for i in range(len(nums)):
            for j in range(i+1, len(nums)):
                if nums[i] + nums[j] == target:
                    return [i, j]

    def twoSum1(self, nums, target):  # O(N)
        hashtable = dict()
        for i, num in enumerate(nums):
            if target - num in hashtable:
                return [hashtable[target - num], i]
            hashtable[nums[i]] = i
        return []


if __name__ == &quot;__main__&quot;:
    slt = Solution()
    t = slt.twoSum([2, 7, 11, 15], 9)
    print(t)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 两数相加</title>
    <url>/2021/08/27/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。<br>请你将两个数相加，并以相同形式返回一个表示和的链表。<br>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/add-two-numbers/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对应位置元素带进位相加</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># Definition for singly-linked list.
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):
    def addTwoNumbers(self, l1, l2):
        &quot;&quot;&quot;
        对应位置元素带进位相加
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        extra = 0
        root = n = ListNode(0)
        while l1 or l2 or extra:
            v1 = v2 = 0
            if l1:
                v1 = l1.val
                l1 = l1.next
            if l2:
                v2 = l2.val
                l2 = l2.next
            extra, val = divmod(v1 + v2 + extra, 10)
            n.next = ListNode(val)
            n = n.next
        return root.next

    def create_linked_list(self, num):
        link_list = ListNode(num % 10)
        r = link_list
        while num &gt;= 10:
            num = num // 10
            node = ListNode(num % 10)
            r.next = node
            r = r.next
        r.next = None
        return link_list

    def len_list(self, link_list):
        count = 0
        p = link_list
        while p is not None:
            count += 1
            p = p.next

        return count

class Solution1:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:
        &quot;&quot;&quot;
        将两个链表分别转化为一个整数,然后将两个整数相加,将结果的逆序构建成一个单链表
  
        t = 1
        res1 = 0

        while l1 is not None:
            res1 += l1.val * t
            t *= 10
            l1 = l1.next

        t = 1
        res2 = 0
        while l2 is not None:
            res2 += l2.val * t
            t *= 10
            l2 = l2.next

        res = res1 + res2
        print(res)

        res_list = ListNode(res % 10)
        r = res_list
        while res &gt;= 10:
            res //= 10
            node = ListNode(res % 10)
            r.next = node
            r = node
        r.next = None

        return res_list

if __name__ == &#39;__main__&#39;:
    slt = Solution()
    l1 = slt.create_linked_list(342)
    l2 = slt.create_linked_list(465)
    res = slt.addTwoNumbers1(l1, l2)

    while res is not None:
        print(res.val)
        res = res.next

    print(slt.len_list(l1))
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 为什么需要非线性激活函数</title>
    <url>/2021/06/23/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="为什么需要非线性激活函数"><a href="#为什么需要非线性激活函数" class="headerlink" title="为什么需要非线性激活函数?"></a>为什么需要非线性激活函数?</h1><p>为什么神经网络需要非线性激活函数？如果使用线性激活函数(恒等激励函数)，那么神经网络只是把输入线性组合<br>再输出。对于深度神经网络来说，如果使用了线性激活函数或者没有使用激活函数，那么无论你的神经网络有多少<br>层，它做的只是计算线性函数，这样的做法与直接去掉全部隐藏层无异。因此，必须通过非线性激活函数来引入非线性。</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>激活函数</tag>
      </tags>
  </entry>
  <entry>
    <title>伪迹移除 | 主成分分析</title>
    <url>/2021/02/23/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h1><p><b style="color: red">PCA is a type of spatial filter that transforms the time domain datasets into a different space by rotating axes in an N-dimensional space(where n is the number of variables or EEG channels) such that each dimension in the new space has minimum variance and the axes are orthogonal to each other.</b></p>
<p>PCA reduces data dimension and highlights specific features of data,which is usually difficult to identify in the spatially unfiltered data as the new components are created by weighted combinations of all EEG channels.</p>
<h2 id="One-important-limitation-of-PCA-or-SVD"><a href="#One-important-limitation-of-PCA-or-SVD" class="headerlink" title="One important limitation of PCA (or SVD)"></a>One important limitation of PCA (or SVD)</h2><p>it fails to separate/identify ocular or similar artifacts from<br>EEG when amplitudes are comparable since PCA depends on<br>the higher order statistical property</p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>伪迹移除</category>
      </categories>
      <tags>
        <tag>伪迹移除</tag>
        <tag>ICA</tag>
        <tag>EEG</tag>
        <tag>PCA</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 二进制求和</title>
    <url>/2021/08/29/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/</url>
    <content><![CDATA[<h1 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67.二进制求和"></a>67.二进制求和</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两个二进制字符串，返回它们的和（用二进制表示）。<br>输入为 非空 字符串且只包含数字 1 和 0。</p>
<span id="more"></span>
<p>示例 1:<br>输入: a = “11”, b = “1”<br>输出: “100”</p>
<p><a href="https://leetcode-cn.com/problems/add-binary/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.先将 a 和 b 转化成十进制数，求和后再转化为二进制数<br>2.列竖式<br>末尾对齐，逐位相加，逢二进一<br>具体的，我们可以取 n=max{∣a∣,∣b∣}，循环 n 次，从最低位开始遍历。我们使用一个变量 carry 表示上一个位置的进位，初始值为 0。记当前位置对其的两个位为 ai​ 和 bi​，则每一位的答案为 (carry+ai+bi) mod 2，下一位的进位为 ⌊(carry+ai+bi)/2⌋。重复上述步骤，直到数字 a 和 b 的每一位计算完毕。最后如果 carry 的最高位不为 0，则将最高位添加到计算结果的末尾。<br>注意，为了让各个位置对齐，你可以先反转这个代表二进制数字的字符串，然后低下标对应低位，高下标对应高位。当然你也可以直接把 a 和 b 中短的那一个补 0 直到和长的那个一样长，然后从高位向低位遍历，对应位置的答案按照顺序存入答案字符串内，最终将答案串反转。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def addBinary(self, a: str, b: str) -&gt; str:
        &quot;&quot;&quot;
        先将 aaa 和 bbb 转化成十进制数，求和后再转化为二进制数
        :param a:
        :param b:
        :return:
        &quot;&quot;&quot;
        # a = int(a, 2)  # 将二进制数转为十进制
        # b = int(b, 2)
        # print(a)
        # print(b)
        # return bin(a+b)[2:]

        return &#39;&#123;0:b&#125;&#39;.format(int(a, 2) + int(b, 2))

    def addBinary1(self, a: str, b: str) -&gt; str:
        ans = list()
        n = max(len(a), len(b))
        carry = 0

        list_a = []
        list_b = []
        for e in a:
            list_a.append(int(e))

        for e in b:
            list_b.append(int(e))

        print(list_a)
        print(list_b)

        for i in range(n):
            carry += list_a[len(a) - i - 1] if i &lt; len(a) else 0
            carry += list_b[len(b) - i - 1] if i &lt; len(b) else 0
            ans.append(str(int(carry % 2)))
            carry /= 2

        if carry &gt; 0:
            ans.append(&#39;1&#39;)

        return &#39;&#39;.join(ans[::-1])


if __name__ == &#39;__main__&#39;:
    s = Solution()
    a = &quot;11&quot;
    b = &quot;1&quot;
    res = s.addBinary1(a, b)
    print(res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>OS | 什么是操作系统</title>
    <url>/2021/10/14/%E4%BB%80%E4%B9%88%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统?"></a>什么是操作系统?</h1><p>“操作系统（operating system，简称OS）是管理计算机硬件与软件资源的计算机程序,是硬件软件之间的一座桥梁。</p>
<p><img src="/2021/10/14/%E4%BB%80%E4%B9%88%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.JPG"></p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>pandas | 从原Excel表中抽出数据存入同一文件的新的Sheet</title>
    <url>/2021/10/29/%E4%BB%8E%E5%8E%9FExcel%E8%A1%A8%E4%B8%AD%E6%8A%BD%E5%87%BA%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5%E5%90%8C%E4%B8%80%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B0%E7%9A%84Sheet/</url>
    <content><![CDATA[<h1 id="从原Excel表中抽出数据存入同一文件的新的Sheet"><a href="#从原Excel表中抽出数据存入同一文件的新的Sheet" class="headerlink" title="从原Excel表中抽出数据存入同一文件的新的Sheet"></a>从原Excel表中抽出数据存入同一文件的新的Sheet</h1><p>实现代码：</p>
<pre><code>import pandas as pd

df = pd.read_excel(&quot;物料表.xlsx&quot;, header=2)
df.head()
#     请求单号     单位     物料编号     架位     批号     数量     日期
# 0     A19X9239156     EA     11010XR0073700     LC000001     PC00001     3     2019-01-03
# 1     A19X9239156     EA     11020XR0025500     LC000002     PC00002     10     2019-01-03
# 2     A19X9239156     EA     11030XR0013200     LC000003     PC00003     3     2019-01-03
# 3     A19X9239156     EA     11140XR0000100     LC000004     PC00004     3     2019-01-03
# 4     A19X9239156     EA     12121XR0172300     LC000005     PC00005     3     2019-01-03

df[&#39;月份&#39;] = df[&#39;日期&#39;].dt.month
df.head()
#     请求单号     单位     物料编号     架位     批号     数量     日期     月份
# 0     A19X9239156     EA     11010XR0073700     LC000001     PC00001     3     2019-01-03     1
# 1     A19X9239156     EA     11020XR0025500     LC000002     PC00002     10     2019-01-03     1
# 2     A19X9239156     EA     11030XR0013200     LC000003     PC00003     3     2019-01-03     1
# 3     A19X9239156     EA     11140XR0000100     LC000004     PC00004     3     2019-01-03     1
# 4     A19X9239156     EA     12121XR0172300     LC000005     PC00005     3     2019-01-03     1

df5 = df[df[&#39;月份&#39;] == 5]
df5.head()
#     请求单号     单位     物料编号     架位     批号     数量     日期     月份
# 9649     A19X9280200     EA     36012XR0413200     LC009650     PC09650     66     2019-05-03     5
# 9650     A19X9280200     EA     60022XR2298300     LC009651     PC09651     66     2019-05-03     5
# 9651     A19X9280561     EA     72004XR2000001     LC009652     PC09652     604     2019-05-03     5
# 9652     A19X9286759     EA     62010XR0161048     LC009653     PC09653     50     2019-05-03     5
# 9653     A19X9286759     EA     62010XR0502208     LC009654     PC09654     100     2019-05-03     5

df8 = df[df[&#39;月份&#39;] == 8]
df8.head()


#     请求单号     单位     物料编号     架位     批号     数量     日期     月份
# 17213     A19X9317364     EA     62010XR0500126     LC017214     PC17214     230     2019-08-01     8
# 17214     A19X9317364     EA     61010XR1120100     LC017215     PC17215     230     2019-08-01     8
# 17215     A19X9317364     EA     62012XR0102262     LC017216     PC17216     230     2019-08-01     8
# 17216     A19X9317364     EA     62010XR050150A     LC017217     PC17217     950     2019-08-01     8
# 17217     A19X9317364     EA     61011XR1150500     LC017218     PC17218     230     2019-08-01     8


# 去掉不需要的月份的数据
def Remove_data(df, month=[]):
    for i in month:
        df = df[df[&#39;月份&#39;] != i]
    return df


df_rest = Remove_data(df, [5, 8])
df_rest.head()
#     请求单号     单位     物料编号     架位     批号     数量     日期     月份
# 0     A19X9239156     EA     11010XR0073700     LC000001     PC00001     3     2019-01-03     1
# 1     A19X9239156     EA     11020XR0025500     LC000002     PC00002     10     2019-01-03     1
# 2     A19X9239156     EA     11030XR0013200     LC000003     PC00003     3     2019-01-03     1
# 3     A19X9239156     EA     11140XR0000100     LC000004     PC00004     3     2019-01-03     1
# 4     A19X9239156     EA     12121XR0172300     LC000005     PC00005     3     2019-01-03     1

with pd.ExcelWriter(&#39;物料表_1.xlsx&#39;, engine=&#39;openpyxl&#39;,
                    datetime_format=&#39;YYYY-MM-DD&#39;) as writer:
    df5.drop(&#39;月份&#39;, axis=1).to_excel(writer, sheet_name=&#39;5月&#39;, index=False)
    df8.drop(&#39;月份&#39;, axis=1).to_excel(writer, sheet_name=&#39;8月&#39;, index=False)
    df_rest.drop(&#39;月份&#39;, axis=1).to_excel(writer, sheet_name=&#39;剩余月份&#39;, index=False)

from openpyxl import load_workbook
from openpyxl.styles import Border, Side, PatternFill, Font, GradientFill, Alignment

thin = Side(border_style=&quot;thin&quot;, color=&quot;000000&quot;)  # 定义边框粗细及颜色
wb = load_workbook(&quot;物料表_1.xlsx&quot;)
for sheetname in wb.sheetnames:
    ws = wb[sheetname]

    # 调整列宽
    ws.column_dimensions[&#39;A&#39;].width = 12
    ws.column_dimensions[&#39;C&#39;].width = 15.5
    ws.column_dimensions[&#39;G&#39;].width = 10

    # 设置字号，对齐，缩小字体填充，加边框
    for row_number in range(2, ws.max_row + 1):
        for col_number in range(1, ws.max_column + 1):
            c = ws.cell(row=row_number, column=col_number)
            c.font = Font(size=10)
            c.border = Border(top=thin, left=thin, right=thin, bottom=thin)
            c.alignment = Alignment(horizontal=&quot;left&quot;, vertical=&quot;center&quot;)
wb.save(&quot;物料表_1.xlsx&quot;)
</code></pre>
<p><a href="物料表.xlsx">物料表.xlsx</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>pandas</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>openpyxl</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>openpyxl | 从多路径多Excel表中获取数据并存入新表</title>
    <url>/2021/10/29/%E4%BB%8E%E5%A4%9A%E8%B7%AF%E5%BE%84%E5%A4%9AExcel%E8%A1%A8%E4%B8%AD%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%AD%98%E5%85%A5%E6%96%B0%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="从多路径多Excel表中获取数据并存入新表"><a href="#从多路径多Excel表中获取数据并存入新表" class="headerlink" title="从多路径多Excel表中获取数据并存入新表"></a>从多路径多Excel表中获取数据并存入新表</h1><p>实现代码：</p>
<pre><code>import os

work_path = os.getcwd() + &quot;\\资料&quot;  # 获取当前工作路径，指定“资料”文件夹
# 获取路径下所有.xlsx文件，并存入列表
pathss = []  # 存储文件夹内所有文件的路径（包括子目录内的文件）
for root, dirs, files in os.walk(work_path):
    path = [os.path.join(root, name) for name in files]  # 将目录和文件名连接起来，才是完整文件路径
    for i in range(len(path)):  # 遍历所有文件的地址
        if path[i].endswith(&quot;.xlsx&quot;):  # 只提取后缀为xlsx的文件
            pathss.append(path[i])

# 定义函数，获取Excel表格中的ID数据
from openpyxl import load_workbook  # 用于读取Excel中的信息


def Get_system_ID(file):
    wb = load_workbook(file)
    ws = wb.active

    ID_list = []
    for row in range(2, ws.max_row + 1):
        ID = ws[&quot;A&quot; + str(row)].value  # ID信息在A列
        if ID != None:  # 过滤空值
            ID_list.append(ID)
    return ID_list


# 获取数据，存入总列表
total_list = []
for file in pathss:
    info = Get_system_ID(file)
    total_list += info

# 写入数据到新的excel表，并设置格式
from openpyxl import Workbook
from openpyxl.styles import Font, colors, Alignment  # 字体，颜色，对齐
from openpyxl.styles import PatternFill  # 单元格填充

wb = Workbook()  # 新建Excel工作簿
ws = wb.active  # 使用活动工作表
ws.column_dimensions[&#39;A&#39;].width = 18.5  # 设定A列宽度
ws.cell(row=1, column=1, value=&quot;ID&quot;)  # 写入字段名
color_fill = PatternFill(fill_type=&#39;solid&#39;, fgColor=&quot;B3CFA1&quot;)  # 设置底色
ws.cell(row=1, column=1).fill = color_fill  # 填充底色

# 批量从列表中提取数据并写入
for row in range(1, len(total_list) + 1):
    ws.cell(row=row + 1, column=1, value=total_list[row - 1])

# 设置字号及对齐
font_set = Font(name=&#39;Arial&#39;, size=9)
for i in range(1, ws.max_row + 1):
    ws.cell(row=i, column=1).font = font_set
    ws.cell(row=i, column=1).alignment = Alignment(horizontal=&#39;left&#39;, vertical=&#39;center&#39;, shrink_to_fit=True)

wb.save(os.getcwd() + &quot;\\ID.xlsx&quot;)

print(f&quot;\n共获取到 &#123;len(pathss)&#125; 个 Excel表，共 &#123;len(total_list)&#125; 个ID。&quot;)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>openpyxl</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>os</tag>
        <tag>openpyxl</tag>
      </tags>
  </entry>
  <entry>
    <title>伪迹移除 | 伪迹去除方法比较总结</title>
    <url>/2021/02/25/%E4%BC%AA%E8%BF%B9%E5%8E%BB%E9%99%A4%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="伪迹去除方法比较总结"><a href="#伪迹去除方法比较总结" class="headerlink" title="伪迹去除方法比较总结"></a>伪迹去除方法比较总结</h1><p>1.(定性比较 or 定量比较)很难对不同伪迹去除方法基于它们去除伪迹的能力进行一个比较，通常只能做一个<b>定性(qualitative)</b>的比较<br>2.(自动 or 半自动)很多基于EEG的应用需要<b>自动信息处理</b>，尤其是一些对<b>在线/实时(需要效率很高的算法和足够低的计算复杂度)</b>有要求的应用。基于<b>BSS(盲源分离)</b>的方法通常是<b>半自动</b>的,因为伪迹成分的识别需要一些训练或参数选择/调整。涉及ICA的伪迹检测/去除方法需要另一个方法才能实现全过程的自动<br>3.(单通道 or 多通道)基于<b>盲源分离</b>的方法需要<b>多通道</b>才能起作用，通道数量越多，越能很好的分离出单个的源(这种方法不能用于低通道 e.g. 4-6或者基于单通道的应用)。基于<b>小波变换和经验模态分解</b>的方法可以通过将单个数据序列分解为多个成分进行<b>单通道</b>分析。<br>4.(参考信号)大多数方法需要参考信号。</p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>伪迹移除</category>
      </categories>
      <tags>
        <tag>伪迹移除</tag>
        <tag>EEG</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程 | 从浏览器访问百度的整个访问过程</title>
    <url>/2020/10/26/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BF%E9%97%AE%E7%99%BE%E5%BA%A6%E7%9A%84%E6%95%B4%E4%B8%AA%E8%AE%BF%E9%97%AE%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="从浏览器访问百度的整个访问过程"><a href="#从浏览器访问百度的整个访问过程" class="headerlink" title="从浏览器访问百度的整个访问过程"></a>从浏览器访问百度的整个访问过程</h1><h2 id="实际场景"><a href="#实际场景" class="headerlink" title="实际场景"></a>实际场景</h2><p>在浏览器的地址输入栏，输入<a href="http://www.baidu.com访问百度./">www.baidu.com访问百度。</a></p>
<h2 id="访问过程"><a href="#访问过程" class="headerlink" title="访问过程"></a>访问过程</h2><ol>
<li>1.先要解析出baidu.com对应的ip地址</li>
<ol>
<li>1.先要知道默认网关的MAC地址</li>
<ol>
<li>1.使用ARP获取默认网关的MAC地址</li>
</ol>
<li>2.组织数据发送给默认网关（IP还是DNS服务器的IP，但MAC地址是默认网关的MAC地址）</li>
<li>3.默认网关拥有转发数据的能力，把数据转发给路由器</li>
<li>4.路由器根据自己的路由协议来选择一个合适的较快的路径转发数据给目的网关</li>
<li>5.目的网关（DNS服务器所在的网关），把数据转发给DNS服务器</li>
<li>6.DNS服务器查询解析出baidu.com对应的IP地址，并把它原路返回给请求这个域名的客户端</li>
</ol>
<li>2.得到了baidu.com对应的IP地址后会发送TCP的3次握手，进行连接</li>
<li>3.使用HTTP协议发送请求数据给WEB服务器</li>
<li>4.WEB服务器收到请求数据之后，通过查询自己的服务器得到响应的结果，原路返回个浏览器</li>
<li>5.浏览器接收到数据后，通过浏览器自己的渲染功能来显示这个网页</li>
<li>6.浏览器关闭TCP连接，即4次挥手</li>
</ol>


]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程 | 使用tftp从服务器下载文件到客户端</title>
    <url>/2020/10/18/%E4%BD%BF%E7%94%A8tftp%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E5%88%B0%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
    <content><![CDATA[<h1 id="使用tftp协议从服务器下载文件到客户端"><a href="#使用tftp协议从服务器下载文件到客户端" class="headerlink" title="使用tftp协议从服务器下载文件到客户端"></a>使用tftp协议从服务器下载文件到客户端</h1><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code>import struct
from socket import *
import time
import os

def main():


    #0. 获取要下载的文件名字:
    downloadFileName = raw_input(&quot;请输入要下载的文件名:&quot;)    

    #1.创建socket
    udpSocket = socket(AF_INET, SOCK_DGRAM)

    requestFileData = struct.pack(&quot;!H%dsb5sb&quot;%len(downloadFileName), 1, downloadFileName, 0, &quot;octet&quot;, 0)

    #2. 发送下载文件的请求
    udpSocket.sendto(requestFileData, (&quot;192.168.119.215&quot;, 69))

    flag = True #表示能够下载数据，即不擅长，如果是false那么就删除
    num = 0
    f = open(downloadFileName, &quot;w&quot;)

    while True:
        #3. 接收服务发送回来的应答数据
        responseData = udpSocket.recvfrom(1024)

        # print(responseData)
        recvData, serverInfo = responseData

        opNum = struct.unpack(&quot;!H&quot;, recvData[:2])

        packetNum = struct.unpack(&quot;!H&quot;, recvData[2:4])

        print(packetNum[0])

        # print(&quot;opNum=%d&quot;%opNum)
        # print(opNum)

        # if 如果服务器发送过来的是文件的内容的话:
        if opNum[0] == 3: #因为opNum此时是一个元组(3,)，所以需要使用下标来提取某个数据
            

            #计算出这次应该接收到的文件的序号值，应该是上一次接收到的值的基础上+1
            num = num + 1

            # 如果一个下载的文件特别大，即接收到的数据包编号超过了2个字节的大小
            # 那么会从0继续开始，所以这里需要判断，如果超过了65535 那么就改为0
            if num==65536:
                num = 0

            # 判断这次接收到的数据的包编号是否是 上一次的包编号的下一个
            # 如果是才会写入到文件中，否则不能写入（因为会重复）
            if num == packetNum[0]:
                # 把收到的数据写入到文件中
                f.write(recvData[4:])
                num = packetNum[0]

            #整理ACK的数据包
            ackData = struct.pack(&quot;!HH&quot;, 4, packetNum[0])
            udpSocket.sendto(ackData, serverInfo)

        elif opNum[0] == 5:
            print(&quot;sorry，没有这个文件....&quot;)
            flag = False

        # time.sleep(0.1)

        if len(recvData)&lt;516:
            break

    if flag == True:
        f.close()
    else:
        os.unlink(downloadFileName)#如果没有要下载的文件，那么就需要把刚刚创建的文件进行删除

if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>tftp</tag>
      </tags>
  </entry>
  <entry>
    <title>openpyxl | 修改excel表中的单元格内容</title>
    <url>/2021/10/16/%E4%BF%AE%E6%94%B9excel%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%8D%95%E5%85%83%E6%A0%BC%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<h1 id="修改excel表中的单元格内容"><a href="#修改excel表中的单元格内容" class="headerlink" title="修改excel表中的单元格内容"></a>修改excel表中的单元格内容</h1><p>以下代码实现了修改 领料单（每日）.xlsx 中的所有表中某单元格的内容。</p>
<span id="more"></span>

<pre><code>from openpyxl import load_workbook

wb = load_workbook(&quot;领料单（每日）.xlsx&quot;)
print(wb.sheetnames)

for sheet_name in wb.sheetnames:  # 遍历每个工作表，更改A4单元格的数据
    print(sheet_name)
    ws = wb[sheet_name]
    ws[&#39;A4&#39;].value = &quot;零件测试领料单&quot; #直接将A4单元格的值改为需要的

wb.save(&quot;资料单（每日）-更改后.xlsx&quot;)
</code></pre>
<p><a href="https://blog.csdn.net/weixin_41546513/article/details/109555832">openpyxl参考资料</a><br><a href="https://openpyxl.readthedocs.io/en/stable/index.html">openpyxl官方文档</a><br><a href="领料单（每日）.xlsx">下载领料单（每日）.xlsx</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>openpyxl</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>openpyxl</tag>
      </tags>
  </entry>
  <entry>
    <title>免费看视频</title>
    <url>/2021/06/19/%E5%85%8D%E8%B4%B9%E7%9C%8B%E8%A7%86%E9%A2%91/</url>
    <content><![CDATA[<h1 id="免费看视频"><a href="#免费看视频" class="headerlink" title="免费看视频"></a>免费看视频</h1><p><b>在视频链接前加wn.run/</b></p>
]]></content>
      <tags>
        <tag>免费看视频</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习 | 决策树</title>
    <url>/2021/02/22/%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    <content><![CDATA[<h1 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h1><p>决策树(Decision Tree)是一种基本的<b>分类与回归方法</b>。决策树由结点(Node)和有向边(Directed Edge)组成。结点有两种类型：内部结点(Internnal Node)和叶结点(Leaf Node)。内部结点表示一个特征或属性，叶结点表示一个类。决策树还有一个唯一的根结点(Root Node)。</p>
<p>我们可以把<b>决策树</b>看成一个<b>if-then规则的集合</b>,将决策树转换成if-then规则的过程是这样的：<br><br>由决策树的根结点到叶结点的每一条路径构建一条规则；路径上内部结点的特征对应着规则的条件，而叶结点对应着规则的结论。<br><br>决策树的路径或其对应的if-then规则集合具有一个重要性质：<b>互斥并且完备</b>(每一个实例都只能被一条路径或一条规则所覆盖(覆盖：实例的特征与路径上的特征一致或实例满足规则的条件))。<br></p>
<h2 id="决策树做预测的步骤"><a href="#决策树做预测的步骤" class="headerlink" title="决策树做预测的步骤"></a>决策树做预测的步骤</h2><p>1.收集数据<br>2.准备数据(将收集的数据按照一定规则整理出来,方便后续进行处理)<br>3.分析数据(在决策树构造完成后，检查决策树图形是否符合预期)<br>4.训练算法(构造决策树/决策树学习—&gt;构造一个决策树的数据结构)<br>5.测试算法(使用经验树计算错误率。当错误率达到可接受范围，这个决策树就可以投放使用)<br>6.使用算法(<b>决策树可以更好地理解数据的内在含义</b>)</p>
<h2 id="如何构建决策树？—构建决策树的3个步骤"><a href="#如何构建决策树？—构建决策树的3个步骤" class="headerlink" title="如何构建决策树？—构建决策树的3个步骤"></a>如何构建决策树？—构建决策树的3个步骤</h2><h3 id="1-特征选择"><a href="#1-特征选择" class="headerlink" title="1.特征选择"></a>1.特征选择</h3><p><b>特征选择就是决定用哪个特征来划分特征空间</b><br><b>特征选择在于选取训练数据具有分类能力的特征</b><br>特征选择的标准：信息增益(Information Gain)/信息增益比。信息增益：在划分数据集之后信息发生的变化。<br><b style="color:red">Note:信息增益最高的特征是最好的选择</b></p>
<h4 id="1-1香农熵-熵-信息论之父克劳德-香农：集合信息的度量方式。"><a href="#1-1香农熵-熵-信息论之父克劳德-香农：集合信息的度量方式。" class="headerlink" title="1.1香农熵(熵)-信息论之父克劳德.香农：集合信息的度量方式。"></a>1.1香农熵(熵)-信息论之父克劳德.香农：集合信息的度量方式。</h4><p>熵定义为信息的期望值。在信息论与概率论中，熵是表示随机变脸不确定性的度量。如果待分类的事物可能划分在多个分类之中，则符号xi的信息定义为：<br><br><img src="/2021/02/22/%E5%86%B3%E7%AD%96%E6%A0%91/1.png"><br>其中p(xi)是该分类的概率。<br><br>通过上式，我们可以得到所有类别的信息。为了计算<b>熵，我们需要计算所有类别所有可能值包含的信息期望值</b>(<b>数学期望-反应随机变量平均取值的大小<b>)，公式如下：<br><br><img src="/2021/02/22/%E5%86%B3%E7%AD%96%E6%A0%91/2.png"><br>其中n是分类的数目。<b>熵越大，随机变量的不确定性就越大。</b></b></b></p>
<p>当熵中的概率由数据估计(特别是最大似然估计-Maximum Likelihood Estimation)得到时，所对应的熵称为<b>经验熵</b>(Empirical Entropy)</p>
<p>我们定义样本数据表中的数据为训练数据集D，则训练数据集D的经验熵为H(D)，|D|表示其样本容量，及样本个数。设有K个类Ck, = 1,2,3,…,K,|Ck|为属于类Ck的样本个数，因此经验熵公式就可以写为 ：<br><img src="/2021/02/22/%E5%86%B3%E7%AD%96%E6%A0%91/3.png"></p>
<h4 id="1-2信息增益"><a href="#1-2信息增益" class="headerlink" title="1.2信息增益"></a>1.2信息增益</h4><p>如何选择特征，需要看信息增益。也就是说，信息增益是相对特征而言的，信息增益越大，特征对最终的分类结果影响也就越大，我们就应该选择对最终分类结果影响最大的那个特征作为我们的分类特征。</p>
<p><b>条件熵H(Y|X)</b>表示在一直随机变量X的条件下随机变量Y的不确定性，随机变量X给定条件下随机变量Y的条件熵(Conditional Entropy)H(Y|X)，定义为X给定条件下Y的条件概率分布的熵对X的数学期望：<br><img src="/2021/02/22/%E5%86%B3%E7%AD%96%E6%A0%91/4.jpg"><br><img src="/2021/02/22/%E5%86%B3%E7%AD%96%E6%A0%91/5.jpg"><br>当条件熵中的概率由数据估计(特别是极大似然估计)得到时，岁对应的条件熵称为<b>条件经验熵</b>(empirical conditional entropy)。</p>
<p>特征A对训练数据集D的信息增益g(D,A)，定义为集合D的经验熵H(D)与特征A给定条件下D的经验条件熵H(D|A)之差，即：<br><img src="/2021/02/22/%E5%86%B3%E7%AD%96%E6%A0%91/6.jpg"><br><b>Note:</b>一般地，熵H(D)与条件熵H(D|A)之差称为互信息(mutual information)。决策树学习中的信息增益等价于训练数据集中类与特征的互信息。</p>
<p>设特征A有n个不同的取值{a1,a2,···,an}，根据特征A的取值将D划分为n个子集{D1,D2，···,Dn}，|Di|为Di的样本个数。记子集Di中属于Ck的样本的集合为Dik，即Dik = Di ∩ Ck，|Dik|为Dik的样本个数。于是经验条件熵的公式可以些为：<br><img src="/2021/02/22/%E5%86%B3%E7%AD%96%E6%A0%91/7.jpg"></p>
<h2>总结</h2>
<h3>决策树的一些优点</h3>
1.<b>易于理解和解释</b>。决策树可以<b>可视化</b>。<br>
2.<b>几乎不需要数据预处理</b>。其他方法经常需要数据标准化，创建虚拟变量和删除缺失值。决策树还不支持缺失值。<br>
3.使用树的<b>花费</b>(例如预测数据)是训练数据点(data points)数量的<b>对数</b>。<br>
4.可以<b>同时处理数值变量和分类变量</b>。其他方法大都适用于分析一种变量的集合。<br>
5.可以处理<b>多值输出</b>变量问题<br>
6.使用<b>白盒模型</b>.如果一个情况被观察到，使用逻辑判断容易表示这种规则。相反，如果是<b>黑盒模型</b>(例如<b>人工神经网络</b>)，结果会非常<b>难解释</b>。<br>
7.即使对真实模型来说，假设无效的情况下，也可以较好的使用<br>
<h3>决策树的一些缺点</h3>
1.决策树学习可能创建一个过于复杂的树，并不能很好的预测数据。也就是<b>过拟合</b>。修剪机制（现在不支持），<b>设置一个叶子节点需要的最小样本数量，或者数的最大深度，可以避免过拟合</b>。<br>
2.<b>决策树可能是不稳定的</b>，因为即使非常小的变异，可能会产生一颗完全不同的树。这个问题通过decision trees with an ensemble来缓解。<br>
3.<b>概念难以学习</b>，因为决策树没有很好的解释他们，例如，XOR, parity or multiplexer problems(奇偶校验或多路复用器问题)。<br>
4.<b>如果某些分类占优势，决策树将会创建一棵有偏差的树</b>。因此，建议在训练之前，先抽样使样本均衡。<br>

<p><a href="https://cuijiahua.com/blog/2017/11/ml_2_decision_tree_1.html">参考资源1</a><br><a href="https://cuijiahua.com/blog/2017/11/ml_3_decision_tree_2.html">参考资源2</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>Decision Tree</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>决策树</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 关于python or numpy在实现神经网络中的一些建议</title>
    <url>/2021/06/21/%E5%85%B3%E4%BA%8Epython-or-numpy%E5%9C%A8%E5%AE%9E%E7%8E%B0%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BB%BA%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="关于python-or-numpy在实现神经网络中的一些建议"><a href="#关于python-or-numpy在实现神经网络中的一些建议" class="headerlink" title="关于python or numpy在实现神经网络中的一些建议"></a>关于python or numpy在实现神经网络中的一些建议</h1><p>在编写神经网络时：<br>1.不要使用秩为1的一维数组<br>2.总是使用n x 1维矩阵(列向量-column vector)或者1 X n维矩阵(行向量-row vector)<br>3.敢于使用reshape()来确保你的矩阵或向量所需要的维数<br>4.在不完全确定一个向量的维维度时使用assert()语句<br>（Python assert（断言）用于判断一个表达式，在表达式条件为 false 的时候触发异常。<br>断言可以在条件不满足程序运行的情况下直接返回错误，而不必等待程序运行后出现崩溃的情况。）</p>
<p><b>demo:</b></p>
<pre><code>a = np.random.randn(5) # Don&#39;t use
# a.shape = (5,) # rank 1 array

a = np.random.randn(5,1) # a.shape=(5,1) column vector

a = np.random.randn(1,5) # a.shape=(1,5) row vector

assert(a.shape == (5,1))

a = a.reshape((5,1))
</code></pre>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程 | 几种web服务器的比较</title>
    <url>/2020/10/31/%E5%87%A0%E7%A7%8Dweb%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<h1 id="几种web服务器的比较"><a href="#几种web服务器的比较" class="headerlink" title="几种web服务器的比较"></a>几种web服务器的比较</h1><h2 id="select版服务器"><a href="#select版服务器" class="headerlink" title="select版服务器"></a>select版服务器</h2><p>优点：跨平台<br>缺点：<br>单个进程能够监视的文件描述符的数量存在最大限制（1024）<br>轮询检测，效率较低</p>
<h2 id="poll版服务器"><a href="#poll版服务器" class="headerlink" title="poll版服务器"></a>poll版服务器</h2><p>优点：解决了套接字有上限的问题<br>缺点：轮询检测</p>
<h2 id="epoll版服务器"><a href="#epoll版服务器" class="headerlink" title="epoll版服务器"></a>epoll版服务器</h2><p>优点：<br>没有1024的最大限制<br>事件通知机制，效率较高</p>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>python | 函数</title>
    <url>/2021/08/05/%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="python中的函数"><a href="#python中的函数" class="headerlink" title="python中的函数"></a>python中的函数</h1><p>python中的三种函数<br>1.函数：定义在模块中类之外的函数<br><strong>示例：</strong></p>
<pre><code>def add(a, b):
    res = a + b
    return res
</code></pre>
<p>2.嵌套函数：定义在函数中的函数<br><strong>示例：</strong></p>
<pre><code>def func1():
    def func2():
        pass
    ...
</code></pre>
<p>3.方法：定义在类中<br><strong>示例：</strong></p>
<pre><code>class A(object)：
    def _ _init_ _(self):   # 构造函数
        pass

    def a(self,...):   # 实例方法
        pass
    
    @classmethod
    def b(cls,...):  # 类方法
        pass
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 划分数据集前对数据的shuffle</title>
    <url>/2021/07/02/%E5%88%92%E5%88%86%E6%95%B0%E6%8D%AE%E9%9B%86%E5%89%8D%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%9A%84shuffle/</url>
    <content><![CDATA[<h1 id="划分数据集前对数据的shuffle"><a href="#划分数据集前对数据的shuffle" class="headerlink" title="划分数据集前对数据的shuffle"></a>划分数据集前对数据的shuffle</h1><p>划分数据集前对数据集和标签的shuffle很重要！！！划分数据集前对数据集和标签的shuffle很重要！！！划分数据集前对数据集和标签的shuffle很重要！！！<br>重要的事情说三遍！</p>
<p>shuffle对模型的accuracy有较大的影响，因此在将数据输入模型之前应该将数据集进行shuffle!</p>
<p><a href="https://blog.csdn.net/qq_38412868/article/details/85473973">Python如何打乱训练数据集顺序的几种方法</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Django | 创建模型对象的两种方式</title>
    <url>/2021/07/26/%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="创建模型对象的两种方式"><a href="#创建模型对象的两种方式" class="headerlink" title="创建模型对象的两种方式"></a>创建模型对象的两种方式</h1><p>使用关键字构造模型对象非常麻烦，一下介绍两种创建对象的方式。</p>
<span id="more"></span>

<p><strong>方式一：在模型类中增加一个类方法—不推荐使用</strong></p>
<pre><code>class ExampleModel(models.Model):
    ...
    @classmethod
    def create(cls, attr1, attr2, ...):
        e = ExampleModel()
        e.attr1 = attr1
        e.attr2 = attr2
        ...
        return e
</code></pre>
<p><strong>方式二：在自定义管理器中添加一个方法—推荐使用</strong></p>
<pre><code>class ExampleModelManager(models.Manager):
    def create(self, attr1, attr2, ...):
        e = ExampleModel()  # 使用在方式一中定义的模型类ExampleModel
        e.attr1 = attr1
        e.attr2 = attr2
        ...
        return e
        
</code></pre>
<p>**Note:**管理器是模型类的属性，用于将对象与数据表映射</p>
]]></content>
      <categories>
        <category>python</category>
        <category>框架</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 删除有序链表中的重复元素</title>
    <url>/2021/08/27/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="83-删除有序链表中的重复元素"><a href="#83-删除有序链表中的重复元素" class="headerlink" title="83.删除有序链表中的重复元素"></a>83.删除有序链表中的重复元素</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 只出现一次 。<br>返回同样按升序排列的结果链表。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>一次遍历法<br>由于链表是按照升序排序的链表，所有重复的元素是相邻的，我们只需遍历一次链表，并判断当前节点与当前节点的后一节点所对应元素是否相等，<br>如果相等则将后者删除，如果不相等，工作指针继续后移，…，以此类推，当遍历完整个链表之后，我们返回链表的头节点即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def deleteDuplicates(self, head):
        &quot;&quot;&quot;
        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        # prev = head
        # p = prev.next
        #
        # while p is not None:  #
        #     if prev.val == p.val:
        #         p = p.next
        #         prev.next = p
        #     else:
        #         prev = prev.next
        #         p = p.next
        #
        # return head


        if not head:
            return head

        cur = head
        while cur.next:
            if cur.val == cur.next.val:
                cur.next = cur.next.next
            else:
                cur = cur.next

        return head

    def create_linked_list(self, list):
        &quot;&quot;&quot;根据list中的所有元素构建单链表&quot;&quot;&quot;
        l = ListNode()  # 单链表头节点
        r = l  # 起始尾指针r指向头节点
        for e in list:
            node = ListNode(e)
            r.next = node
            r = r.next

        return l.next

    def print_linked_list(self, linked_list) -&gt; None:
        &quot;&quot;&quot;
        打印单链表中的所有元素

        :param linked_list: 单链表
        :return: 无
        &quot;&quot;&quot;
        print(&quot;----------------------------------------&quot;)
        pointer = linked_list
        while pointer is not None:
            print(pointer.val)
            pointer = pointer.next


if __name__ == &quot;__main__&quot;:
    slt = Solution()
    l1 = slt.create_linked_list([1, 1, 2, 3, 3])
    l = slt.deleteDuplicates(l1)
    slt.print_linked_list(l)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 删除链表元素</title>
    <url>/2021/08/27/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="203-删除链表元素"><a href="#203-删除链表元素" class="headerlink" title="203.删除链表元素"></a>203.删除链表元素</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.递归<br>链表的定义具有递归的性质，因此链表题目常可以用递归的方法求解。<br>对于给定的链表，首先对除了头节点 head 以外的节点进行删除操作，然后判断 head 的节点值是否等于给定的 val。如果 head 的节点值等于 val，则 head 需要被删除，因此删除操作后的头节点为 head.next；如果 head 的节点值不等于 val，则 head\ 保留，因此删除操作后的头节点还是 head。<br>递归的终止条件是 head 为空，此时直接返回 head。当 head 不为空时，递归地进行删除操作，然后判断 head 的节点值是否等于 val 并决定是否要删除 head。<br>2.迭代<br>用 temp 表示当前节点。如果 temp 的下一个节点不为空且下一个节点的节点值等于给定的 val，则需要删除下一个节点。删除下一个节点可以通过以下做法实现：<br>temp.next=temp.next.next<br>如果 temp 的下一个节点的节点值不等于给定的 val，则保留下一个节点，将 temp 移动到下一个节点即可。<br>当 temp 的下一个节点为空时，链表遍历结束，此时所有节点值等于 val 的节点都被删除。<br>具体实现方面，由于链表的头节点 head 有可能需要被删除，因此创建哑节点 dummyHead，令 dummyHead.next=head，初始化 temp=dummyHead，然后遍历链表进行删除操作。最终返回 dummyHead.next 即为删除操作后的头节点。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def removeElements(self, head, val):
        &quot;&quot;&quot;
        移除单链表head中所有值为val的节点（迭代法）

        时间复杂度：O(n)
        空间复杂度：O(1)

        :type head: ListNode
        :type val: int
        :rtype: ListNode
        &quot;&quot;&quot;
        # # 为单链表怎加一个头节点
        # head_node = ListNode()
        # head_node.next = head
        #
        # # 定义工作指针p和工作指针的前一个节点指针prev
        # prev = head_node  # prev指向头节点
        # p = prev.next  # p指向链表的第一个节点
        #
        # while p is not None:
        #     if p.val == val:
        #         prev.next = p.next
        #         p = p.next
        #     else:
        #         prev = p
        #         p = p.next
        #
        # return head_node.next

        dummyHead = ListNode()
        dummyHead.next = head
        temp = dummyHead

        while temp.next is not None:
            if temp.next.val == val:
                temp.next = temp.next.next
            else:
                temp = temp.next
        return dummyHead.next

    def removeElements1(self, head, val):
        &quot;&quot;&quot;
        移除单链表head中所有值为val的节点（递归法）

        时间复杂度：O(n)
        空间复杂度：O(n)

        :param head:
        :param val:
        :return:
        &quot;&quot;&quot;
        if head is None:
            return head

        head.next = self.removeElements1(head.next, val)

        return head.next if head.val == val else head

    def create_linked_list(self, list):
        &quot;&quot;&quot;根据list中的所有元素构建单链表&quot;&quot;&quot;
        l = ListNode()  # 单链表头节点
        r = l  # 起始尾指针r指向头节点
        for e in list:
            node = ListNode(e)
            r.next = node
            r = r.next

        return l.next

    def print_linked_list(self, linked_list) -&gt; None:
        &quot;&quot;&quot;
        打印单链表中的所有元素

        :param linked_list: 单链表
        :return: 无
        &quot;&quot;&quot;
        print(&quot;----------------------------------------&quot;)
        pointer = linked_list
        while pointer is not None:
            print(pointer.val)
            pointer = pointer.next


if __name__ == &quot;__main__&quot;:
    slt = Solution()

    linked_list = slt.create_linked_list([1, 2, 6, 3, 4, 5, 6])
    # linked_list = slt.create_linked_list([7, 7, 7, 7])

    slt.print_linked_list(linked_list)

    deleted_linked_list = slt.removeElements1(linked_list, 6)

    slt.print_linked_list(deleted_linked_list)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>算法刷题 | 刷题笔记</title>
    <url>/2021/06/24/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="刷题笔记"><a href="#刷题笔记" class="headerlink" title="刷题笔记"></a>刷题笔记</h1><p><a href="https://github.com/CyC2018/CS-Notes">刷题笔记1</a></p>
<p><a href="https://github.com/Jack-Cherish/LeetCode">刷题笔记2</a></p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 前向传播和反向传播中使用的cache</title>
    <url>/2021/06/30/%E5%89%8D%E5%90%91%E4%BC%A0%E6%92%AD%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84cache/</url>
    <content><![CDATA[<h1 id="前向传播和反向传播中使用的cache"><a href="#前向传播和反向传播中使用的cache" class="headerlink" title="前向传播和反向传播中使用的cache"></a>前向传播和反向传播中使用的cache</h1><p>the “cache” records values from the forward propagation units and sends it to the backward<br>propagation units because it is needed to compute the chain rule derivatives.(“cache”记录<br>来自正向传播单元的值并将其发送到反向传播单元，因为需要链式计算导数。)</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>前向传播</tag>
        <tag>反向传播</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程 | 单任务服务器的缺点</title>
    <url>/2020/10/30/%E5%8D%95%E4%BB%BB%E5%8A%A1%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BC%BA%E7%82%B9/</url>
    <content><![CDATA[<h1 id="单任务服务器的缺点"><a href="#单任务服务器的缺点" class="headerlink" title="单任务服务器的缺点"></a>单任务服务器的缺点</h1><p><b style="color:red">为一个顾客服务的时候，不能为其他顾客服务</b><br><strong>注意点</strong>：accept()、recv()</p>
<span id="more"></span>

<pre><code>import socket 

serverSocket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
serverSocket.bind((&#39;&#39;,8080))
serverSocket.listen(5)

while True:
    #如果没有客户端到来，程序将阻塞等待
    clientSocket,clientAddr = serverSocket.accept()
    
    while True:
        #有一个客户端到来，将一直等待客户端发数据,若客户端一直不发数据，程序将一直卡在这里,从而造成程序不能处理新的客户端的请求
        recvData = newSocket.recv(1024)
        if data:
            print(&quot;%s:%s&quot;%(str(clientAddr),recvData))
        else:
            break
</code></pre>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>python | 匹配第n个分组的内容</title>
    <url>/2021/08/28/%E5%8C%B9%E9%85%8D%E7%AC%ACn%E4%B8%AA%E5%88%86%E7%BB%84%E7%9A%84%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<h1 id="1…-9"><a href="#1…-9" class="headerlink" title="\1…\9"></a>\1…\9</h1><p>\1…\9用来匹配与第n(1~9)个分组的内容，必须与()配合使用<br>例：在以下代码段中\2表示匹配第2个分组（一个括号代表一个分组）的内容，即\2匹配”world”字符串</p>
<pre><code>import re
string = &quot;helloworld world&quot;
pattern = r&#39;^(\w+)(world) \2$&#39;
print(re.search(pattern, string))
</code></pre>
<p><a href="https://www.jianshu.com/p/8a4ce87ef4b2">参考资料</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>内置模块</category>
        <category>re</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>re</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 单词规律</title>
    <url>/2021/09/08/%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B/</url>
    <content><![CDATA[<h1 id="290-单词规律"><a href="#290-单词规律" class="headerlink" title="290.单词规律"></a>290.单词规律</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。<br>这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。</p>
<p>示例1:<br>输入: pattern = “abba”, str = “dog cat cat dog”<br>输出: true</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/word-pattern/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.哈希表<br>在本题中，我们需要判断字符与字符串之间是否恰好一一对应。即任意一个字符都对应着唯一的字符串，任意一个字符串也只被唯一的一个字符对应。在集合论中，这种关系被称为「双射」。<br>想要解决本题，我们可以利用哈希表记录每一个字符对应的字符串，以及每一个字符串对应的字符。然后我们枚举每一对字符与字符串的配对过程，不断更新哈希表，如果发生了冲突，则说明给定的输入不满足双射关系。<br>在实际代码中，我们枚举 pattern 中的每一个字符，利用双指针来均摊线性地找到该字符在 str 中对应的字符串。每次确定一个字符与字符串的组合，我们就检查是否出现冲突，最后我们再检查两字符串是否比较完毕即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):
    def wordPattern(self, pattern, s):
        &quot;&quot;&quot;
        :type pattern: str
        :type s: str
        :rtype: bool
        &quot;&quot;&quot;
        word2ch = dict()
        ch2word = dict()
        words = s.split()
        if len(pattern) != len(words):
            return False

        for ch, word in zip(pattern, words):
            if (word in word2ch and word2ch[word] != ch) or (ch in ch2word and ch2word[ch] != word):
                return False
            word2ch[word] = ch
            ch2word[ch] = word

        return True

    def wordPattern(self, pattern, s):
        dct = dict()
        s = s.split(&#39; &#39;)
        if len(s) != len(pattern):  # 两个字符串长度不相同，返回False
            return False

        for i in range(len(pattern)):
            if pattern[i] not in dct:  # 如果pattern[i]不在字典中，此时要加入pattern[i]
                if s[i] not in dct.values():  # 如果s[i]还未存在，则加入新的映射
                    dct[pattern[i]] = s[i]
                else:
                    return False  # 但是如果与dct[pattern[i]]对应的s[i]已经存在字典的值中，说明不是唯一映射
            else:
                if dct[pattern[i]] != s[i]:  # 如果pattern[i]在字典中，但是dct[pattern[i]]的值不等于s[i]，说明已存在其他映射
                    return False
        return True



if __name__ == &#39;__main__&#39;:
    slt = Solution()
    res = slt.wordPattern1(&quot;abba&quot;, &quot;dog cat cat dog&quot;)
    print(res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>哈希表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>CNN | 卷积神经网络如何处理一维时间序列数据</title>
    <url>/2021/10/26/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%B8%80%E7%BB%B4%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="卷积神经网络如何处理一维时间序列数据"><a href="#卷积神经网络如何处理一维时间序列数据" class="headerlink" title="卷积神经网络如何处理一维时间序列数据?"></a>卷积神经网络如何处理一维时间序列数据?</h1><p><a href="https://zhuanlan.zhihu.com/p/67496559">卷积神经网络如何处理一维时间序列数据?</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
        <category>CNN</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>CNN</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 反转字符串</title>
    <url>/2021/08/29/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。<br>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。<br>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p>
<span id="more"></span>
<p>示例 1：<br>输入：[“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]</p>
<p><a href="https://leetcode-cn.com/problems/reverse-string">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.字符串切片 —&gt; reversString()<br>2.使用list.reverse()方法 —&gt; reversString1()<br>3.使用reversed()函数 —&gt; reversString2()<br>4.使用栈 —&gt; reversString3()<br>将s列表看作一个栈，低端作为栈底，高端作为栈顶，依次将栈顶元素出栈即可。<br>5.for —&gt; reversString4()<br>将列表中的第i个元素与倒数第i个元素交换（0&lt; i &lt; len(s)//2）<br>6.递归 —&gt; reversString5()</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):
    def reverseString(self, s):
        &quot;&quot;&quot;
        :type s: List[str]
        :rtype: None Do not return anything, modify s in-place instead.
        &quot;&quot;&quot;
        return s[::-1]

    def reverseString1(self, s):
        s.reverse()

    def reverseString2(self, s):
        s[:] = list(reversed(s))

    def reverseString3(self, s):
        result = list()

        while len(s) &gt; 0:
            result.append(s.pop())

        s[:] = result

    def reverseString4(self, s):
        for i in range(len(s)//2):
            s[i], s[len(s) - i - 1] = s[len(s) - i - 1], s[i]

    # def reverseString5(self, s):
    #     if len(s) &lt; 1:
    #         return s
    #     return self.reverseString4(s[1:]) + s[0]
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 反转字符串2</title>
    <url>/2021/09/01/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B22/</url>
    <content><![CDATA[<h1 id="541-反转字符串2"><a href="#541-反转字符串2" class="headerlink" title="541.反转字符串2"></a>541.反转字符串2</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串 s 和一个整数 k，从字符串开头算起，每 2k 个字符反转前 k 个字符。<br>    如果剩余字符少于 k 个，则将剩余字符全部反转。<br>    如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p>
<span id="more"></span>
<p>示例 1：<br>输入：s = “abcdefg”, k = 2<br>输出：”bacdfeg”</p>
<p><a href="https://leetcode-cn.com/problems/reverse-string-ii/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>反转每个下标从 2k 的倍数开始的，长度为 k 的子串。若该子串长度不足 k，则反转整个子串</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def reverseStr(self, s: str, k: int) -&gt; str:
        t = list(s)
        for i in range(0, len(t), 2 * k):
            t[i: i + k] = reversed(t[i: i + k])
        return &quot;&quot;.join(t)


if __name__ == &#39;__main__&#39;:
    slt = Solution()
    s = &quot;abcdefg&quot;
    k = 2
    res = slt.reverseStr(s, k)  # bacdfeg
    print(res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 反转字符串中的元音字母</title>
    <url>/2021/09/01/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D/</url>
    <content><![CDATA[<h1 id="345-反转字符串中的元音字母"><a href="#345-反转字符串中的元音字母" class="headerlink" title="345.反转字符串中的元音字母"></a>345.反转字符串中的元音字母</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 s ，仅反转字符串中的所有元音字母，并返回结果字符串。<br>元音字母包括 ‘a’、’e’、’i’、’o’、’u’，且可能以大小写两种形式出现。</p>
<span id="more"></span>

<p><a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string">题目链接</a>+</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.先将字符串中的元音字母的位置找出来，然后再将各元音字母反转<br>2.双指针<br>我们可以使用两个指针 i 和 j 对字符串相向地进行遍历。<br>具体地，指针 i 初始时指向字符串 s 的首位，指针 j 初始时指向字符串 s 的末位。在遍历的过程中，我们不停地将 i 向右移动，直到 i 指向一个元音字母（或者超出字符串的边界范围）；同时，我们不停地将 j 向左移动，直到 j 指向一个元音字母。此时，如果 i&lt;j，那么我们交换 i 和 j 指向的元音字母，否则说明所有的元音字母均已遍历过，就可以退出遍历的过程。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def reverseVowels(self, s: str) -&gt; str:
        &quot;&quot;&quot;
        find ans reverse
        :param s:
        :return:
        &quot;&quot;&quot;
        vowels = list()
        s = list(s)
        for i in range(len(s)):
            ch = s[i].lower()
            if ch == &#39;a&#39; or ch == &#39;e&#39; or ch == &#39;i&#39; or ch == &#39;o&#39; or ch == &#39;u&#39;:
                vowels.append(i)

        for i in range(len(vowels)//2):
            s[vowels[i]], s[vowels[len(vowels) - i -1]] = s[vowels[len(vowels) - i -1]], s[vowels[i]]

        return &#39;&#39;.join(s)

    def reverseVowels1(self, s: str) -&gt; str:
        &quot;&quot;&quot;双指针&quot;&quot;&quot;
        def isVowel(ch: str) -&gt; bool:
            return ch in &quot;aeiouAEIOU&quot;

        n = len(s)
        s = list(s)
        i, j = 0, n - 1
        while i &lt; j:
            while i &lt; n and not isVowel(s[i]):
                i += 1
            while j &gt; 0 and not isVowel(s[j]):
                j -= 1
            if i &lt; j:
                s[i], s[j] = s[j], s[i]
                i += 1
                j -= 1

        return &#39;&#39;.join(s)


if __name__ == &quot;__main__&quot;:
    s = Solution()
    string = &quot;hello&quot;
    res = s.reverseVowels(string)
    print(res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 反转字符串中的单词3</title>
    <url>/2021/09/02/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D3/</url>
    <content><![CDATA[<h1 id="557-反转字符串中的单词3"><a href="#557-反转字符串中的单词3" class="headerlink" title="557.反转字符串中的单词3"></a>557.反转字符串中的单词3</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p>
<span id="more"></span>
<p>示例：<br>输入：”Let’s take LeetCode contest”<br>输出：”s’teL ekat edoCteeL tsetnoc”</p>
<p><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.将字符串按照空格划分开得到字符串中的每一个单词,然后将每个单词反转<br>，在将反转后的所有单词用空格拼接起来<br>2.使用额外空间<br>开辟一个新字符串。然后从头到尾遍历原字符串，直到找到空格为止，此时找到了一个单词，并能得到单词的起止位置。随后，根据单词的起止位置，可以将该单词逆序放到新字符串当中。如此循环多次，直到遍历完原字符串，就能得到翻转后的结果。<br>3.原地解法<br>此题也可以直接在原字符串上进行操作，避免额外的空间开销。当找到一个单词的时候，我们交换字符串第一个字符与倒数第一个字符，随后交换第二个字符与倒数第二个字符……如此反复，就可以在原空间上翻转单词。<br>需要注意的是，原地解法在某些语言（比如 Java，JavaScript，python）中不适用，因为在这些语言中 String 类型是一个不可变的类型。<br>在python中可以先将字符串转为列表然后进行算法设计。</p>
<p><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/solution/python-fan-zhuan-zi-fu-chuan-zhong-dan-ci-si-lu-xi/">更多思路参考“一行流”，简直牛逼！！！</a></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def reverseWords(self, s: str) -&gt; str:
        &quot;&quot;&quot;
        将字符串按照空格划分开得到字符串中的每一个单词
        将每个单词反转
        将反转后的所有单词用空格拼接起来
        &quot;&quot;&quot;
        words = s.split(&#39; &#39;)
        reversed_words = []
        for word in words:
            reversed_words.append(self.reverseStr(word))
        return &#39; &#39;.join(reversed_words)

    def reverseStr(self, s: str) -&gt; str:
        s = list(s)
        s[:] = s[::-1]
        return &#39;&#39;.join(s)

    def reverseWords2(self, s: str) -&gt; str:
        &quot;&quot;&quot;使用额外空间&quot;&quot;&quot;
        ret = &#39;&#39;
        length = len(s)
        i = 0
        while i &lt; length:
            start = i
            # 遍历字符串找到空格位置（找到了一个单词）
            while i &lt; length and s[i] != &#39; &#39;:
                i += 1
            # 根据单词的起止位置，可以将该单词逆序放到新字符串当中
            for p in range(start, i):
                ret += s[start + i - 1 - p]
            # 拼上单词后的空格
            while i &lt; length and s[i] == &#39; &#39;:
                i += 1
                ret += &#39; &#39;

        return ret

    def reverseWords3(self, s: str) -&gt; str:
        s = list(s)  # python中字符串为不可变类型，不支持原地修改，可转列表
        length = len(s)
        i = 0
        while i &lt; length:
            start = i

            while i &lt; length and s[i] != &#39; &#39;:
                i += 1

            left = start
            right = i - 1
            while left &lt; right:
                s[left], s[right] = s[right], s[left]
                left += 1
                right -= 1

            while i &lt; length and s[i] == &#39; &#39;:
                i += 1
        return &#39;&#39;.join(s)


if __name__ == &quot;__main__&quot;:
    slt = Solution()
    s = &quot;Let&#39;s take LeetCode contest&quot;
    res = slt.reverseWords3(s)
    print(&quot;反转单词后的字符串：&quot;, res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 反转链表</title>
    <url>/2021/08/27/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.递归<br>递：将大问题分解为小问题，将整个链表依次拆解直到只剩下一个节点<br>归：在链表只剩下一个节点时开始”归“，使用head.next.next = head,head.next = None这两行代码从后往前（从原链表的视角看）将链表中的每一个连接改为反向的<br>2.迭代<br>假设链表为 1→2→3→∅，我们想要把它改成 ∅←1←2←3。<br>在遍历链表时，将当前节点的 next 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。<br>3.头插法<br>首先创建一个只有头节点的反转链表，从头到尾遍历原链表，将每次遍历到的节点按照头插法插入反转链表中，以此类推，当我们遍历完整个链表时就得到一个反转链表。<br>头插法：即每次都将将要插入的节点作为链表的首节点（不是头节点）<br>头插法代码实现：</p>
<pre><code>node.next = head.next
head.next = node
</code></pre>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def reverseList(self, head):
        &quot;&quot;&quot;
        迭代法

        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        # if not head:
        #     return head
        #
        # p = head
        #
        # reversed = ListNode()
        # while p is not None:
        #     node = ListNode(p.val)
        #     node.next = reversed.next
        #     reversed.next = node
        #
        #     p = p.next
        #
        # return reversed.next

        prev = None
        curr = head
        while curr is not None:
            next = curr.next
            curr.next = prev
            prev = curr
            curr = next
        return prev

    def reverseList1(self, head):
        &quot;&quot;&quot;
        递归法

        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        if not head or not head.next:
            return head
        new_head = self.reverseList1(head.next)
        head.next.next = head
        head.next = None
        return new_head

    def reverseList2(self, head):
        &quot;&quot;&quot;
        头插法

        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        if not head:
            return head

        p = head

        reversed = ListNode()
        while p is not None:
            node = ListNode(p.val)
            node.next = reversed.next
            reversed.next = node

            p = p.next

        return reversed.next

    def create_linked_list(self, list):
        &quot;&quot;&quot;根据list中的所有元素构建单链表&quot;&quot;&quot;
        l = ListNode()  # 单链表头节点
        r = l  # 起始尾指针r指向头节点
        for e in list:
            node = ListNode(e)
            r.next = node
            r = r.next

        return l.next

    def print_linked_list(self, linked_list) -&gt; None:
        &quot;&quot;&quot;
        打印单链表中的所有元素

        :param linked_list: 单链表
        :return: 无
        &quot;&quot;&quot;
        print(&quot;----------------------------------------&quot;)
        pointer = linked_list
        while pointer is not None:
            print(pointer.val)
            pointer = pointer.next


if __name__ == &quot;__main__&quot;:
    slt = Solution()

    linked_list = slt.create_linked_list([1, 2, 3, 4, 5])

    slt.print_linked_list(linked_list)

    reversed_linked_list = slt.reverseList1(linked_list)

    slt.print_linked_list(reversed_linked_list)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>openpyxl | 合并excel表格中上下行内容相同的单元格</title>
    <url>/2021/10/21/%E5%90%88%E5%B9%B6excel%E8%A1%A8%E6%A0%BC%E4%B8%AD%E4%B8%8A%E4%B8%8B%E8%A1%8C%E5%86%85%E5%AE%B9%E7%9B%B8%E5%90%8C%E7%9A%84%E5%8D%95%E5%85%83%E6%A0%BC/</url>
    <content><![CDATA[<h1 id="合并excel表格中上下行内容相同的单元格"><a href="#合并excel表格中上下行内容相同的单元格" class="headerlink" title="合并excel表格中上下行内容相同的单元格"></a>合并excel表格中上下行内容相同的单元格</h1><p>以下代码实现自动合并excel表格中上下行内容相同的单元格</p>
<span id="more"></span>
<pre><code># 获取Excel表格中的数据
from openpyxl import load_workbook  # 用于读取Excel中的信息


def merge_cells(ws, target_list, start_row, col):
    &quot;&quot;&quot;
    ws: 是需要操作的工作表
    target_list: 是目标列表，即含有重复数据的列表
    start_row: 是开始行，即工作表中开始比对数据的行（需要将标题除开）
    col: 是需要处理数据的列
    &quot;&quot;&quot;
    start = 0  # 开始行计数，初试值为0，对应列表中的第1个元素的位置0
    end = 0  # 结束行计数，初试值为0，对应列表中的第1个元素的位置0
    reference = target_list[0]  # 设定基准，以列表中的第一个字符串开始
    for i in range(len(target_list)):  # 遍历列表
        if target_list[i] != reference:  # 开始比对，如果内容不同执行如下
            reference = target_list[i]  # 基准变成列表中下一个字符串
            end = i - 1  # 列计数器
            ws.merge_cells(col + str(start + start_row) + &quot;:&quot; + col + str(end + start_row))
            start = end + 1
        if i == len(target_list) - 1:  # 遍历到最后一行，按如下操作
            end = i
            ws.merge_cells(col + str(start + start_row) + &quot;:&quot; + col + str(end + start_row))


wb = load_workbook(&#39;产品清单.xlsx&#39;)
sheet_names = wb.get_sheet_names()
for sheet_name in sheet_names:  # 遍历每个工作表，抓取数据，并根据要求合并单元格
    ws = wb[sheet_name]
    customer_list = []  # 客户名称
    pn_list = []  # 产品编码

    for row in range(6, ws.max_row - 2):
        customer = ws[&#39;B&#39; + str(row)].value
        pn = ws[&#39;C&#39; + str(row)].value
        customer_list.append(customer)
        pn_list.append(pn)

    # 调用以上定义的合并单元格函数`Merge_cells`做单元格合并操作
    start_row = 6  # 开始行是第六行
    merge_cells(ws, customer_list, start_row, &quot;B&quot;)  # &quot;B&quot; - 客户名称是在B列
    merge_cells(ws, pn_list, start_row, &quot;C&quot;)  # &quot;C&quot; - 产品编码是在C列

wb.save(&quot;产品清单-合并单元.xlsx&quot;)
</code></pre>
<p><a href="产品清单.xlsx">产品清单.xlsx</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>openpyxl</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>openpyxl</tag>
      </tags>
  </entry>
  <entry>
    <title>python-docx | 合并word表格中上下行那内容相同的单元格</title>
    <url>/2021/10/21/%E5%90%88%E5%B9%B6word%E8%A1%A8%E6%A0%BC%E4%B8%AD%E4%B8%8A%E4%B8%8B%E8%A1%8C%E9%82%A3%E5%86%85%E5%AE%B9%E7%9B%B8%E5%90%8C%E7%9A%84%E5%8D%95%E5%85%83%E6%A0%BC/</url>
    <content><![CDATA[<h1 id="合并word表格中上下行那内容相同的单元格"><a href="#合并word表格中上下行那内容相同的单元格" class="headerlink" title="合并word表格中上下行那内容相同的单元格"></a>合并word表格中上下行那内容相同的单元格</h1><p>以下代码实现自动合并excel表格中上下行内容相同的单元格</p>
<span id="more"></span>
<pre><code>from docx import Document


# 定义合并单元格的函数
def Merge_cells(table, target_list, start_row, col):
    &quot;&quot;&quot;
    table: 是需要操作的表格
    target_list: 是目标列表，即含有重复数据的列表
    start_row: 是开始行，即表格中开始比对数据的行（需要将标题除开）
    col: 是需要处理数据的列
    &quot;&quot;&quot;
    start = 0  # 开始行计数
    end = 0  # 结束行计数
    reference = target_list[0]  # 设定基准，以列表中的第一个字符串开始
    for i in range(len(target_list)):  # 遍历列表
        if target_list[i] != reference:  # 开始比对，如果内容不同执行如下
            reference = target_list[i]  # 基准变成列表中下一个字符串
            end = i - 1
            table.cell(start + start_row, col).merge(table.cell(end + start_row, col))
            start = end + 1
        if i == len(target_list) - 1:  # 遍历到最后一行，按如下操作
            end = i
            table.cell(start + start_row, col).merge(table.cell(end + start_row, col))


doc = Document(&quot;收货记录.docx&quot;)
# 读取word文档中的第一个表格的第二和第三列除标题和尾部总数行的数据
table = doc.tables[0]  # 已确定是第一个表格，其索引是0
supplier = []  # 存储供应商名称
pn = []  # 存储物料编码
max_row = len(table.rows)  # 获取第最大一行

# 读取第二行到29行，第2，3列中的数据
for i in range(1, max_row - 1):
    supplier_name = table.rows[i].cells[1].text  # cells[1]指表格第二列
    supplier.append(supplier_name)

for i in range(1, max_row - 1):
    material_pn = table.rows[i].cells[2].text  # cells[2]指表格第三列
    pn.append(material_pn)

Merge_cells(table, supplier, 1, 1)  # 开始合并行为2，索引为1；供应商名称是在2列，索引为1
Merge_cells(table, pn, 1, 2)  # 开始合并行为2，索引为1；物料编码是在3列，索引为2

# 重新往第2和第3列写入数据，以覆盖之前重复的数据
for row in range(1, len(supplier) + 1):
    table.cell(row, 1).text = supplier[row - 2]
    table.cell(row, 2).text = pn[row - 2]
doc.save(&quot;收货记录-合并单元格.docx&quot;)
</code></pre>
<p><a href="收货记录.docx">收货记录.docx</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>python-docx</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python-docx</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 合并两个有序链表</title>
    <url>/2021/08/27/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21.合并两个有序链表"></a>21.合并两个有序链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>方法1：递归<br>如果 l1 或者 l2 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束。<br>方法2：迭代<br>当 l1 和 l2 都不是空链表时，判断 l1 和 l2 哪一个链表的头节点的值更小，将较小值的节点添加到结果里，当一个节点被添加到结果里之后，将对应链表中的节点向后移一位。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def mergeTwoLists(self, l1, l2):
        &quot;&quot;&quot;
        迭代法

        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        if l1 is None:
            return l2
        elif l2 is None:
            return l1
        else:
            p = l1
            q = l2
            l3 = ListNode()
            r = l3  # r表示l3单链表的尾指针

            while p and q:  # 注意：此处的循环判断条件为 p and q
                if p.val &lt;= q.val:  # p指针指向的元素小，将此元素并入结果链表
                    node = ListNode(p.val)

                    # 尾插法构建链表
                    r.next = node
                    r = r.next

                    # 工作指针指向当前链表中的下一个节点
                    p = p.next
                else:  # q指针指向的元素小，将此元素并入结果链表
                    node = ListNode(q.val)
                    r.next = node
                    r = r.next

                    q = q.next
            if p is not None:
                r.next = p
            elif q is not None:
                r.next = q

            return l3.next

    def mergeTwoLists1(self, l1, l2):  # 1 2 3   1 3 4
        &quot;&quot;&quot;
        递归法
        &quot;&quot;&quot;
        if l1 is None:
            return l2
        elif l2 is None:
            return l1
        elif l1.val &lt; l2.val:
            l1.next = self.mergeTwoLists1(l1.next, l2)
            return l1
        else:
            l2.next = self.mergeTwoLists1(l1, l2.next)
            return l2

    def len_linked_list(self, linked_list):
        &quot;&quot;&quot;
        返回单链表的长度
        :param linked_list:需要返回其长度的单链表
        :return:单链表的长度
        &quot;&quot;&quot;
        p = linked_list

        n = 0
        while p is not None:
            n += 1
            p = p.next

        return n

    def print_linked_list(self, linked_list) -&gt; None:
        &quot;&quot;&quot;
        打印单链表中的所有元素

        :param linked_list: 单链表
        :return: 无
        &quot;&quot;&quot;
        print(&quot;----------------------------------------&quot;)
        pointer = linked_list
        while pointer is not None:
            print(pointer.val)
            pointer = pointer.next

    def create_linked_list(self, list):
        &quot;&quot;&quot;根据list中的所有元素构建单链表&quot;&quot;&quot;
        l = ListNode()  # 单链表头节点
        r = l  # 起始尾指针r指向头节点
        for e in list:
            node = ListNode(e)
            r.next = node
            r = r.next

        return l.next


if __name__ == &quot;__main__&quot;:
    slt = Solution()

    l1 = slt.create_linked_list([1, 2, 4])
    l2 = slt.create_linked_list([1, 3, 4])

    slt.print_linked_list(l1)
    slt.print_linked_list(l2)

    l3 = slt.mergeTwoLists1(l1, l2)

    slt.print_linked_list(l3)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>python-docx | 向Word文档中添加图片</title>
    <url>/2021/10/24/%E5%90%91Word%E6%96%87%E6%A1%A3%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h1 id="向Word文档中添加图片"><a href="#向Word文档中添加图片" class="headerlink" title="向Word文档中添加图片"></a>向Word文档中添加图片</h1><p>以下代码使用python-docx向Word文档中的指定位置添加图片</p>
<span id="more"></span>
<pre><code># 提取Excel表中的数据
from openpyxl import load_workbook  # 用于读取Excel中的信息

wb = load_workbook(&#39;数据.xlsx&#39;)
ws = wb.active
data = []
for row in range(2, ws.max_row + 1):
    number = ws[&#39;A&#39; + str(row)].value
    problem = ws[&#39;B&#39; + str(row)].value
    owner = ws[&#39;C&#39; + str(row)].value
    info_list = [number, problem, owner]
    data.append(info_list)

# print(data)

from docx import Document
from docx.shared import Cm
import os

doc = Document(&quot;6S稽查问题模板.docx&quot;)

# 将图片按修改时间排序(这样才能与图片的描述一致)，将路径存入列表，以便后面逐个插入图片时调用
path = &quot;6s_pictures&quot;
list_p = [path + &quot;\\&quot; + i for i in os.listdir(path)]  # 获取图片的文件名,并拼接完整路径
list_p.sort(key=lambda path: os.path.getmtime(path))  # 将列表中的文件按其修改时间排序，os.path.getmtime() 函数是获取文件最后修改时间

table = doc.tables[0]  # 已确定是第一个表格，其索引是0

# 增加需要的行，以便足够填入数据
for i in range(len(data) - 1):
    table.add_row()

# 写入数据及图片
for row in range(1, len(data) + 1):
    table.cell(row, 0).text = str(data[row - 1][0])  # 往第1列写入序号
    table.cell(row, 1).text = data[row - 1][1]  # 往第2列写入问题描述
    table.cell(row, 3).text = data[row - 1][2]  # 往第4列写入责任部门

    # 插入图片并调整图片的高度和宽度，以适合模板中的单元格尺寸
    run = table.cell(row, 2).paragraphs[0].add_run()  # 新增一个文字块
    picture = run.add_picture(list_p[row - 1])  # 插入图片
    picture.height = Cm(4.4)  # 设置图片高度
    picture.width = Cm(6.2)  # 设置图片宽度

doc.save(&quot;6S稽查问题.docx&quot;)
</code></pre>
<p><a href="6S稽查问题模板.docx">6S稽查问题模板.docx</a><br><a href="数据.xlsx">数据.xlsx</a><br><a href="https://github.com/victory-liao/victory-liao.github.io/tree/master/source/images/6s_pictures">6s_pictures</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>python-docx</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python-docx</tag>
        <tag>openpyxl</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 删除链表中的节点</title>
    <url>/2021/08/27/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="237.删除链表中的节点"></a>237.删除链表中的节点</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>由于单链表不能直接访问当前节点的前一个节点，现要删除当前节点，我们可以将当前节点的下一个节点的值复制到当前节点，然后改变当前节点的next指针删除当前节点的下一个节点即可达到删除当前节点的效果。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def deleteNode(self, node):
        &quot;&quot;&quot;
        :type node: ListNode
        :rtype: void Do not return anything, modify node in-place instead.
        &quot;&quot;&quot;
        node.val = node.next.val
        node.next = node.next.next
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>python-docx | 向word中的表格写入数据</title>
    <url>/2021/10/24/%E5%90%91word%E4%B8%AD%E7%9A%84%E8%A1%A8%E6%A0%BC%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="向word中的表格写入数据"><a href="#向word中的表格写入数据" class="headerlink" title="向word中的表格写入数据"></a>向word中的表格写入数据</h1><p>以下代码实现一键往word文档的表格中填写数据。</p>
<span id="more"></span>

<pre><code># 从Excel表中提取数据
from openpyxl import load_workbook

wb = load_workbook(&quot;收货数据.xlsx&quot;)
ws = wb.active
data = []
for row in range(2, ws.max_row + 1):
    seq = ws[&quot;A&quot; + str(row)].value
    supplier = ws[&quot;B&quot; + str(row)].value
    material_pn = ws[&quot;C&quot; + str(row)].value
    material_model = ws[&quot;D&quot; + str(row)].value
    desp = ws[&quot;E&quot; + str(row)].value
    qty = ws[&quot;F&quot; + str(row)].value
    date = ws[&quot;G&quot; + str(row)].value.date()
    info = [seq, supplier, material_pn, material_model, desp, qty, date]
    data.append(info)


# 定义数量加总函数
def Sum_list(list):
    s = 0
    for i in list:  # 累加列表中的所有数
        s += i
    return s


# 加总数量列的所有数字
qty_list = []
for i in data:
    qty_list.append(i[5])  # 数量在内层列表的第6个位置，索引是5
sum_qty = Sum_list(qty_list)  # 调用加总函数加总


# 定义合并单元格的函数
def Merge_cells(table, target_list, start_row, col):
    &#39;&#39;&#39;
    table: 是需要操作的表格
    target_list: 是目标列表，即含有重复数据的列表
    start_row: 是开始行，即表格中开始比对数据的行（需要将标题除开）
    col: 是需要处理数据的列
    &#39;&#39;&#39;
    start = 0  # 开始行计数
    end = 0  # 结束行计数
    reference = target_list[0]  # 设定基准，以列表中的第一个字符串开始
    for i in range(len(target_list)):  # 遍历列表
        if target_list[i] != reference:  # 开始比对，如果内容不同执行如下
            reference = target_list[i]  # 基准变成列表中下一个字符串
            end = i - 1
            table.cell(start + start_row, col).merge(table.cell(end + start_row, col))
            start = end + 1
        if i == len(target_list) - 1:  # 遍历到最后一行，按如下操作
            end = i
            table.cell(start + start_row, col).merge(table.cell(end + start_row, col))


# 数据提取即处理完毕后，就可以往Word的表格中写入数据了
from docx import Document

doc = Document(&quot;收货记录模板.docx&quot;)
# 读取word文档中的第一个表格的第二和第三列除标题和尾部总数行的数据
table = doc.tables[0]  # 已确定是第一个表格，其索引是0
supplier = []  # 存储供应商名称
pn = []  # 存储物料编码
for i in data:
    supplier.append(i[1])
    pn.append(i[2])
# 按需增加行，以便填写数据
for i in range(len(supplier)):  # 模板中已经有一行了，所以总共只需增加len(supplier)行
    table.add_row()
# 增加好行后先做合并单元格操作
Merge_cells(table, supplier, 1, 1)  # 开始合并行为2，索引为1；供应商名称是在2列，索引为1
Merge_cells(table, pn, 1, 2)  # 开始合并行为2，索引为1；物料编码是在3列，索引为2

# 写入数据到表格
for row in range(1, len(supplier) + 1):
    for col in range(7):
        table.cell(row, col).text = str(data[row - 1][col])

max_row = len(table.rows)  # 获取最大一行
qty_row = max_row - 1  # 确定需要写入加总数据的一行
table.cell(qty_row, 5).merge(table.cell(qty_row, 6))  # 合并右下角用于填写数量的两个单元格
table.cell(qty_row, 4).text = &#39;总数：&#39;
table.cell(qty_row, 5).text = str(sum_qty)

doc.save(&quot;收货记录3.docx&quot;)
</code></pre>
<p><a href="收货数据.xlsx">收货数据.xlsx</a><br><a href="收货记录模板.docx">收货记录模板.docx</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>python-docx</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python-docx</tag>
        <tag>openpyxl</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 吴恩达课后作业</title>
    <url>/2021/06/23/%E5%90%B4%E6%81%A9%E8%BE%BE%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<h1 id="吴恩达课后作业"><a href="#吴恩达课后作业" class="headerlink" title="吴恩达课后作业"></a>吴恩达课后作业</h1><p>这是在b站学习吴恩达深度学习课程时发现的课后作业实现，非常详细！！！点赞！！！</p>
<p><a href="https://blog.csdn.net/u013733326/article/details/79827273">链接：吴恩达深度学习课后作业</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>吴恩达</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 回文链表</title>
    <url>/2021/08/27/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234.回文链表"></a>234.回文链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.按照原链表构建一个反向链表，如果两个链表完全相同则为回文链表<br>2.将原链表中的所有节点的val顺序存储在数组中后使用双指针（array[::] == array[::-1]）<br>3.递归<br>4.快慢指针<br>将链表的后半部分反转，然后将前半部分和后半部分进行比较。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):

    def isPalindrome(self, head):
        &quot;&quot;&quot;
        按照原链表构建一个反向链表，如果两个链表完全相同则为回文链表
        :type head: ListNode
        :rtype: bool
        &quot;&quot;&quot;
        # p = head
        # reversed = ListNode()
        # while p is not None:
        #     node = ListNode(p.val)
        #     node.next = reversed.next
        #     reversed.next = node
        #
        #     p = p.next
        #
        # p1 = head
        # p2 = reversed.next
        # while p1 and p2:
        #     if p1.val == p2.val:
        #         p1 = p1.next
        #         p2 = p2.next
        #     else:
        #         break
        # if p1 is None and p2 is None:
        #     return True
        # else:
        #     return False

        reversed = self.reverseList(head)
        p1 = head
        p2 = reversed
        while p1 and p2:
            if p1.val == p2.val:
                p1 = p1.next
                p2 = p2.next
            else:
                break
        if p1 is None and p2 is None:
            return True
        else:
            return False

    def isPalindrome1(self, head):
        &quot;&quot;&quot;
        将原链表中的所有节点的val顺序存储在数组中后使用双指针
        :type head: ListNode
        :rtype: bool
        &quot;&quot;&quot;
        p = head
        vals = []
        while p:
            vals.append(p.val)
            p = p.next
        return vals[::] == vals[::-1]

    def isPalindrome2(self, head):
        &quot;&quot;&quot;
        递归法

        :type head: ListNode
        :rtype: bool
        &quot;&quot;&quot;
        self.front_pointer = head

        def recursively_check(current_node=head):
            if current_node is not None:
                if not recursively_check(current_node.next):
                    return False
                if self.front_pointer.val != current_node.val:
                    return False
                self.front_pointer = self.front_pointer.next

            return True

        return recursively_check()

    def isPalindrome3(self, head):
        &quot;&quot;&quot;
        快慢指针
        将链表的后半部分反转（修改链表结构），然后将前半部分和后半部分进行比较。

        :type head: ListNode
        :rtype: bool
        &quot;&quot;&quot;
        if head is None:
            return True

        # 找到前半部分链表的尾节点并反转后半部分链表
        first_half_end = self.end_of_first_half(head)
        second_half_start = self.reverseList(first_half_end.next)

        # 判断是否回文
        result = True
        first_position = head
        second_position =second_half_start

        while result and second_position is not None:
            if first_position.val != second_position.val:
                result = False
            first_position = first_position.next
            second_position = second_position.next

        # 还原链表并返回结果
        first_half_end.next = self.reverseList((second_half_start))
        return result

    def end_of_first_half(self, head):
        fast = head
        slow = head

        while fast.next is not None and fast.next.next is not None:
            fast = fast.next.next
            slow = slow.next

        return slow

    def reverseList(self, head):
        &quot;&quot;&quot;
        递归法反转链表

        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        if not head or not head.next:
            return head
        new_head = self.reverseList(head.next)
        head.next.next = head
        head.next = None
        return new_head

    def create_linked_list(self, list):
        &quot;&quot;&quot;根据list中的所有元素构建单链表&quot;&quot;&quot;
        l = ListNode()  # 单链表头节点
        r = l  # 起始尾指针r指向头节点
        for e in list:
            node = ListNode(e)
            r.next = node
            r = r.next

        return l.next

    def print_linked_list(self, linked_list) -&gt; None:
        &quot;&quot;&quot;
        打印单链表中的所有元素

        :param linked_list: 单链表
        :return: 无
        &quot;&quot;&quot;
        print(&quot;----------------------------------------&quot;)
        pointer = linked_list
        while pointer is not None:
            print(pointer.val)
            pointer = pointer.next


if __name__ == &quot;__main__&quot;:
    slt = Solution()

    linked_list = slt.create_linked_list([1, 2, 2, 1])

    slt.print_linked_list(linked_list)

    res = slt.isPalindrome3(linked_list)
    print(res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>openpyxl | 在Excel中按条件筛选数据并存入新的表</title>
    <url>/2021/10/25/%E5%9C%A8Excel%E4%B8%AD%E6%8C%89%E6%9D%A1%E4%BB%B6%E7%AD%9B%E9%80%89%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%AD%98%E5%85%A5%E6%96%B0%E7%9A%84%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="在Excel中按条件筛选数据并存入新的表"><a href="#在Excel中按条件筛选数据并存入新的表" class="headerlink" title="在Excel中按条件筛选数据并存入新的表"></a>在Excel中按条件筛选数据并存入新的表</h1><p>实现代码：</p>
<pre><code># 1.获取满足条件的数据
from openpyxl import load_workbook

wb = load_workbook(&quot;每月物料表.xlsx&quot;)
data = &#123;&#125;  # 储存所有工作表中满足条件的数据，以工作表名称为键
sheet_names = wb.sheetnames
for sheet_name in sheet_names:
    ws = wb[sheet_name]
    qty_list = []
    # 获取G列的数据，并用enumrate给其对应的元素编号
    for row in range(2, ws.max_row + 1):
        qty = ws[&#39;G&#39; + str(row)].value
        qty_list.append(qty)
    # print(qty_list)

    qty_idx = list(enumerate(qty_list))  # 用于编号

    # 判断数据是否大于1000，然后返回大于1000的数据所对应的行数
    row_idx = []  # 用于储存数量大于1000所对应的的行号
    for i in range(len(qty_idx)):
        if qty_idx[i][1] &gt; 1000:
            row_idx.append(qty_idx[i][0] + 2)
    # print(row_idx)

    # 获取满足条件的数据
    data_morethan1K = []
    for i in row_idx:
        data_morethan1K.append(ws[&#39;A&#39; + str(i) + &quot;:&quot; + &#39;I&#39; + str(i)])

    # print(data_morethan1K)

    data[sheet_name] = data_morethan1K

# 2.写入获取的数据
from openpyxl.styles import Border, Side, PatternFill, Font, GradientFill, Alignment

thin = Side(border_style=&quot;thin&quot;, color=&quot;000000&quot;)  # 定义边框粗细及颜色

wb = load_workbook(&quot;模板.xlsx&quot;)
ws = wb.active
for month in data.keys():
    ws_new = wb.copy_worksheet(ws)  # 复制模板中的工作表
    ws_new.title = month
    print(ws_new.title)
    # 将每个月的数据条数逐个取出并写入新的工作表
    for i in range(len(data[month])):  # 按数据行数计数，每行数据对应9列，所以每行需分别写入9个单元格
        ws_new.cell(row=i + 2, column=1).value = data[month][i][0][0].value
        ws_new.cell(row=i + 2, column=2).value = data[month][i][0][1].value
        ws_new.cell(row=i + 2, column=3).value = data[month][i][0][2].value
        ws_new.cell(row=i + 2, column=4).value = data[month][i][0][3].value.date()
        ws_new.cell(row=i + 2, column=5).value = data[month][i][0][4].value
        ws_new.cell(row=i + 2, column=6).value = data[month][i][0][5].value
        ws_new.cell(row=i + 2, column=7).value = data[month][i][0][6].value
        ws_new.cell(row=i + 2, column=8).value = data[month][i][0][7].value
        ws_new.cell(row=i + 2, column=9).value = data[month][i][0][8].value

    # 设置字号，对齐，缩小字体填充，加边框
    # Font(bold=True)可加粗字体

    for row_number in range(2, ws_new.max_row + 1):
        for col_number in range(1, 10):
            c = ws_new.cell(row=row_number, column=col_number)
            c.font = Font(size=10)
            c.border = Border(top=thin, left=thin, right=thin, bottom=thin)
            c.alignment = Alignment(horizontal=&quot;left&quot;, vertical=&quot;center&quot;, shrink_to_fit=True)
wb.save(&quot;每月(大于1K).xlsx&quot;)
</code></pre>
<p><a href="模板.xlsx">模板.xlsx</a><br><a href="每月物料表.xlsx">每月物料表.xlsx</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>openpyxl</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>openpyxl</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 在系统中查找重复文件</title>
    <url>/2021/09/05/%E5%9C%A8%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%9F%A5%E6%89%BE%E9%87%8D%E5%A4%8D%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="609-在系统中查找重复文件"><a href="#609-在系统中查找重复文件" class="headerlink" title="609.在系统中查找重复文件"></a>609.在系统中查找重复文件</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个目录信息列表，包括目录路径，以及该目录中的所有包含内容的文件，您需要找到文件系统中的所有重复文件组的路径。一组重复的文件至少包括二个具有完全相同内容的文件。<br>输入列表中的单个目录信息字符串的格式如下：<br>“root/d1/d2/…/dm f1.txt(f1_content) f2.txt(f2_content) … fn.txt(fn_content)”<br>这意味着有 n 个文件（f1.txt, f2.txt … fn.txt 的内容分别是 f1_content, f2_content … fn_content）在目录 root/d1/d2/…/dm 下。注意：n&gt;=1 且 m&gt;=0。如果 m=0，则表示该目录是根目录。<br>该输出是重复文件路径组的列表。对于每个组，它包含具有相同内容的文件的所有文件路径。文件路径是具有下列格式的字符串：<br>“directory_path/file_name.txt”</p>
<span id="more"></span>
<p>示例 1：<br>输入：<br>[“root/a 1.txt(abcd) 2.txt(efgh)”, “root/c 3.txt(abcd)”, “root/c/d 4.txt(efgh)”, “root 4.txt(efgh)”]<br>输出：<br>[[“root/a/2.txt”,”root/c/d/4.txt”,”root/4.txt”],[“root/a/1.txt”,”root/c/3.txt”]]</p>
<p><a href="https://leetcode-cn.com/problems/find-duplicate-file-in-system
">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.哈希表<br>首先我们通过字符串操作获取目录路径、文件名和文件内容。我们使用哈希映射（HashMap）来寻找重复文件，哈希映射中的键（key）是文件内容，值（value）是存储路径和文件名的列表。<br>我们遍历每一个文件，并把它加入哈希映射中。在这之后，我们遍历哈希映射，如果一个键对应的值列表的长度大于 1，说明我们找到了重复文件，可以把这个列表加入到答案中。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):
    def findDuplicate(self, paths):
        &quot;&quot;&quot;
        :type paths: List[str]
        :rtype: List[List[str]]
        &quot;&quot;&quot;
        map = &#123;&#125;
        for path in paths:
            values = path.split(&quot; &quot;)
            for i in range(1, len(values)):
                name_cont = values[i].split(&#39;(&#39;)[-1]
                name_cont = name_cont.replace(&#39;)&#39;, &#39;&#39;)
                value_list = map.get(name_cont, [])
                value_list.append(values[0] + &#39;/&#39; + values[i].split(&#39;(&#39;)[0])
                map[name_cont] = value_list
        res = []
        for key in map.keys():
            if len(map.get(key)) &gt; 1:
                res.append(map.get(key))

        return res


if __name__ == &#39;__main__&#39;:
    slt = Solution()
    result = slt.findDuplicate([&quot;root/a 1.txt(abcd) 2.txt(efgh)&quot;, &quot;root/c 3.txt(abcd)&quot;, &quot;root/c/d 4.txt(efgh)&quot;, &quot;root 4.txt(efgh)&quot;])
    print(result)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>python | 在python代码中使用c语言编写的函数</title>
    <url>/2020/10/16/%E5%9C%A8python%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%BD%BF%E7%94%A8c%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E7%9A%84%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="在python代码中使用c语言编写的函数-以输出Hello-World为例"><a href="#在python代码中使用c语言编写的函数-以输出Hello-World为例" class="headerlink" title="在python代码中使用c语言编写的函数-以输出Hello World为例"></a>在python代码中使用c语言编写的函数-以输出Hello World为例</h1><p><b style="color:red">linux环境下！！！</b></p>
<h2 id="Step-1-编写c语言代码-sayHello-c"><a href="#Step-1-编写c语言代码-sayHello-c" class="headerlink" title="Step 1:编写c语言代码-sayHello.c"></a>Step 1:编写c语言代码-sayHello.c</h2><pre><code>include&lt;stdio.h&gt;
void sayHello()
&#123;
    printf(&quot;Hello World!&quot;);
&#125;
</code></pre>
<h2 id="Step-2-把c语言文件编译成一个动态库"><a href="#Step-2-把c语言文件编译成一个动态库" class="headerlink" title="Step 2:把c语言文件编译成一个动态库"></a>Step 2:把c语言文件编译成一个动态库</h2><pre><code>gcc sayHello.c -shared -o lib-sayHello.so
</code></pre>
<h2 id="Step-3-编写python代码-main-py"><a href="#Step-3-编写python代码-main-py" class="headerlink" title="Step 3:编写python代码-main.py"></a>Step 3:编写python代码-main.py</h2><pre><code>from ctypes import *

#加载动态库
lib = cdll.LoadLibrary(&quot;./lib-sayHello.so&quot;)
#调用sayHello函数
lib.sayHello()
</code></pre>
<h2 id="Step-4-运行python代码"><a href="#Step-4-运行python代码" class="headerlink" title="Step 4:运行python代码"></a>Step 4:运行python代码</h2><pre><code>python3 main.py
</code></pre>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 外观数列</title>
    <url>/2021/08/28/%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<h1 id="38-外观数列"><a href="#38-外观数列" class="headerlink" title="38.外观数列"></a>38.外观数列</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个正整数 n ，输出外观数列的第 n 项。<br>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。</p>
<span id="more"></span>
<p>你可以将其视作是由递归公式定义的数字字符串序列：<br>    countAndSay(1) = “1”<br>    countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。<br>前五项如下：</p>
<ol>
<li><pre><code>1
</code></pre>
</li>
<li><pre><code>11
</code></pre>
</li>
<li><pre><code>21
</code></pre>
</li>
<li><pre><code>1211
</code></pre>
</li>
<li><pre><code>111221
</code></pre>
第一项是数字 1<br>描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 “11”<br>描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 “21”<br>描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 “1211”<br>描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 “111221”<br>要 描述 一个数字字符串，首先要将字符串分割为 最小 数量的组，每个组都由连续的最多 相同字符 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。</li>
</ol>
<p><a href="https://leetcode-cn.com/problems/count-and-say/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.递归<br>递归出口为n == 1时，返回”1”；<br>当n &gt; 1时，我们只需要计算countAndSay(n - 1)中每个数字的个数：<br>对于计算字符串中每个数字出现的个数，使用双指针i, j，其中i表示当前字符，j则是计数指针，向后移动判断；<br>以求n = 5，lastStr = countAndSay(4) = “1211”为例，answer = “”，一开始让i = 0, j = 1，此时’1’ != ‘2’，<br>故answer += (j - i) + lastStr.charAt(i)，ans = “11”；然后让i = j（第二个不同字符起始位置），<br>然后j++往后移动；此时i = j = 1，j = j + 1 = 2，又’2’ != ‘1’，<br>所以answer += (j - i) + lastStr.charAt(i),ans = “1112”,重复i = j = 2， j = ++j = 3；此时’1’ = ‘1’；<br>故直接j = ++j = 4 == lastStr.length()，所以跳出循环，然后把最后一次的字符个数字符加上，即执行：<br>answer += (j - i) + lastStr.charAt(i),ans = “111221”，即countAndSay(5) = “111221”。<br>2.正则表达式<br>用正则表达式匹配一个数字的重复序列和数字本身，然后将匹配的序列的长度加上数字本身替换原字符串中重复序列，…，以此类推。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def countAndSay(self, n: int) -&gt; str:
        &quot;&quot;&quot;
        递归法
        :param n:
        :return:
        &quot;&quot;&quot;
        if n == 1:  # 递归出口
            return &quot;1&quot;
        else:
            lastStr = self.countAndSay(n - 1)
            ans = &quot;&quot;
            i = 0
            j = 1

            while j &lt; len(lastStr):
                if lastStr[i] != lastStr[j]:
                    ans += str(j-i)
                    ans += str(lastStr[i])
                    i = j  # 下一个不同字符的起始位置

                j += 1

            ans += str(j - i)
            ans += str(lastStr[i])

            return str(ans)

    def countAndSay1(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: str
        &quot;&quot;&quot;
        import re

        s = &#39;1&#39;
        for _ in range(n - 1):
            s = re.sub(r&#39;(.)\1*&#39;, lambda a: str(len(a.group(0))) + a.group(1), s)  # sub(pattern, repl, string)
            # r&#39;(.)\1*&#39; (.)匹配一个任意字符作为一个分组 \1*匹配与第一个分组相同内容0次/多次
        return s


if __name__ == &#39;__main__&#39;:
    s = Solution()
    res = s.countAndSay1(5)
    print(res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>可视化 | 多个坐标轴可视化主要代码python</title>
    <url>/2021/03/11/%E5%A4%9A%E4%B8%AA%E5%9D%90%E6%A0%87%E8%BD%B4%E5%8F%AF%E8%A7%86%E5%8C%96%E4%B8%BB%E8%A6%81%E4%BB%A3%E7%A0%81python/</url>
    <content><![CDATA[<h1 id="多个坐标轴可视化主要代码"><a href="#多个坐标轴可视化主要代码" class="headerlink" title="多个坐标轴可视化主要代码"></a>多个坐标轴可视化主要代码</h1><p>在机器学习算法的使用中，我们需要使用多个坐标轴对一些过程数据/预测结果等进行可视化以便于进一步的分析，它的主要python代码如下：</p>
<span id="more"></span>

<pre><code>from matplotlib.font_manager import FontProperties  # be used to set the fonts
import matplotlib.pyplot as plt

font = FontProperties(fname=r&#39;c:\windows\fonts\simsun.ttc&#39;, size=14)

fig, axs = plt.subplots(nrows=&#39;number_of_rows&#39;, ncols=&#39;number_of_cols&#39;, sharex=&#39;False&#39;, sharey=&#39;False&#39;, figsize=(width, height))
axs[m][n].plot(x, y)  # m&lt;number_of_rows,n&lt;number_of_cols x,y:a list
title = axs[m][n].set_title(u&#39;&#39;,FontProperties=font)
ylabel = axs[m][n].set_ylabel(u&#39;&#39;,FontProperties=font)
xlabel = axs[m][n].set_xlabel(u&#39;&#39;,FontProperties=font)
plt.setp(title/xlabel/ylabel, size=&#39;&#39;, weight=&#39;&#39;, color=&#39;&#39;)
plt.show()  # show the figure
</code></pre>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>可视化(Visualization)</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程 | 多线程下载图片</title>
    <url>/2021/08/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h1 id="多线程下载图片"><a href="#多线程下载图片" class="headerlink" title="多线程下载图片"></a>多线程下载图片</h1><p>下面的代码是一个网络爬虫程序，可以定期下载图片。这个网络爬虫程序每隔一段时间都会执行一次下载图片任务，在下载任务完成后，休眠一段时间在执行。这样反复执行，知道爬虫程序停止。</p>
<p><strong>示例代码：</strong></p>
<pre><code># coding=utf-8

import time
import threading
import urllib.request as request

# 线程停止变量
isrunning = True


# 工作线程体函数
def workthread_body():
    while isrunning:
        # 线程开始工作
        print(&#39;工作线程执行下载任务...&#39;)
        download()
        # 线程休眠
        time.sleep(5)
    print(&#39;工作线程结束&#39;)


# 控制线程体函数
def controlthread_body():
    global isrunning
    while isrunning:
        # 从键盘输入停止指令exit
        command = input(&#39;请输入停止指令&#39;)
        if command == &#39;exit&#39;:
            isrunning = False
            print(&#39;控制线程结束。&#39;)


def download():
    url = &#39;https://victory-liao.github.io/images/avatar.jpg&#39;
    req = request.Request(url)
    with request.urlopen(req) as response:
        data = response.read()
        f_name = &#39;download.jpg&#39;
        with open(f_name, &#39;wb&#39;) as f:
            f.write(data)
            print(&#39;下载文件成功&#39;)


# 主线程
# 创建工作线程对象workthread
workthread = threading.Thread(target=workthread_body)
# 启动线程workthred
workthread.start()

# 创建控制线程对象controlthread
controlthread = threading.Thread(target=controlthread_body)
# 启动线程controlthread
controlthread.start()
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>内置模块</category>
        <category>threading</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>threading</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>系统编程 | 多进程拷贝文件</title>
    <url>/2020/10/14/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="多进程拷贝文件"><a href="#多进程拷贝文件" class="headerlink" title="多进程拷贝文件"></a>多进程拷贝文件</h1><h2 id="实现流程分析"><a href="#实现流程分析" class="headerlink" title="实现流程分析"></a>实现流程分析</h2><ol>
<li>获取要copy的文件夹的名字</li>
<li>创建一个文件夹</li>
<li>获取old文件夹中的所有的文件名字</li>
<li>使用多进程方式copy原文件夹中的所有文件到新的文件夹中</li>
</ol>

<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code>from multiprocessing import Pool,Manager
import os
import time

def copyFileTask(name,oldFolderName,newFolderName,queue):
    &quot;complete the function of coping a file&quot;
    fr = open(oldFolderName+&quot;/&quot;+name)
    fw = open(newFolderName+&quot;/&quot;+name,&quot;w&quot;)
    content = fr.read()
    fw.write(content)
    fr.close()
    fw.close()
    queue.put(name)

def main():
    #0.get the file name you want to copy
    oldFolderName = input(&quot;Please input the file name:&quot;)
    #1.create a file directory
    newFolderName = oldFolderName+&quot;-copy&quot;
    #pmrint(newFolderName)
    os.mkdir(newFolderName)
    #2.get all file name of old file directory
    fileNames = os.listdir(oldFolderName)
    #print(fileNames)
    #3.copy all file of old file directory to a new file directory
    pool = Pool(5)
    queue = Manager().Queue()
    for name in fileNames:
        pool.apply_async(copyFileTask,args=(name,oldFolderName,newFolderName,queue))
    num = 0
    allNum = len(fileNames)
    while num &lt; allNum:
        queue.get()
        num += 1
        copyRate = num/allNum
        print(&quot;\rcopy process:%.2f%% &quot;%(copyRate*100),end=&quot;&quot;)
        time.sleep(1)
    print(&#39;\ncompleted&#39;)
    pool.close()
    pool.join()
if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
]]></content>
      <categories>
        <category>系统编程</category>
      </categories>
      <tags>
        <tag>系统编程</tag>
        <tag>多进程</tag>
      </tags>
  </entry>
  <entry>
    <title>如何计算深度学习代码实践中的trainsteps</title>
    <url>/2021/08/02/%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E8%B7%B5%E4%B8%AD%E7%9A%84trainsteps/</url>
    <content><![CDATA[<h1 id="如何计算深度学习代码实践中的trainsteps"><a href="#如何计算深度学习代码实践中的trainsteps" class="headerlink" title="如何计算深度学习代码实践中的trainsteps?"></a>如何计算深度学习代码实践中的trainsteps?</h1><p>深度学习中已经有epoch参数了，为什么还要再定义steps参数？</p>
<p>epoch:全体训练数据过几遍</p>
<p>steps:模型会计算几次loss,即模型参数会更新几次梯度</p>
<p>当我们训练模型时，epoch变成了一个间接的关注对象，我们关系模型能更新多少次，这些才知道循环多少次，计算多少次loss。其实最主要的一点是训练步数与模型的参数会有相关关系，比如如果要采用自适应学习率，那每步都是有一个不同的学习率的。</p>
<p>train steps通常按以下公式进行计算：<br>train steps = len(data) // batch_size</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>train steps</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 字符串中的单词数</title>
    <url>/2021/09/01/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0/</url>
    <content><![CDATA[<h1 id="434-字符串中的单词数"><a href="#434-字符串中的单词数" class="headerlink" title="434.字符串中的单词数"></a>434.字符串中的单词数</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。<br>请注意，你可以假定字符串里不包括任何不可打印的字符。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/number-of-segments-in-a-string/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.使用语言内置函数split()<br>2.原地法<br>计算单词的数量，就等同于计数单词开始的下标个数。因此，只需要定义好下标的条件，就可以遍历整个字符串，检测每个下标。定义如下：若该下标前为空格（或者为初始下标），且自身不为空格，则其为单词开始的下标。该条件可以以常数时间检测。最后，返回满足条件的下标个数。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def countSegments(self, s: str) -&gt; int:
        list_s = s.split(&#39; &#39;)
        for i in range(list_s.count(&#39;&#39;)):
            list_s.remove(&#39;&#39;)
        if not list_s:
            return 0
        return len(list_s)

    def countSegments1(self, s):
        return len(s.split())

    def countSegments2(self, s):
        segment_count = 0

        for i in range(len(s)):
            if (i == 0 or s[i-1] == &#39; &#39;) and s[i] != &#39; &#39;:
                segment_count +=1

        return segment_count


if __name__ == &#39;__main__&#39;:
    slt = Solution()
    # s = &quot;      &quot;
    s = &quot;The one-hour drama series Westworld is a dark odyssey about the dawn of artificial consciousness and the evolution of sin. Set at the intersection of the near future and the reimagined past, it explores a world in which every human appetite, no matter how noble or depraved, can be indulged.&quot;
    res = slt.countSegments2(s)
    print(res)

    # 分割文本
    # s = &quot;The sky is very blue.&quot;
    # words = s.split(&quot; &quot;)
    # print(words)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 字符串相乘</title>
    <url>/2021/09/05/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</url>
    <content><![CDATA[<h1 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43.字符串相乘"></a>43.字符串相乘</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p>
<p>示例 1:<br>输入: num1 = “2”, num2 = “3”<br>输出: “6”</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/multiply-strings">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.将num1、num2两个字符串转为整数相乘，然后将结果转为字符串返回<br>2.使用python内置函数eval()执行num1 * num2表达式，将eval函数返回结果转为字符串返回<br>3.做加法（<a href="https://leetcode-cn.com/problems/multiply-strings/solution/zi-fu-chuan-xiang-cheng-by-leetcode-solution/">详细思路见leetcode题解</a>）<br>4.做乘法（<a href="https://leetcode-cn.com/problems/multiply-strings/solution/zi-fu-chuan-xiang-cheng-by-leetcode-solution/">详细思路见leetcode题解</a>）</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):
    def multiply(self, num1, num2):
        &quot;&quot;&quot;
        将num1、num2两个字符串转为整数相乘，然后将结果转为字符串返回

        :type num1: str
        :type num2: str
        :rtype: str
        &quot;&quot;&quot;
        return str(int(num1) * int(num2))

    def multiply1(self, num1: str, num2: str) -&gt; str:
        &quot;&quot;&quot;
        将num1、num2两个字符串转为整数相乘，然后将结果转为字符串返回
        :param num1:
        :param num2:
        :return:
        &quot;&quot;&quot;
        if num1 == &quot;0&quot; or num2 == &quot;0&quot;:
            return &quot;0&quot;

        num1_to_int = 0
        num2_to_int = 0

        t = 1
        for i in range(1, len(num1)+1):
            num1_to_int += int(num1[-i]) * t
            t = t * 10

        t = 1
        for i in range(1, len(num2)+1):
            num2_to_int += int(num2[-i]) * t
            t = t * 10

        return str(num1_to_int * num2_to_int)

    def multiply2(self, num1: str, num2: str) -&gt; str:
        &quot;&quot;&quot;使用python内置函数eval()执行num1 * num2表达式，将eval函数返回结果转为字符串返回&quot;&quot;&quot;
        if num1 == &quot;0&quot; or num2 == &quot;0&quot;:
            return &quot;0&quot;

        return str(eval(num1 + &#39;*&#39; + num2))  # eval() 函数用来执行一个字符串表达式，并返回表达式的值。

    def multiply3(self, num1: str, num2: str) -&gt; str:
        &quot;&quot;&quot;做加法&quot;&quot;&quot;
        if num1 == &quot;0&quot; or num2 == &quot;0&quot;:
            return &quot;0&quot;

        ans = &quot;0&quot;
        m, n = len(num1), len(num2)
        for i in range(n - 1, -1, -1):
            add = 0
            y = int(num2[i])
            curr = [&quot;0&quot;] * (n - i - 1)  # num2除了最低位以外，其余的每一位的运算结果都需要补0
            print(&quot;curr:&quot;, curr)
            for j in range(m - 1, -1, -1):
                product = int(num1[j]) * y + add
                curr.append(str(product % 10))
                add = product // 10
            if add &gt; 0:
                curr.append(str(add))
            curr = &quot;&quot;.join(curr[::-1])
            ans = self.addStrings(ans, curr)
        return ans

    def addStrings(self, num1: str, num2: str) -&gt; str:
        i, j = len(num1) - 1, len(num2) - 1
        add = 0
        ans = list()
        while i &gt;= 0 or j &gt;= 0 or add != 0:
            x = int(num1[i]) if i &gt;= 0 else 0
            y = int(num2[j]) if j &gt;= 0 else 0
            result = x + y + add
            ans.append(str(result % 10))
            add = result // 10
            i -= 1
            j -= 1
        return &#39;&#39;.join(ans[::-1])

    def multiply4(self, num1: str, num2: str) -&gt; str:
        &quot;&quot;&quot;做乘法&quot;&quot;&quot;
        if num1 == &quot;0&quot; or num2 == &quot;0&quot;:
            return &quot;0&quot;

        m, n = len(num1), len(num2)
        ansArr = [0] * (m + n)
        for i in range(m - 1, -1, -1):
            x = int(num1[i])
            for j in range(n - 1, -1, -1):
                ansArr[i + j + 1] += x * int(num2[j])

        for i in range(m + n - 1, 0, -1):
            ansArr[i-1] += ansArr[i] // 10
            ansArr[i] %= 10

        index = 1 if ansArr[0] == 0 else 0
        ans = &quot;&quot;.join(str(x) for x in ansArr[index:])
        return ans


if __name__ == &quot;__main__&quot;:
    slt = Solution()
    result = slt.multiply4(&quot;12&quot;, &quot;34&quot;)
    print(result)
    print(type(result))
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 学生出勤记录1</title>
    <url>/2021/09/02/%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E8%AE%B0%E5%BD%951/</url>
    <content><![CDATA[<h1 id="551-学生出勤记录1"><a href="#551-学生出勤记录1" class="headerlink" title="551.学生出勤记录1"></a>551.学生出勤记录1</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 s 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：<br>    ‘A’：Absent，缺勤<br>    ‘L’：Late，迟到<br>    ‘P’：Present，到场<br>如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：<br>    按 总出勤 计，学生缺勤（’A’）严格 少于两天。<br>    学生 不会 存在 连续 3 天或 连续 3 天以上的迟到（’L’）记录。<br>如果学生可以获得出勤奖励，返回 true ；否则，返回 false 。</p>
<span id="more"></span>
<p>示例 1：<br>输入：s = “PPALLP”<br>输出：true<br>解释：学生缺勤次数少于 2 次，且不存在 3 天或以上的连续迟到记录。</p>
<p><a href>题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.一次遍历<br>可奖励的出勤记录要求缺勤次数少于 2 和连续迟到次数少于 3。判断出勤记录是否可奖励，只需要遍历出勤记录，判断这两个条件是否同时满足即可。<br>遍历过程中，记录缺勤次数和连续迟到次数，根据遍历到的字符更新缺勤次数和连续迟到次数：<br>    如果遇到 ‘A’，即缺勤，则将缺勤次数加 1，否则缺勤次数不变；<br>    如果遇到 ‘L’，即迟到，则将连续迟到次数加 1，否则将连续迟到次数清零。<br>如果在更新缺勤次数和连续迟到次数之后，出现缺勤次数大于或等于 2 或者连续迟到次数大于或等于 3，则该出勤记录不满足可奖励的要求，返回 false。如果遍历结束时未出现出勤记录不满足可奖励的要求的情况，则返回 true。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def checkRecord(self, s: str) -&gt; bool:
        # 统计字符串中出现‘A’的的次数
        count_A = s.count(&#39;A&#39;)
        # 字符串中是否有连续3个以上的‘L&#39;
        for i in range(len(s)):
            if i + 2 &lt; len(s) and s[i] == &#39;L&#39; and s[i+1] == &#39;L&#39; and s[i+2] == &#39;L&#39;:
                    return False

        return True if count_A &lt; 2 else False

    def checkRecord1(self, s: str) -&gt; bool:
        absents = lates = 0
        for char in s:
            if char == &quot;A&quot;:
                absents += 1
                lates = 0
            elif char == &quot;L&quot;:
                lates += 1
            else:
                lates = 0

            if lates &gt;= 3 or absents &gt; 1:
                return False

        return True
        # absents = lates = 0
        # for i, c in enumerate(s):
        #     if c == &quot;A&quot;:
        #         absents += 1
        #         if absents &gt;= 2:
        #             return False
        #
        #     if c == &quot;L&quot;:
        #         lates += 1
        #         if lates &gt;= 3:
        #             return False
        #     else:
        #         lates = 0
        #
        # return True


if __name__ == &quot;__main__&quot;:
    slt = Solution()
    # res = slt.checkRecord2(&quot;PPALLL&quot;)
    res = slt.checkRecord2(&quot;PPALLP&quot;)
    print(res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>实现strStr方法</title>
    <url>/2021/08/27/%E5%AE%9E%E7%8E%B0strStr%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="28-实现strStr"><a href="#28-实现strStr" class="headerlink" title="28.实现strStr()"></a>28.实现strStr()</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>实现 strStr() 函数。<br>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。<br><a href="https://leetcode-cn.com/problems/implement-strstr/">题目链接</a></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.直接调用python内置方法<br>2.暴力匹配<br>让字符串 needle 与字符串 haystack 的所有长度为 m（needle字符串的长度） 的子串均匹配一次。<br>为了减少不必要的匹配，我们每次匹配失败即立刻停止当前子串的匹配，对下一个子串继续匹配。如果当前子串匹配成功，我们返回当前子串的开始位置即可。如果所有子串都匹配失败，则返回 −1-1−1。<br><strong style="color:red">3.kmp算法</strong><br>kmp算法的目的：为了避免不必要的指针回溯<br>主串指针i不回溯，模式串指针j的变化取决于模式串的结构是否有重复<br>pi数组值的计算：<br>pi数组的值为最长相同前后缀长度+1(串本身不能作为前后缀)<br>pi[1]=0,其他情况next[]=1.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    &quot;&quot;&quot;
    kmp算法的目的：为了避免不必要的指针回溯

    主串指针i不回溯，模式串指针j的变化取决于模式串的结构是否有重复

    pi数组值的计算：
    pi数组的值为最长相同前后缀长度+1(串本身不能作为前后缀)
    pi[1]=0,其他情况next[]=1.
    &quot;&quot;&quot;
    def strStr(self, haystack: str, needle: str) -&gt; int:
        # 获取主串和模式串的长度
        n = len(haystack)
        m = len(needle)

        # 如果模式串的长度为0，则返回0
        if m == 0:
            return 0

        pi = [0]*m

        # 求模式串的前缀函数值
        i = 1
        j = 0
        while i &lt; m:
            while j &gt; 0 and needle[i] != needle[j]:
                j = pi[j-1]  # 回溯

            if needle[i] == needle[j]:
                j += 1

            pi[i] = j

            i += 1

        print(&quot;模式串的前缀函数值:&quot;, pi)

        # kmp
        i = 0
        j = 0
        while i &lt; n:
            while j &gt; 0 and haystack[i] != needle[j]:
                j = pi[j-1]  # 回溯

            if haystack[i] == needle[j]:
                j += 1

            if j == m:
                return i - m + 1

            i += 1

        return -1

    def strStr1(self, haystack: str, needle: str) -&gt; int:
        &quot;&quot;&quot;调用内置方法&quot;&quot;&quot;
        # 方法1
        # return haystack.find(needle)

        # 方法2
        if not needle:
            return 0

        try:
            return haystack.index(needle)
        except ValueError:
            return -1

    def strStr2(self, haystack: str, needle: str) -&gt; int:
        &quot;&quot;&quot;暴力匹配&quot;&quot;&quot;
        n = len(haystack)
        m = len(needle)

        i = 0

        while i + m &lt;= n:
            flag = True

            j = 0
            while j &lt; m:
                if haystack[i + j] != needle[j]:
                    flag = False
                    break

                j += 1

            if flag:
                return i

            i += 1
        return -1


if __name__ == &quot;__main__&quot;:
    s = Solution()
    # print(s.strStr(&quot;mississippi&quot;, &quot;issip&quot;))  # [0, 0, 0, 1, 0]
    # print(s.strStr1(&quot;mississippi&quot;, &quot;issip&quot;))  # [0, 0, 0, 1, 0]
    print(s.strStr2(&quot;mississippi&quot;, &quot;issip&quot;))  # [0, 0, 0, 1, 0]
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>kmp算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Django | 安装mysql_python失败</title>
    <url>/2021/07/25/%E5%AE%89%E8%A3%85mysql-python%E5%A4%B1%E8%B4%A5/</url>
    <content><![CDATA[<h1 id="安装mysql-python失败"><a href="#安装mysql-python失败" class="headerlink" title="安装mysql_python失败"></a>安装mysql_python失败</h1><p><a href="https://blog.csdn.net/qq_37431752/article/details/87965695">解决办法！！！</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>框架</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程 | 实现线程体的两种方式</title>
    <url>/2021/08/05/%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E4%BD%93%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="实现线程体的两种方式"><a href="#实现线程体的两种方式" class="headerlink" title="实现线程体的两种方式"></a>实现线程体的两种方式</h1><p>实现线程体主要有以下两种方式：<br>1.自定义函数实现线程体<br>代码实例：</p>
<pre><code># coding=utf-8

import threading
import time


# 线程体函数
def thread_body():
    # 当前线程对象
    t = threading.current_thread()
    for n in range(5):
        # 当前线程名
        print(&#39;第&#123;0&#125;次执行线程&#123;1&#125;&#39;.format(n, t.name))
        # 线程休眠
        time.sleep(2)
    print(&#39;线程&#123;0&#125;执行完成！&#39;.format(t.name))


# 主线程
# 创建线程对象t1
t1 = threading.Thread(target=thread_body)
# 创建线程对象t2
t2 = threading.Thread(target=thread_body, name=&#39;MyThread&#39;)
# 启动线程t1
t1.start()
# 启动线程t2
t2.start()
</code></pre>
<p>2.自定义线程类实现线程体<br>代码实例：</p>
<pre><code># coding=utf-8

import time
import threading


class SmallThread(threading.Thread):
    def __init__(self, name=None):
        super().__init__(name=name)

    # 线程体函数
    def run(self):
        # 当前线程对象
        t = threading.current_thread()
        for n in range(5):
            # 当前线程名
            print(&#39;第&#123;0&#125;次执行线程&#123;1&#125;&#39;.format(n, t.name))
            # 线程休眠
            time.sleep(2)
        print(&#39;线程&#123;0&#125;执行完成&#39;.format(t.name))


# 主线程
# 创建线程对象t1
t1 = SmallThread()  # 通过自定义线程类，创建线程对象
# 创建线程对象t2
t2 = SmallThread(name=&#39;MyThread&#39;)
# 启动线程t1
t1.start()
# 启动线程t2
t2.start()
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>内置模块</category>
        <category>threading</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>threading</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>sviewgui | 对数据文件中的数据进行可视化</title>
    <url>/2021/10/19/%E5%AF%B9%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<h1 id="使用sviewgui对csv文件或Pandas的DataFrame的数据可视化"><a href="#使用sviewgui对csv文件或Pandas的DataFrame的数据可视化" class="headerlink" title="使用sviewgui对csv文件或Pandas的DataFrame的数据可视化"></a>使用sviewgui对csv文件或Pandas的DataFrame的数据可视化</h1><p><a href="https://mp.weixin.qq.com/s/6ftmwDzlyuCgN5YsX81pKQ">参考资料</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>sviewgui</category>
      </categories>
      <tags>
        <tag>sviewgui</tag>
      </tags>
  </entry>
  <entry>
    <title>伪迹移除 | 小波变换</title>
    <url>/2021/02/23/%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="小波变换-Wavelet-Transform-WT"><a href="#小波变换-Wavelet-Transform-WT" class="headerlink" title="小波变换(Wavelet Transform,WT)"></a>小波变换(Wavelet Transform,WT)</h1><p>小波变化是一个时间尺度的表示方法，它把信号分解成时间和尺度的基函数(母小波基函数的扩展/变体)</p>
<h2 id="一些基于小波理论的技术"><a href="#一些基于小波理论的技术" class="headerlink" title="一些基于小波理论的技术"></a>一些基于小波理论的技术</h2><p>1.wavelet packets<br>2.wavelet approximation and decomposition<br>3.discrete and continuous wavelet transform<br>…<br>其中，最常用的技术是离散小波变换(Discrete Wavelet Transform);<br>离散小波变换是由离散输入的连续小波变换得到的；<br>离散小波变换将信号输入到低通滤波器中，得到低频分量，进入高通滤波器得到高频分量。</p>
<h2 id="离散小波变换进行2级分解的示例结构"><a href="#离散小波变换进行2级分解的示例结构" class="headerlink" title="离散小波变换进行2级分解的示例结构"></a>离散小波变换进行2级分解的示例结构</h2><p><img src="/2021/02/23/%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2/1.png"><br>where g[n] is a low pass filter and h[n] is a high pass filter</p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>伪迹移除</category>
      </categories>
      <tags>
        <tag>伪迹移除</tag>
        <tag>EEG</tag>
        <tag>小波变换</tag>
      </tags>
  </entry>
  <entry>
    <title>wxPython | 布局管理器嵌套</title>
    <url>/2021/08/03/%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8%E5%B5%8C%E5%A5%97/</url>
    <content><![CDATA[<h1 id="布局管理器嵌套"><a href="#布局管理器嵌套" class="headerlink" title="布局管理器嵌套"></a>布局管理器嵌套</h1><p><strong>实现效果：</strong><br>单击Button1按钮，显示“Button1单击”静态文本，单击Button2按钮，显示“Button2单击”静态文本。</p>
<p><strong>示例代码：</strong></p>
<h1 id="布局管理器嵌套-1"><a href="#布局管理器嵌套-1" class="headerlink" title="布局管理器嵌套"></a>布局管理器嵌套</h1><pre><code># coding=utf-8
import wx

class MyFrame(wx.Frame):
    def __init__(self):
        super().__init__(None, title=&quot;布局管理器嵌套&quot;, size=(300, 120))
        panel = wx.Panel(parent=self)
        self.static_text = wx.StaticText(parent=panel, label=&quot;请单击按钮&quot;)
        b1 = wx.Button(parent=panel, id=10, label=&#39;Button1&#39;)
        b2 = wx.Button(parent=panel, id=11, label=&#39;Button2&#39;)

        # 创建水平方向的盒子布局管理器hbox对象
        hbox = wx.BoxSizer(wx.HORIZONTAL)
        # 添加b1到hbox布局管理器
        hbox.Add(b1, proportion=1, flag=wx.EXPAND|wx.ALL, border=10)
        hbox.Add(b2, proportion=1, flag=wx.EXPAND|wx.ALL, border=10)

        # 创建垂直方向的盒子布局管理器对象vbox
        vbox = wx.BoxSizer(wx.VERTICAL)
        # 添加静态文本到vbox布局管理器
        vbox.Add(self.static_text, proportion=1, flag=wx.CENTER | wx.FIXED_MINSIZE | wx.TOP, border=10)
        # 将水平hbox布局管理器对象添加到垂直vbox布局管理器对象
        vbox.Add(hbox, proportion=1, flag=wx.CENTER)

        # 设置面板（panel）采用vbox布局管理器
        panel.SetSizer(vbox)

        # 将两个按钮（b1和b2）的单击事件绑定到self.on_click办法
        self.Bind(wx.EVT_BUTTON, self.on_click, id=10, id2=11)

    def on_click(self, event):
        event_id = event.GetId()
        print(event_id)
        if event_id == 10:
            self.static_text.SetLabelText(&#39;Button1单击&#39;)
        else:
            self.static_text.SetLabelText(&#39;Button2单击&#39;)


app = wx.App()  # 创建应用程序对象
frm = MyFrame()  # 创建窗口对象
frm.Show()  # 显示窗口
app.MainLoop()  # 进入主事件循环
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>wxPython</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>wxPython</tag>
      </tags>
  </entry>
  <entry>
    <title>入门指南 | 开发遇到问题怎么解决？</title>
    <url>/2021/02/20/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="开发遇到问题怎么解决？"><a href="#开发遇到问题怎么解决？" class="headerlink" title="开发遇到问题怎么解决？"></a>开发遇到问题怎么解决？</h1><p>我们在做开发的过程中常常会遇到这样、那样的问题，软件安装出错、配置出错、代码运行报错等等令人十分痛苦的问题，那么我们遇到问题时应该怎样去solve?<br><b>Answer:</b>我们在开发中遇到的百分之八九十的问题可以通过<br><b style="color:red">“官方文档+github+stack overflow”</b>去解决！</p>
]]></content>
      <categories>
        <category>入门指南</category>
      </categories>
  </entry>
  <entry>
    <title>基础知识 | 归一化</title>
    <url>/2021/02/21/%E5%BD%92%E4%B8%80%E5%8C%96/</url>
    <content><![CDATA[<h1 id="归一化-Normalization"><a href="#归一化-Normalization" class="headerlink" title="归一化(Normalization)"></a>归一化(Normalization)</h1><p>在使用机器学习算法进行分类工作时，有时候我们发现某个特征对计算结果的影响最大，然而本质上用于分类的几个特征是同等重要的，而某个特征对计算结果影响大这一现象的原因仅仅是因为这个特征的特征值值比其他特征值大。因此<b style="color:red">在处理这种不同范围的特征值时，我们通常采用的方法是将数值归一化</b>，如将取值范围处理为0到1/-1到1之间。<br><b>例</b>：将任意取值范围的特征值转化为0到1区间内的值:<br><b style="red">newValue = (oldValue - min)/(max-min)</b><br>其中min和max分别是数据集中的最小特征值和最大特征值<br><b>Note:改变数值范围增加了分类器的复杂度</b></p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>归一化</tag>
      </tags>
  </entry>
  <entry>
    <title>openpyxl | 快速提取一串字符中的中文</title>
    <url>/2021/10/21/%E5%BF%AB%E9%80%9F%E6%8F%90%E5%8F%96%E4%B8%80%E4%B8%B2%E5%AD%97%E7%AC%A6%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%87/</url>
    <content><![CDATA[<h1 id="快速提取一串字符中的中文"><a href="#快速提取一串字符中的中文" class="headerlink" title="快速提取一串字符中的中文"></a>快速提取一串字符中的中文</h1><p>以下代码实现了快速提取（正则表达式）一串字符串中的中文。</p>
<span id="more"></span>
<pre><code>import re
from openpyxl import load_workbook

data = []
wb = load_workbook(&#39;data/data.xlsx&#39;)
ws = wb.active
for row in range(2, ws.max_row + 1):  # 从第二行开始遍历excel文件所有行
    info = ws[&#39;A&#39; + str(row)].value
    data.append(info)

chinese_list = []
for i in data:
    chinese = re.findall(&#39;[\u4e00-\u9fa5]&#39;, i)
    chinese_list.append(&#39;&#39;.join(chinese))

for row in range(2, ws.max_row + 1):
    ws[&#39;B&#39; + str(row)].value = chinese_list[row - 2]
wb.save(&quot;./data/data_chinese.xlsx&quot;)
</code></pre>
<p><a href="data.xlsx">下载data.xlsx</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>openpyxl</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>openpyxl</tag>
        <tag>re</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 情绪识别想法与实践的起点</title>
    <url>/2021/07/02/%E6%83%85%E7%BB%AA%E8%AF%86%E5%88%AB%E6%83%B3%E6%B3%95%E4%B8%8E%E5%AE%9E%E8%B7%B5%E7%9A%84%E8%B5%B7%E7%82%B9/</url>
    <content><![CDATA[<h1 id="情绪识别想法与实践的起点"><a href="#情绪识别想法与实践的起点" class="headerlink" title="情绪识别想法与实践的起点"></a>情绪识别想法与实践的起点</h1><p>步入研一以来，about我的研究方向，一开始聚焦在脑电伪迹去除，大约看了10篇左右论文，后来在与给老师的汇报和交流中，关于研究方向<br>的keywords变成了：深度学习、脑电、分类、音乐、情绪识别，偶然我遇到了下面这篇论文，题目的每一个字都与我的research密切对应，<br>因此一场深度学习情绪分类的战役由此拉开。。。</p>
<p><b>Paper title:</b> Spatiotemporal Emotion Recognition using Deep CNN Based on EEG during Music Listening<br><a href="https://www.researchgate.net/publication/336736347_Spatiotemporal_Emotion_Recognition_using_Deep_CNN_Based_on_EEG_during_Music_Listening">论文地址</a></p>
<p>这篇论文的作者有几篇关于脑电情绪分类的研究文章，详细信息查看researchgate!<br><a href="https://www.researchgate.net/profile/Panayu-Keelawat">researcher researchgate site</a></p>
<h2 id="论文简要介绍"><a href="#论文简要介绍" class="headerlink" title="论文简要介绍"></a>论文简要介绍</h2><p><b>Considerations:</b><br>1.explore the model’s capabilities in varied window sizes and electrode orders<br>2.model’s complexity:(3conv ~ 6conv)</p>
<p><b>Results:</b><br>temporal information in distinct window sizes significantly affects recognition performance</p>
<p><b>Used Megthod:CNN</b><br>without mannually extracting features</p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>脑电分类</category>
        <category>CNN</category>
      </categories>
      <tags>
        <tag>脑电分类</tag>
        <tag>深度学习</tag>
        <tag>EEG</tag>
        <tag>CNN</tag>
        <tag>情绪识别</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 感知机</title>
    <url>/2021/06/24/%E6%84%9F%E7%9F%A5%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h1><p><a href="https://mp.weixin.qq.com/s/OKUCFdBLuwkJMxRz-gvthQ">点这里查看更多关于感知机的知识！！！</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>感知机</tag>
      </tags>
  </entry>
  <entry>
    <title>C# | 我的第一个CSharp程序</title>
    <url>/2021/07/03/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AACSharp%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="我的第一个CSharp程序"><a href="#我的第一个CSharp程序" class="headerlink" title="我的第一个CSharp程序"></a>我的第一个CSharp程序</h1><pre><code>using System;
/*包含 System 命名空间*/

/*声明命名空间*/
namespace project1
&#123;
    /*定义一个名为HelloWorld的类*/
    class HelloWorld
    &#123;
        /*我的第一个C#程序*/
        static void Main(String[] args)
        &#123;/*Main方法：C#程序的入口*/
            /*WriteLine 是一个定义在 System 命名空间中的 Console 类的一个方法*/
            Console.WriteLine(&quot;Hello World&quot;);
            Console.ReadKey();
        &#125;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>python-docx | 批量修改word文件中的段落格式</title>
    <url>/2021/10/28/%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9word%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%AE%B5%E8%90%BD%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="批量修改word文件中的段落格式"><a href="#批量修改word文件中的段落格式" class="headerlink" title="批量修改word文件中的段落格式"></a>批量修改word文件中的段落格式</h1><p>实现代码：</p>
<pre><code>import os
import docx
# 定义字体格式
from docx.shared import Pt  # 用于设定字体大小（磅值）
from docx.oxml.ns import qn  # 用于应用中文字体


def F_title(run):
    # 标题文字
    run.font.size = Pt(22)  # 文字大小磅值
    run.bold = True  # 加粗
    run.font.name = &quot;方正小标宋_GBK&quot;  # 字体
    r = run._element.rPr.rFonts
    r.set(qn(&quot;w:eastAsia&quot;), &quot;方正小标宋_GBK&quot;)  # 字体


def F_name_dept(run):
    # 姓名，部门，日期
    run.font.size = Pt(17)  # 文字大小磅值
    run.bold = False  # 加粗
    run.font.name = &quot;楷体&quot;  # 字体
    r = run._element.rPr.rFonts
    r.set(qn(&quot;w:eastAsia&quot;), &quot;楷体&quot;)  # 字体


def F_main(run):
    # 正文的格式
    run.font.size = Pt(17)  # 文字大小磅值
    run.bold = False  # 加粗
    run.font.name = &quot;仿宋&quot;  # 字体
    r = run._element.rPr.rFonts
    r.set(qn(&quot;w:eastAsia&quot;), &quot;仿宋&quot;)  # 字体


def F_title1(run):
    # 标题一的格式
    run.font.size = Pt(17)  # 文字大小磅值
    run.bold = False  # 加粗
    run.font.name = &quot;黑体&quot;  # 字体
    r = run._element.rPr.rFonts
    r.set(qn(&quot;w:eastAsia&quot;), &quot;黑体&quot;)  # 字体


def F_title2(run):
    # 标题二的格式
    run.font.size = Pt(17)  # 文字大小磅值
    run.bold = True  # 加粗
    run.font.name = &quot;楷体&quot;  # 字体
    r = run._element.rPr.rFonts
    r.set(qn(&quot;w:eastAsia&quot;), &quot;楷体&quot;)  # 字体


# 获取待处理的文件的路径
path = &#39;待处理文件&#39;  # 文件所在文件夹
files = [path + &quot;\\&quot; + i for i in os.listdir(path)]  # 获取文件夹下的文件名,并拼接完整路径
# print(files)
# 逐个提取文件，设置字体格式
for file in files:
    doc = docx.Document(file)
    for run in doc.paragraphs[0].runs:  # 总标题字体格式
        F_title(run)

    for para in doc.paragraphs[1:3]:  # 部门、姓名及日期字体格式
        for run in para.runs:
            F_name_dept(run)

    title1 = [&quot;一、&quot;, &quot;二、&quot;, &quot;三、&quot;, &quot;四、&quot;]  # 标题一的唯一特征字符串
    title2 = [&quot;1、&quot;, &quot;2、&quot;, &quot;3、&quot;, &quot;4、&quot;]  # 标题二的唯一特征字符串
    for para in doc.paragraphs[3:]:
        if any(i in para.text for i in title1):  # 若该段落是标题一，则应用标题一的字体格式
            for run in para.runs:
                F_title1(run)
        elif any(j in para.text for j in title2):  # 若该段落是标题二，则应用标题二的字体格式
            for run in para.runs:
                F_title2(run)
        else:
            for run in para.runs:  # 其余都应用正文的字体格式
                F_main(run)
    doc.save(&#39;已处理文件\\&#123;&#125;&#39;.format(file.split(&quot;\\&quot;)[1]))
    
</code></pre>
<p>已处理文件：<br><a href="报告-何十.docx">报告-何十.docx</a><br><a href="报告-刘七.docx">报告-刘七.docx</a><br><a href="报告-张三.docx">报告-张三.docx</a><br><a href="报告-朱八.docx">报告-朱八</a><br><a href="报告-李四.docx">报告-李四.docx</a><br><a href="报告-猪八戒.docx">报告-猪八戒.docx</a><br><a href="报告-王五.docx">报告-王五.docx</a><br><a href="报告-秦九.docx">报告-秦九.docx</a><br><a href="报告-赵六.docx">报告-赵六.docx</a><br><a href="报告-黄二.docx">报告-黄二.docx</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>python-docx</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python-docx</tag>
      </tags>
  </entry>
  <entry>
    <title>PIL | 批量压缩图片</title>
    <url>/2021/10/24/%E6%89%B9%E9%87%8F%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h1 id="批量压缩图片"><a href="#批量压缩图片" class="headerlink" title="批量压缩图片"></a>批量压缩图片</h1><p>实现代码：</p>
<pre><code># 将图片按修改时间排序(这样才能与图片的描述一致)，将路径存入列表，以便后面逐个插入图片时调用
import os
from PIL import Image
from docx import Document

path = &quot;6s_pictures&quot;
list_p = [path + &quot;\\&quot; + i for i in os.listdir(path)]  # 获取图片的文件名,并拼接完整路径
list_p.sort(key=lambda path: os.path.getmtime(path))  # 将列表中的文件按其修改时间排序，os.path.getmtime() 函数是获取文件最后修改时间
print(list_p)

# 按比例缩小图片尺寸
for infile in list_p:
    im = Image.open(infile)
    (x, y) = im.size  # 读取图片尺寸（像素）
    x_s = 165  # 定义缩小后的标准宽度
    y_s = int(y * x_s / x)  # 基于标准宽度计算缩小后的高度
    out = im.resize((x_s, y_s), Image.ANTIALIAS)  # 改变尺寸，保持图片高品质
    out.save(r&quot;6s_pictures_new\&#123;&#125;&quot;.format(infile.split(&quot;\\&quot;)[-1]))

path = &quot;6s_pictures_new&quot;
list_p = [path + &quot;\\&quot; + i for i in os.listdir(path)]  # 获取图片的文件名,并拼接完整路径
list_p.sort(key=lambda path: os.path.getmtime(path))  # 将列表中的文件按其修改时间排序，os.path.getmtime() 函数是获取文件最后修改时间

doc = Document(&quot;6S稽查问题模板.docx&quot;)
table = doc.tables[0]  # 已确定是第一个表格，其索引是0

# 增加需要的行，以便足够填入数据
for i in range(len(list_p) - 1):
    table.add_row()

# 写入数据及图片
for row in range(1, len(list_p) + 1):
    # 插入图片
    run = table.cell(row, 2).paragraphs[0].add_run()  # 新增一个文字块
    picture = run.add_picture(list_p[row - 1])  # 插入图片

doc.save(&quot;6S稽查问题.docx&quot;)
</code></pre>
<p><a href="https://github.com/victory-liao/victory-liao.github.io/tree/master/source/images/6s_pictures">6s_pictures</a><br><a href="6S稽查问题模板.docx">6S稽查问题模板.docx</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>PIL</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python-docx</tag>
        <tag>PIL</tag>
      </tags>
  </entry>
  <entry>
    <title>win32api | 批量打印文件</title>
    <url>/2021/10/29/%E6%89%B9%E9%87%8F%E6%89%93%E5%8D%B0%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="定义打印函数，以便重复调用"><a href="#定义打印函数，以便重复调用" class="headerlink" title="定义打印函数，以便重复调用"></a>定义打印函数，以便重复调用</h1><p>实现代码：</p>
<pre><code>import win32api


def Print(fileName):
    win32api.ShellExecute(
        0,  # 指定父窗口句柄，搞不懂
        &quot;print&quot;,  # 指定操作，这里的&quot;print&quot;表示启动打印应用程序
        fileName,  # 要打印的文件名
        None,  # 打印机设置，若是&quot;None&quot;，则使用windows设置的默认打印机
        &quot;.&quot;,  # 指定默认目录，照抄的，搞不懂
        0  # 若fileName参数是一个可执行程序，则此参数指定程序窗口的初始显示方式，否则此参数应设置为0
    )


# 获取待打印文件的路径
import os

path = &#39;文件&#39;  # 文件所在文件夹
files = [path + &quot;\\&quot; + i for i in os.listdir(path)]  # 获取文件夹下的文件名,并拼接完整路径

# 批量打印
for file in files:
    Print(file)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>win32api</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>os</tag>
        <tag>win32api</tag>
      </tags>
  </entry>
  <entry>
    <title>pypiwin32 | 批量发送不同内容的邮件给不同的收件人</title>
    <url>/2021/10/27/%E6%89%B9%E9%87%8F%E5%8F%91%E9%80%81%E4%B8%8D%E5%90%8C%E5%86%85%E5%AE%B9%E7%9A%84%E9%82%AE%E4%BB%B6%E7%BB%99%E4%B8%8D%E5%90%8C%E7%9A%84%E6%94%B6%E4%BB%B6%E4%BA%BA/</url>
    <content><![CDATA[<h1 id="批量发送不同内容的邮件给不同的收件人"><a href="#批量发送不同内容的邮件给不同的收件人" class="headerlink" title="批量发送不同内容的邮件给不同的收件人"></a>批量发送不同内容的邮件给不同的收件人</h1><p>程序实现自动将’年假_按部门’下各个部门的年假情况Excel表格发送给’邮件地址.xlsx’中各个部门的负责人。</p>
<span id="more"></span>
<p>实现代码：</p>
<pre><code>import os
from openpyxl import load_workbook

wb = load_workbook(&quot;邮件地址.xlsx&quot;)
ws = wb.active
address = &#123;&#125;
for i in range(2, ws.max_row + 1):
    dept = ws[&quot;A&quot; + str(i)].value
    to_add = ws[&quot;B&quot; + str(i)].value
    cc_add = ws[&quot;C&quot; + str(i)].value
    address[dept] = [to_add, cc_add]

import win32com.client as win32


def Send_mail(to_add, cc_add, file_path, dept):
    &#39;&#39;&#39;
    传入参数说明：
    to_add,收件人地址
    cc_add,抄送地址
    file_path,附件路径
    dept,部门名称
    &#39;&#39;&#39;
    outlook = win32.Dispatch(&#39;Outlook.Application&#39;)  # 调用windows outlook应用
    mail = outlook.CreateItem(0)  # 创建邮件
    mail.to = to_add  # 收件人
    mail.cc = cc_add  # 抄送人
    mail.Subject = &quot;&#123;&#125;年假情况&quot;.format(dept)  # 主题
    mail.Attachments.Add(file_path)  # 添加附件。若有多个附件，则多调用几次即可
    mail.Body = &#39;&#39;&#39;Dear All,\n这是&#123;&#125;的年假情况，请查收！谢谢。\n\nBest regards!\n人事部 小李&#39;&#39;&#39;.format(dept)  # 正文内容
    mail.Send()  # 发送邮件


# 发送邮件到各部门
for dept in address.keys():
    to_add = address[dept][0]
    cc_add = address[dept][1]
    file_path = os.getcwd() + &#39;\\年假_按部门\\年假情况_&#123;&#125;.xlsx&#39;.format(dept)
    Send_mail(to_add, cc_add, file_path, dept)

print(&quot;邮件发送完成。&quot;)
</code></pre>
<p>‘年假_按部门’文件夹包括以下内容：<br><a href="年假情况_人事部.xlsx">年假情况_人事部.xlsx</a><br><a href="年假情况_关务部.xlsx">年假情况_关务部.xlsx</a><br><a href="年假情况_品质部.xlsx">年假情况_品质部.xlsx</a><br><a href="年假情况_工程部.xlsx">年假情况_工程部.xlsx</a><br><a href="年假情况_总务部.xlsx">年假情况_总务部.xlsx</a><br><a href="年假情况_物料部.xlsx">年假情况_物料部.xlsx</a><br><a href="年假情况_生产部.xlsx">年假情况_生产部.xlsx</a><br><a href="年假情况_研发部.xlsx">年假情况_研发部.xlsx</a><br><a href="年假情况_船务部.xlsx">年假情况_船务部.xlsx</a><br><a href="年假情况_采购部.xlsx">年假情况_采购部.xlsx</a></p>
<p><a href="邮件地址.xlsx">邮件地址.xlsx</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>pypiwin32</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>openpyxl</tag>
        <tag>pypiwin32</tag>
      </tags>
  </entry>
  <entry>
    <title>python-pptx | 批量生成PPT版荣誉证书</title>
    <url>/2021/10/16/%E6%89%B9%E9%87%8F%E7%94%9F%E6%88%90PPT%E7%89%88%E8%8D%A3%E8%AA%89%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<h1 id="批量生成PPT版荣誉证书"><a href="#批量生成PPT版荣誉证书" class="headerlink" title="批量生成PPT版荣誉证书"></a>批量生成PPT版荣誉证书</h1><p>以下代码实现了根据一个excel名单和一个荣誉证书模板批量生成名单中所有人的荣誉证书。</p>
<span id="more"></span>

<pre><code>import time
from pptx import Presentation
from openpyxl import load_workbook

prs = Presentation(r&#39;data\荣誉证书模板.pptx&#39;)
slide = prs.slides.add_slide(prs.slide_layouts[0])  # 第一个模板的第0个板式
for ph in slide.placeholders:  # 遍历这页PPT的所有占位符
    phf = ph.placeholder_format  # 获取占位符的格式
    print(phf.idx)  # 打印其ID编号
    ph.text = str(phf.idx)  # 将编号写入PPT对应的位置中，以便后面一一对应
# 以上读取到占位符的ID方便后面调用
prs.save(r&#39;data\荣誉证书模板-占位符编号.pptx&#39;)


wb = load_workbook(r&quot;data\名单.xlsx&quot;)
ws = wb.active
data = &#123;&#125;
for row in range(2, ws.max_row + 1):
    class_id = ws[&#39;A&#39; + str(row)].value
    name = ws[&#39;B&#39; + str(row)].value
    data.setdefault(class_id, [])
    data[class_id].append(name)

t0 = time.time()  # 程序开始运行的时间

prs = Presentation(r&#39;data\荣誉证书模板.pptx&#39;)
slide_layout = prs.slide_layouts[0]  # 调用设置好的母版，因为是母版的第一版式，所以取[0]
for class_id in data:
    for name in data[class_id]:
        slide = prs.slides.add_slide(slide_layout)  # 以母版的版式为基础新增一页幻灯片
        # 往幻灯片中写入内容
        slide.placeholders[10].text = &quot;&#123;&#125; 班 &#123;&#125; 同学：&quot;.format(class_id, name)  # 此处是班级和姓名
        slide.placeholders[11].text = &quot;在2019-2020学年度第一学期获得&quot;
        slide.placeholders[12].text = &quot;“好孩子”称号。&quot;
        slide.placeholders[13].text = &quot;特发此证，以资鼓励。&quot;
        slide.placeholders[14].text = &quot;市幼儿园&quot;
        slide.placeholders[15].text = &quot;2020年1月&quot;
prs.save(&#39;data\荣誉证书(总).pptx&#39;)
t1 = time.time()

print(&#39;程序用时：&#39;, str(round(t1 - t0)) + &#39;秒。&#39;)
</code></pre>
<p><a href="荣誉证书模板.pptx">荣誉证书模板.pptx</a><br><a href="名单.xlsx">下载名单.xlsx</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>python-pptx</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>openpyxl</tag>
        <tag>python-pptx</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 把隐藏层数量当做参数</title>
    <url>/2021/06/24/%E6%8A%8A%E9%9A%90%E8%97%8F%E5%B1%82%E6%95%B0%E9%87%8F%E5%BD%93%E5%81%9A%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h1 id="把隐藏层数量当做参数"><a href="#把隐藏层数量当做参数" class="headerlink" title="把隐藏层数量当做参数"></a>把隐藏层数量当做参数</h1><p>在搭建深度网络时，不一定非要使用很多隐藏层，在刚开始解决一个新问题时，通常可以从<br>logistic回归开始，再试试一到两个隐层，把隐藏层数量当做参数、超参数一样去调试，这样<br>去找比较合适的深度。</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础 | 折半查找</title>
    <url>/2021/05/24/%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h1 id="递归折半查找算法"><a href="#递归折半查找算法" class="headerlink" title="递归折半查找算法"></a>递归折半查找算法</h1><pre><code>def recursive_binary_search(arr, low, high, key):
        if low &lt;= high:
                mid = (low + high) // 2
            if arr[mid] == key:
                    return mid
            elif key &lt; arr[mid]:
                    return recursive_binary_search(arr, low, mid-1, key)
            else:
                    return recursive_binary_search(arr, mid+1, high, key)

        return -1
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
        <category>算法基础</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>折半查找</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 括号生成</title>
    <url>/2021/09/05/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<h1 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22.括号生成"></a>22.括号生成</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。<br>有效括号组合需满足：左括号必须以正确的顺序闭合。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/generate-parentheses/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>1.暴力法</strong><br>可以生成所有 2^2n 个 ‘(‘ 和 ‘)’ 字符构成的序列，然后我们检查每一个是否有效即可。<br><strong>2.回溯法</strong><br>方法一还有改进的余地：我们可以只在序列仍然保持有效时才添加 ‘(‘ or ‘)’，而不是像 方法一 那样每次添加。我们可以通过跟踪到目前为止放置的左括号和右括号的数目来做到这一点，<br>如果左括号数量不大于 n，我们可以放一个左括号。如果右括号数量小于左括号的数量，我们可以放一个右括号。<br>3.按括号序列的长度递归</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>from functools import lru_cache

class Solution(object):
    def generateParenthesis(self, n):
        &quot;&quot;&quot;
        暴力法
        :type n: int
        :rtype: List[str]
        &quot;&quot;&quot;
        # 生成所有括号组合，然后判断是否是有效括号
        def generate(A):
            if len(A) == 2 * n:
                # print(A)
                if valid(A):
                    ans.append(&quot;&quot;.join(A))
            else:
                A.append(&#39;(&#39;)
                generate(A)
                A.pop()
                A.append(&#39;)&#39;)
                generate(A)
                A.pop()

        def valid(A):
            bal = 0  # 表示左括号的数量减去右括号的数量
            for c in A:
                if c == &#39;(&#39;:
                    bal += 1
                else:
                    bal -= 1

                if bal &lt; 0:
                    return False

            return bal == 0

        ans = []
        generate([])
        return ans

    def generateParenthesis1(self, n):
        &quot;&quot;&quot;
        回溯法

        对暴力解法的改进：
        只在序列仍然保持有效时才添加 &#39;(&#39; or &#39;)&#39;，而不是像 暴力解法 那样每次添加
        我们可以通过跟踪到目前为止放置的左括号和右括号的数目来做到这一点

        如果左括号数量不大于 n，我们可以放一个左括号
        如果右括号数量小于左括号的数量，我们可以放一个右括号
        &quot;&quot;&quot;
        def backtrack(S, left, right):
            if len(S) == 2 * n:
                ans.append(&#39;&#39;.join(S))
                return
            if left &lt; n:
                S.append(&#39;(&#39;)
                backtrack(S, left + 1, right)
                S.pop()
            if right &lt; left:
                S.append(&#39;)&#39;)
                backtrack(S, left, right + 1)
                S.pop()

        ans = []
        backtrack([], 0, 0)
        return ans


class Solution1:
    @lru_cache(None)
    def generateParenthesis(self, n: int):
        &quot;&quot;&quot;按括号序列的长度递归&quot;&quot;&quot;
        if n == 0:
            return [&#39;&#39;]
        ans = []
        for c in range(n):
            for left in self.generateParenthesis(c):
                for right in self.generateParenthesis(n-1-c):
                    ans.append(&#39;(&#123;&#125;)&#123;&#125;&#39;.format(left, right))
        return ans


if __name__ == &#39;__main__&#39;:
    slt = Solution1()
    parenthesis_list = slt.generateParenthesis(3)
    print(parenthesis_list)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>python-pptx | 提取ppt中的文字到word中</title>
    <url>/2021/10/21/%E6%8F%90%E5%8F%96ppt%E4%B8%AD%E7%9A%84%E6%96%87%E5%AD%97%E5%88%B0word%E4%B8%AD/</url>
    <content><![CDATA[<h1 id="提取ppt中的文字到word中"><a href="#提取ppt中的文字到word中" class="headerlink" title="提取ppt中的文字到word中"></a>提取ppt中的文字到word中</h1><p>以下代码实现了将ppt中的所有文字提取到word中。</p>
<span id="more"></span>
<pre><code>from pptx import Presentation

data = []
prs = Presentation(&#39;data\制造业必修课.pptx&#39;)
for slide in prs.slides:  # 遍历每页ppt
    for shape in slide.shapes:  # 遍历ppt中的每个形状
        if shape.has_text_frame:  # 判断该形状是否包含文本，保证有文本才提取
            for paragraph in shape.text_frame.paragraphs:  # 按文本框中的段落提取
                data.append(paragraph.text)  # 提取一个段落的文本，就存到列表data中

# 写入文本文件
TxtFile = open(&#39;data\制造业必修课.txt&#39;, &#39;w&#39;, encoding=&#39;utf-8&#39;)
for i in data:
    TxtFile.write(i + &#39;\n&#39;)  # 写入并换行，以保证正确分段
TxtFile.close()  # 保存

# 写入word文件
import docx

doc = docx.Document()  # 创建一个word文件对象
for i in data:
    doc.add_paragraph(i)  # 增加一个段落，并将列表中的一个字符串写入word文件
doc.save(&#39;data\制造业必修课.docx&#39;)
</code></pre>
<p><a href="制造业必修课.pptx">制造业必修课.pptx</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>python-pptx</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python-docx</tag>
        <tag>python-pptx</tag>
      </tags>
  </entry>
  <entry>
    <title>支持向量机</title>
    <url>/2021/03/20/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="支持向量机-Support-Vector-Machine-SVM"><a href="#支持向量机-Support-Vector-Machine-SVM" class="headerlink" title="支持向量机(Support Vector Machine,SVM)"></a>支持向量机(Support Vector Machine,SVM)</h1><p>支持向量机是我们用于分类的一种算法。</p>
<h2 id="小故事理解SVM"><a href="#小故事理解SVM" class="headerlink" title="小故事理解SVM:"></a>小故事理解SVM:</h2><p>当一个分类问题，数据是线性可分的，也就是用一根棍就可以将两种小球分开的时候，我们只要将棍的位置放在让小球距离棍的距离最大化的位置即可，寻找这个最大间隔的过程，就叫做最优化。但是，现实往往是很残酷的，一般的数据是线性不可分的，也就是找不到一个棍将两种小球很好的分类。这个时候，我们就需要像大侠一样，将小球拍起，用一张纸代替小棍将小球进行分类。想要让数据飞起，我们需要的东西就是核函数(kernel)，用于切分小球的纸，就是超平面。<br>问题是从线性可分延伸到线性不可分的</p>
<h2 id="线性SVM"><a href="#线性SVM" class="headerlink" title="线性SVM"></a>线性SVM</h2><p><img src="/2021/03/20/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/1.png"><br>上图中的(a)是已有的数据，红色和蓝色分别代表两个不同的类别。数据显然是线性可分的，但是将两类数据点分开的直线显然不止一条。上图的(b)和(c)分别给出了B、C两种不同的分类方案，其中黑色实线为分界线，术语称为“决策面”。每个决策面对应了一个线性分类器。虽然从分类结果上看，分类器A和分类器B的效果是相同的。但是他们的性能是有差距的，看下图：<br><img src="/2021/03/20/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/2.png"><br>在”决策面”不变的情况下，我又添加了一个红点。可以看到，分类器B依然能很好的分类结果，而分类器C则出现了分类错误。显然分类器B的”决策面”放置的位置优于分类器C的”决策面”放置的位置，SVM算法也是这么认为的，它的依据就是分类器B的分类间隔比分类器C的分类间隔大。这里涉及到第一个SVM独有的概念”分类间隔”。在保证决策面方向不变且不会出现错分样本的情况下移动决策面，会在原来的决策面两侧找到两个极限位置（越过该位置就会产生错分现象），如虚线所示。虚线的位置由决策面的方向和距离原决策面最近的几个样本的位置决定。而这两条平行虚线正中间的分界线就是在保持当前决策面方向不变的前提下的最优决策面。两条虚线之间的垂直距离就是这个最优决策面对应的分类间隔。显然每一个可能把数据集正确分开的方向都有一个最优决策面（有些方向无论如何移动决策面的位置也不可能将两类样本完全分开），而不同方向的最优决策面的分类间隔通常是不同的，那个具有“最大间隔”的决策面就是SVM要寻找的最优解。而这个真正的最优解对应的两侧虚线所穿过的样本点，就是SVM中的支持样本点，称为”支持向量”。</p>
<h2 id="数学建模"><a href="#数学建模" class="headerlink" title="数学建模"></a>数学建模</h2><p>决策面方程<br>分类间隔方程<br>约束条件</p>
<h2 id="最优化问题的两个基本因素："><a href="#最优化问题的两个基本因素：" class="headerlink" title="最优化问题的两个基本因素："></a>最优化问题的两个基本因素：</h2><p>1.目标函数 你希望什么东西的什么指标达到最好<br>2.优化对象 你期望通过改变哪些因素来使你的目标函数达到最优<br>Example:<br>在线性SVM算法中，目标函数就是分类间隔，优化对象就是决策面</p>
<h2 id="最优化问题的分类："><a href="#最优化问题的分类：" class="headerlink" title="最优化问题的分类："></a>最优化问题的分类：</h2><p>1.无约束优化问题 min f(x)<br>求解方法：费马大定理(求f(x)的导数，令其为0，求得候选最优值，再在这些候选值中验证；如果是凸函数，可以保证是最优解)<br>2.有等式约束的优化问题<br>min f(x)<br>s.t. hi(x)=0,i=1,2,…,n<br>求解方法：拉格朗日乘子法(把等式约束hi(x)用一个系数与f(x)写成一个式子，称为拉格朗日函数，而系数称为拉格朗日乘子。通过拉格朗日函数对各个变量求导，令其为0，求得候选值集合，然后验证求得最优值)<br>3.有不等式约束的优化问题<br>min f(x)<br>s.t. gi(x)&lt;=0,i=1,2,…,n<br>hj(x)=0,j=1,2,…,m<br>求解方法：拉格朗日+KKT条件 把所有的等式、不等式约束与f(x)写成一个式子，也叫拉格朗日函数，系数也称为拉格朗日乘子，通过一些条件可以求出最优值的必要条件，这个条件称为KKT条件。</p>
<p>KKT条件的全称是Karush-Kuhn-Tucker条件，KKT条件是说最优值条件必须满足以下条件：<br>条件一：经过拉格朗日函数处理之后的新目标函数L(w,b,α)对x求导为零：<br>条件二：h(x) = 0；<br>条件三：α*g(x) = 0；</p>
<p><b>使用拉格朗日方程的目的：</b><br>将约束条件放到目标函数中，将有约束优化问题转换为无约束优化问题（我们知道我们要求解的是最小化问题，所以一个直观的想法是如果我能够构造一个函数，使得该函数在可行解区域内与原目标函数完全一致，而在可行解区域外的数值非常大，甚至是无穷大，那么这个没有约束条件的新目标函数的优化问题就与原来有约束条件的原始目标函数的优化问题是等价的问题。）</p>
<p>使用拉格朗日获得的函数使用求导方法求解依然困难，进而需要对问题进行一次转换，即使用一个数学技巧：拉格朗日对偶(将最小值和最大值的计算位置交换)</p>
<p><b>拉个朗日优化问题的两个步骤：</b><br>1.将有约束的原始目标函数转换为无约束的新构造的拉格朗日目标函数<br>2.使用拉格朗日对偶性，将不易求解的优化问题转化为容易求解的优化问题</p>
<p><b>求解对偶问题的三个步骤：</b><br>1.首先要让L(w,b,α)关于w和b最小化<br>2.求对α的极大<br>3.利用SMO算法求解对偶问题中的拉格朗日乘子</p>
<h2 id="SMO算法"><a href="#SMO算法" class="headerlink" title="SMO算法"></a>SMO算法</h2><p>1996年，John Platt发布了一个称为SMO的强大算法，用于训练SVM。SMO表示序列最小化(Sequential Minimal Optimizaion)。Platt的SMO算法是将大优化问题分解为多个小优化问题来求解的。这些小优化问题往往很容易求解，并且对它们进行顺序求解的结果与将它们作为整体来求解的结果完全一致的。在结果完全相同的同时，SMO算法的求解时间短很多。</p>
<p><b>SMO算法的目标:</b><br>求出一系列alpha和b，一旦求出了这些alpha，就很容易计算出权重向量w并得到分隔超平面。</p>
<p><b>SMO算法的工作原理是：</b><br>每次循环中选择两个alpha进行优化处理。一旦找到了一对合适的alpha，那么就增大其中一个同时减小另一个。这里所谓的”合适”就是指两个alpha必须符合以下两个条件，条件之一就是两个alpha必须要在间隔边界之外，而且第二个条件则是这两个alpha还没有进行过区间化处理或者不在边界上。</p>
<p><b>注意：</b><br>实际上，对于目标函数，是存在一个假设(数据100%线性可分)的，但现实中的数据都不那么干净，这时我们就可以通过引入松弛变量ξ(slack variable)和惩罚参数C来允许有些数据点可以处于超平面的错误的一侧—&gt;约束条件的改变—&gt;目标函数的改变</p>
<h2 id="SMO算法优化"><a href="#SMO算法优化" class="headerlink" title="SMO算法优化"></a>SMO算法优化</h2><p>启发式选择第二个alpha值</p>
<h2 id="非线性SVM"><a href="#非线性SVM" class="headerlink" title="非线性SVM"></a>非线性SVM</h2><h3 id="核技巧"><a href="#核技巧" class="headerlink" title="核技巧"></a>核技巧</h3><p>对于非线性情况：SVM的处理方式是选择一个核函数。简而言之：在线性不可分的情况下，SVM通过某种事先选择的非线性映射（核函数）将输入变量映到一个高维特征空间，将其变成在高维空间线性可分，在这个高维空间中构造最优分类超平面。</p>
<h3 id="建立非线性学习器分为两步："><a href="#建立非线性学习器分为两步：" class="headerlink" title="建立非线性学习器分为两步："></a>建立非线性学习器分为两步：</h3><p>1.首先使用一个非线性映射将数据变换到一个特征空间F；<br>2.然后在特征空间使用线性学习器分类。</p>
<h3 id="核函数方法"><a href="#核函数方法" class="headerlink" title="核函数方法"></a>核函数方法</h3><p>在特征空间中直接计算内积 &lt;ϕ(xi),ϕ(x)&gt;的方法称为核函数方法</p>
<p>核是一个函数k，对所有x,z∈X，满足k(x,z)=&lt;ϕ(xi),ϕ(x)&gt;，这里ϕ(·)是从原始输入空间X到内积空间F的映射。</p>
<p>简而言之：如果不是用核技术，就会先计算线性映ϕ(x1)和ϕ(x2)，然后计算这它们的内积，使用了核技术之后，先把ϕ(x1)和ϕ(x2)的一般表达式&lt;ϕ(x1),ϕ(x2)&gt;=k(&lt;ϕ(x1),ϕ(x2) &gt;)计算出来，这里的&lt;·，·&gt;表示内积，k(·，·)就是对应的核函数</p>
<p>将内积替换成核函数的方式被称为核技巧(kernel trick)。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="SVM的优缺点"><a href="#SVM的优缺点" class="headerlink" title="SVM的优缺点"></a>SVM的优缺点</h3><p>优点：<br>1.可用于线性/非线性分类，也可以用于回归，泛化错误率低，也就是说具有良好的学习能力，且学到的结果具有很好的推广性。<br>2.可以解决小样本情况下的机器学习问题，可以解决高维问题，可以避免神经网络结构选择和局部极小点问题。<br>3.SVM是最好的现成的分类器，现成是指不加修改可直接使用。并且能够得到较低的错误率，SVM可以对训练集之外的数据点做很好的分类决策。</p>
<p>缺点：对参数调节和和函数的选择敏感。</p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>SVM</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>SVM</tag>
        <tag>支持向量机</tag>
      </tags>
  </entry>
  <entry>
    <title>数据中的缺失值的处理</title>
    <url>/2021/03/19/%E6%95%B0%E6%8D%AE%E4%B8%AD%E7%9A%84%E7%BC%BA%E5%A4%B1%E5%80%BC%E7%9A%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="数据中的缺失值的处理"><a href="#数据中的缺失值的处理" class="headerlink" title="数据中的缺失值的处理"></a>数据中的缺失值的处理</h1><p>1.使用可用特征的均值来填补缺失值；<br>2.使用特殊值来填补缺失值，如-1；<br>3.忽略有缺失值的样本；<br>4.使用相似样本的均值添补缺失值；<br>5.使用另外的机器学习算法预测缺失值。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>数据缺失值处理</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 旋转链表</title>
    <url>/2021/08/27/%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61.旋转链表"></a>61.旋转链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/rotate-list/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>方法一：</strong> 闭合为环<br>记给定链表的长度为 n，注意到当向右移动的次数 k≥n 时，我们仅需要向右移动 k mod n 次即可。因为每 n 次移动都会让链表变为原状。这样我们可以知道，新链表的最后一个节点为原链表的第 (n−1)−(k mod n) 个节点（从 0 开始计数）。<br>这样，我们可以先将给定的链表连接成环，然后将指定位置断开。<br>具体代码中，我们首先计算出链表的长度 n，并找到该链表的末尾节点，将其与头节点相连。这样就得到了闭合为环的链表。然后我们找到新链表的最后一个节点（即原链表的第 (n−1)−(k mod n) 个节点），将当前闭合为环的链表断开，即可得到我们所需要的结果。<br><strong>方法二：</strong> 将后k个节点移到前n-k个节点之前（n为链表长度）<br><strong>特别地，当链表长度不大于 1，或者 k 为 n 的倍数时，新链表将与原链表相同，我们无需进行任何处理。</strong></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def rotateRight(self, head, k):
        &quot;&quot;&quot;
        :type head: ListNode
        :type k: int
        :rtype: ListNode
        &quot;&quot;&quot;
        # 如果链表为空直接返回head
        # 如果右旋转的次数为0直接返回head
        if head is None or head.next is None or k == 0 :
            return head

        # 统计head链表的长度
        p1 = head
        count = 0
        while p1:
            count += 1
            p1 = p1.next

        # 如果链表只有一个节点，直接返回head
        # 如果右旋转次数除以链表长度的余数为0,直接返回head
        if k % count == 0:
            return head

        i = 0
        p2 = head
        k = k % count  # 去掉整圈的旋转
        while i &lt; count - k - 1:  # 找到后k个节点的前一个节点
            p2 = p2.next
            i += 1
        second = p2.next  # second为后k个节点组成的链表
        p2.next = None  # 将前count - k个节点的最后一个节点的next值置空

        p3 = second
        while p3.next is not None:  # 找到后k个节点组成的链表的最后一个节点
            p3 = p3.next

        p3.next = head  # 将后k个节点组成的链表与前count-k个节点组成的链表连接起来

        return second

    def rotateRight1(self, head, k):
        &quot;&quot;&quot;
        :type head: ListNode
        :type k: int
        :rtype: ListNode
        &quot;&quot;&quot;
        if k == 0 or not head or not head.next:
            return head

        # 求链表长度
        n = 1
        cur = head
        while cur.next:
            cur = cur.next
            n += 1

        add = n - k % n
        if add == n:
            return head

        # 链表闭合成环
        cur.next = head
        while add:
            cur = cur.next
            add -= 1

        ret = cur.next
        cur.next = None  # 将闭合为环的链表断开
        return ret

    def create_linked_list(self, list):
        &quot;&quot;&quot;根据list中的所有元素构建单链表&quot;&quot;&quot;
        l = ListNode()  # 单链表头节点
        r = l  # 起始尾指针r指向头节点
        for e in list:
            node = ListNode(e)
            r.next = node
            r = r.next

        return l.next

    def print_linked_list(self, linked_list) -&gt; None:
        &quot;&quot;&quot;
        打印单链表中的所有元素

        :param linked_list: 单链表
        :return: 无
        &quot;&quot;&quot;
        print(&quot;----------------------------------------&quot;)
        pointer = linked_list
        while pointer is not None:
            print(pointer.val)
            pointer = pointer.next


if __name__ == &quot;__main__&quot;:
    slt = Solution()

    linked_list = slt.create_linked_list([1, 2])

    slt.print_linked_list(linked_list)

    rotated_linked_list = slt.rotateRight1(linked_list, 2)

    slt.print_linked_list(rotated_linked_list)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 无重复字符的最长子串</title>
    <url>/2021/08/27/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a>3.无重复字符的最长子串</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>找出字符串中所有不包含重复字符的字串,返回长度最长的一个子串</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def lengthOfLongestSubstring(self, s: str) -&gt; int:
        &quot;&quot;&quot;找出字符串中所有不包含重复字符的字串,返回长度最长的一个子串&quot;&quot;&quot;
        s_list = list(s)  # 将字符串转化为列表
        max_length = 0  # 最大字串长度

        # 找出以字符串中的每个字母开头的不包含重复字符的字串
        for i in range(0, len(s_list)):
            sub_str_list = []
            sub_str_list.append(s_list[i])
            for j in range(i + 1, len(s_list)):
                if s_list[j] not in sub_str_list:
                    sub_str_list.append(s_list[j])
                else:  # 遇到字串中已有的字符,则结束当前子串的寻找
                    break
            # print(&quot;sub_str_list:&quot;, sub_str_list)

            if len(sub_str_list) &gt; max_length:
                max_length = len(sub_str_list)
                # print(&quot;max_length:&quot;, max_length)
                sub_str = &quot;&quot;
                for e in sub_str_list:
                    sub_str += e
                # print(&quot;sub_str:&quot;, sub_str)
                # print(&quot;long_sub_str:&quot;, sub_str)

        print(&quot;无重复字符的最长字串是&#123;&#125;,长度为&#123;&#125;&quot;.format(sub_str, max_length))

        return max_length

    def lengthOfLongestSubstring1(self, s: str) -&gt; int:
        # 哈希集合，记录每个字符是否出现过
        occ = set()
        n = len(s)
        # 右指针，初始值为-1，相当于我们在字符串的左边界的左侧，还没有开始移动
        rk, ans = -1, 0
        for i in range(n):
            if i != 0:
                # 左指针向右移动一格，移动一个字符
                occ.remove(s[i - 1])
            while rk + 1 &lt; n and s[rk + 1] not in occ:
                # 不断地移动右指针
                occ.add(s[rk + 1])
                rk += 1
            # 第i到rk个字符是一个极长的无重复字符字串
            ans = max(ans, rk - i + 1)
        return ans


if __name__ == &quot;__main__&quot;:
    s = &quot;pwwkew&quot;
    slt = Solution()
    len_long_sub_str = slt.lengthOfLongestSubstring1(s)
    print(len_long_sub_str)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>伪迹移除 | 时频表示</title>
    <url>/2021/02/23/%E6%97%B6%E9%A2%91%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<h1 id="时频表示-Time-Frequency-Representation"><a href="#时频表示-Time-Frequency-Representation" class="headerlink" title="时频表示(Time Frequency Representation)"></a>时频表示(Time Frequency Representation)</h1><p>时频表示基于短时傅里叶变换(Short-Time Fourier Transfrom,STFT)。</p>
<h2 id="同时使用时间、频率域分析的原因："><a href="#同时使用时间、频率域分析的原因：" class="headerlink" title="同时使用时间、频率域分析的原因："></a>同时使用时间、频率域分析的原因：</h2><p>脑电信号的非稳定特性</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>在所有的频率范围有统一的时频分辨率，然而我们感兴趣的脑电的频率通常小于30Hz,很多伪迹的频率小于10Hz，这就需要在低频范围有STFT(短时傅里叶变换)不能提供的高频分辨率。</p>
<h2 id="问题的解决"><a href="#问题的解决" class="headerlink" title="问题的解决"></a>问题的解决</h2><p>采用基于小波的方法-小波变换（适合为脑电信号的每一个频带提供相应的分辨率）</p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>伪迹移除</category>
      </categories>
      <tags>
        <tag>EEG</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 最简单的神经网络</title>
    <url>/2021/06/20/%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="最简单的神经网络"><a href="#最简单的神经网络" class="headerlink" title="最简单的神经网络"></a>最简单的神经网络</h1><p><img src="/2021/06/20/%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/1.png"></p>
<p>其中：X为神经网络的输入 Y为神经网络的输出<br>描述：输入X通过一个节点（一个单独的神经元），最终输出Y<br>例：把房屋的面积作为神经网络的输入，通过一个神经元，最终输出了房屋的价格</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 最长公共前缀</title>
    <url>/2021/08/27/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
    <content><![CDATA[<h1 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14.最长公共前缀"></a>14.最长公共前缀</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。<br>如果不存在公共前缀，返回空字符串 “”。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/longest-common-prefix/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.横向扫描<br>用 LCP(S1…Sn)\textit{LCP}(S_1 \ldots S_n)LCP(S1​…Sn​) 表示字符串 S1…SnS_1 \ldots S_nS1​…Sn​ 的最长公共前缀。<br>可以得到以下结论：<br>LCP(S1…Sn)=LCP(LCP(LCP(S1,S2),S3),…Sn)<br>基于该结论，可以得到一种查找字符串数组中的最长公共前缀的简单方法。依次遍历字符串数组中的每个字符串，对于每个遍历到的字符串，更新最长公共前缀，当遍历完所有的字符串以后，即可得到字符串数组中的最长公共前缀。<br>如果在尚未遍历完所有的字符串时，最长公共前缀已经是空串，则最长公共前缀一定是空串，因此不需要继续遍历剩下的字符串，直接返回空串即可。<br>2.纵向扫描<br>纵向扫描时，从前往后遍历所有字符串的每一列，比较相同列上的字符是否相同，如果相同则继续对下一列进行比较，如果不相同则当前列不再属于公共前缀，当前列之前的部分为最长公共前缀。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def longestCommonPrefix(self, strs) -&gt; str:
        if not strs:
            return &quot;&quot;

        prefix, count = strs[0], len(strs)
        for i in range(1, count):
            prefix = self.lcp(prefix, strs[i])
            if not prefix:
                break

        return prefix

    def lcp(self, str1, str2):
        length, index = min(len(str1), len(str2)), 0
        while index &lt; length and str1[index] == str2[index]:
            index += 1

        return str1[:index]

    def longestCommonPrefix1(self, strs) -&gt; str:
        if not strs:
            return &#39;&#39;

        length, count = len(strs[0]), len(strs)
        for i in range(length):
            c = strs[0][i]
            for j in range(1, count):
                if i == len(strs[j]) or strs[j][i] != c:
                    return strs[0][:i]

        return strs[0]


if __name__ == &quot;__main__&quot;:
    slt = Solution()

    # strs = [&quot;&quot;]
    # strs = [&quot;&quot;, &quot;&quot;]
    # strs = [&#39;ab&#39;, &#39;a&#39;]
    # strs = [&quot;dog&quot;, &quot;racecar&quot;, &quot;car&quot;]
    # strs = [&#39;abcd&#39;, &#39;abcf&#39;, &#39;abcde&#39;]
    strs = [&quot;flower&quot;, &quot;flow&quot;, &quot;flight&quot;]

    prefix = slt.longestCommonPrefix1(strs)
    print(&quot;当前&#123;&#125;个字符串的最长公共前缀为：&#123;&#125;&quot;.format(len(strs), prefix))
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 最长回文串</title>
    <url>/2021/09/03/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="5-最长回文串"><a href="#5-最长回文串" class="headerlink" title="5.最长回文串"></a>5.最长回文串</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 s，找到 s 中最长的回文子串。</p>
<span id="more"></span>
<p>示例 1：<br>输入：s = “babad”<br>输出：”bab”<br>解释：”aba” 同样是符合题意的答案。</p>
<p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.暴力解法<br><strong>2.动态规划</strong><br><strong>3.中心扩展算法</strong><br>4.Manacher 算法<br>注：算法详情请参考leetcode题解</p>
<p><a href="https://writings.sh/post/algorithm-longest-palindromic-substring">几种方法的总结！！！强烈推荐！！！</a></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def longestPalindrome(self, s: str) -&gt; str:
        &quot;&quot;&quot;暴力解法（超出时间限制）&quot;&quot;&quot;
        # max_len = 0
        # longest_palindrome = &quot;&quot;
        # for i in range(0, len(s)):
        #     for j in range(i+1, len(s)+1):
        #         string = s[i:j]
        #         # print(string)
        #         if self.isPalindrome(string):
        #             if len(string) &gt; max_len:
        #                 max_len = len(string)
        #                 longest_palindrome = string
        #
        # return longest_palindrome

        len_s = len(s)
        if len_s &lt; 2:
            return s

        max_len = 1
        begin = 0
        # 枚举所有长度严格大于1的字串
        for i in range(0, len_s-1):
            for j in range(i + 1, len_s):
                if j - i + 1 &gt; max_len and self.isPalindrome(s[i: j+1]):
                    max_len = j - i + 1
                    begin = i

        return s[begin:begin + max_len]

    def isPalindrome(self, s: str) -&gt; bool:
        &quot;&quot;&quot;
        筛选+判断（判断反转字符串是否与原字符串相同）
        &quot;&quot;&quot;
        new_s = &quot;&quot;.join(ch.lower() for ch in s if ch.isalnum())
        return new_s == new_s[::-1]

    def longestPalindrome1(self, s: str) -&gt; str:
        &quot;&quot;&quot;
        动态规划算法

        一个回文串去掉两头以后，剩下的部分依然是回文

        -状态：dp[i][j]表示字串s[i..j]是否为回文子串
        -得到状态转移方程：dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]
         边界条件：j - 1 - (i + 1) + 1 &lt; 2,整理得j - i &lt; 3 &lt;===&gt; j - i + 1 &lt; 4
         (s[i][j]长度为2或者3时，不用检查字串是否回文)
        -初始化：dp[i][i] = true
        -输出：在得到一个状态的值为true的时候，记录起始位置和长度，填表完成以后再截取

        状态转移方程：dp[i][j] = (s[i] == s[j]) and (j - i &lt; 3 or dp[i + 1][j - 1]
        &quot;&quot;&quot;
        n = len(s)
        if n &lt; 2:
            return s

        max_len = 1
        begin = 0

        # dp[i][j]表示s[i..j]是否是回文串
        dp = [[False] * n for _ in range(n)]
        for i in range(n):
            dp[i][i] = True

        # 注意：先填左下角
        for j in range(1, n):
            for i in range(0, j):
                if s[i] != s[j]:
                    dp[i][j] = False
                else:
                    if j - i &lt; 3:
                        dp[i][j] = True
                    else:
                        dp[i][j] = dp[i + 1][j-1]

                # 只要 dp[i][j] == true 成立，就表示子串 s[i..j] 是回文，此时记录回文长度和起始位置
                if dp[i][j] and j - i + 1 &gt; max_len:
                    max_len = j - i + 1
                    begin = i
        return s[begin:begin + max_len]

    def longestPalindrome2(self, s: str) -&gt; str:
        &quot;&quot;&quot;中心扩展算法&quot;&quot;&quot;
        start = 0  # 最长回文串的起始位置
        end = 0  # 最长回文串的结束位置
        for i in range(len(s)):
            left1, right1 = self.expandAroundCenter(s, i, i)  # 边界情况1：子串长度为1的情况
            left2, right2 = self.expandAroundCenter(s, i, i + 1)  # # 边界情况2：子串长度为2的情况
            if right1 - left1 &gt; end - start:  # 扩展的新回文串长度大于当前最长回文串
                start, end = left1, right1
            if right2 - left2 &gt; end - start:
                start, end = left2, right2
        return s[start:end + 1]

    def expandAroundCenter(self, s, left, right):
        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return left + 1, right - 1

    def expand(self, s, left, right):
        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return (right - left - 2) // 2

    def longestPalindrome3(self, s: str) -&gt; str:
        &quot;&quot;&quot;Manacher 算法&quot;&quot;&quot;
        end = -1
        start = 0
        s = &#39;#&#39; + &#39;#&#39;.join(list(s)) + &#39;#&#39;
        arm_len = []
        right = -1
        j = -1
        for i in range(len(s)):
            if right &gt;= i:
                i_sym = 2 * j - i
                min_arm_len = min(arm_len[i_sym], right - i)
                cur_arm_len = self.expand(s, i - min_arm_len, i + min_arm_len)
            else:
                cur_arm_len = self.expand(s, i, i)
            arm_len.append(cur_arm_len)
            if i + cur_arm_len &gt; right:
                j = i
                right = i + cur_arm_len
            if 2 * cur_arm_len + 1 &gt; end - start:
                start = i - cur_arm_len
                end = i + cur_arm_len
        return s[start + 1:end + 1:2]


if __name__ == &#39;__main__&#39;:
    slt = Solution()
    s = &quot;abad&quot;
    res = slt.longestPalindrome(s)
    print(&quot;最长的回文串为：&quot;, res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 最小栈</title>
    <url>/2021/08/27/%E6%9C%80%E5%B0%8F%E6%A0%88/</url>
    <content><![CDATA[<h1 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155.最小栈"></a>155.最小栈</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。<br>    push(x) —— 将元素 x 推入栈中。<br>    pop() —— 删除栈顶的元素。<br>    top() —— 获取栈顶元素。<br>    getMin() —— 检索栈中的最小元素。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/min-stack/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>栈的性质：先进后出</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class MinStack(object):
    def __init__(self):
        &quot;&quot;&quot;
        initialize your data structure here.
        &quot;&quot;&quot;
        self.stack = list()

    def push(self, val):
        &quot;&quot;&quot;
        :type val: int
        :rtype: None
        &quot;&quot;&quot;
        self.stack.append(val)

    def pop(self):
        &quot;&quot;&quot;
        :rtype: None
        &quot;&quot;&quot;
        if len(self.stack) != 0:
            self.stack.pop()

    def top(self):
        &quot;&quot;&quot;
        :rtype: int
        &quot;&quot;&quot;
        if len(self.stack) != 0:
            return self.stack[-1]

    def getMin(self):
        &quot;&quot;&quot;
        :rtype: int
        &quot;&quot;&quot;
        if len(self.stack) != 0:
            return min(self.stack)

# Your MinStack object will be instantiated and called as such:
# obj = MinStack()
# obj.push(val)
# obj.pop()
# param_3 = obj.top()
# param_4 = obj.getMin()

import math

class MinStack1:
    &quot;&quot;&quot;辅助栈&quot;&quot;&quot;
    def __init__(self):
        self.stack = []
        self.min_stack = [math.inf]

    def push(self, x: int) -&gt; None:
        self.stack.append(x)
        self.min_stack.append(min(x, self.min_stack[-1]))

    def pop(self) -&gt; None:
        self.stack.pop()
        self.min_stack.pop()

    def top(self) -&gt; int:
        return self.stack[-1]

    def getMin(self) -&gt; int:
        return self.min_stack[-1]



if __name__ == &quot;__main__&quot;:
    # min_stack = MinStack()
    min_stack = MinStack1()
    min_stack.push(-2)
    min_stack.push(0)
    min_stack.push(-3)
    print(min_stack.getMin())
    min_stack.pop()
    print(min_stack.top())
    print(min_stack.getMin())
    print(math.inf)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 最长特殊序列</title>
    <url>/2021/09/01/%E6%9C%80%E9%95%BF%E7%89%B9%E6%AE%8A%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="521-最长特殊序列"><a href="#521-最长特殊序列" class="headerlink" title="521.最长特殊序列"></a>521.最长特殊序列</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两个字符串，请你从这两个字符串中找出最长的特殊序列。<br>「最长特殊序列」定义如下：该序列为某字符串独有的最长子序列（即不能是其他字符串的子序列）。<br>子序列 可以通过删去字符串中的某些字符实现，但不能改变剩余字符的相对顺序。空序列为所有字符串的子序列，任何字符串为其自身的子序列。<br>输入为两个字符串，输出最长特殊序列的长度。如果不存在，则返回 -1。</p>
<span id="more"></span>
<p>刷到这道题目时我表示有点没看懂，然后就看了leetcode的评论，也有许多人没看懂，最后就看了题解。。。<br>我认为，本题按照leetcode官方题解解法二的解决方案容易理解。</p>
<p><a href="https://leetcode-cn.com/problems/longest-uncommon-subsequence-i/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>字符串 aaa 和 bbb 共有 3 种情况：<br>    a=b。如果两个字符串相同，则没有特殊子序列，返回 -1。<br>    length(a)=length(b) 且 a≠b。例如：abc 和 abd。这种情况下，一个字符串一定不会是另外一个字符串的子序列，因此可以将任意一个字符串看作是特殊子序列，返回 length(a) 或 length(b)。<br>    length(a)≠length(b)。例如：abcd 和 abc。这种情况下，长的字符串一定不会是短字符串的子序列，因此可以将长字符串看作是特殊子序列，返回 max(length(a),length(b))。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def findLUSlength(self, a: str, b: str) -&gt; int:
        if a == b:
            return -1

        return max(len(a), len(b))


if __name__ == &quot;__main__&quot;:
    slt = Solution()
    a = &quot;aaa&quot;
    b = &quot;bbb&quot;
    res = slt.findLUSlength(a, b)
    print(res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>有效的括号</title>
    <url>/2021/08/27/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。<br>有效字符串需满足：<br>    左括号必须用相同类型的右括号闭合。<br>    左括号必须以正确的顺序闭合。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/valid-parentheses/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>遍历字符串，遇到右括号将右括号入栈，遇到左括号判断此左括号是否与栈顶括号相同，若相同则将栈顶元素出栈，…，最后在遍历结束后判断栈是否为空，若为空则为有效括号。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):
    def isValid(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: bool
        &quot;&quot;&quot;
        if len(s) % 2 == 1:
            return False

        stack = []
        for ch in s:
            if ch == &#39;(&#39; or ch == &#39;[&#39; or ch == &#39;&#123;&#39;:
                stack.append(ch)
            elif ch == &#39;)&#39; and len(stack) != 0:
                    if stack[-1] == &#39;(&#39;:
                        stack.pop()
                    else:
                        return False
            elif ch == &#39;]&#39; and len(stack) != 0:
                    if stack[-1] == &#39;[&#39;:
                        stack.pop()
                    else:
                        return False
            elif ch == &#39;&#125;&#39; and len(stack) != 0:
                    if stack[-1] == &#39;&#123;&#39;:
                        stack.pop()
                    else:
                        return False
            else:
                return False

        if len(stack) == 0:
            return True
        else:
            return False

    def isValid1(self, s):
        if len(s) % 2 == 1:
            return False

        pairs = &#123;
            &quot;)&quot;: &quot;(&quot;,
            &quot;]&quot;: &quot;[&quot;,
            &quot;&#125;&quot;: &quot;&#123;&quot;
        &#125;
        stack = list()
        for ch in s:
            if ch in pairs:
                if not stack or stack[-1] != pairs[ch]:
                    return False
                stack.pop()
            else:
                stack.append(ch)

        return not stack




if __name__ == &quot;__main__&quot;:
    slt = Solution()
    # s = &quot;()&quot;
    # s = &quot;()[]&#123;&#125;&quot;
    # s = &quot;(]&quot;
    # s = &quot;([)]&quot;
    # s = &quot;&#123;[]&#125;&quot;
    s = &quot;]&quot;
    ret = slt.isValid1(s)
    print(ret)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习 | 朴素贝叶斯</title>
    <url>/2021/03/05/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/</url>
    <content><![CDATA[<h1 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h1><p>朴素贝叶斯算法(Naive Bayes)是<b>有监督(supervised)</b>的学习算法，解决的是<b>分类</b>问题(例如：客户是否流失、是否值得投资、信用等级评定等<b>多分类</b>问题)</p>
<span id="more"></span>
<h2 id="朴素贝叶斯理论"><a href="#朴素贝叶斯理论" class="headerlink" title="朴素贝叶斯理论"></a>朴素贝叶斯理论</h2><p><b style="color:red">朴素贝叶斯理论的核心思想：选择具有最高概率的决策</b></p>
<p>假设现在我们用p1(x,y)表示数据点(x,y)属于类别1的概率，用p2(x,y)表示数据点(x,y)属于类别2的概率，那么对于一个新的数据点，可以用以下规则来进行判断：</p>
<li>如果p1(x,y) > p2(x,y),那么类别为1</li>
<li>如果p1(x,y) < p2(x,y),那么类别为2</li>

<h2 id="条件概率-Conditional-probability"><a href="#条件概率-Conditional-probability" class="headerlink" title="条件概率(Conditional probability)"></a>条件概率(Conditional probability)</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>条件概率指在事件B发生的情况下，事件A发生的概率，用P(A|B)来表示。</p>
<h3 id="条件概率计算公式"><a href="#条件概率计算公式" class="headerlink" title="条件概率计算公式"></a>条件概率计算公式</h3><p><b style="color:red">P(A|B)=P(B|A)P(A)/P(B)</b></p>
<h2 id="全概率公式"><a href="#全概率公式" class="headerlink" title="全概率公式"></a>全概率公式</h2><p><img src="/2021/03/05/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/1.jpg"><br>全概率公式：<br><img src="/2021/03/05/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/2.jpg"><br>条件概率的另一种写法：<br><img src="/2021/03/05/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/3.jpg"></p>
<h2 id="贝叶斯推断"><a href="#贝叶斯推断" class="headerlink" title="贝叶斯推断"></a>贝叶斯推断</h2><p>对条件概率公式进行变形，得到：<br><img src="/2021/03/05/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/4.jpg"><br>其中，P(A)称为“<b>先验概率</b>”(Prior probability),即在B事件发生之前，我们对A事件概率的一个判断。<br><br>P(A|B)称为“<b>后验概率</b>”，即在B事件发生之后，我们对A事件概率的重新判断。<br><br>P(B|A)/P(B)称为“可能性函数”，即调整因子，使得预估概率更接近真实概率。可能性函数&gt;1：意味着先验概率被增强，事件A发生的可能性变大；可能性函数=1：意味着B事件无助于判断事件A的可能性；可能性函数&lt;1:意味着先验概率被削弱，事件A的可能性变小</p>
<p>因此，我们可以把条件概率理解成：<br><b>后验概率 = 先验概率 * 调整因子</b></p>
<p><b style="color:red">贝叶斯推断的含义：我们先预估一个“先验概率”，然后加入实验结果，看这个实验结果到底是增强还是削弱了“先验概率”，由此得到更接近事实的”后验概率”</b></p>
<h2 id="朴素贝叶斯推断"><a href="#朴素贝叶斯推断" class="headerlink" title="朴素贝叶斯推断"></a>朴素贝叶斯推断</h2><p>贝叶斯和朴素贝叶斯的概念是不同的，区别就在于“朴素”二字，朴素贝叶斯对条件概率分布做了条件独立性的假设。<br></p>
<p>假设有n个特征：<br><img src="/2021/03/05/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/5.jpg"><br>由于每个特征都是独立的，故：<br><img src="/2021/03/05/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/6.jpg"></p>
<h2 id="朴素贝叶斯改进之拉普拉斯平滑"><a href="#朴素贝叶斯改进之拉普拉斯平滑" class="headerlink" title="朴素贝叶斯改进之拉普拉斯平滑"></a>朴素贝叶斯改进之拉普拉斯平滑</h2><p>1.利用贝叶斯分类器进行分类时，要计算多个概率的乘积，如果其中有一个概率值为0，那么最后的结果为0。<br>solution:拉普拉斯平滑(Laplace Smoothing)-加一平滑(比较常用的平滑方法，可以解决0概率问题)<br>2.很多很小的数相乘，造成下溢出<br>solution:可以通过求对数避免下溢出或浮点数舍入导致的错误</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="朴素贝叶斯推断的一些优点："><a href="#朴素贝叶斯推断的一些优点：" class="headerlink" title="朴素贝叶斯推断的一些优点："></a>朴素贝叶斯推断的一些优点：</h3><li>生成式模型，通过计算概率来进行分类，可以用来处理<b>多分类问题</b></li>
<li>对小规模数据表现很好，适合<b>多分类任务</b>，适合增量式训练，算法也比较简单</li>
<li>简单易懂、学习效率高，在某些领域的分类问题中能够与决策树、神经网络相媲美</li>

<h3 id="朴素贝叶斯推断的一些缺点："><a href="#朴素贝叶斯推断的一些缺点：" class="headerlink" title="朴素贝叶斯推断的一些缺点："></a>朴素贝叶斯推断的一些缺点：</h3><li>对输入数据的表现形式敏感</li>
<li>由于朴素贝叶斯的“朴素”特点(算法以自变量之间的独立性(条件特征独立)和连续变量的正态性假设为前提)，所以会带来一些准确率上的损失</li>
<li>需要计算先验概率，分类决策存在错误率</li>

<p><a href="https://cuijiahua.com/blog/2017/11/ml_4_bayes_1.html">参考资源1</a><br><a href="https://cuijiahua.com/blog/2017/11/ml_5_bayes_2.html">参考资源2</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>Naive Bayes</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>朴素贝叶斯</tag>
        <tag>Naive Bayes</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 机器人能否返回原点</title>
    <url>/2021/09/03/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%83%BD%E5%90%A6%E8%BF%94%E5%9B%9E%E5%8E%9F%E7%82%B9/</url>
    <content><![CDATA[<h1 id="657-机器人能够返回原点"><a href="#657-机器人能够返回原点" class="headerlink" title="657.机器人能够返回原点"></a>657.机器人能够返回原点</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在二维平面上，有一个机器人从原点 (0, 0) 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 (0, 0) 处结束。<br>移动顺序由字符串表示。字符 move[i] 表示其第 i 次移动。机器人的有效动作有 R（右），L（左），U（上）和 D（下）。如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。<br>注意：机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。</p>
<span id="more"></span>

<p><a href="https://leetcode-cn.com/problems/robot-return-to-origin/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>起始时机器人的坐标为 (0,0)，在遍历完所有指令并对机器人进行移动之后，判断机器人的坐标是否为 (0,0) 即可。</p>
<p>具体来说，我们用两个变量 x 和 y 来表示机器人当前所在的坐标为 (x,y)，起始时 x=0，y=0。接下来我们遍历指令并更新机器人的坐标：<br>    如果指令是 U，则令 y=y−1<br>    如果指令是 D，则令 y=y+1<br>    如果指令是 L，则令 x=x−1<br>    如果指令是 R，则令 x=x+1<br>最后判断 (x,y) 是否为 (0,0) 即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def judgeCircle(self, moves: str) -&gt; bool:
        if len(moves) % 2 != 0:
            return False

        pos_x = 0
        pos_y = 0

        for move in moves:
            if move == &#39;U&#39;:
                pos_y += 1
            elif move == &#39;D&#39;:
                pos_y -= 1
            elif move == &#39;R&#39;:
                pos_x += 1
            elif move == &#39;L&#39;:
                pos_x -= 1

        if pos_x == 0 and pos_y == 0:
            return True
        else:
            return False

    def judgeCircle1(self, moves: str) -&gt; bool:
        if moves.count(&#39;L&#39;) == moves.count(&#39;R&#39;) and moves.count(&#39;U&#39;) == moves.count(&#39;D&#39;):
            return True
        else:
            return False


if __name__ == &quot;__main__&quot;:
    slt = Solution()
    res = slt.judgeCircle(&quot;UD&quot;)
    # res = slt.judgeCircle1(&quot;LLL&quot;)
    print(res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习 | 机器学习中分类标签次数统计代码模板</title>
    <url>/2021/02/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%88%86%E7%B1%BB%E6%A0%87%E7%AD%BE%E6%AC%A1%E6%95%B0%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="机器学习中分类标签次数统计代码模板"><a href="#机器学习中分类标签次数统计代码模板" class="headerlink" title="机器学习中分类标签次数统计代码模板"></a>机器学习中分类标签次数统计代码模板</h1><p>在使用机器学习的算法进行分类时，很多时候我们需要去统计各个分类标签在数据集中出现的次数，它的实现代码模板如下：</p>
<pre><code>def class_count(class_list):  # class_list:数据集数据的所有标签列表
    # 存放各个分类出现的次数
    class_counts = &#123;&#125;
    # 统计class_list中每个元素出现的次数
    for cla in class_list:
        if cla not in class_counts.keys():
            class_counts[cla] = 0
        class_counts[cla] += 1
    # 排序
    sorted_class_count = sorted(class_counts.items(), key=operator.itemgetter(1), reverse=True)
    return sorted_class_count
</code></pre>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习 | 机器学习分类的一般步骤</title>
    <url>/2021/05/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%88%86%E7%B1%BB%E7%9A%84%E4%B8%80%E8%88%AC%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<h1 id="机器学习分类的一般步骤"><a href="#机器学习分类的一般步骤" class="headerlink" title="机器学习分类的一般步骤"></a>机器学习分类的一般步骤</h1><p>1.get data from file<br>2.data preprocess<br>3.get data and label<br>4.design the model used here<br>5.train the model<br>6.validate the model<br>7.test the model<br>8.save the model with best accuracy<br>note: pay more attention on<br><b>1)how to deal with the source data that model can process.</b><br>In general,the size of the input of the model is [B, C, H, W],<br>where B is batch size,C is number of channels,H ans W is two dimension of the input data respectively.<br><b>2)how to calculate ‘in_features’ of the first fully connected layer</b>`</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习基础知识</title>
    <url>/2020/10/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1>机器学习（Machine Learning,ML）</h1>
<h2>机器是如何学习的？</h2>
<h3>1.什么是机器学习？</h3>
通过输入海量训练数据对模型进行训练，使模型掌握数据所蕴含的潜在规律，进而对新输入的数据进行准确的分类和预测。
Note:
1)计算机程序能够处理的只有数值和运算
2）要让一段程序了解客观世界变化万千的实物，则必须将这些实物数值化，将事物的变化和不同事物之间的关联转化为运算。
3）现实世界和计算机之间，概念<-->数值，关系<-->运算的映射，造就了机器可以自主学习实物规律的可能
<span id="more"></span>
<h3>2.机器学习的分类</h3>
有监督学习 通过标注进行学习（用于学习的数据包含样本和标签）
无监督学习 用于学习的数据只有样本没有标签


<h2>机器学习三要素</h2> 
数据、模型、算法（算法通过在数据上进行运算产生模型）
<h3>1.数据</h3>  <h3></h3>
原数据（图片/文字/声音（计算机能够处理的是数值））---->特征工程（1.确定用哪些特征来表示数据 2.确定用什么方式表达这些特征）--VSM(向量空间模型)--> vector ---->算法--算运-->模型
有标注数据（数据样本有标签）
无标注数据（数据样本无标签）
<h3>2.模型</h3>
模型是机器学习的结果，学习的过程称为训练
机器学习的两类问题
    回归（输出结果是一个数值）
    分类（输出结果是一个标签）
<h3>3.算法</h3>
损失函数 描述预测值与真实值之间的差别（针对一个训练数据）
代价函数 （针对所有的训练数据）
目标函数 最小化的代价函数
如何找到最小的参数？---->优化算法
优化算法
    梯度下降法（最常用）
    共轭梯度法
    牛顿法
    拟牛顿法
    模拟退火法
    ...

<h2>模型的获取和改进</h2>
<h3>1.获取模型的过程（-训练-将算法应用到数据上进行运算的过程）</h3>
数据+算法=模型
模型构建步骤
    Step1 数据准备
        Step1.1数据预处理 收集数据、清洗数据、标注数据
        Step1.2构建数据的VSM(将文本、图片、音频、视频等格式的数据转换为向量)
        Step1.3将构件号的VSM的数据分为训练集、验证集和测试集
    Step2 训练--将训练集输入给训练程序进行运算。训练程序的核心是算法，所有输入的向量化数据都会按该训练程序所以及的算法进行运算。训练程序输出的结果就是模型
        Step2.1编写训练程序
            Step2.1.1选择模型类型
            Step2.1.2选择优化算法
            Step2.1.3根据模型类型和算法编写程序
        Step2.2训练-->获得临时模型
        Step2.3在训练集上运行临时模型，获得训练集预测结果
        Step2.4在验证集上运行临时模型，获得验证集预测结果
        Step2.5综合参照Step2.3和step2.4的预测结果，改进模型
        Step2.6 Step2.2到Step2.5反复迭代，直至获得让我们满意，或者已经无法继续优化的模型
    Step3 测试--将测试机数据输入给训练获得的模型，得到预测结果；再将预测结果与这些数据原本预期的结果进行比较
Note:
    训练集：用来做训练的数据的集合
    验证集：用来在训练的过程中每个训练轮次结束后验证当前模型性能，为进一步优化模型提供参考的数据的集合
    测试集：用来做测试的数据的集合，用于检验最终得出的模型的性能
    每个集合都应当是独立的，和另外两个没有重叠
    训练集市训练过程的基础，而验证和测试集则是在不同阶段用来评价训练结果的
<h3>2.改进模型</h3>
数据
    大量的高质量训练数据，是提高模型质量的有效手段，但通常我们可以用来训练的数据量相当有限
    有限的数据---->归一化（Normalization）、正则化(Regularization)、Bootstrap、根据业务进行特征选取（从业务角度区分输入数据包含的特征，并理解这些特征对结果的贡献）
调参
    超参数需要模型训练者自己来设置和调整
选择合适的模型

<p>模型的质量和评判指标<br>分类模型评判指标<br>    精确率（Precision)<br>    召回率（Recall）<br>    F1Score(综合Precision和Recall)<br>一个机器学习模型的质量问题，从对训练集样本拟合程度的角度，可以分为两类：<br>欠拟合（Underfitting）模型在训练集上的预测结果不佳，指标偏低<br>    解决方法：选择更复杂的模型，增加特征<br>过拟合（Overfitting）模型在训练集上指标很好，而在验证或测绘集上指标偏低<br>    解决方法：选择更简单的模型，减少特征</p>
<p>模型<br>    线性回归 LinearRegression,LR<br>    逻辑回归 LogisticRegression<br>    朴素贝叶斯分类器 Naive Bayes Classifier,NB<br>    决策树 DecisionTree,DT<br>    支持向量机 Supporting Vector Machine,SVM<br>    支持向量回归机器 Support Vector Regressioon,SVR<br>    隐马尔科夫模型 Hiden Marcov Model,HMM<br>    条件随机场 Conditional Random Field,CRF<br>    K邻近 K Nearest Neighbor,KNN<br>    K均值 K Means</p>
</--></-->]]></content>
      <categories>
        <category>机器学习</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>脑电分类 | 机器学习实现脑电分类</title>
    <url>/2021/02/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E7%8E%B0%E8%84%91%E7%94%B5%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="机器学习实现脑电分类"><a href="#机器学习实现脑电分类" class="headerlink" title="机器学习实现脑电分类"></a>机器学习实现脑电分类</h1><p><img src="/2021/02/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E7%8E%B0%E8%84%91%E7%94%B5%E5%88%86%E7%B1%BB/1.jpg"></p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>脑电分类</category>
      </categories>
      <tags>
        <tag>脑电分类</tag>
        <tag>机器学习</tag>
        <tag>EEG</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习 | 机器学习常用的两种验证方法</title>
    <url>/2021/05/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E9%AA%8C%E8%AF%81%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="机器学习常用的两种验证方法"><a href="#机器学习常用的两种验证方法" class="headerlink" title="机器学习常用的两种验证方法"></a>机器学习常用的两种验证方法</h1><p>1.Leave One Subject Out<br>2.K Fold Cross Validation</p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>验证方法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 权重初始化</title>
    <url>/2021/06/22/%E6%9D%83%E9%87%8D%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<h1 id="权重初始化"><a href="#权重初始化" class="headerlink" title="权重初始化"></a>权重初始化</h1><p>在训练神经网络时，权重随机初始化是很重要的。</p>
<p>对于<strong>逻辑回归</strong>，把<strong>权重初始化为0</strong>当然也是可以的。但是对于一个<strong>神经网络</strong>，如果你把权重<br>或者参数都初始化为 0，那么<strong>梯度下降将不会起作用</strong>。</p>
<p>如果你<strong>把权重都初始化为 0，那么由于隐含单元开始计算同一个函数</strong>，所有的隐含单元就会对输出单元有同样的影响。<br>一次迭代后同样的表达式结果仍然是相同的，即<strong>隐含单元仍是对称的</strong>。通过推导，两次、三次、无论多少次迭代，不管你训练网络多长时间，<br>隐含单元仍然计算的是同样的函数。因此这种情况下超过 1 个隐含单元也没什么意义，因为他们计算同样的东西。如果你要初始化成 0，<br>由于所有的隐含单元都是对称的，无论你运行梯度下降多久，他们一直计算同样的函数。这没有任何帮助，因为你想要两个不同<br>的隐含单元计算不同的函数，这个问题的解决方法就是<b>随机初始化参数</b>。</p>
<p><a href="https://www.bilibili.com/video/BV1FT4y1E74V?p=35&spm_id_from=pageDriver">参考吴恩达深度学习视频</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Research and Paper | 查找论文代码的两个网站</title>
    <url>/2021/07/03/%E6%9F%A5%E6%89%BE%E8%AE%BA%E6%96%87%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h1 id="查找论文代码的两个网站"><a href="#查找论文代码的两个网站" class="headerlink" title="查找论文代码的两个网站"></a>查找论文代码的两个网站</h1><p><a href="https://www.paperswithcode.com/">网址1</a></p>
<p><a href="https://researchcode.com/">网址2</a></p>
]]></content>
      <categories>
        <category>Research and Paper</category>
      </categories>
      <tags>
        <tag>论文代码</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 检测大写字母</title>
    <url>/2021/09/01/%E6%A3%80%E6%B5%8B%E5%A4%A7%E5%86%99%E5%AD%97%E6%AF%8D/</url>
    <content><![CDATA[<h1 id="520-检测大写字母"><a href="#520-检测大写字母" class="headerlink" title="520.检测大写字母"></a>520.检测大写字母</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个单词，你需要判断单词的大写使用是否正确。<br>我们定义，在以下情况时，单词的大写用法是正确的：<br>    全部字母都是大写，比如”USA”。<br>    单词中所有字母都不是大写，比如”leetcode”。<br>    如果单词不只含有一个字母，只有首字母大写， 比如 “Google”。<br>否则，我们定义这个单词没有正确使用大写字母。</p>
<span id="more"></span>
<p>示例 1:<br>输入: “USA”<br>输出: True<br>示例 2:<br>输入: “FlaG”<br>输出: False<br>注意: 输入是由大写和小写拉丁字母组成的非空单词。</p>
<p><a href="https://leetcode-cn.com/problems/detect-capital/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>按照单词大写用法进行判断，满足返回True，不满足返回False</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def detectCapitalUse(self, word: str) -&gt; bool:
        if word.islower() or word.isupper():
            return True
        elif word[0].isupper() and word[1:].islower():
            return True
        else:
            return False


if __name__ == &quot;__main__&quot;:
    slt = Solution()
    # word = &quot;USA&quot;
    # word = &quot;leetcode&quot;
    # word = &quot;Google&quot;
    word = &quot;flaG&quot;
    res = slt.detectCapitalUse(word)
    print(res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>pygame | 植物大战僵尸</title>
    <url>/2021/10/25/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8/</url>
    <content><![CDATA[<h1 id="植物大战僵尸"><a href="#植物大战僵尸" class="headerlink" title="植物大战僵尸"></a>植物大战僵尸</h1><p>python pygame 实现植物大战僵尸.<br><a href="https://blog.csdn.net/Gtieguo/article/details/112093640">植物大战僵尸</a></p>
<span id="more"></span>
<p>实现代码：</p>
<pre><code># 引入需要的模块
import pygame
import random

# 配置图片地址
IMAGE_PATH = &#39;imgs/&#39;

# 设置页面宽高
scrrr_width = 800
scrrr_height = 560

# 创建控制游戏结束的状态
GAMEOVER = False

# 图片加载报错处理
LOG = &#39;文件:&#123;&#125;中的方法:&#123;&#125;出错&#39;.format(__file__, __name__)

# 创建地图类
class Map():
    map_names_list = [IMAGE_PATH + &#39;map1.png&#39;, IMAGE_PATH + &#39;map2.png&#39;]

    # 初始化地图
    def __init__(self, x, y, img_index):
        self.image = pygame.image.load(Map.map_names_list[img_index])
        self.position = (x, y)

        # 是否能够种植
        self.can_grow = True

    # 加载地图
    def load_map(self):
        MainGame.window.blit(self.image, self.position)


# 植物类
class Plant(pygame.sprite.Sprite):
    def __init__(self):
        super(Plant, self).__init__()
        self.live = True

    def load_image(self):
        if hasattr(self, &#39;image&#39;) and hasattr(self, &#39;rect&#39;):
            MainGame.window.blit(self.image, self.rect)
        else:
            print(LOG)


# 向日葵类
class Sunflower(Plant):
    def __init__(self, x, y):
        super(Sunflower, self).__init__()
        self.image = pygame.image.load(&#39;imgs/sunflower.png&#39;)
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.price = 50
        self.hp = 100
        # 5 时间计数器
        self.time_count = 0

    # 新增功能：生成阳光

    def produce_money(self):
        self.time_count += 1
        if self.time_count == 25:
            MainGame.money += 5
            self.time_count = 0

    # 向日葵加入到窗口中
    def display_sunflower(self):
        MainGame.window.blit(self.image, self.rect)

# 豌豆射手类
class PeaShooter(Plant):
    def __init__(self, x, y):
        super(PeaShooter, self).__init__()
        # self.image 为一个 surface
        self.image = pygame.image.load(&#39;imgs/peashooter.png&#39;)
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.price = 50
        self.hp = 200
        # 6 发射计数器
        self.shot_count = 0

    # 增加射击方法
    def shot(self):
        # 6 记录是否应该射击
        should_fire = False
        for zombie in MainGame.zombie_list:
            if zombie.rect.y == self.rect.y and zombie.rect.x &lt; 800 and zombie.rect.x &gt; self.rect.x:
                should_fire = True
        # 6 如果活着
        if self.live and should_fire:
            self.shot_count += 1
            # 6 计数器到25发射一次
            if self.shot_count == 25:
                # 6 基于当前豌豆射手的位置，创建子弹
                peabullet = PeaBullet(self)
                # 6 将子弹存储到子弹列表中
                MainGame.peabullet_list.append(peabullet)
                self.shot_count = 0

    # 将豌豆射手加入到窗口中的方法
    def display_peashooter(self):
        MainGame.window.blit(self.image, self.rect)


# 豌豆子弹类
class PeaBullet(pygame.sprite.Sprite):
    def __init__(self, peashooter):
        self.live = True
        self.image = pygame.image.load(&#39;imgs/peabullet.png&#39;)
        self.damage = 50
        self.speed = 10
        self.rect = self.image.get_rect()
        self.rect.x = peashooter.rect.x + 60
        self.rect.y = peashooter.rect.y + 15

    def move_bullet(self):
        # 7 在屏幕范围内，实现往右移动
        if self.rect.x &lt; scrrr_width:
            self.rect.x += self.speed
        else:
            self.live = False

    # 7 新增，子弹与僵尸的碰撞
    def hit_zombie(self):
        for zombie in MainGame.zombie_list:
            if pygame.sprite.collide_rect(self, zombie):
                # 打中僵尸之后，修改子弹的状态，
                self.live = False
                # 僵尸掉血
                zombie.hp -= self.damage
                if zombie.hp &lt;= 0:
                    zombie.live = False
                    self.nextLevel()
    # 7闯关方法

    def nextLevel(self):
        MainGame.score += 20
        MainGame.remnant_score -= 20
        for i in range(1, 100):
            if MainGame.score == 100 * i and MainGame.remnant_score == 0:
                MainGame.remnant_score = 100 * i
                MainGame.shaoguan += 1
                MainGame.produce_zombie += 50

    def display_peabullet(self):
        MainGame.window.blit(self.image, self.rect)


# 僵尸类
class Zombie(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super(Zombie, self).__init__()
        self.image = pygame.image.load(&#39;imgs/zombie.png&#39;)
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.hp = 1000
        self.damage = 2
        self.speed = 1
        self.live = True
        self.stop = False
    # 9 僵尸的移动

    def move_zombie(self):
        if self.live and not self.stop:
            self.rect.x -= self.speed
            if self.rect.x &lt; -80:
                # 8 调用游戏结束方法
                MainGame().gameOver()

    # 9 判断僵尸是否碰撞到植物，如果碰撞，调用攻击植物的方法
    def hit_plant(self):
        for plant in MainGame.plants_list:
            if pygame.sprite.collide_rect(self, plant):
                # 8  僵尸移动状态的修改
                self.stop = True
                self.eat_plant(plant)
    # 9 僵尸攻击植物

    def eat_plant(self, plant):
        # 9 植物生命值减少
        plant.hp -= self.damage
        # 9 植物死亡后的状态修改，以及地图状态的修改
        if plant.hp &lt;= 0:
            a = plant.rect.y // 80 - 1
            b = plant.rect.x // 80
            map = MainGame.map_list[a][b]
            map.can_grow = True
            plant.live = False
            # 8 修改僵尸的移动状态
            self.stop = False

    # 9 将僵尸加载到地图中

    def display_zombie(self):
        MainGame.window.blit(self.image, self.rect)


# 主程序
class MainGame():
    # 2 创建关数，得分，剩余分数，钱数
    shaoguan = 1
    score = 0
    remnant_score = 100
    money = 200
    # 3 存储所有地图坐标点
    map_points_list = []
    # 3 存储所有的地图块
    map_list = []
    # 4 存储所有植物的列表
    plants_list = []
    # 7 存储所有豌豆子弹的列表
    peabullet_list = []
    # 9 新增存储所有僵尸的列表
    zombie_list = []
    count_zombie = 0
    produce_zombie = 100
    # 1 加载游戏窗口

    def init_window(self):
        # 1 调用显示模块的初始化
        pygame.display.init()
        # 1 创建窗口
        MainGame.window = pygame.display.set_mode([scrrr_width, scrrr_height])

    # 2 文本绘制
    def draw_text(self, content, size, color):
        pygame.font.init()
        font = pygame.font.SysFont(&#39;kaiti&#39;, size)
        text = font.render(content, True, color)
        return text

    # 2 加载帮助提示
    def load_help_text(self):
        text1 = self.draw_text(&#39;1.按左键创建向日葵 2.按右键创建豌豆射手&#39;, 26, (255, 0, 0))
        MainGame.window.blit(text1, (5, 5))

    # 3 初始化坐标点
    def init_plant_points(self):
        for y in range(1, 7):
            points = []
            for x in range(10):
                point = (x, y)
                points.append(point)
            MainGame.map_points_list.append(points)
            print(&quot;MainGame.map_points_list&quot;, MainGame.map_points_list)

    # 3 初始化地图
    def init_map(self):
        for points in MainGame.map_points_list:
            temp_map_list = list()
            for point in points:
                # map = None
                if (point[0] + point[1]) % 2 == 0:
                    map = Map(point[0] * 80, point[1] * 80, 0)
                else:
                    map = Map(point[0] * 80, point[1] * 80, 1)
                # 将地图块加入到窗口中
                temp_map_list.append(map)
                print(&quot;temp_map_list&quot;, temp_map_list)
            MainGame.map_list.append(temp_map_list)
        print(&quot;MainGame.map_list&quot;, MainGame.map_list)

    # 3 将地图加载到窗口中
    def load_map(self):
        for temp_map_list in MainGame.map_list:
            for map in temp_map_list:
                map.load_map()

    # 6 增加豌豆射手发射处理
    def load_plants(self):
        for plant in MainGame.plants_list:
            # 6 优化加载植物的处理逻辑
            if plant.live:
                if isinstance(plant, Sunflower):
                    plant.display_sunflower()
                    plant.produce_money()
                elif isinstance(plant, PeaShooter):
                    plant.display_peashooter()
                    plant.shot()
            else:
                MainGame.plants_list.remove(plant)

    # 7 加载所有子弹的方法
    def load_peabullets(self):
        for b in MainGame.peabullet_list:
            if b.live:
                b.display_peabullet()
                b.move_bullet()
                # v1.9 调用子弹是否打中僵尸的方法
                b.hit_zombie()
            else:
                MainGame.peabullet_list.remove(b)

    # 8事件处理

    def deal_events(self):
        # 8 获取所有事件
        eventList = pygame.event.get()
        # 8 遍历事件列表，判断
        for e in eventList:
            if e.type == pygame.QUIT:
                self.gameOver()
            elif e.type == pygame.MOUSEBUTTONDOWN:
                # print(&#39;按下鼠标按键&#39;)
                print(e.pos)
                # print(e.button)#左键1  按下滚轮2 上转滚轮为4 下转滚轮为5  右键 3

                x = e.pos[0] // 80
                y = e.pos[1] // 80
                print(x, y)
                map = MainGame.map_list[y - 1][x]
                print(map.position)
                # 8 增加创建时候的地图装填判断以及金钱判断
                if e.button == 1:
                    if map.can_grow and MainGame.money &gt;= 50:
                        sunflower = Sunflower(map.position[0], map.position[1])
                        MainGame.plants_list.append(sunflower)
                        print(&#39;当前植物列表长度:&#123;&#125;&#39;.format(len(MainGame.plants_list)))
                        map.can_grow = False
                        MainGame.money -= 50
                elif e.button == 3:
                    if map.can_grow and MainGame.money &gt;= 50:
                        peashooter = PeaShooter(
                            map.position[0], map.position[1])
                        MainGame.plants_list.append(peashooter)
                        print(&#39;当前植物列表长度:&#123;&#125;&#39;.format(len(MainGame.plants_list)))
                        map.can_grow = False
                        MainGame.money -= 50

    # 9 新增初始化僵尸的方法
    def init_zombies(self):
        for i in range(1, 7):
            dis = random.randint(1, 5) * 200
            zombie = Zombie(800 + dis, i * 80)
            MainGame.zombie_list.append(zombie)

    # 9将所有僵尸加载到地图中
    def load_zombies(self):
        for zombie in MainGame.zombie_list:
            if zombie.live:
                zombie.display_zombie()
                zombie.move_zombie()
                # v2.0 调用是否碰撞到植物的方法
                zombie.hit_plant()
            else:
                MainGame.zombie_list.remove(zombie)
    # 1 开始游戏

    def start_game(self):
        # 1 初始化窗口
        self.init_window()
        # 3 初始化坐标和地图
        self.init_plant_points()
        self.init_map()
        # 9 调用初始化僵尸的方法
        self.init_zombies()
        # 1 只要游戏没结束，就一直循环
        while not GAMEOVER:
            # 1 渲染白色背景
            MainGame.window.fill((255, 255, 255))
            # 2 渲染的文字和坐标位置
            MainGame.window.blit(
                self.draw_text(
                    &#39;当前钱数$: &#123;&#125;&#39;.format(
                        MainGame.money), 26, (255, 0, 0)), (500, 40))
            MainGame.window.blit(
                self.draw_text(
                    &#39;当前关数&#123;&#125;，得分&#123;&#125;,距离下关还差&#123;&#125;分&#39;.format(
                        MainGame.shaoguan,
                        MainGame.score,
                        MainGame.remnant_score),
                    26,
                    (255,
                     0,
                     0)),
                (5,
                 40))
            self.load_help_text()

            # 3 需要反复加载地图
            self.load_map()
            # 6 调用加载植物的方法
            self.load_plants()
            # 7  调用加载所有子弹的方法
            self.load_peabullets()
            # 8 调用事件处理的方法
            self.deal_events()
            # 9 调用展示僵尸的方法
            self.load_zombies()
            # 9 计数器增长，每数到100，调用初始化僵尸的方法
            MainGame.count_zombie += 1
            if MainGame.count_zombie == MainGame.produce_zombie:
                self.init_zombies()
                MainGame.count_zombie = 0
            pygame.time.wait(10)
            pygame.display.update()

    def gameOver(self):
        MainGame.window.blit(
            self.draw_text(
                &#39;游戏结束&#39;, 50, (255, 0, 0)), (300, 200))
        print(&#39;游戏结束&#39;)
        pygame.time.wait(400)
        global GAMEOVER
        GAMEOVER = True


if __name__ == &#39;__main__&#39;:
    game = MainGame()
    game.start_game()
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>pygame</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pygame</tag>
        <tag>植物大战僵尸</tag>
      </tags>
  </entry>
  <entry>
    <title>励志 | 活法</title>
    <url>/2021/07/22/%E6%B4%BB%E6%B3%95/</url>
    <content><![CDATA[<h1 id="活法"><a href="#活法" class="headerlink" title="活法"></a>活法</h1><p>读了稻盛和夫的活法，书中的每一字每一句都可以作为人生哲学和信条，下面记录了自己应该首先去学习、去执行的一些人生哲学：</p>
<span id="more"></span>

<h2 id="只有主动追求的东西才可能到手"><a href="#只有主动追求的东西才可能到手" class="headerlink" title="只有主动追求的东西才可能到手"></a>只有主动追求的东西才可能到手</h2><p>“心不唤物，物不至”，只有自己内心渴望的事情，才能将它呼唤到可能事先的射程之内。</p>
<h2 id="只要思考达到每个细节，目标就一定能实现"><a href="#只要思考达到每个细节，目标就一定能实现" class="headerlink" title="只要思考达到每个细节，目标就一定能实现"></a>只要思考达到每个细节，目标就一定能实现</h2><p>在我们的人生中，想要做成某件事，我们首先要描画它的理想状态，然后把实现它的过程在头脑中模拟演练，<br>一直到“看见”它的结果为止。你事先能“看见”的东西就能做成，“看不见”的东西就做不成。</p>
<h2 id="心态决定命运"><a href="#心态决定命运" class="headerlink" title="心态决定命运"></a>心态决定命运</h2><p>人的命运绝不是天定的，它不是在事先铺设好的轨道上运行的，根据我们的意志，命运既可以变好，也可以变坏。</p>
<h2 id="原理原则"><a href="#原理原则" class="headerlink" title="原理原则"></a>原理原则</h2><p>作为人，何为正确？</p>
<h2 id="人生方程式"><a href="#人生方程式" class="headerlink" title="人生方程式"></a>人生方程式</h2><p>人生·工作的结果 = 思维方式 x 热情 x 能力</p>
<h2 id="自己的人生之戏如何编演"><a href="#自己的人生之戏如何编演" class="headerlink" title="自己的人生之戏如何编演"></a>自己的人生之戏如何编演</h2><p>人生是一出戏，我们每个人都是戏里的主角。不仅如此，而且这戏剧的导演、编剧、主演都可由自己单肩独挑。其实这出戏也<br>只能自编自演，这就是我们的人生。</p>
<h2 id="不在现场流汗什么也学不到"><a href="#不在现场流汗什么也学不到" class="headerlink" title="不在现场流汗什么也学不到"></a>不在现场流汗什么也学不到</h2><p>体验重于知识，“知”未必等于“会”。进入信息社会，进入偏重知识的时代，认为“只要知道自然就会了”的人越来越多了。这种<br>看法大错特错。“会”和“知”中间有一条鸿沟，只有靠现场的经验才能填补。</p>
<h2 id="成为自我燃烧型的人"><a href="#成为自我燃烧型的人" class="headerlink" title="成为自我燃烧型的人"></a>成为自我燃烧型的人</h2><p>要成为自燃型的人，最好最有效的办法是“喜欢自己的工作”，能做成事情的人，他们不仅自我燃烧而且其能量还可与周围人分享。</p>
<h2 id="我正在干一件了不起的工作"><a href="#我正在干一件了不起的工作" class="headerlink" title="我正在干一件了不起的工作"></a>我正在干一件了不起的工作</h2><p>在你讨厌工作，觉得难以忍受时，你还是要多加忍耐，要决心朝前走，要发奋努力，这将改变你的人生。</p>
<h2 id="喜欢与投入"><a href="#喜欢与投入" class="headerlink" title="喜欢与投入"></a>喜欢与投入</h2><p>“喜欢”和“投入”是硬币的正反两面，两者之间是因果循环的关系：因为喜欢就会投入工作；在投入工作的过程中就会产生喜欢。</p>
<h2 id="看似复杂的现象，其实不过是简单事物的投影而已"><a href="#看似复杂的现象，其实不过是简单事物的投影而已" class="headerlink" title="看似复杂的现象，其实不过是简单事物的投影而已"></a>看似复杂的现象，其实不过是简单事物的投影而已</h2><h2 id="生存的意义和目的"><a href="#生存的意义和目的" class="headerlink" title="生存的意义和目的"></a>生存的意义和目的</h2><p>相对于浩瀚宇宙的历史长河，我们的人生不过是一闪而过。但正因为如此，在我们稍纵即逝的人生中，我们的灵魂在终结时的价值<br>必须高于降生时的价值，这才是我们生存的意义和目的。</p>
<h2 id="“六项精进”-磨炼心志的指针"><a href="#“六项精进”-磨炼心志的指针" class="headerlink" title="“六项精进”-磨炼心志的指针"></a>“六项精进”-磨炼心志的指针</h2><p>1.付出不亚于任何人的努力<br>2.谦虚戒骄<br>3.天天反省<br>4.活着就要感谢<br>5.积善行、思利他<br>6.不要有感性的烦恼</p>
<h2 id="率直之心"><a href="#率直之心" class="headerlink" title="率直之心"></a>率直之心</h2><p>所谓率直之心并不是别人要你向右转你就向右转，并不是盲目顺从，而是抱着谦虚的态度，如实承认自己的弱点和不足，然后不惜一切<br>努力奋斗。具备一对虚心聆听他人意见的大耳朵，具备一双真诚审视自己的大眼睛，耳聪目明，充分发挥耳朵、眼睛的作用。</p>
<p>把发自内心的喜悦之情、感恩之心直率地表达出来，可以成为一种动力，激励我们持续这种枯燥的研究和单调的工作。不管什么小事，<br>只要开心，只要赶集，就要率直地表达出来，不绕圈子，不装深沉。</p>
<h2 id="在做出结论之前，先设置一个“理性的缓冲器”"><a href="#在做出结论之前，先设置一个“理性的缓冲器”" class="headerlink" title="在做出结论之前，先设置一个“理性的缓冲器”"></a>在做出结论之前，先设置一个“理性的缓冲器”</h2><h2 id="喜悦从苦劳与艰辛中渗出，工作的乐趣潜藏在超越困难的过程之中"><a href="#喜悦从苦劳与艰辛中渗出，工作的乐趣潜藏在超越困难的过程之中" class="headerlink" title="喜悦从苦劳与艰辛中渗出，工作的乐趣潜藏在超越困难的过程之中"></a>喜悦从苦劳与艰辛中渗出，工作的乐趣潜藏在超越困难的过程之中</h2><h2 id="踏上社会，要转变角色，要为周围的人服务，要为团队、为企业做贡献"><a href="#踏上社会，要转变角色，要为周围的人服务，要为团队、为企业做贡献" class="headerlink" title="踏上社会，要转变角色，要为周围的人服务，要为团队、为企业做贡献"></a>踏上社会，要转变角色，要为周围的人服务，要为团队、为企业做贡献</h2><h2 id="养成在更大视野内观察事物的眼光，从更大的视角、以相对的观点来审视自己的行为"><a href="#养成在更大视野内观察事物的眼光，从更大的视角、以相对的观点来审视自己的行为" class="headerlink" title="养成在更大视野内观察事物的眼光，从更大的视角、以相对的观点来审视自己的行为"></a>养成在更大视野内观察事物的眼光，从更大的视角、以相对的观点来审视自己的行为</h2><h2 id="主宰人生的两只看不见的手"><a href="#主宰人生的两只看不见的手" class="headerlink" title="主宰人生的两只看不见的手"></a>主宰人生的两只看不见的手</h2><p>主宰人生的两只看不见的手，一只叫命运，一只叫因果报应法则。<br>我们身上发生的各种事情，都有其产生的原因。这原因不是别的，就是我们自己的思想和行为。你在想什么做什么，都成为因，而<br>必生其果，你对所生结果如何应对，又成为因，有必有所果。<br>人生超脱命运的轨迹，那是因为因果法则这个力量在发挥作用；而另一方面，善行有时并不立即产生善果，那是因为命运的力量在干扰。<br>在这里，因果报应法则要强于命运的法则。因此，由上苍决定的命运也可以用自己的力量加以改变。</p>
<h2 id="为善不见其益，如草里冬瓜自暗应长"><a href="#为善不见其益，如草里冬瓜自暗应长" class="headerlink" title="为善不见其益，如草里冬瓜自暗应长"></a>为善不见其益，如草里冬瓜自暗应长</h2><p>我们人生的意义是什么？人生的目的在哪里？<br>要带着一颗比降生是稍稍善良、稍稍美丽的心灵离开人世，从生至死都要尽力去思善行善，陶冶人格，使人生终点时灵魂的品格比起点时有所提升。</p>
<p>在此我定下一个目标，一定要在n年后重读此书，看看自己的感悟与此时此刻有何不同，自己有没有按照书中的“活法”去生活、工作、学习！</p>
]]></content>
      <categories>
        <category>书籍</category>
        <category>励志类</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>活法</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 深度学习中常用的几种激活函数</title>
    <url>/2021/06/22/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="深度学习中常用的几种激活函数"><a href="#深度学习中常用的几种激活函数" class="headerlink" title="深度学习中常用的几种激活函数"></a>深度学习中常用的几种激活函数</h1><p>使用一个神经网络时，需要决定使用哪种激活函数用隐藏层上，哪种用在输出节点上。<br><b style="color:red">在不同的神经网络层中，激活函数可以不同</b><br><b>几种常用的激活函数：</b><br><img src="/2021/06/22/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/1.png"></p>
<p><b>note:</b><br>1.tanh函数总体上优于sigmoid函数(因为tanh函数值值域在-1,1之间，其均值更接近0)</p>
<p>2.例外：在二分类的问题中，对于输出层，因为𝑦的值是 0 或 1，所以想让𝑦^的数<br>值介于 0 和 1 之间，而不是在-1 和+1 之间。所以需要使用 sigmoid 激活函数。</p>
<p>如果输出是 0、1 值（二分类问题），则输出层选择 sigmoid 函数，然后其它的所有单<br>元都选择 Relu 函数。</p>
<p>3.sigmoid 函数和 tanh 函数两者共同的缺点是，在𝑧特别大或者特别小的情况下，导数的<br>梯度或者函数的斜率会变得特别小，最后就会接近于 0，导致降低梯度下降的速度。</p>
<p><b>总结：</b><br>sigmoid 激活函数：除了输出层是一个二分类问题基本不会用它。<br>tanh 激活函数：tanh 是非常优秀的，几乎适合所有场合。<br>ReLu 激活函数：最常用的默认函数，，如果不确定用哪个激活函数，就使用 ReLu 或者<br>Leaky Relu</p>
<p><a href="https://mp.weixin.qq.com/s/9N-d8_D5rniJylDMLXdTPQ">点这里查看更多的激活函数，有更加详细的解释！</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>激活函数</tag>
      </tags>
  </entry>
  <entry>
    <title>生成器 | 生成器输出fibonacci数列</title>
    <url>/2021/11/01/%E7%94%9F%E6%88%90%E5%99%A8%E8%BE%93%E5%87%BAfibonacci%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<h1 id="生成器输出小于max-num的fibonacci数列"><a href="#生成器输出小于max-num的fibonacci数列" class="headerlink" title="生成器输出小于max_num的fibonacci数列"></a>生成器输出小于max_num的fibonacci数列</h1><p>代码：</p>
<pre><code>def feb(max_num):
    n_1 = 1
    n_2 = 1
    n = 0
    while n &lt; max_num:
        if n == 0 or n == 1:
            yield 1
            n += 1
        else:
            yield n_1 + n_2
            new_n_2 = n_1
            n_1 = n_1 + n_2
            n_2 = new_n_2
            n += 1

g = feb(5)
for n in g:
    print(n)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>生成器</category>
      </categories>
      <tags>
        <tag>生成器</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 环形链表</title>
    <url>/2021/08/27/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141.环形链表"></a>141.环形链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个链表，判断链表中是否有环。<br>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。<br>如果链表中存在环，则返回 true 。 否则，返回 false 。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/linked-list-cycle/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.哈希表<br>最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。<br>具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。<br>2.快慢指针<br>定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution:
    def hasCycle(self, head: ListNode) -&gt; bool:
        &quot;&quot;&quot;
        哈希表

        :param head:单链表头节点
        :return:True-linked list has cycle/False-linked list has not cycle
        &quot;&quot;&quot;
        seen = set()
        while head:
            if head in seen:
                return True
            seen.add(head)
            head = head.next
        return False

    def hasCycle1(self, head: ListNode) -&gt; bool:
        &quot;&quot;&quot;
        快慢指针

        :param head:单链表头节点
        :return:True-linked list has cycle/False-linked list has not cycle
        &quot;&quot;&quot;
        if not head or not head.next:  # 如果头节点为空，或者链表第一个节点为空，则链表没有环
            return False

        slow = head
        fast = head.next

        while slow != fast:
            if not fast or not fast.next:
                return False

            slow = slow.next
            fast = fast.next.next
        return True

    def create_linked_list(self):
        node4 = ListNode(-4)
        node3 = ListNode(0)
        node2 = ListNode(2)
        node1 = ListNode(3)
        node1.next = node2
        node2.next = node3
        node3.next = node4
        node4.next = node2

        return node1

    def print_linked_list(self, linked_list) -&gt; None:
        &quot;&quot;&quot;
        打印单链表中的所有元素

        :param linked_list: 单链表
        :return: 无
        &quot;&quot;&quot;
        print(&quot;----------------------------------------&quot;)
        pointer = linked_list
        while pointer is not None:
            print(pointer.val)
            pointer = pointer.next


if __name__ == &quot;__main__&quot;:
    slt = Solution()

    linked_list = slt.create_linked_list()

    print(slt.hasCycle1(linked_list))
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>生成器 | 生成器输出小于maxnum的偶数或奇数</title>
    <url>/2021/11/01/%E7%94%9F%E6%88%90%E5%99%A8%E8%BE%93%E5%87%BA%E5%B0%8F%E4%BA%8Emaxnum%E7%9A%84%E5%81%B6%E6%95%B0%E6%88%96%E5%A5%87%E6%95%B0/</url>
    <content><![CDATA[<h1 id="生成器输出小于max-num的偶数或奇数"><a href="#生成器输出小于max-num的偶数或奇数" class="headerlink" title="生成器输出小于max_num的偶数或奇数"></a>生成器输出小于max_num的偶数或奇数</h1><p>代码：</p>
<pre><code># 1.输出小于max_num的偶数或奇数
def odd(max_num):
    
    i = 1
    while i &lt; max_num:
        if i % 2 == 0:  # if % 2 == 1可生成奇数
            yield i
        i += 1

g = odd(10)
for n in g:
    print(n)

# 2.输出任意个偶数或奇数
def odd():
i = 2
while i:
    if i % 2 == 0:  # if % 2 == 1可生成奇数
        yield i
    i += 1
g = odd()
for i in range(100):
    print(next(g))
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>生成器</category>
      </categories>
      <tags>
        <tag>生成器</tag>
      </tags>
  </entry>
  <entry>
    <title>生成器 | 生成器输出质数</title>
    <url>/2021/11/01/%E7%94%9F%E6%88%90%E5%99%A8%E8%BE%93%E5%87%BA%E8%B4%A8%E6%95%B0/</url>
    <content><![CDATA[<h1 id="生成器输出小于max-num的质数"><a href="#生成器输出小于max-num的质数" class="headerlink" title="生成器输出小于max_num的质数"></a>生成器输出小于max_num的质数</h1><p>通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。<br>而且，创建一个包含成百上千完个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前<br>面几个元素，那后面绝大多数元素占用的空间都白白浪费了。生成器有效的解决了这个问题。</p>
<span id="more"></span>
<p>代码：</p>
<pre><code>def factor(max_num):
    # 这是一个函数  用于输出所有小于max_num的质数
    factor_list = []
    n = 2
    while n &lt; max_num:
        find = False
        for f in factor_list:
            # 先看看列表里面有没有能整除它的
            if n % f == 0:
                find = True
                break
        if not find:
            factor_list.append(n)
            yield n

        n += 1

g = factor(10)

for n in g:
    print(n)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>生成器</category>
      </categories>
      <tags>
        <tag>生成器</tag>
      </tags>
  </entry>
  <entry>
    <title>本地与服务器互传文件</title>
    <url>/2021/04/18/%E6%9C%AC%E5%9C%B0%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BA%92%E4%BC%A0%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="本地与服务器互传文件"><a href="#本地与服务器互传文件" class="headerlink" title="本地与服务器互传文件"></a>本地与服务器互传文件</h1><p>命令安装：yum install lrzsz</p>
<p>从服务器发送文件到客户端： sz filename</p>
<p>从客户端上传文件到服务端： rz</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Chicken Soup for the Soul | 生活没有想象的那么糟</title>
    <url>/2021/10/14/%E7%94%9F%E6%B4%BB%E6%B2%A1%E6%9C%89%E6%83%B3%E8%B1%A1%E7%9A%84%E9%82%A3%E4%B9%88%E7%B3%9F/</url>
    <content><![CDATA[<h1 id="生活没有想象的那么糟"><a href="#生活没有想象的那么糟" class="headerlink" title="生活没有想象的那么糟"></a>生活没有想象的那么糟</h1><p>生活可能不像你想象的那么好，但是也不会像你想象的那么糟，人的脆弱和坚强，都超乎了自己的想象，有时候，可能脆弱的一句话就泪流满面，有时候你发现你自己咬着牙，已经走过很长的路。</p>
<p>2021/10/14</p>
]]></content>
      <categories>
        <category>Chicken Soup for the Soul</category>
      </categories>
      <tags>
        <tag>Chicken Soup for the Soul</tag>
      </tags>
  </entry>
  <entry>
    <title>openpyxl | 用Python在Excel中查找并替换数据</title>
    <url>/2021/10/25/%E7%94%A8Python%E5%9C%A8Excel%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%B9%B6%E6%9B%BF%E6%8D%A2%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="用Python在Excel中查找并替换数据"><a href="#用Python在Excel中查找并替换数据" class="headerlink" title="用Python在Excel中查找并替换数据"></a>用Python在Excel中查找并替换数据</h1><p>实现代码：</p>
<pre><code>from openpyxl import load_workbook  # 用于读取Excel中的信息

# 获取Excel表格中的数据
wb = load_workbook(&#39;查找替换.xlsx&#39;)  # 读取工作簿
ws = wb.active  # 读取活动工作表
data = &#123;&#125;  # 新建字典，用于储存数据

for row in range(2, ws.max_row + 1):
    chazhao = str(ws[&#39;A&#39; + str(row)].value)  # 转换成字符串，以免后续比对时出现数据类型冲突
    tihuan = str(ws[&#39;B&#39; + str(row)].value)  # 转换成字符串，以免后续比对时出现数据类型冲突
    data[chazhao] = tihuan  # 键值对应存入字典

wb = load_workbook(&#39;原表.xlsx&#39;)  # 读取目标工作簿
ws = wb.active
ID_list = []  # 新建一个列表，用于储存原表D列的信息
for row in range(2, ws.max_row + 1):
    ID = ws[&#39;D&#39; + str(row)].value  # 遍历整个工作表，将D列的数据逐个存入ID变量
    ID_list.append(ID)  # 将读取到的结果存入列表

code = []
for i in ID_list:
    if i is None:  # 如果是None，则放入None占位，以保持列表的值的顺序与原表一致
        code.append(None)
    else:
        code.append(i.split(&quot;：&quot;)[-1])  # 不是None,则按&quot;：&quot;符号分割，并放分割后的最后一个值进入新列表code

for i in range(len(code)):
    if code[i] in data:
        ws.cell(row=i + 2, column=4).value = ID_list[i].split(&quot;：&quot;)[0] + &quot;：&quot; + data[code[i]]
wb.save(&#39;原表-替换.xlsx&#39;)
</code></pre>
<p><a href="查找替换.xlsx">查找替换.xlsx</a><br><a href="原表.xlsx">原表.xlsx</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>openpyxl</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>openpyxl</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 用两个队列实现栈</title>
    <url>/2021/08/27/%E7%94%A8%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
    <content><![CDATA[<h1 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225.用队列实现栈"></a>225.用队列实现栈</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。<br>实现 MyStack 类：<br>    void push(int x) 将元素 x 压入栈顶。<br>    int pop() 移除并返回栈顶元素。<br>    int top() 返回栈顶元素。<br>    boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。</p>
<p>注意：<br>    你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。<br>    你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>1.使用两个队列实现栈</strong><br>使用两个队列实现栈的操作，其中 queue1 用于存储栈内的元素，queue2 作为入栈操作的辅助队列。<br>入栈操作时，首先将元素入队到 queue2，然后将 queue1 的全部元素依次出队并入队到 queue2，此时 queue2 的前端的元素即为新入栈的元素，再将 queue1 和 queue2 互换，则 queue1 的元素即为栈内的元素，queue1 的前端和后端分别对应栈顶和栈底。<br>由于每次入栈操作都确保 queue1 的前端元素为栈顶元素，因此出栈操作和获得栈顶元素操作都可以简单实现。出栈操作只需要移除 queue1 的前端元素并返回即可，获得栈顶元素操作只需要获得 queue1 的前端元素并返回即可（不移除元素）。<br>由于 queue1 用于存储栈内的元素，判断栈是否为空时，只需要判断 queue1 是否为空即可。<br><strong>2.使用一个队列实现栈</strong><br>使用一个队列时，为了满足栈的特性，即最后入栈的元素最先出栈，同样需要满足队列前端的元素是最后入栈的元素。<br>入栈操作时，首先获得入栈前的元素个数 n，然后将元素入队到队列，再将队列中的前 n 个元素（即除了新入栈的元素之外的全部元素）依次出队并入队到队列，此时队列的前端的元素即为新入栈的元素，且队列的前端和后端分别对应栈顶和栈底。<br>由于每次入栈操作都确保队列的前端元素为栈顶元素，因此出栈操作和获得栈顶元素操作都可以简单实现。出栈操作只需要移除队列的前端元素并返回即可，获得栈顶元素操作只需要获得队列的前端元素并返回即可（不移除元素）。<br>由于队列用于存储栈内的元素，判断栈是否为空时，只需要判断队列是否为空即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>import collections


class MyStack(object):
    &quot;&quot;&quot;使用两个队列实现栈&quot;&quot;&quot;
    def __init__(self):
        &quot;&quot;&quot;
        Initialize your data structure here.
        &quot;&quot;&quot;
        self.queue1 = collections.deque()
        self.queue2 = collections.deque()

    def push(self, x):
        &quot;&quot;&quot;
        Push element x onto stack.
        :type x: int
        :rtype: None
        &quot;&quot;&quot;
        self.queue2.append(x)
        while self.queue1:
            self.queue2.append(self.queue1.popleft())
        self.queue1, self.queue2 = self.queue2, self.queue1

    def pop(self):
        &quot;&quot;&quot;
        Removes the element on top of the stack and returns that element.
        :rtype: int
        &quot;&quot;&quot;
        return self.queue1.popleft()

    def top(self):
        &quot;&quot;&quot;
        Get the top element.
        :rtype: int
        &quot;&quot;&quot;
        return self.queue1[0]

    def empty(self):
        &quot;&quot;&quot;
        Returns whether the stack is empty.
        :rtype: bool
        &quot;&quot;&quot;
        return not self.queue1


class MyStack1(object):
    &quot;&quot;&quot;使用1个队列实现栈&quot;&quot;&quot;
    def __init__(self):
        &quot;&quot;&quot;
        Initialize your data structure here.
        &quot;&quot;&quot;
        self.queue = collections.deque()

    def push(self, x):
        &quot;&quot;&quot;
        Push element x onto stack.
        :type x: int
        :rtype: None
        &quot;&quot;&quot;
        n = len(self.queue)
        self.queue.append(x)
        for _ in range(n):
            self.queue.append(self.queue.popleft())

    def pop(self):
        &quot;&quot;&quot;
        Removes the element on top of the stack and returns that element.
        :rtype: int
        &quot;&quot;&quot;
        return self.queue.popleft()

    def top(self):
        &quot;&quot;&quot;
        Get the top element.
        :rtype: int
        &quot;&quot;&quot;
        return self.queue[0]

    def empty(self):
        &quot;&quot;&quot;
        Returns whether the stack is empty.
        :rtype: bool
        &quot;&quot;&quot;
        return not self.queue
# Your MyStack object will be instantiated and called as such:
# obj = MyStack()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.top()
# param_4 = obj.empty()


if __name__ == &quot;__main__&quot;:
    my_stack = MyStack()
    my_stack = MyStack1()
    my_stack.push(1)
    my_stack.push(2)
    print(&quot;当前栈顶元素为: &#123;&#125;&quot;.format(my_stack.top()))
    print(&quot;当前弹出的元素为: &#123;&#125;&quot;.format(my_stack.pop()))
    print(&quot;当前栈空：&#123;&#125;&quot;.format(&quot;yes&quot; if my_stack.empty() is True else &quot;no&quot;))
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 用栈实现队列</title>
    <url>/2021/08/27/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232.用栈实现队列"></a>232.用栈实现队列</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：<br>实现 MyQueue 类：<br>    void push(int x) 将元素 x 推到队列的末尾<br>    int pop() 从队列的开头移除并返回元素<br>    int peek() 返回队列开头的元素<br>    boolean empty() 如果队列为空，返回 true ；否则，返回 false<br>说明：<br>    你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。<br>    你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</p>
<span id="more"></span>

<p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用两个栈实现队列，一个栈作为输入栈（入队），一个对作为输出栈（出队/取队头元素）。<br>入队操作的实现：将元素压入输入栈<br>出队操作的实现：弹出输出栈栈顶元素，若输出栈为空，输入栈不为空，则将输入栈所有元素出栈并压入输出栈，接着再弹出输出栈栈顶元素。<br>队列判空：输入栈和输出栈同时为空时队列为空。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class MyQueue(object):
    &quot;&quot;&quot;用2个栈实现队列&quot;&quot;&quot;
    def __init__(self):
        &quot;&quot;&quot;
        Initialize your data structure here.
        &quot;&quot;&quot;
        self.stack1 = list()
        self.stack2 = list()

    def push(self, x):
        &quot;&quot;&quot;
        Push element x to the back of queue.
        :type x: int
        :rtype: None
        &quot;&quot;&quot;
        self.stack1.append(x)

    def pop(self):
        &quot;&quot;&quot;
        Removes the element from in front of queue and returns that element.
        :rtype: int
        &quot;&quot;&quot;
        if len(self.stack2) != 0:
            return self.stack2.pop()
        else:
            for _ in range(len(self.stack1)):
                self.stack2.append(self.stack1.pop())
            return self.stack2.pop()

    def peek(self):
        &quot;&quot;&quot;
        Get the front element.
        :rtype: int
        &quot;&quot;&quot;
        if len(self.stack2) != 0:
            return self.stack2[-1]
        else:
            for _ in range(len(self.stack1)):
                self.stack2.append(self.stack1.pop())
            return self.stack2[-1]


    def empty(self):
        &quot;&quot;&quot;
        Returns whether the queue is empty.
        :rtype: bool
        &quot;&quot;&quot;
        return not self.stack1 and not self.stack2


# Your MyQueue object will be instantiated and called as such:
# obj = MyQueue()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.peek()
# param_4 = obj.empty()


if __name__ == &quot;__main__&quot;:
    my_queue = MyQueue()
    my_queue.push(1)
    my_queue.push(2)
    print(&quot;当前队头元素为：&#123;&#125;&quot;.format(my_queue.peek()))
    print(&quot;当前出队元素为：&#123;&#125;&quot;.format(my_queue.pop()))
    print(&quot;当前队列空：&#123;&#125;&quot;.format(&quot;yes&quot; if my_queue.empty() is True else &quot;no&quot;))
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 电话号码的字母组合</title>
    <url>/2021/09/04/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h1 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17.电话号码的字母组合"></a>17.电话号码的字母组合</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。<br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.遍历并组合每一个数字对应的字母列表 –&gt; letterCombinations()<br><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/zhi-xing-yong-shi-ji-bai-9954nei-cun-xia-gwkb/">点击这里查看完整解题思路！！！</a><br>2.使用内置库 –&gt; letterCombinations1()<br><strong>3.回溯</strong> –&gt; letterCombinations2()<br><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/dian-hua-hao-ma-de-zi-mu-zu-he-by-leetcode-solutio/">回溯法和使用内置库思路见leetcode题解</a></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    num2ch = &#123;
        &#39;2&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],
        &#39;3&#39;: [&#39;d&#39;, &#39;e&#39;, &#39;f&#39;],
        &#39;4&#39;: [&#39;g&#39;, &#39;h&#39;, &#39;i&#39;],
        &#39;5&#39;: [&#39;j&#39;, &#39;k&#39;, &#39;l&#39;],
        &#39;6&#39;: [&#39;m&#39;, &#39;n&#39;, &#39;o&#39;],
        &#39;7&#39;: [&#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;],
        &#39;8&#39;: [&#39;t&#39;, &#39;u&#39;, &#39;v&#39;],
        &#39;9&#39;: [&#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;]
    &#125;

    def letterCombinations(self, digits: str) -&gt; list:
        if len(digits) == 0:
            return []

        list1 = []  # 用于存储digits数组中每个字符对应的字母列表
        for d in digits:
            list1.append(self.num2ch[d])

        i = 0
        j = 1
        while j &lt; len(list1):
            list1[j] = self.concat(list1[i], list1[j])
            i = j
            j += 1

        return list1[-1]

    def concat(self, list1, list2):
        res = []
        for e1 in list1:
            for e2 in list2:
                res.append(e1 + e2)
        return res

    def letterCombinations1(self, digits: str):
        if not digits:
            return list()

        phoneMap = &#123;
            &quot;2&quot;: &quot;abc&quot;,
            &quot;3&quot;: &quot;def&quot;,
            &quot;4&quot;: &quot;ghi&quot;,
            &quot;5&quot;: &quot;jkl&quot;,
            &quot;6&quot;: &quot;mno&quot;,
            &quot;7&quot;: &quot;pqrs&quot;,
            &quot;8&quot;: &quot;tuv&quot;,
            &quot;9&quot;: &quot;wxyz&quot;,
        &#125;

        groups = (phoneMap[digit] for digit in digits)

        import itertools
        return [&quot;&quot;.join(combination) for combination in itertools.product(*groups)]

    def letterCombinations2(self, digits: str):
        if not digits:
            return list()

        phoneMap = &#123;
            &quot;2&quot;: &quot;abc&quot;,
            &quot;3&quot;: &quot;def&quot;,
            &quot;4&quot;: &quot;ghi&quot;,
            &quot;5&quot;: &quot;jkl&quot;,
            &quot;6&quot;: &quot;mno&quot;,
            &quot;7&quot;: &quot;pqrs&quot;,
            &quot;8&quot;: &quot;tuv&quot;,
            &quot;9&quot;: &quot;wxyz&quot;,
        &#125;

        def backtrack(index: int):
            if index == len(digits):
                combinations.append(&#39;&#39;.join(combination))
            else:
                digit = digits[index]
                for letter in phoneMap[digit]:
                    combination.append(letter)
                    backtrack(index + 1)
                    combination.pop()

        combination = list()
        combinations = list()
        backtrack(0)
        return combinations


if __name__ == &#39;__main__&#39;:
    slt = Solution()
    digits = &quot;23&quot;
    res = slt.letterCombinations2(digits)
    print(res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>wxPython | 盒子布局管理器</title>
    <url>/2021/08/03/%E7%9B%92%E5%AD%90%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<h1 id="盒子布局管理器"><a href="#盒子布局管理器" class="headerlink" title="盒子布局管理器"></a>盒子布局管理器</h1><p>wxPython提供了布局管理器类帮助实现界面布局，主要分为两大类：盒子布局管理器（类似于CSS中的弹性布局）和网格布局管理器。</p>
<p>下面我们做一个盒子布局管理器（垂直方向布局）的例子：<br>1.代码</p>
<pre><code># coding=utf-8
import wx
class MyFrame(wx.Frame):
    def __init__(self):
        super().__init__(None, title=&quot;事件处理&quot;, size=(300, 180))
        panel = wx.Panel(parent=self)
        self.statictext = wx.StaticText(parent=panel, label=&quot;请单击OK按钮&quot;)
        b = wx.Button(parent=panel, label=&quot;OK&quot;)
        self.Bind(wx.EVT_BUTTON, self.on_click, b)

        # 创建垂直方向的盒子布局管理器对象vbox
        vbox = wx.BoxSizer(wx.VERTICAL)
        # 添加静态文本到vbox布局管理器
        vbox.Add(self.statictext, proportion=1, flag=wx.ALIGN_CENTER_HORIZONTAL | wx.FIXED_MINSIZE | wx.TOP, border=30)
        # 添加按钮b到vbox布局管理器
        vbox.Add(b, proportion=1, flag=wx.EXPAND | wx.BOTTOM, border=10)
        panel.SetSizer(vbox)

    def on_click(self, event):
        self.statictext.SetLabelText(&#39;Hello, World.&#39;)


app = wx.App()  # 创建应用程序对象
frm = MyFrame()  # 创建窗口对象
frm.Show()  # 显示窗口
app.MainLoop()  # 进入主事件循环
</code></pre>
<p>2.界面<br><img src="/2021/08/03/%E7%9B%92%E5%AD%90%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8/1.png"></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>wxPython</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>wxPython</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 盛最多水的容器</title>
    <url>/2021/08/27/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11.盛最多水的容器"></a>11.盛最多水的容器</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>说明：你不能倾斜容器。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/container-with-most-water/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>双指针法<br>height=[a1,a2,…,an]<br>起始两个指针l、r分别指向n个非负整数的两端，接着计算容器容积area = min(height[l], height[r]) * (r - l),然后移动l、r指针中指针指向元素较小的那个指针（向另一个指针所在的方向移动），再计算area,…,以此类推，然会最大的area</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):
    def maxArea(self, height):
        &quot;&quot;&quot;
        :type height: List[int]
        :rtype: int
        &quot;&quot;&quot;
        # 容器的高为height中每一对值中较小的
        # 容器的宽为每一对值的下标相减，后者下标减去前者下标
        # Area = H x W

        n = len(height)  # 输入数组的长度
        max = 0  # 最大容器容量
        for i in range(n):
            for j in range(i+1, n):
                h = min(height[i], height[j])
                w = j - i
                if h * w &gt; max:
                    max = h * w

        return max

    def maxArea1(self, height):
        l, r = 0, len(height) - 1
        ans = 0

        while l &lt; r:
            area = min(height[l], height[r]) * (r - l)
            ans = max(ans, area)
            if height[l] &lt;= height[r]:
                l += 1
            else:  # height[l] &gt;= height[r]
                r -= 1
        return ans


if __name__ == &quot;__main__&quot;:
    slt = Solution()
    height = [1, 8, 6, 2, 5, 4, 8, 3, 7]
    max_area = slt.maxArea(height)
    print(max_area)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>伪迹移除 | 盲源分离和独立成分分析</title>
    <url>/2021/02/21/%E7%9B%B2%E6%BA%90%E5%88%86%E7%A6%BB%E5%92%8C%E7%8B%AC%E7%AB%8B%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="盲源分离-BSS-和独立成分分析-ICA"><a href="#盲源分离-BSS-和独立成分分析-ICA" class="headerlink" title="盲源分离(BSS)和独立成分分析(ICA)"></a>盲源分离(BSS)和独立成分分析(ICA)</h1><h2 id="BSS"><a href="#BSS" class="headerlink" title="BSS"></a>BSS</h2><p>盲源分离是最流行的伪迹检测/移除方法之一，其目的是提取混合信号中独立的未知的源信号；同时尽可能在对源信号和混合通道没有或者有非常有限的了解下尽可能仅通过在每一个通道的输出观测到的混合信号来估计未知的混合通道。盲源分离包括ICA(独立成分分析)、CCA(典型成分分析)、MCA(形态成分分析)三种方法。</p>
<h3 id="数学表示式："><a href="#数学表示式：" class="headerlink" title="数学表示式："></a>数学表示式：</h3><p><b>X = AS + N</b><br><b>S’ = WX</b><br>其中,X表示观测到的信号(假设X为若干源信号和噪声信号的混合),N代表噪声信号，A为系数矩阵，W也为系数矩阵（需要对W矩阵进行估计），S’为S的估计<br><img src="/2021/02/21/%E7%9B%B2%E6%BA%90%E5%88%86%E7%A6%BB%E5%92%8C%E7%8B%AC%E7%AB%8B%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/bss.png"></p>
<h2 id="ICA"><a href="#ICA" class="headerlink" title="ICA"></a>ICA</h2><p>独立成分分析是盲源分离的一个特例，它假设组成观测信号的若干源信号是线性独立的。</p>
<h3 id="基于ICA的伪迹检测和去除方法存在的问题"><a href="#基于ICA的伪迹检测和去除方法存在的问题" class="headerlink" title="基于ICA的伪迹检测和去除方法存在的问题"></a>基于ICA的伪迹检测和去除方法存在的问题</h3><p>1.非自动的<br>2.需要人为介入去除观察到的伪迹</p>
<h3 id="基于ICA的伪迹检测和去除方法的自动化"><a href="#基于ICA的伪迹检测和去除方法的自动化" class="headerlink" title="基于ICA的伪迹检测和去除方法的自动化"></a>基于ICA的伪迹检测和去除方法的自动化</h3><p><b style="color:red">1.ICA+WT(Wavelet Transform,小波变换)<br>2.ICA+EMD(Empirical Mode Decomposition,经验模态分解)<br>3.使用分类器，例如SVM(Support Vector Machine,支持向量机-一种机器学习算法)<br>4.参考信号辅助</b></p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>1.伪迹独立成分仍然可能包含残余的神经信号导致神经信号的失真<br>2.不能用于单通道数据<br>3.不适合实时应用</p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>伪迹移除</category>
      </categories>
      <tags>
        <tag>ICA</tag>
        <tag>BSS</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 相交链表</title>
    <url>/2021/08/27/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="160-环形链表"><a href="#160-环形链表" class="headerlink" title="160.环形链表"></a>160.环形链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.哈希表<br>判断两个链表是否相交，可以使用哈希集合存储链表节点。<br>首先遍历链表 headA，并将链表 headA 中的每个节点加入哈希集合中。然后遍历链表 headB，对于遍历到的每个节点，判断该节点是否在哈希集合中：<br>    如果当前节点不在哈希集合中，则继续遍历下一个节点；<br>    如果当前节点在哈希集合中，则后面的节点都在哈希集合中，即从当前节点开始的所有节点都在两个链表的相交部分，因此在链表 headB 中遍历到的第一个在哈希集合中的节点就是两个链表相交的节点，返回该节点。<br>如果链表 headB 中的所有节点都不在哈希集合中，则两个链表不相交，返回 null。<br>2.双指针<br>只有当链表 headA 和 headB 都不为空时，两个链表才可能相交。因此首先判断链表 headA 和 headB 是否为空，如果其中至少有一个链表为空，则两个链表一定不相交，返回 null。<br>当链表 headA 和 headB 都不为空时，创建两个指针 pA 和 pB，初始时分别指向两个链表的头节点 headA 和 headB，然后将两个指针依次遍历两个链表的每个节点。具体做法如下：<br>    每步操作需要同时更新指针 pA 和 pB。<br>    如果指针 pA 不为空，则将指针 pA 移到下一个节点；如果指针 pB 不为空，则将指针 pB 移到下一个节点。<br>    如果指针 pA 为空，则将指针 pA 移到链表 headB 的头节点；如果指针 pB 为空，则将指针 pB 移到链表 headA 的头节点。<br>    当指针 pA 和 pB 指向同一个节点或者都为空时，返回它们指向的节点或者 null。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># Definition for singly-linked list.
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):
    def getIntersectionNode(self, headA, headB):
        &quot;&quot;&quot;
        哈希表

        :type head1, head1: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        if not headA or not headB:
            return None
        seen = set()
        p1 = headA
        p2 = headB
        while p1 is not None:
            seen.add(p1)
            p1 = p1.next

        while p2 is not None:
            if p2 in seen:
                return p2.val
            p2 = p2.next

        return None

    def getIntersectionNode1(self, headA, headB):
        &quot;&quot;&quot;
        双指针

        :param headA:
        :param headB:
        :return:
        &quot;&quot;&quot;
        if not headA or not headB:
            return None

        p_A = headA
        p_B = headB

        while p_A != p_B:
            p_A = headB if p_A is None else p_A.next
            p_B = headA if p_B is None else p_B.next

        return p_A


    def create_linked_list(self):
        &quot;&quot;&quot;
        创建两个相交的单链表
        :return:两个相交但表表的头指针
        &quot;&quot;&quot;
        a_node1 = ListNode(4)
        a_node2 = ListNode(1)

        b_node1 = ListNode(5)
        b_node2 = ListNode(0)
        b_node3 = ListNode(1)

        common_node1 = ListNode(8)
        common_node2 = ListNode(4)
        common_node3 = ListNode(5)

        a_node1.next = a_node2
        a_node2.next = common_node1
        common_node1.next = common_node2
        common_node2.next = common_node3

        b_node1.next = b_node2
        b_node2.next = b_node3
        b_node3.next = common_node1
        common_node1.next = common_node2
        common_node2.next = common_node3

        return a_node1, b_node2


if __name__ ==&quot;__main__&quot;:
    slt = Solution()

    head_a, head_b = slt.create_linked_list()

    intersected_node = slt.getIntersectionNode1(head_a, head_b)
    print(intersected_node.val)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 神经网络中的超参数</title>
    <url>/2021/06/30/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E8%B6%85%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h1 id="神经网络中的超参数"><a href="#神经网络中的超参数" class="headerlink" title="神经网络中的超参数"></a>神经网络中的超参数</h1><p><b>神经网络中常见的超参数：</b><br>1.隐藏层的大小n^[l](size of hidden layers)<br>2.学习率 alpha(learning rate)<br>3.迭代次数(number of iterations)<br>4.神经网络中的层数L(number of layers L in the neral network)</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>超参数</tag>
      </tags>
  </entry>
  <entry>
    <title>入门指南 | 程序员必备的8大学习网站</title>
    <url>/2021/02/20/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%E7%9A%848%E5%A4%A7%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h1 id="程序员必备的8大学习网站"><a href="#程序员必备的8大学习网站" class="headerlink" title="程序员必备的8大学习网站"></a>程序员必备的8大学习网站</h1><table>
<thead>
<tr>
<th>网站</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>github</td>
<td>代码托管平台</td>
</tr>
<tr>
<td>stackoverflow</td>
<td>技术问答</td>
</tr>
<tr>
<td>leetcode</td>
<td>刷题讨论 码不停题</td>
</tr>
<tr>
<td>bilibili</td>
<td>学习</td>
</tr>
<tr>
<td>牛客网</td>
<td>应届毕业生找工作的天堂</td>
</tr>
<tr>
<td>papers with code</td>
<td>论文+代码</td>
</tr>
<tr>
<td>菜鸟教程</td>
<td>技术手册</td>
</tr>
<tr>
<td>W3School</td>
<td>技术手册</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>入门指南</category>
      </categories>
      <tags>
        <tag>程序员必备的8大学习网站</tag>
      </tags>
  </entry>
  <entry>
    <title>小说 | 研究生第一本书-恶意</title>
    <url>/2020/10/08/%E7%AC%AC%E4%B8%80%E6%9C%AC%E4%B9%A6/</url>
    <content><![CDATA[<h1>研究生第一本书-恶意</h1>
“<strong style="color:red">这个世界上有两个东西不能直视，一个是太阳，一个是人心。</strong>”
<span id="more"></span>
晓燕老师在微博视频中提到一本书-恶意，开头这句活是这本书中一句特别经典的话：正是冲着这句话，我读完了恶意这本书。

<p>这本书是由日本著名作家-东野圭吾写的，书中主要说了一个人由于嫉妒一位朋友（这位朋友是他小时候的好朋友）的文学才华，<br>这恶意深不见底，于是最后杀害了自己的这位朋友；然而朋友的死亡任然不能了却他心中的仇恨、恶意，他精心谋划杀害并企图<br>让这位朋友身败名裂；</p>
<p>这本书中有这样一句话：“<strong style="color:red">在你的心中深藏着对他的恶意，这仇恨深的连你自己都无法解释<br></strong>”</p>
<p>别人对你的恶意是没有理由、没有原因的，因此我们能做的只有做自己。</p>
<p>因为“这个世界上有两个东西不能直视，一个是太阳，一个是人心。”这句话读这本书，从始至终我也试图在书中遇到这么一句话，<br>然我翻到书最后一页也没有见到这句话。后来在网上得知，这句话藏在东野圭吾写的另一个优秀作品-《白夜行》里面。</p>
<p><img src="/2020/10/08/%E7%AC%AC%E4%B8%80%E6%9C%AC%E4%B9%A6/%E6%81%B6%E6%84%8F.jpg" alt="恶意"></p>
]]></content>
      <categories>
        <category>书籍</category>
        <category>小说类</category>
      </categories>
      <tags>
        <tag>恶意</tag>
      </tags>
  </entry>
  <entry>
    <title>人生经历 | 第一次工作面试</title>
    <url>/2021/07/07/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="f14616c556d44103c9ff2b86aa1ee0f52f97227630385289e35a7db8f991ddee">5fa8d7dd4aaa9bde3945cea575f036350644f9a4f5c0b32d0d2de067b73e8ac8bf4e611e865e7ed9b29692f3df8d4b6a978e485acefe710776ac7f50bf5f51f7a4a99a71a01878e93d058395d5d93a2b9cc22097e99ae920538312efdd5e286a81da9d1b736a71d9a123f9d6ea25c731067e47d6f160862fa960c95bfdf6175be9186f5aaa2d2c5c897afbcb2b94c610c5512f72bf7617c6701cdca762cc3e7e837e37e4a1566f9780c15d0a8fa6d7bd65c49c7a981d3f38c3d20d8758aa6a4b8a1478761d32b4b5ae7de43a0a490b5a2c94ecf372831a19b4154eaa2711a71b3f0fec9d024b30616a94e4bf991657c3b4fd4482a97bd7478f591a0f30b9336aeede5ead853486506ad22a9c79140833e2390da1c4e4edc6834e3b14ce2c83277c21930fdf394ed5c39da49d30f37fee48548f5b0733d7527a9b8b9893617eee2090d644a477d0ec91f27c913af1d3000517258e15ef02b32fa87a40ae0d30cb58004073b3ca2f4f750f0438527390c2102cd4ea275d7d1a15cfec872e6c537efbfd6933a029493422463fde13170d18e7d42ac1b6cbfd9490883cc7c7701531c0623fea48fef6e6e5111aa1954f7117a3cbb1c8d856d8918d29083c4efd819e18db923205a73c27ab7a5f5dd635ff805bdd20f4170cef0d9e4cb38469d791b0728d4ecb84cbcad6ae4d92121d673a3e5ee8b12d1747aa94827da11c050dc938ccd35015545a3cdde889afd7a39515544219b7155b6b1108bd5bb882f40f319fd9d29584556ee7abb7ec7d88a76e4b0c3b63e9c96031b2e11724202acc9c3bc19e94023d8567f7bd82ffac553e52b25bbe489c2e31a91df601a6ef3191aef1053226c63ae66523dc5feec275a15baf05b553459c88410a6b10b61eb274d4e2756d1ff9e2e00e44214f597e6afc2c46cdf6b467b0464c70d534c285a2cd163cc534da9f600d56f5e6f5f1b85b148126f95bc3758acc01848f6f183788210c41559e055514df93a6e4271d5952cddf91fdbe7a9ab3752a7452ceb2b1907f5794fc92cb900dbbf392bd9b84b92627dc030d9995a4eafba8b8a7d0756760d6dc016c3697d619a906833e7128b0873dd0fee83eb49c2f21720faa8f1667766db7cb5efe92ceda0feaa256dc2ab09521d3d988173f8787bafe67fb36294ae9ac79f808d6cdf0467eabb97fedaaa0fa3007b322cdcf6190280dfed2392677b191a3db99cedc37550f5e7cd9d5cd2e196ce175ebce80c23b22b6b467290c8a8204b4d6eb4996a389ba7ebe20256bf80a1551ffdb51b490e62cac8534d2a237cbd65617601f8d2680cd9f90bd139c4325e15a151921c6022bb768fbb4e3a44b34056649b7edb2119e5dccc1804f29f32000cbc9a423ce92a11ef7599594af177e0c6f5c934e99b7098cd4a3e99ab9f59fe1958e676cba2626b63adbbdaf7d4c24e5bfe630ef64d56bc53109a5ced9a159ecefba9ef1f96952e6675bc39a24a773bb60ad4bb2f43ea7da2b6547665e110c260ab908f2c1cca89bd55143f4c60af93acaf42d6aaffdc087e491e75f976dce57670e07ca54e77eb62121386597978e80946c9d2ac381140526f8cc13bf2c8b4ce6d9e8a70552181a001a70e87f0ed20a3220c5263b5f440df845e771eae54b49fa433a5467a6a0d17d96131d21dee9695b0eb02455a94269d1d0c012ae2e8eb1a37fc1be0c53cc0532e1d4c7f3e070cfcc89b2037b2dce453c3c7e2b243d18ce10122d1aa4ec87a28a4917f870fef44c1c2a9befef260b684ddf9e430258e397a81c60756995567cf6d3fc3cb705f21078636f2b32a909f9afead9f0cd08cc0316c39231594546a7be17f3399fc6bdd643c1a6e38a36d7f69565d9df0e0fb5e43a88b6775f39cdc658b52e5810062ad1be66b4460059e32a376a33409caa4f94a9ac2edeb27dd855a886d5de400e40edcffaca468c906d8fbf180d43111956c13dff1ddbe4f4b8bdb2eba1a4e429efd7010f65c433d5481196a24b124fac4ebd75156e402ffc312cd5e65b94e8c225754d2841b31e2eae44524d7e7c1155b4ae502bd5311676a80b168ee125b8ee695d51d3600370205bf8bb82137740df4cdc526b634d97f6b41105580ddf0fed974101a65e570e3c2cc699e51cde9c3dd921b3466bc2d5a2928c0bdce3d4e462a47e8ed421d4a39981e9c5f18bdf2903d2c64a243d72ffc3745c74efe16b35417845de495d3bb5e09f9ccede446fa201967c58c9c82a99643e06f63841369903bcc9d5e98d0cc025e09b7b8ed0ce9960a80e0a34432a82992a9a5c863990561c0781c1a2e64999127f8507d3e315a047f42a57294f8723ae0e36f9a213bed96e0dc7272c1bcd944c45313a212e3d16d9b738006aac517e9364c4ad6f25cff848996ba28d94812e85509680dfdd3cc513ab7a971d1f00a486ca98f3b311c413d0bbc58cf6908eaef31ae5ca66d93b643322080918a11da928ad77e31bb8c9c6390ac3b7ca97c1f2bbce3a88b7cda4cdf2741068a22315ee7d4890d429759ef49df2f79526695f8d659e49aae30330027f15d73d19d70681343495908d97075dc74cafb0b2c700a4c0b835939d6a06eff598c601896992e7bb5a6a3dca92fb5c6fa7257287d11ffdbbd60ac640b4a54e9630507c2bc71a5bfd9d7a8254543efd696576e81446ba6a93b5126350d28f8eee8c42ebadb22ff1dd85949f37df5c848bf69b667f2f4d18139d022860a41bc03b03be947bed1c1fec906527588921c83228ffaca5ebe297294b8e9dd4570eba26d74c652889f75936616b6ae6c1707e72a2b29f254b62147577bbbf585e1db1462782844905b173eafcedb8319861daf37c3de30b89e2b9c146827b18ebcf41c3cf4824d00fa69fe86e060b994d7480c5e8dba591a12c97dd50ab8380edd716c6eb7a34c2d889cc712bb7e46215c4029e2446a7d124a2bf7ddd5b175c40029213348a0f8e8bbbec537cb1f50a06c73acc4559a5b1f13d22832d9c7437d5e44b4e948bba1730844abe0eb5f0ce1d8b3354375eaade88154089148d278b0cf9294c8a55e65ec619a1066284b5c46edbda77a6695eab1987ee9d482f2ec7e2a7a7d46a1e677b3ddc244fba2361d68a2f875aaa4ba5b6504a7d9c03925c0b7af814c1a127e2ac07c2458bea892d5c277f078f9c7717024aced6b2e3629286ecca0144632e73bd6f03a765396425b3fd8b8c043edb1f234bd40c6752ffedbaf8dbc2b1e587617053fb3da887679829e25c6cf7c82900d3aba440190090a5735ed0348cef10d25a2e0d5f7dea154e0aa2780f19c2d9282c8bed4d90e6072827d03404ab11f4be57be94cfc408a98f84c45716c3cd3f66835d8981f8601994289ee62b7f0f9dbbc2d64517aa4733b5d01c0eaa95c395476b884ebc1336a1dd7be1d5cef0b1909a07aa7e16b92d57a2ca8bf448784181123e4e546d5d95bc365698ca573d33945b3bd5bfeb8182cd9b62f5645a63a47c0e6f412ddbe5b99ba9a14c9ca17cb51ae7c2b46e85760e5e154321c205f212dee929ee0bc8d59389c306304f7987fe92d6fd41d09920782c31c189f86db261bdf1fed28cf8dc27354ca33ed1705c5ddae446388910199207b20787a439ab09b7c7d2c02ce323332bf9f3d5e8dce840cd2bdcca073f2d9d221b29436839514015983228ff2d0df2c5eaeaea601d66bc967659222cde4ca70157ece8c5987b687cd3e6555c9b095f0ac03a1a3185733bfae1f8bab7f1642d85b717ed4bad58757bf7289afe18ab6871a4aee9c6682d7514dfb1252bb84bb5532b998b99b8c561e69ef5955af46f0b9b14542fca37b65f093004be0cf329cc5325682f0431dccb512a1961303151a81d206ea7e8a9f2b24c8d3f0054af9d6033e315222d62d4689016dc4d5dd8e8515628ca5f8b691c52fcc3638da76bbd06ed3c544c0826656193894733114f0db965d0e9cecaec42c1272fcf92850aacd9e85607410dae688f61bc9bd48db6e968a376449336752a18635c4aaef648cd6204d43180491f8d1ca14ae65574294cc1d36dd39c41e5a74c5a55315e5cdd2ef517d9f39bdbe6b28ca29e5f1a137b3b0663b29c201a5b942d0d063c8f782f3891794c956ab6861aa9b1888acfda8fc4d5ef80849faa31ad44efdb258947fe595686a7c0e1c90d25192d007b3adcb4abd638d6c93f40ea26277382096110574c0f8c0dfb570799675e76e232e7424f8710919524b3e0cc552b5779512b55621eafe1d24009caf6ebac0b0943a758743972070743826c28bc61587b8ddb6d930c3e1ddce11ed6932b755e01cff4f32533af10f68cd78d559fdcd5668365732d0e6a59648dfe5a7c383597beb7061a16b1206df301389c2ecf3a0f820489cec622e50371e5f5e7f91c15f535dc67f7816407d2cbc25f135e8cefb40e247f8b59a246999c32253c8fbbb376dd4c293ff15591b538ec9591b8fc2c64018e17d2d47648e2434c8c1e6c9b98f4fefd180809f6681b6839ec608bcf3851d7ad1df7d92356ae71295aac44d930120108b5a069ca0482c0486d4ced50e24e0e73f89cc539ea5cf09a69e8852943171b713cb8549fa44a300fad9d610e07bcd21748711eb343f256c0d1364a4f819650451274921d5e2d603dd6f7de983383907104d4f795bee4f151c1a24cfa1c39817bd6072b8675e5922bb662c7f096e3f7b5d25148d1e40569d219b09c773e8871348f2221f53e3c932a21930af820398148f70485d3bb08c92c13a2bb298b690b260d22cb2999e7086e241f9c3f1b29ed3e83e31c4bc562d707c07a6ebd1067ea66289e16a2c784a8637ea203bd64e3bb08315bc9d597f2131602df234cf5bf7af8938d79ebfda8473897c1cde5e3739ba68198b81b0a20337aa78ada19dcf70c9f6830d2a20bad263eb440c3883710849673f3e9c733b06d0e9641ddc5a2f8454580e5af74fb24ed7c9937d90d4128e4bdaa3862f5c433130a0aaf3c0194dc45cc3500cb5be5968b0ffef55d9840991ababd9b92ecb1a26a7076cb3a7f78c293b60e27850ae7b42f556e8989ad1e4fbe1583489970fe0b111a43cf8a0077593d5a8cc24f886d06fd9056aee01c413ba5dd848e25a6eb08e59d7de5c19fdfe8d7e01d4e848fb7c6c254df14296ea5fdf799cb6a287d857d5f9f7d700bae210c24dc634cfdb522ee0d5cc260752b68c72f7f7d06fa96442156599ca72a4c5d271ce713eccb29b65d81b79d20593f65bcd7e16e946c16a85aba9adccac1c9ede154d372b9a334a6f7aea78bb1adb1c3c0a23e263e8c8cabf71190e29d91d5283d8a1d8173820bd5f8ac288174ed24484fa2996e4adef142c5f26f77477003037885b5b77ca31657132089d859416a06998f3ff3b3a6eec9289cfe183e806aed3f1c9642236029373ed5e3f39c9f19eac9769f5594b1517bee0f195f7a0a60dd5246e46d4d4cec7f47c81cd0ae8d5dd60d1f5ee580dae0577e6231e31a924009ee6405227f0f76e41a07c68263425d7537bcda044d5ea7cdfe04b5464cbbca064bb3d5c20ad0592bbaee16f4a08141ad269544f82703120744e5420c871306790d73b5f7c56fd9d323914e854d6afa80d86baba4606d223f1160545275372ad75716090ba94dedae83300bdb63036e12e2e40ee9b3205d60e239e51ad3873694769ea36007a4030fcbeb3af9808c516e360153a8d3c8b076f274e621c7e816d93f4fc49cca6a09f1e9b519f15d559af05d5bc4ae26fa673d482396b64ce79be4de5a3e77768d7c439493bc0b2d4a9cef624d8c0d61d066425df1283ec3adb6d46119f33348cc061922cb2182ee42841929438411c01f63c30976f2b6dc289a67ed5d5be6594a9f05b9ba7f52278a530709aa63eafeea0a90effe12f23bbce3f6250f25dc272f9a7f3c586d9b92f7a6cc92a7baa56ce491c16ede99e26295c839374fc9660dd00de279c86d4689b36ae569bb4fc14cac86e6532d8fd2e5b0e0cd37e860a09ec2b135e3ad2f0a042e08bb7e70d3f615555c70eba08d4c4ef948922a93d982f47fbaf237dfd71b5fc4cf14863cb5d365e310960cf1e63f751baca49697c383750ac3553f13f28f4ae81b6dd67b1a0c71ceffc99b3933e4505564ff1d70ddd834dc8c43c74ef4cf7dced6a87083ec0964e668e7383815c06df990b7f488ad0714348b7af4071ab78b97c73521ecf9015aa66e4a89c7ad42f121fafdb1f408718b05589a513cc0bcabc7d1bb837b2fcfa6e2d0a9f187743b7f8b3c61014ef4a0f83669bcd437db69283e4700bc3714728972b5f195ca5b7e0febc331aed2b6d8e4316b9c40c867ca166b69c3e5966378e4f59dfec81f39a9040beea458ba07ed1224ac616c223614327c44ad1b832842303e5eee0aca2036198a685cf7ae07f480a20047f421b4dd99e61953ea7c6ed05f58367776f33138a21db6c6dffa66c0bfd6d0c4cd5b3c272c33aa49f8a4595bbdafc5824deb2bd1846c8d0277653294911f3f483397fee7ff7617ea8c3ab3e300566b77d8cadad260703ed2d038cdf03d1482dbda9b03489b9c15c373da8f813021193440aa84c5a8d42df6eb9e0cb7649dfc00250dbe67df126d575b3123b5aa761a0762ea8d6c709260b4f1def3a8596339c2c19778fefcb448d8143485bf9f00f1e8c6ea7896c046489b9b95806c0f5eb0c1ef7ac9d0cd6a0a51cc3fcc1f0d0330725f94d2eaf63eeb0bc52f3c1ea92b77f916a26e9acb3df6cc5cfb3a7c035cfb660fe46dca4f254e80c9cf00eaafc7b7e6207636a5c6238b721c14ae319ca092bbffb8a23f661a1fb3e557e98c811a891ff7cac213b41ccb6ec7c998ce907c7610dd180e838947741993bc477dc384f33340d70872375d255a4ee3e324e96d6438ec5b2c12ff4739a12c3a7c6a3665411c74661f8e90b3ebbfbb18ef2a71ceed01b8b396084760ec7420ee3e0da2669d31abd36916257859481301c23cd7c357a889fd0e9bddc85b762640faa6caf8a222bcab326578b01ff14d9d8493682d3f3c8dc15ef26fdfd355019765f7fc55522a76be92b3e110f6dfd9a453cb43c3489b2bed2697b9b234aa2be55b76e2913611179c60e17094784af977dc3aa8b6e899e7fc72d4ea1955af0b8c3cc60200273465c4ef8b6a45639fc36c6101d751d0ac224f0f36f604c86cea28a647b35e165210ea2425615c739473c7cf8e5db1ad22fea646c2602b18a11faf5f18775eba48273048903e2d35382ea6095070879901992336dc6f392fcfe28ad5ac45a28ff64185aa780f287a3ca2f38afdd269098806dcf27d08f932f34d223e65c91f77460ff700eb372ba55ed9e78abbfa5e4898b3f6bb85420053589d8e141e374ec1d9c682f8c2e46ab5c4f599606ee7d90e045cd82f8087e0c467cfebe24d138aecdc08a2f70ed2e8628cee653c8be507e021b9f136a5152637bab5daadbe</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>人生经历</category>
        <category>工作</category>
      </categories>
      <tags>
        <tag>人生经历</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程 | 等待线程结束</title>
    <url>/2021/08/05/%E7%AD%89%E5%BE%85%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9D%9F/</url>
    <content><![CDATA[<h1 id="等待线程结束"><a href="#等待线程结束" class="headerlink" title="等待线程结束"></a>等待线程结束</h1><p><strong>等待线程结束：</strong> 一个线程（假设是主线程）需要等待另外一个线程（假设是t1子线程）执行结束才能继续执行。<br><strong>实现：</strong> 通过调用join(timeout=None)方法<br>参数timeout用来设置超时时间，单位为秒。如果没有设置timeout，则可以一直等待，知道结束。</p>
<span id="more"></span>
<p><strong>实例代码：</strong></p>
<pre><code># coding=utf-8

import time
import threading

# 共享变量
value = []  # 多个线程都可以访问的变量


# 线程体函数
def thread_body():
    # 当前线程对象
    print(&#39;t1子线程开始...&#39;)

    for n in range(2):
        print(&#39;t1子线程执行...&#39;)
        value.append(n)
        # 线程休眠
        time.sleep(2)

    print(&#39;t1子线程结束。&#39;)


# 主线程
print(&#39;主线程开始执行...&#39;)
# 创建线程对象t1
t1 = threading.Thread(target=thread_body)
# 启动线程t1
t1.start()
# 主线程阻塞，等待t1线程结束
t1.join()
print(&#39;value = &#123;0&#125;&#39;.format(value))
print(&#39;主线程继续执行...&#39;)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>内置模块</category>
        <category>threading</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>threading</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>C# | 简单计算器</title>
    <url>/2021/07/03/%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E5%99%A8/</url>
    <content><![CDATA[<h1 id="简单计算器-C-实现"><a href="#简单计算器-C-实现" class="headerlink" title="简单计算器(C#实现)"></a>简单计算器(C#实现)</h1><p>下面的代码实现了一个简单计算器的功能！</p>
<pre><code>using System;

namespace ConsoleApp1
&#123;
    class Calculator
    &#123;
        public int num1;
        public int num2;
        public int Add()
        &#123;
            return num1 + num2;
        &#125;
        public int Minus()
        &#123;
            return num1 - num2;
        &#125;

        public int Multiply()
        &#123;
            return num1 * num2;
        &#125;

        public int Divide()
        &#123;
            try
            &#123;
                return num1 / num2;
            &#125;
            catch(DivideByZeroException e)
            &#123;
                Console.WriteLine(&quot;DivideByZeroException: &#123;0&#125;&quot;, e.Message);
                return -1;
            &#125;
        &#125;
    &#125;

    class Execution
    &#123;
        static void Main(string[] args)
        &#123;
            char op;
            Calculator c = new Calculator();
            Console.WriteLine(&quot;请输入第一个操作数：&quot;);
            c.num1 = Convert.ToInt32(Console.ReadLine());
            Console.WriteLine(&quot;请输入第一个操作数：&quot;);
            c.num2 = Convert.ToInt32(Console.ReadLine());
            Console.WriteLine(&quot;请输入操作符：&quot;);
            op = Convert.ToChar(Console.ReadLine());

            switch (op)
            &#123;
                case &#39;+&#39;: Console.WriteLine(&quot;&#123;0&#125;&#123;1&#125;&#123;2&#125;=&#123;3&#125;&quot;, c.num1, op, c.num2, c.Add()); break;
                case &#39;-&#39;: Console.WriteLine(&quot;&#123;0&#125;&#123;1&#125;&#123;2&#125;=&#123;3&#125;&quot;, c.num1, op, c.num2, c.Minus()); break;
                case &#39;*&#39;: Console.WriteLine(&quot;&#123;0&#125;&#123;1&#125;&#123;2&#125;=&#123;3&#125;&quot;, c.num1, op, c.num2, c.Multiply()); break;
                case &#39;/&#39;: Console.WriteLine(&quot;&#123;0&#125;&#123;1&#125;&#123;2&#125;=&#123;3&#125;&quot;, c.num1, op, c.num2, c.Divide()); break;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程 | 线程停止</title>
    <url>/2021/08/05/%E7%BA%BF%E7%A8%8B%E5%81%9C%E6%AD%A2/</url>
    <content><![CDATA[<h1 id="线程停止"><a href="#线程停止" class="headerlink" title="线程停止"></a>线程停止</h1><p>在线程体结束时，线程就停止了。但在某些业务比较复杂时，会在线程体重执行一个“死循环”。线程体是够执行“死循环”是通过<br><strong>判断停止变量</strong>实现的，“死循环”结束则线程体结束，线程也就结束了。</p>
<p><strong>示例代码：</strong></p>
<pre><code># coding=utf-8

import time
import threading

# 线程停止变量
isrunning = True


# 工作线程体函数
def workthread_body():
    while isrunning:
        # 线程开始工作
        print(&#39;工作线程执行中...&#39;)
        # 线程休眠
        time.sleep(5)
    print(&#39;工作线程结束。&#39;)


# 控制线程体函数
def controlthread_body():
    global isrunning
    while isrunning:
        # 从键盘输入停止指令exit
        command = input(&#39;请输入停止指令：&#39;)
        if command == &#39;exit&#39;:
            isrunning = False
            print(&#39;控制线程结束&#39;)


# 主线程
# 创建工作线程对象workthread
workthread = threading.Thread(target=workthread_body)
# 启动线程workthread
workthread.start()

# 创建控制线程对象controlthread
controlthread = threading.Thread(target=controlthread_body)
# 启动线程controlthread
controlthread.start()
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>内置模块</category>
        <category>threading</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>threading</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>伪迹移除 | 经验模态分解</title>
    <url>/2021/02/23/%E7%BB%8F%E9%AA%8C%E6%A8%A1%E6%80%81%E5%88%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="EMD"><a href="#EMD" class="headerlink" title="EMD"></a>EMD</h1><p>EMD is an <b>empirical and data-driven method</b> developed to perform on <b>non-stationary</b>,<b>non-linear</b>, <b>stochastic</b> processes(it is ideally suitable for EEG signal analysis and processing)</p>
<h2 id="Disadvantages"><a href="#Disadvantages" class="headerlink" title="Disadvantages:"></a>Disadvantages:</h2><p>1.the <b>computational complexity</b> is quite heavy(not suitable for online application)<br>2.the <b>theory</b> behind EMD is still not complete and so far used in empirical studies(difficult to predict its robustness in all EEG recordings)</p>
<h2 id="EMD-Algorithm"><a href="#EMD-Algorithm" class="headerlink" title="EMD Algorithm"></a>EMD Algorithm</h2><p><b style="color: red">EMD algorithm decomposes a signal,s[n] into a sum of the band-limited components/functions,c[n] called intrinsic mode funciton(IMF) with well defined instantaneous frequencies.</b></p>
<h3 id="Two-Basic-Conditions-to-be-an-IMF"><a href="#Two-Basic-Conditions-to-be-an-IMF" class="headerlink" title="Two Basic Conditions to be an IMF"></a>Two Basic Conditions to be an IMF</h3><p>1.the numberof extrema must be equal(or at most may differ by one) to the number of zero crossings<br>2.any point,the mean value of the two envelopes defined by the local maxima and the local minima has to be zero</p>
<h3 id="The-General-Process-flow-of-EMD-Algorithm"><a href="#The-General-Process-flow-of-EMD-Algorithm" class="headerlink" title="The General Process flow of EMD Algorithm"></a>The General Process flow of EMD Algorithm</h3><p>Input: data sequence s[n]<br>1.Identify all the local extrema<br>2.Separately connect all the maxima and minima with natural cubic spline lines to form the upper,u[n],and lower,l[n],envelopes.<br>3.Find the mean of the envolopes as <b>z[n]=[u[n]+l[n]]/2</b><br>4.Take the difference between the data and the mean as the proto-IMF,<b>h[n]=s[n]-z[n]</b><br>5.Check the proto-IMF against the definition of IMF and the stoppage criterion to determine if it is an IMF<br>6.If the proto-IMF does not satisfy the definition,repeat step 1 to 5 on h[n] as many times as needed till it satisfies the definition<br>7.If the proto-IMF does satisfy the definition,assign the proto-IMF as an IMF component,c[n]<br>8.Repeat the operation step 1 to 7 on the residue,q[n]=s[n]-c[n],as the data<br>9.The operation ends when the residue contains no more than one extrema</p>
<h3 id="EEMD-enhanced-version-of-EMD"><a href="#EEMD-enhanced-version-of-EMD" class="headerlink" title="EEMD(enhanced version of EMD)"></a>EEMD(enhanced version of EMD)</h3><p>EEMD it inspired from the fact that <b>EMD is very sensitive to noise</b>,which often leads to mode mixing complication.<br>EEMD is proposed which uses an <b>average number of ensembles(IMFs) from EMD as the optimal IMFs</b> thus it provides a <b>noise-assisted data analysis method</b>.</p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>伪迹移除</category>
      </categories>
      <tags>
        <tag>EMD</tag>
        <tag>经验模态分解</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 结构化数据与非结构化数据</title>
    <url>/2021/06/21/%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE%E4%B8%8E%E9%9D%9E%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="结构化数据与非结构化数据"><a href="#结构化数据与非结构化数据" class="headerlink" title="结构化数据与非结构化数据"></a>结构化数据与非结构化数据</h1><p><img src="/2021/06/21/%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE%E4%B8%8E%E9%9D%9E%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE/1.png"></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>matplotlib | 绘制几个模型某性能指标在某个范围内的大小比较图</title>
    <url>/2021/10/12/%E7%BB%98%E5%88%B6%E5%87%A0%E4%B8%AA%E6%A8%A1%E5%9E%8B%E6%9F%90%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E5%9C%A8%E6%9F%90%E4%B8%AA%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%AF%94%E8%BE%83%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="绘制几个模型某性能指标在某个范围内的大小比较图"><a href="#绘制几个模型某性能指标在某个范围内的大小比较图" class="headerlink" title="绘制几个模型某性能指标在某个范围内的大小比较图"></a>绘制几个模型某性能指标在某个范围内的大小比较图</h1><p>我们在做深度学习实验时，很多时候会需要对几个模型的性能进行对比并进行可视化，从而清楚地展示模型性能的大小关系。</p>
<span id="more"></span>
<p>下面以几个模型的精确度大小比较为例：</p>
<p><strong>代码：</strong></p>
<pre><code>import matplotlib.pyplot as plt

CNNLSTM_valence_acc = [0.6885742, 0.690625, 0.69453126, 0.69277346, 0.69003904, 0.6965332, 0.6917969, 0.68652344, 0.6916992, 0.69140625, 0.6933594, 0.6972656, 0.69277346, 0.6941406, 0.69501954, 0.69257814, 0.6929687, 0.69208986, 0.6905273, 0.6930664, 0.69384766, 0.6856445, 0.6958984, 0.6929687, 0.693457, 0.69501954, 0.6893555, 0.7, 0.6904297, 0.69628906, 0.6921875, 0.6910156, 0.6988281, 0.69492185, 0.69541013, 0.69443357, 0.69257814, 0.6955078, 0.6942383, 0.69628906, 0.6933594, 0.6976563, 0.69267577, 0.6948242, 0.69277346, 0.6964844, 0.6923828, 0.6959961, 0.6993164, 0.6935547]
CNN3Conv_valence_acc = [0.53, 0.57, 0.52, 0.55, 0.57, 0.53, 0.54, 0.55, 0.5, 0.49, 0.53, 0.45, 0.55, 0.56, 0.54, 0.49, 0.54, 0.55, 0.57, 0.52, 0.49, 0.54, 0.5, 0.49, 0.56, 0.52, 0.52, 0.55, 0.55, 0.57, 0.5, 0.5, 0.52, 0.55, 0.54, 0.57, 0.53, 0.55, 0.51, 0.54, 0.54, 0.53, 0.56, 0.52, 0.53, 0.53, 0.54, 0.53, 0.5, 0.54]
CNN5Conv_valence_acc = [0.69, 0.6699999999999999, 0.6799999999999999, 0.66, 0.54, 0.57, 0.6699999999999999, 0.6699999999999999, 0.61, 0.61, 0.63, 0.62, 0.63, 0.62, 0.6699999999999999, 0.62, 0.66, 0.6699999999999999, 0.62, 0.58, 0.61, 0.66, 0.61, 0.65, 0.63, 0.62, 0.62, 0.59, 0.62, 0.63, 0.62, 0.63, 0.62, 0.62, 0.63, 0.61, 0.62, 0.62, 0.6699999999999999, 0.63, 0.64, 0.64, 0.65, 0.6699999999999999, 0.62, 0.69, 0.58, 0.59, 0.63, 0.61]

print(len(CNNLSTM_valence_acc))
print(len(CNN3Conv_valence_acc))
print(len(CNN5Conv_valence_acc))

x = range(len(CNN5Conv_valence_acc))
plt.plot(x, CNNLSTM_valence_acc, label=u&#39;CNN-LSTM&#39;)
plt.plot(x, CNN3Conv_valence_acc, label=u&#39;CNN3Conv&#39;)
plt.plot(x, CNN5Conv_valence_acc, label=u&#39;CNN5Conv&#39;)
plt.legend()
plt.xlabel(u&quot;epoch&quot;)
plt.ylabel(u&quot;accuracy&quot;)
plt.show()
</code></pre>
<p><strong>效果图：</strong><br><img src="/2021/10/12/%E7%BB%98%E5%88%B6%E5%87%A0%E4%B8%AA%E6%A8%A1%E5%9E%8B%E6%9F%90%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E5%9C%A8%E6%9F%90%E4%B8%AA%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%AF%94%E8%BE%83%E5%9B%BE/myplot.png"></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>matplotlib</category>
      </categories>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title>绝对路径和相对路径</title>
    <url>/2020/11/29/%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%92%8C%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h1><p><strong>绝对路径</strong>：相对于磁盘的位置定位文件的地址<br><strong>相对路径</strong>：相对于引用文件本身定位被引用文件的地址</p>
<p>Note:<br>./ 当前文件所在目录下<br>../ 当前文件所在目录的上一级目录</p>
]]></content>
      <tags>
        <tag>绝对路径</tag>
        <tag>相对路径</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程 | 网络中常见的协议以及术语</title>
    <url>/2020/10/22/%E7%BD%91%E7%BB%9C%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8D%8F%E8%AE%AE%E4%BB%A5%E5%8F%8A%E6%9C%AF%E8%AF%AD/</url>
    <content><![CDATA[<h1 id="几种常见tcp、ip协议以及常见术语"><a href="#几种常见tcp、ip协议以及常见术语" class="headerlink" title="几种常见tcp、ip协议以及常见术语"></a>几种常见tcp、ip协议以及常见术语</h1><p>ICMP(internet 控制报文协议)—&gt;使用ping命令时</p>
<p>ARP(地址解析协议)—&gt;根据IP地址找MAC地址</p>
<p>RARP(反向地址解析协议)—&gt;根据MAC地址找IP地址</p>
<p>MAC(媒体访问控制地址)—&gt;网卡的编号</p>
<p>IP:标记逻辑上的地址</p>
<p>mac：标记实际转发数据时的设备地址</p>
<p>DHCP(动态主机配置协议):发现当前局域网内没有IP的电脑，给这台电脑自动分配IP</p>
<p>netmask:和ip地址一起来确定网络号</p>
<p>默认网关：发送的ip不在同一个网段内，那么会把这个数据转发给默认网关<br><b>Note:</b><br>MAC地址在两个设备之间通信时在变化<br>IP地址在整个通信过程中都不会发生变化</p>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title>Chicken Soup for the Soul | 罗曼罗兰英雄主义</title>
    <url>/2021/10/12/%E7%BD%97%E6%9B%BC%E7%BD%97%E5%85%B0%E8%8B%B1%E9%9B%84%E4%B8%BB%E4%B9%89/</url>
    <content><![CDATA[<h1 id="Chicken-Soup"><a href="#Chicken-Soup" class="headerlink" title="Chicken Soup"></a>Chicken Soup</h1><p>人生当中成功只是一时的，失败却是主旋律，但是如何面对失败，却把人分成了不同的样子，有的人会被失败击垮，有的人能够不断地爬起来继续向前，我想真正的成熟，并不是追求完美，而是直面自己的缺憾，这才是生活的本质。罗曼罗兰说过：这个世上只有一种真正的英雄注意，那就是认清生活的真相，并且依然热爱它。</p>
<p>2021/10/13</p>
]]></content>
      <categories>
        <category>Chicken Soup for the Soul</category>
      </categories>
      <tags>
        <tag>Chicken Soup for the Soul</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 罗马数字转整数</title>
    <url>/2021/08/27/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<h1 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13.罗马数字转整数"></a>13.罗马数字转整数</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>
<p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000</p>
<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。<br>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：<br>    I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>    X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>    C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/roman-to-integer/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>通常情况下，罗马数字中小的数字在大的数字的右边。若输入的字符串满足该情况，那么可以将每个字符视作一个单独的值，累加每个字符对应的数值即可。<br>例如 XXVII 可视作 X+X+V+I+I=10+10+5+1+1=27。<br>若存在小的数字在大的数字的左边的情况，根据规则需要减去小的数字。对于这种情况，我们也可以将每个字符视作一个单独的值，若一个数字右侧的数字比它大，则将该数字的符号取反。<br>例如 XIV 可视作 X−I+V=10−1+5=14。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):
    def romanToInt(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: int
        &quot;&quot;&quot;
        # SYMBOL_VALUES = &#123;
        #     &#39;I&#39;: 1,
        #     &#39;V&#39;: 5,
        #     &#39;X&#39;: 10,
        #     &#39;L&#39;: 50,
        #     &#39;C&#39;: 100,
        #     &#39;D&#39;: 500,
        #     &#39;M&#39;: 1000,
        # &#125;
        # ans = 0
        # n = len(s)
        # for i, ch in enumerate(s):
        #     value = SYMBOL_VALUES[ch]
        #     if i &lt; n - 1 and value &lt; SYMBOL_VALUES[s[i+1]]:
        #         ans -= value
        #     else:
        #         ans += value
        # return ans

        roman2int = &#123;
            &#39;I&#39;: 1,
            &#39;V&#39;: 5,
            &#39;X&#39;: 10,
            &#39;L&#39;: 50,
            &#39;C&#39;: 100,
            &#39;D&#39;: 500,
            &#39;M&#39;: 1000,
        &#125;

        num = 0
        i = 0
        while i &lt; len(s):
            if s[i] == &#39;I&#39; and i+1 &lt; len(s) and (s[i+1] == &#39;V&#39; or s[i+1] == &#39;X&#39;):
                num += (roman2int[s[i+1]] - roman2int[s[i]])
                i += 2
            elif s[i] == &#39;X&#39; and i+1 &lt; len(s) and (s[i+1] == &#39;L&#39; or s[i+1] == &#39;C&#39;):
                num += (roman2int[s[i+1]] - roman2int[s[i]])
                i += 2
            elif s[i] == &#39;C&#39; and i+1 &lt; len(s) and (s[i+1] == &#39;D&#39; or s[i+1] == &#39;M&#39;):
                num += (roman2int[s[i+1]] - roman2int[s[i]])
                i += 2
            else:
                num += roman2int[s[i]]
                i += 1

        return num



if __name__ == &quot;__main__&quot;:
    slt = Solution()
    s = &quot;MCMXCIV&quot;
    int_num = slt.romanToInt(s)
    print(&quot;罗马数字 &#123;&#125; 对应的整数为 &#123;&#125; &quot;.format(s, int_num))
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>EEG | 脑电信号采用深度学习方法存在的问题</title>
    <url>/2020/11/10/%E8%84%91%E7%94%B5%E4%BF%A1%E5%8F%B7%E9%87%87%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="脑电信号采用深度学习方法存在的问题"><a href="#脑电信号采用深度学习方法存在的问题" class="headerlink" title="脑电信号采用深度学习方法存在的问题"></a>脑电信号采用深度学习方法存在的问题</h1><p>深度学习是一种构造多层神经网络的机器学习方法，具有发现数据中隐藏的分布式特征表示的能力。</p>
<h2 id="脑电信号特征提取方法："><a href="#脑电信号特征提取方法：" class="headerlink" title="脑电信号特征提取方法："></a>脑电信号特征提取方法：</h2><p>时域分析方法<br>频域分析方法<br>时频域分析犯法<br>非线性分析方法</p>
<h2 id="脑电信号采用深度学习方法目前存在的问题"><a href="#脑电信号采用深度学习方法目前存在的问题" class="headerlink" title="脑电信号采用深度学习方法目前存在的问题"></a>脑电信号采用深度学习方法目前存在的问题</h2><p>（1）<b style="color:red">深度神经网络层数的最优化，不是越多的网络层数就能得到最好的结果</b><br>（2）数据量也是造成深度学习方法无法深入的原因</p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>EEG</tag>
      </tags>
  </entry>
  <entry>
    <title>EEG | 脑电数据集下载网站</title>
    <url>/2021/04/17/%E8%84%91%E7%94%B5%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8B%E8%BD%BD%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h1 id="脑电数据集下载网站"><a href="#脑电数据集下载网站" class="headerlink" title="脑电数据集下载网站"></a>脑电数据集下载网站</h1><p><a href="www.physionet.org">网站1</a></p>
<p><a href="https://archive.ics.uci.edu/ml/datasets/EEG+Database">网站2</a></p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
      </categories>
      <tags>
        <tag>EEG</tag>
        <tag>数据集</tag>
      </tags>
  </entry>
  <entry>
    <title>伪迹移除 | 自适应滤波器</title>
    <url>/2021/02/23/%E8%87%AA%E9%80%82%E5%BA%94%E6%BB%A4%E6%B3%A2%E5%99%A8/</url>
    <content><![CDATA[<h1 id="Adaptive-Filter"><a href="#Adaptive-Filter" class="headerlink" title="Adaptive Filter"></a>Adaptive Filter</h1><p>Adaptive Filter is a system with a linear filter that has a transfer function controlled by variable parameters and a means to adjust those parameters according to an optimization algorithm.The filter weights can adapt based on the feedback from output of the system and it requires a reference input o compare the desired output with the observed output.</p>
<h2 id="The-use-of-adaptive-filter-for-EOG-artifact-removal"><a href="#The-use-of-adaptive-filter-for-EOG-artifact-removal" class="headerlink" title="The use of adaptive filter for EOG artifact removal"></a>The use of adaptive filter for EOG artifact removal</h2><p><img src="/2021/02/23/%E8%87%AA%E9%80%82%E5%BA%94%E6%BB%A4%E6%B3%A2%E5%99%A8/1.PNG"><br>where s[n] is observed signal,x[n] is original EEG,r[n] is artifact,x’[n] is artifact-free EEG.</p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>伪迹移除</category>
      </categories>
      <tags>
        <tag>自适应滤波器</tag>
      </tags>
  </entry>
  <entry>
    <title>urllib.request | 解码json数据</title>
    <url>/2021/08/05/%E8%A7%A3%E7%A0%81json%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="使用json提供的loads-str-函数进行JSON数据的解码"><a href="#使用json提供的loads-str-函数进行JSON数据的解码" class="headerlink" title="使用json提供的loads(str)函数进行JSON数据的解码"></a>使用json提供的loads(str)函数进行JSON数据的解码</h1><p><strong>函数说明：</strong><br>    str - JSON字符串<br>    返回值 - python数据<br><strong>示例代码：</strong></p>
<pre><code># coding=utf-8

import urllib.request
import json

# 使用json模块的loads(str)函数进行JSON数据的解码
url = &#39;http://localhost:8080/NoteWebService/note.do?action=query&amp;ID=10&#39;

req = urllib.request.Request(url)

with urllib.request.urlopen(req) as response:
    data = response.read()
    json_data = data.decode()
    print(&quot;JSON字符串：&quot;, json_data)

    py_dict = json.loads(json_data)  # 解码JSON字符串，返回字典
    print(&#39;备忘录ID：&#39;, py_dict[&#39;ID&#39;])
    print(&#39;备忘录日期：&#39;, py_dict[&#39;CDate&#39;])
    print(&#39;备忘录内容：&#39;, py_dict[&#39;Content&#39;])
    print(&#39;用户ID：&#39;, py_dict[&#39;UserID&#39;])
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>内置模块</category>
        <category>urllib</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>urllib</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 计算图</title>
    <url>/2021/06/19/%E8%AE%A1%E7%AE%97%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h1><p>一个计算流程图，就是正向或者说从左到右的计算来计算成本函数𝐽，你可能<br>需要优化的函数，然后反向从右到左计算导数。<br><img src="/2021/06/19/%E8%AE%A1%E7%AE%97%E5%9B%BE/1.png"><br><b>参考吴恩达深度学习视频：</b><a href="https://www.bilibili.com/video/BV1FT4y1E74V?p=15&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV1FT4y1E74V?p=15&amp;spm_id_from=pageDriver</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>计算图</tag>
      </tags>
  </entry>
  <entry>
    <title>python-docx | 设置word文档里表格的格式</title>
    <url>/2021/10/24/%E8%AE%BE%E7%BD%AEword%E6%96%87%E6%A1%A3%E9%87%8C%E8%A1%A8%E6%A0%BC%E7%9A%84%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="设置word文档里表格的格式"><a href="#设置word文档里表格的格式" class="headerlink" title="设置word文档里表格的格式"></a>设置word文档里表格的格式</h1><p>以下代码实现使用python-docx对word文档里表格的格式进行设置。</p>
<span id="more"></span>

<pre><code># 单元格边框设置函数
from docx.table import _Cell
from docx.oxml import OxmlElement
from docx.oxml.ns import qn


def Set_cell_border(cell: _Cell, **kwargs):
    &quot;&quot;&quot;
    设置单元格边框函数
    使用方法:
    Set_cell_border(
        cell,
        top=&#123;&quot;sz&quot;: 12, &quot;val&quot;: &quot;single&quot;, &quot;color&quot;: &quot;#FF0000&quot;, &quot;space&quot;: &quot;0&quot;&#125;,
        bottom=&#123;&quot;sz&quot;: 12, &quot;color&quot;: &quot;#00FF00&quot;, &quot;val&quot;: &quot;single&quot;&#125;,
        start=&#123;&quot;sz&quot;: 24, &quot;val&quot;: &quot;dashed&quot;, &quot;shadow&quot;: &quot;true&quot;&#125;,
        end=&#123;&quot;sz&quot;: 12, &quot;val&quot;: &quot;dashed&quot;&#125;,
    )
    传入参数有cell, 即单元格；top指上边框；bottom指下边框；start指左边框；end指右边框。
    &quot;sz&quot;指线的粗细程度；&quot;val&quot;指线型，比如单线，虚线等；&quot;color&quot;指颜色，颜色编码可百度；
    &quot;space&quot;指间隔，一般不设置，设置的值大于0会导致线错开；&quot;shadow&quot;指边框阴影
    &quot;&quot;&quot;
    tc = cell._tc
    tcPr = tc.get_or_add_tcPr()

    tcBorders = tcPr.first_child_found_in(&quot;w:tcBorders&quot;)
    if tcBorders is None:
        tcBorders = OxmlElement(&#39;w:tcBorders&#39;)
        tcPr.append(tcBorders)

    for edge in (&#39;start&#39;, &#39;top&#39;, &#39;end&#39;, &#39;bottom&#39;, &#39;insideH&#39;, &#39;insideV&#39;):
        edge_data = kwargs.get(edge)
        if edge_data:
            tag = &#39;w:&#123;&#125;&#39;.format(edge)

            element = tcBorders.find(qn(tag))
            if element is None:
                element = OxmlElement(tag)
                tcBorders.append(element)

            for key in [&quot;sz&quot;, &quot;val&quot;, &quot;color&quot;, &quot;space&quot;, &quot;shadow&quot;]:
                if key in edge_data:
                    element.set(qn(&#39;w:&#123;&#125;&#39;.format(key)), str(edge_data[key]))


# 定义单元格填充颜色函数
from docx.oxml.ns import nsdecls
from docx.oxml import parse_xml


def Set_Background_Color(cell, rgbColor):
    shading_elm = parse_xml(
        r&#39;&lt;w:shd &#123;&#125; w:fill=&quot;&#123;color_value&#125;&quot;/&gt;&#39;.format(nsdecls(&#39;w&#39;), color_value=rgbColor))  # 固定写法，照抄即可
    cell._tc.get_or_add_tcPr().append(shading_elm)


from docx.enum.text import WD_ALIGN_PARAGRAPH  # 设置水平居中对齐需要用到的库
from docx.enum.table import WD_ALIGN_VERTICAL  # 设置垂直居中对齐需要用到的库
from docx.shared import Cm  # 长度单位（厘米cm用到的库)
from docx import Document

doc = Document(&quot;收货记录.docx&quot;)  # 打开word文件
table = doc.tables[0]
max_row = len(table.rows)  # 获取表格总行数

# 1.最后一行中，“总数”两个字要加粗
run = table.cell(max_row - 1, 4).paragraphs[0].runs[0]  # 获取最后一行第五列对应单元格中的文字块，即“总数”字样所在单元格
run.font.bold = True  # 将文字块设置为粗体

# 2.最后一行的行高要调大一点，现在这样扁扁的，难看
table.rows[max_row - 1].height = Cm(1)  # 将最后一行的行高设置为1厘米

# 3.最后一行那几个空单元格有框线，太碍眼，得去掉，将总数及左边两个cell左边框和下边框设成白色
for i in range(3):
    cell = table.cell(max_row - 1, i)
    Set_cell_border(
        cell,
        bottom=&#123;&quot;color&quot;: &quot;#FFFFFF&quot;&#125;,
        start=&#123;&quot;color&quot;: &quot;#FFFFFF&quot;&#125;,
        end=&#123;&quot;color&quot;: &quot;#FFFFFF&quot;&#125;
    )

cell_1 = table.cell(max_row - 1, 3)
Set_cell_border(cell_1, start=&#123;&quot;color&quot;: &quot;#FFFFFF&quot;&#125;, bottom=&#123;&quot;color&quot;: &quot;#FFFFFF&quot;&#125;)

cell_2 = table.cell(max_row - 1, 6)
Set_cell_border(cell_2, end=&#123;&quot;color&quot;: &quot;#FFFFFF&quot;&#125;, bottom=&#123;&quot;color&quot;: &quot;#FFFFFF&quot;&#125;)

# 4.各单元格水平和垂直方向都要居中对齐
for row in range(1, max_row):
    for col in range(len(table.columns)):
        table.cell(row, col).paragraphs[0].alignment = WD_ALIGN_PARAGRAPH.CENTER
        table.cell(row, col).vertical_alignment = WD_ALIGN_VERTICAL.CENTER

# 5.数量列≥85的，底色设置为橙色
qty = []  # 存储数量信息
# 读取第二行到29行，第2，3列中的数据
for i in range(1, max_row - 1):
    qty_info = table.rows[i].cells[5].text  # cells[5]指表格第6列
    qty.append(int(qty_info))

# 将数量≥85的单元格填色
row = 1  # 行计数器
for i in qty:
    if i &gt;= 85:
        cell = table.cell(row, 5)  # 第6列数据为数量，列索引是5
        Set_Background_Color(cell, &quot;98F5FF&quot;)  # 填充颜色，&quot;98F5FF&quot;是蓝色的编码
    row += 1  # 跳转到下一行

doc.save(&quot;收货记录-整理.docx&quot;)
</code></pre>
<p><a href="收货记录.docx">收货记录.docx</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>python-docx</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python-docx</tag>
      </tags>
  </entry>
  <entry>
    <title>requests | 获取网站新文章</title>
    <url>/2021/10/29/%E8%8E%B7%E5%8F%96%E7%BD%91%E7%AB%99%E6%96%B0%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="Python爬虫-已爬取目标网站所有文章，后续如何只获取新文章"><a href="#Python爬虫-已爬取目标网站所有文章，后续如何只获取新文章" class="headerlink" title="Python爬虫~已爬取目标网站所有文章，后续如何只获取新文章?"></a>Python爬虫~已爬取目标网站所有文章，后续如何只获取新文章?</h1><p>代码：</p>
<pre><code>print(&quot;文章刷新中......&quot;)

# 定义函数，获取想要的文章并批量写入word文件
import requests
from bs4 import BeautifulSoup
import docx
from docx.shared import Pt  # 用于设定字体大小（磅值）
from docx.oxml.ns import qn  # 用于应用中文字体
import random
import time
import os


def Get_article_to_word(url, date):
    user_agent_list = [
        &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36&quot;,
        &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&quot;,
        &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36&quot;,
        &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.62 Safari/537.36&quot;,
        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36&quot;,
        &quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)&quot;,
        &quot;Mozilla/5.0 (Macintosh; U; PPC Mac OS X 10.5; en-US; rv:1.9.2.15) Gecko/20110303 Firefox/3.6.15&quot;
        ]
    header = &#123;&#39;User-Agent&#39;: random.choice(user_agent_list)&#125;
    wb_data = requests.get(url, headers=header)
    soup = BeautifulSoup(wb_data.content)
    title = soup.select(&#39;.headword&#39;)[0].text.strip()  # 获得标题
    content1 = soup.select(&quot;.MsoNormal&quot;)  # 针对正文布局为 class = &quot;MsoNormal&quot;
    content2 = soup.select(&quot;#art_content&quot;)  # 针对正文布局为 id = &quot;art_content&quot;

    doc = docx.Document()  # 新建空白word文档
    # 设定全局字体
    doc.styles[&#39;Normal&#39;].font.name = u&#39;宋体&#39;
    doc.styles[&#39;Normal&#39;]._element.rPr.rFonts.set(qn(&#39;w:eastAsia&#39;), u&#39;宋体&#39;)

    # 写入标题行，并设置字体格式
    p = doc.add_paragraph()
    r = p.add_run(title)
    r.bold = True
    r.font.size = Pt(18)

    doc.add_paragraph(date)  # 写入日期
    doc.add_paragraph(url)  # 写入文章链接

    dirs = os.getcwd() + &quot;\\文章&quot;
    if not os.path.exists(dirs):
        os.makedirs(dirs)
    # 写入正文
    for i in content2:
        doc.add_paragraph(i.text)
    for i in content1:
        doc.add_paragraph(i.text)
    doc.save(f&quot;&#123;dirs&#125;\\&#123;title&#125;.docx&quot;)


# 判断网站是否有新文章
import requests
import json

header = &#123;
    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.75 &#39;
                  &#39;Safari/537.36&#39;&#125;
form_data = &#123;&#39;_q&#39;: &#39;Article.list&#39;,
             &#39;siteId&#39;: &#39;7e0b3b27-2622-4aa7-b6f8-abfe5c5df922&#39;,
             &#39;catalogId&#39;: &#39;34f92da3-d6d0-4e96-899f-d7f581c18162&#39;,
             &#39;pub&#39;: &#39;true&#39;,
             &#39;limit&#39;: 150,  # 网站更新速度较慢，每次查看是否有更新的时候，只获取前10页共150篇文章的信息
             &#39;start&#39;: 1&#125;

# 这是异步加载，请求方法是POST
url = &quot;http://www.bicpa.org.cn/dtzj/zxgg/getArticles.action&quot;
res = requests.post(url, data=form_data, headers=header)
article_data0 = res.text.split(&quot;&#123;success:true,datas:&quot;)[1]  # 去掉字符串前面的无用信息“&#123;success:true,datas:”
article_data = article_data0.split(&quot;,total:&quot;)[0]  # 去掉字符串后面的无用信息“,total:xxxx&#125;”
obj = json.loads(article_data)

# 载入数据库中的所有链接，作为判断基准
f = open(os.getcwd() + &#39;\\links.txt&#39;, &#39;r&#39;)
link_database = f.read()  # 读取成一个大字符串

# 将所有新文章链接写入文本文件
path = r&quot;http://www.bicpa.org.cn&quot;
links_file = open(&#39;links.txt&#39;, &#39;a&#39;)  # 避免覆盖已有数据，用添加模式`a`写入
counter_link = 0  # 新文章链接计数器
counter_download = 0  # 新下载文章计数器
for info in obj:
    link = path + info[&#39;url&#39;] + info[&#39;primaryKey&#39;] + &quot;.html&quot;  # 拼接链接信息
    if link in link_database:  # 判断新提取的链接是否已存在于数据库
        pass
    else:
        links_file.write(link + &quot;\n&quot;)  # 写入链接信息
        counter_link += 1

        # 下载标题含有&quot;委员会专家提示&quot;的文章
        if &quot;委员会专家提示&quot; in info[&#39;title&#39;]:
            Get_article_to_word(link, info[&quot;publishDate&quot;])  # 调用写好的函数，下载文章到word文件
            counter_download += 1  # 每下载一篇文章，计数器增加1

links_file.close()  # 写完后关闭文件

# 显示每次的结果
if counter_link == 0:
    print(&quot;没有文章更新！&quot;)
else:
    print(f&quot;共获取到 &#123;counter_link&#125; 篇新文章的链接，并加入数据库。&quot;)

if counter_download == 0:
    print(&quot;没有&#39;委员会专家提示&#39;文章更新！&quot;)
else:
    print(f&quot;共下载 &#123;counter_download&#125; 篇&#39;委员会专家提示&#39;新文章，请到文件夹查看。&quot;)

print(&quot;程序运行完成，关闭窗口退出.&quot;)
input()
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>requests</category>
      </categories>
      <tags>
        <tag>os</tag>
        <tag>python-docx</tag>
        <tag>requests</tag>
        <tag>BeautifulSoup</tag>
        <tag>random</tag>
        <tag>json</tag>
        <tag>time</tag>
      </tags>
  </entry>
  <entry>
    <title>win32com | 识别加密word文件</title>
    <url>/2021/10/31/%E8%AF%86%E5%88%AB%E5%8A%A0%E5%AF%86word%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="识别加密word文件"><a href="#识别加密word文件" class="headerlink" title="识别加密word文件"></a>识别加密word文件</h1><p>Python本身是难以识别word文件的加密状态的，那我们可以考虑利用程序在处理有密码的文档的时候的报错信息来进行处理。word文件有两种密码，一种是“打开密码”，另一种是“修改密码”。对于前者，若不输入正确的密码，是无法打开文件查看内容的；对于后者，即使不知道密码，还是可以用只读模式打开文件，查看内容并另存为新的文件的。<br>因此对于设置了“修改密码”的doc文件，并不影响用如下程序另存为docx文件。只是在另存之前，窗口会弹出如下对话框，我们只需要点击一下“只读”即可，程序就能正常运行下去。<br>如果设置了“打开密码”，程序在运行的时候也会弹出对话框，让输入密码。如果输入正确的密码，程序也是可以运行的；如果不知道密码或输入错误密码，则程序会出现如下的“com_error”错误。如果不知道密码，可以加入try..except..语句，让程序在except语句中将这个文件移动到名字为“有密码文件”的文件夹，以便后续处理。</p>
<span id="more"></span>
<p>实现代码：</p>
<pre><code>from win32com import client as wc  # 导入模块

file = r&quot;C:\Users\dywei\python\python_excel\实例65_Python区分出加密的word文件\doc文件\\测试-有打开密码.doc&quot;
word = wc.Dispatch(&quot;Word.Application&quot;)  # 打开word应用程序
doc = word.Documents.Open(file)  # 打开word文件
doc.SaveAs(&quot;&#123;&#125;x&quot;.format(file), 12)  # 另存为后缀为&quot;.docx&quot;的文件，其中参数12指docx文件
doc.Close()  # 关闭原来word文件
word.Quit()

# 增加异常处理语句
import shutil  # 用于操作文件和文件夹
from win32com import client as wc

file = r&quot;C:\Users\dywei\python\python_excel\实例65_Python区分出加密的word文件\doc文件\\测试-有打开密码.doc&quot;
try:
    word = wc.Dispatch(&quot;Word.Application&quot;)  # 打开word应用程序
    doc = word.Documents.Open(file)  # 打开word文件
    doc.SaveAs(&quot;&#123;&#125;x&quot;.format(file), 12)  # 另存为后缀为&quot;.docx&quot;的文件，其中参数12指docx文件
    doc.Close()  # 关闭原来word文件
    word.Quit()
except:
    # 将有密码的文件移动到专门的文件夹
    shutil.move(file, r&quot;C:\Users\dywei\python\python_excel\实例65_Python区分出加密的word文件\有密码文件&quot;)
    print(f&quot;已移动加密文件 &#123;file&#125;&quot;)

# #文件有“打开密码”的情况
# import docx
# doc = docx.Document(&#39;docx文件\\报告-有打开密码.docx&#39;)
# PackageNotFoundError: Package not found at &#39;docx文件\报告-有打开密码.docx&#39;

# 文件有“修改密码”的情况
import docx

doc = docx.Document(&#39;docx文件\\报告-有修改密码.docx&#39;)
p = doc.paragraphs[0]
pNew = p.insert_paragraph_before()
run = pNew.add_run(&quot;测试&quot;)
doc.save(&quot;docx文件\\报告-有修改密码.docx&quot;)

import docx
import shutil
file = &quot;docx文件\\报告-有打开密码.docx&quot;
try:
    doc = docx.Document(file)
    pass
except:
    shutil.move(file, &#39;有密码文件&#39;)
    print(f&quot;已移动加密文件 &#123;file&#125; 到指定文件夹&quot;)
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>win32com</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>win32com</tag>
        <tag>python-docx</tag>
        <tag>shutil</tag>
      </tags>
  </entry>
  <entry>
    <title>wordcloud | 词云</title>
    <url>/2021/10/28/%E8%AF%8D%E4%BA%91/</url>
    <content><![CDATA[<h1 id="词云"><a href="#词云" class="headerlink" title="词云"></a>词云</h1><p>根据文章中的关键词的词频生成词云图。</p>
<span id="more"></span>

<p>实现代码：</p>
<pre><code>import numpy as np  # numpy数据处理库
import wordcloud  # 词云库
from PIL import Image  # 图像处理库，用于读取背景图片
import matplotlib.pyplot as plt  # 图像展示库，以便在notebook中显示图片
from openpyxl import load_workbook  # 读取词频Excel文件
import os  # 获取词频Excel文件路径

# 将存好的Excel词频表读取成字典
path = &#39;词频&#39;  # 文件所在文件夹
files = [path + &quot;\\&quot; + i for i in os.listdir(path)]  # 获取文件夹下的文件名,并拼接完整路径
maskImage = np.array(Image.open(&#39;background.png&#39;))  # 定义词频背景图

for file in files:
    # 将词频Excel文件读取为字典
    wb = load_workbook(file)
    ws = wb.active
    wordFreq = &#123;&#125;
    for i in range(2, ws.max_row + 1):
        word = ws[&quot;A&quot; + str(i)].value
        freq = ws[&quot;B&quot; + str(i)].value
        wordFreq[word] = freq

        # 定义词云样式
    wc = wordcloud.WordCloud(
        font_path=&#39;C:/Windows/Fonts/simhei.ttf&#39;,  # 设置字体
        mask=maskImage,  # 设置背景图
        max_words=500,  # 最多显示词数
        max_font_size=100)  # 字号最大值

    # 生成词云图
    wc.generate_from_frequencies(wordFreq)  # 从字典生成词云
    # 保存图片到指定文件夹
    wc.to_file(&quot;词云图\\&#123;&#125;.png&quot;.format(file.split(&quot;\\&quot;)[1][:4]))
    # 在notebook中显示词云图
    plt.imshow(wc)  # 显示词云
    plt.axis(&#39;off&#39;)  # 关闭坐标轴
    plt.show()  # 显示图像
</code></pre>
<p><a href="https://victory-liao.github.io/2021/10/27/python%E8%AF%8D%E9%A2%91%E5%88%86%E6%9E%90/#more">词频文件夹</a><br><a href="background.PNG">background.PNG</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>第三方库</category>
        <category>wordcloud</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>wordcloud</tag>
        <tag>词云</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 赎金信</title>
    <url>/2021/09/01/%E8%B5%8E%E9%87%91%E4%BF%A1/</url>
    <content><![CDATA[<h1 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383.赎金信"></a>383.赎金信</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。<br>(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/ransom-note/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>遍历ransomNote中的每一个元素，并查找这个元素是否在magazine中，如果没有查找到，则返回False，如果查找到了，则将这个元素在magazine中移除，以此类推，直到遍历完ransomNote中的每一个元素。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool:
        ransomNote = list(ransomNote)
        magazine = list(magazine)

        for i in range(len(ransomNote)):
            if ransomNote[i] in magazine:
                magazine.remove(ransomNote[i])
                print(ransomNote)
            else:
                return False

        if i == len(ransomNote)-1:
            return True


if __name__ == &#39;__main__&#39;:
    s = Solution()
    res = s.canConstruct(&#39;aa&#39;, &#39;aab&#39;)
    print(res)

    # list1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;]
    # list1.remove(&#39;a&#39;)
    # print(list1)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>软件架构 | 软件设计策略</title>
    <url>/2021/03/11/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h1 id="软件设计策略"><a href="#软件设计策略" class="headerlink" title="软件设计策略"></a>软件设计策略</h1><p>1.面向对象设计</p>
<p>2.面向功能设计(结构化)</p>
<p>3.面向主题设计</p>
<p>4.面向数据结构设计(数据库)</p>
]]></content>
      <categories>
        <category>SA</category>
      </categories>
      <tags>
        <tag>软件架构</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 逆波兰表达式求值</title>
    <url>/2021/08/27/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
    <content><![CDATA[<h1 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150.逆波兰表达式求值"></a>150.逆波兰表达式求值</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>根据 逆波兰表示法，求表达式的值。<br>有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。<br>说明：<br>    整数除法只保留整数部分。<br>    给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p>
<p>示例 1：<br>输入：tokens = [“2”,”1”,”+”,”3”,”*”]<br>输出：9<br>解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</p>
<span id="more"></span>
<p><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.栈<br>遍历逆波兰表达式中的每一个字符，遇到数字则将数字入栈，遇到运算符则将栈顶的两个操作数出栈作此运算符对应的运算，再将运算结果入栈，…，以此类推，直到遍历完整个表达式，栈中剩余的元素就是表达式的结果。<br>2.数组模拟栈<br>对于一个有效的逆波兰表达式，其长度 n 一定是奇数，且操作数的个数一定比运算符的个数多 1 个，即包含 (n+1)/2 个操作数和 (n-1)/2 个运算符。考虑遇到操作数和运算符时，栈内元素个数分别会如何变化：<br>    如果遇到操作数，则将操作数入栈，因此栈内元素增加 1 个；<br>    如果遇到运算符，则将两个操作数出栈，然后将一个新操作数入栈，因此栈内元素先减少 2 个再增加 1 个，结果是栈内元素减少 1 个。<br>由此可以得到操作数和运算符与栈内元素个数变化的关系：遇到操作数时，栈内元素增加 1 个；遇到运算符时，栈内元素减少 1 个。<br>最坏情况下，(n+1)/2 个操作数都在表达式的前面，(n-1)/2 个运算符都在表达式的后面，此时栈内元素最多为 (n+1)/2 个。在其余情况下，栈内元素总是少于 (n+1)/2 个。因此，在任何情况下，栈内元素最多可能有 (n+1)/2 个，将数组的长度定义为 (n+1)/2 即可。<br>具体实现方面，创建数组 stack 模拟栈，数组下标 0 的位置对应栈底，定义 index 表示栈顶元素的下标位置，初始时栈为空，index=−1。当遇到操作数和运算符时，进行如下操作：<br>    如果遇到操作数，则将 index 的值加 111，然后将操作数赋给 stack[index]；<br>    如果遇到运算符，则将 index 的值减 111，此时 stack[index] 和 stack[index+1] 的元素分别是左操作数和右操作数，使用运算符对两个操作数进行运算，将运算得到的新操作数赋给 stack[index]。<br>整个逆波兰表达式遍历完毕之后，栈内只有一个元素，因此 index=0，此时 stack[index] 即为逆波兰表达式的值。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):
    def evalRPN(self, tokens):
        &quot;&quot;&quot;
        使用栈进行表达式求值

        :type tokens: List[str]
        :rtype: int
        &quot;&quot;&quot;
        op_to_binary_fn = &#123;
            &quot;+&quot;: lambda x, y: x + y,
            &#39;-&#39;: lambda x, y: x - y,
            &#39;*&#39;: lambda x, y: x * y,
            &#39;/&#39;: lambda x, y: int(x / y),
        &#125;

        stack = list()
        for token in tokens:
            try:
                num = int(token)
            except ValueError:
                num2 = stack.pop()
                num1 = stack.pop()
                num = op_to_binary_fn[token](num1, num2)
            finally:
                stack.append(num)

        return stack[0]

    def evalRPN1(self, tokens):
        &quot;&quot;&quot;
        使用数组模拟栈进行表达式求值

        :type tokens: List[str]
        :rtype: int
        &quot;&quot;&quot;
        op_to_binary_fn = &#123;
            &quot;+&quot;: lambda x, y: x + y,
            &#39;-&#39;: lambda x, y: x - y,
            &#39;*&#39;: lambda x, y: x * y,
            &#39;/&#39;: lambda x, y: int(x / y),
        &#125;
        n = len(tokens)
        stack = [0] * ((n + 1) // 2)
        index = -1
        for token in tokens:
            try:
                num = int(token)
                index += 1
                stack[index] = num
            except ValueError:
                index -= 1
                stack[index] = op_to_binary_fn[token](stack[index], stack[index + 1])
        return stack[0]


if __name__ == &quot;__main__&quot;:
    slt = Solution()
    # tokens = [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]
    # tokens = [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]
    tokens = [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]
    print(&quot;表达式的值为：&#123;&#125;&quot;.format(slt.evalRPN1(tokens)))
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 防止模型过拟合的6种必备方法</title>
    <url>/2021/07/03/%E9%98%B2%E6%AD%A2%E6%A8%A1%E5%9E%8B%E8%BF%87%E6%8B%9F%E5%90%88%E7%9A%846%E7%A7%8D%E5%BF%85%E5%A4%87%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="防止模型过拟合的6种必备方法"><a href="#防止模型过拟合的6种必备方法" class="headerlink" title="防止模型过拟合的6种必备方法"></a>防止模型过拟合的6种必备方法</h1><p>在训练机器学习模型时常常会遇到模型过拟合的情况，即模型在训练集上的表现良好，但是在验证集或者<br>测试集上表现相对较差；<br><b>常见的防止过拟合的方法：</b><br>1.使用K重交叉验证方法或者留一验证方法<br>2.数据增强<br>3.正则化<br>4.早停<br>5.Dropout<br>6.移除特征<br><a href="https://mp.weixin.qq.com/s/RP9iFbyw-aNMKx-UAOe-aA">参考资料</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>过拟合</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 | 飞桨推出的深度学习资料一站式获取平台项目</title>
    <url>/2021/06/23/%E9%A3%9E%E6%A1%A8%E6%8E%A8%E5%87%BA%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E4%B8%80%E7%AB%99%E5%BC%8F%E8%8E%B7%E5%8F%96%E5%B9%B3%E5%8F%B0%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="飞桨推出的深度学习资料一站式获取平台项目"><a href="#飞桨推出的深度学习资料一站式获取平台项目" class="headerlink" title="飞桨推出的深度学习资料一站式获取平台项目"></a>飞桨推出的深度学习资料一站式获取平台项目</h1><p>这是飞桨推出的深度学习资料一站式获取平台项目，可以看看有没有符合自己的资料哈~~</p>
<p><a href="https://github.com/PaddlePaddle/awesome-DeepLearning">飞桨PaddlePaddle</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>飞桨</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode | 验证回文串</title>
    <url>/2021/08/28/%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125.验证回文串"></a>125.验证回文串</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。<br>说明：本题中，我们将空字符串定义为有效的回文串。</p>
<span id="more"></span>
<p>示例 1:<br>输入: “A man, a plan, a canal: Panama”<br>输出: true<br>解释：”amanaplanacanalpanama” 是回文串</p>
<p><a href="https://leetcode-cn.com/problems/count-and-say/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.判断第i(0 &lt; i &lt; len(new_s)//2)个字符与倒数第i个字符是否相等来确定字符串是否回文，其中new_s是去除了除数字字母外字符的字符串<br>2.判断反转字符串是否与原字符串相同<br>3.双指针（去除除数字字母外的其他字符）<br>初始时，左右指针分别指向字符串的两侧，随后我们不断地将这两个指针相向移动，每次移动一步，并判断这两个指针指向的字符是否相同。当这两个指针相遇时，就说明是回文串。<br>4.双指针（直接在原字符串上进行判断）<br>与3.相同</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:
    def isPalindrome(self, s: str) -&gt; bool:
        import re
        new_s = re.sub(r&#39;\W|_&#39;, &#39;&#39;, s).lower()
        len_new_s = len(new_s)
        i = 0
        while i &lt; len_new_s // 2:
            if new_s[i] == new_s[len_new_s-i-1]:
                i += 1
            else:
                break
        if i == len_new_s // 2:
            return True
        else:
            return False

    def isPalindrome1(self, s: str) -&gt; bool:
        &quot;&quot;&quot;
        筛选+判断（判断反转字符串是否与原字符串相同）
        :param s:
        :return:
        &quot;&quot;&quot;
        new_s = &quot;&quot;.join(ch.lower() for ch in s if ch.isalnum())
        return new_s == new_s[::-1]

    def isPalindrome2(self, s: str) -&gt; bool:
        &quot;&quot;&quot;
        双指针
        &quot;&quot;&quot;
        new_s = &quot;&quot;.join(ch.lower() for ch in s if ch.isalnum())
        left, right = 0, len(new_s) - 1

        while left &lt; right:
            if new_s[left] != new_s[right]:
                return False

            left, right = left + 1, right - 1

        return True

    def isPalindrome3(self, s: str) -&gt; bool:
        &quot;&quot;&quot;在原字符串上直接判断&quot;&quot;&quot;
        n = len(s)
        left, right = 0, n - 1

        while left &lt; right:
            while left &lt; right and not s[left].isalnum():
                left += 1
            while left &lt; right and not s[right].isalnum():
                right -= 1
            if left &lt; right:
                if s[left].lower() != s[right].lower():
                    return False
                left, right = left + 1, right - 1

        return True


if __name__ == &quot;__main__&quot;:
    slt = Solution()
    string = &quot;abcb&quot;
    res = slt.isPalindrome(string)
    print(res)
</code></pre>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>ICA | 鸡尾酒宴会问题</title>
    <url>/2021/02/21/%E9%B8%A1%E5%B0%BE%E9%85%92%E5%AE%B4%E4%BC%9A%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="鸡尾酒宴会问题"><a href="#鸡尾酒宴会问题" class="headerlink" title="鸡尾酒宴会问题"></a>鸡尾酒宴会问题</h1><p>鸡尾酒宴会问题是独立成分分析(Indepen Compon Analysis)的经典问题。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>假设在party中有n个人，他们可以同时说话，我们也在房间中一些角落里共放置了n个声音接收器（Microphone）用来记录声音。宴会过后，我们从n个麦克风中得到了一组数据<br><img src="/2021/02/21/%E9%B8%A1%E5%B0%BE%E9%85%92%E5%AE%B4%E4%BC%9A%E9%97%AE%E9%A2%98/1.png"><br>，i表示采样的时间顺序，也就是说共得到了m组采样，每一组采样都是n维的。我们的目标是单单从这m组采样数据中分辨出每个人说话的信号。</p>
<p>将第二个问题细化一下，有n个信号源<br><img src="/2021/02/21/%E9%B8%A1%E5%B0%BE%E9%85%92%E5%AE%B4%E4%BC%9A%E9%97%AE%E9%A2%98/2.png"><br>,每一维都是一个人的声音信号，每个人发出的声音信号独立。A是一个未知的混合矩阵（mixing matrix），用来组合叠加信号s，那么<br>X = AS<br>X的意义在上文解释过，这里的x不是一个向量，是一个矩阵。其中每个列向量是<br><img src="/2021/02/21/%E9%B8%A1%E5%B0%BE%E9%85%92%E5%AE%B4%E4%BC%9A%E9%97%AE%E9%A2%98/3.png"><br>表示成图就是<br><img src="/2021/02/21/%E9%B8%A1%E5%B0%BE%E9%85%92%E5%AE%B4%E4%BC%9A%E9%97%AE%E9%A2%98/4.jpg"><br><img src="/2021/02/21/%E9%B8%A1%E5%B0%BE%E9%85%92%E5%AE%B4%E4%BC%9A%E9%97%AE%E9%A2%98/5.png"><br>x(i)的每个分量都由s(i)的分量线性表示。A和s都是未知的，x是已知的，我们要想办法根据x来推出s。这个过程也称作为盲信号分离。<br><img src="/2021/02/21/%E9%B8%A1%E5%B0%BE%E9%85%92%E5%AE%B4%E4%BC%9A%E9%97%AE%E9%A2%98/8.png"><br>将W表示成<br><img src="/2021/02/21/%E9%B8%A1%E5%B0%BE%E9%85%92%E5%AE%B4%E4%BC%9A%E9%97%AE%E9%A2%98/9.png"><br>其中<img src="/2021/02/21/%E9%B8%A1%E5%B0%BE%E9%85%92%E5%AE%B4%E4%BC%9A%E9%97%AE%E9%A2%98/10.png">,起始就是将wi携程行向量形式。那么得到：<br><img src="/2021/02/21/%E9%B8%A1%E5%B0%BE%E9%85%92%E5%AE%B4%E4%BC%9A%E9%97%AE%E9%A2%98/11.png"></p>
]]></content>
      <categories>
        <category>Research and Paper</category>
        <category>EEG</category>
        <category>伪迹移除</category>
      </categories>
      <tags>
        <tag>ICA</tag>
        <tag>鸡尾酒宴会问题</tag>
      </tags>
  </entry>
</search>
