<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Victory&#39;s Blog</title>
  
  <subtitle>非淡泊无以明志，非宁静无以致远</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-10-18T13:19:48.694Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>victory-liao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python-pptx | 批量生成PPT版荣誉证书</title>
    <link href="http://example.com/2021/10/16/%E6%89%B9%E9%87%8F%E7%94%9F%E6%88%90PPT%E7%89%88%E8%8D%A3%E8%AA%89%E8%AF%81%E4%B9%A6/"/>
    <id>http://example.com/2021/10/16/%E6%89%B9%E9%87%8F%E7%94%9F%E6%88%90PPT%E7%89%88%E8%8D%A3%E8%AA%89%E8%AF%81%E4%B9%A6/</id>
    <published>2021-10-16T13:52:18.000Z</published>
    <updated>2021-10-18T13:19:48.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="批量生成PPT版荣誉证书"><a href="#批量生成PPT版荣誉证书" class="headerlink" title="批量生成PPT版荣誉证书"></a>批量生成PPT版荣誉证书</h1><p>以下代码实现了根据一个excel名单和一个荣誉证书模板批量生成名单中所有人的荣誉证书。</p><pre><code>import timefrom pptx import Presentationfrom openpyxl import load_workbookprs = Presentation(r&#39;data\荣誉证书模板.pptx&#39;)slide = prs.slides.add_slide(prs.slide_layouts[0])  # 第一个模板的第0个板式for ph in slide.placeholders:  # 遍历这页PPT的所有占位符    phf = ph.placeholder_format  # 获取占位符的格式    print(phf.idx)  # 打印其ID编号    ph.text = str(phf.idx)  # 将编号写入PPT对应的位置中，以便后面一一对应# 以上读取到占位符的ID方便后面调用prs.save(r&#39;data\荣誉证书模板-占位符编号.pptx&#39;)wb = load_workbook(r&quot;data\名单.xlsx&quot;)ws = wb.activedata = &#123;&#125;for row in range(2, ws.max_row + 1):    class_id = ws[&#39;A&#39; + str(row)].value    name = ws[&#39;B&#39; + str(row)].value    data.setdefault(class_id, [])    data[class_id].append(name)t0 = time.time()  # 程序开始运行的时间prs = Presentation(r&#39;data\荣誉证书模板.pptx&#39;)slide_layout = prs.slide_layouts[0]  # 调用设置好的母版，因为是母版的第一版式，所以取[0]for class_id in data:    for name in data[class_id]:        slide = prs.slides.add_slide(slide_layout)  # 以母版的版式为基础新增一页幻灯片        # 往幻灯片中写入内容        slide.placeholders[10].text = &quot;&#123;&#125; 班 &#123;&#125; 同学：&quot;.format(class_id, name)  # 此处是班级和姓名        slide.placeholders[11].text = &quot;在2019-2020学年度第一学期获得&quot;        slide.placeholders[12].text = &quot;“好孩子”称号。&quot;        slide.placeholders[13].text = &quot;特发此证，以资鼓励。&quot;        slide.placeholders[14].text = &quot;市幼儿园&quot;        slide.placeholders[15].text = &quot;2020年1月&quot;prs.save(&#39;data\荣誉证书(总).pptx&#39;)t1 = time.time()print(&#39;程序用时：&#39;, str(round(t1 - t0)) + &#39;秒。&#39;)</code></pre><div class="pdfobject-container" data-target="./批量生成PPT版荣誉证书/荣誉证书模板.pptx" data-height="500px"></div><object classid="clsid:CA8A9780-280D-11CF-A24D-444553540000" width="600px" height="650px"><param name="SRC" value="./批量生成PPT版荣誉证书/荣誉证书模板.pptx"><embed width="700" height="650" fullscreen="yes" src="./批量生成PPT版荣誉证书/荣誉证书模板.pptx"></object>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;批量生成PPT版荣誉证书&quot;&gt;&lt;a href=&quot;#批量生成PPT版荣誉证书&quot; class=&quot;headerlink&quot; title=&quot;批量生成PPT版荣誉证书&quot;&gt;&lt;/a&gt;批量生成PPT版荣誉证书&lt;/h1&gt;&lt;p&gt;以下代码实现了根据一个excel名单和一个荣誉证书模板批量生</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="python-pptx" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/python-pptx/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="openpyxl" scheme="http://example.com/tags/openpyxl/"/>
    
    <category term="python-pptx" scheme="http://example.com/tags/python-pptx/"/>
    
  </entry>
  
  <entry>
    <title>itchat | python微信轰炸</title>
    <link href="http://example.com/2021/10/16/python%E5%BE%AE%E4%BF%A1%E8%BD%B0%E7%82%B8/"/>
    <id>http://example.com/2021/10/16/python%E5%BE%AE%E4%BF%A1%E8%BD%B0%E7%82%B8/</id>
    <published>2021-10-16T13:20:30.000Z</published>
    <updated>2021-10-16T13:22:12.154Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python微信轰炸"><a href="#python微信轰炸" class="headerlink" title="python微信轰炸"></a>python微信轰炸</h1><p><a href="https://www.bilibili.com/read/cv11064085/">python微信轰炸</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;python微信轰炸&quot;&gt;&lt;a href=&quot;#python微信轰炸&quot; class=&quot;headerlink&quot; title=&quot;python微信轰炸&quot;&gt;&lt;/a&gt;python微信轰炸&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/read</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="itchat" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/itchat/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="itchat" scheme="http://example.com/tags/itchat/"/>
    
    <category term="微信轰炸" scheme="http://example.com/tags/%E5%BE%AE%E4%BF%A1%E8%BD%B0%E7%82%B8/"/>
    
  </entry>
  
  <entry>
    <title>openpyxl | 修改excel表中的单元格内容</title>
    <link href="http://example.com/2021/10/16/%E4%BF%AE%E6%94%B9excel%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%8D%95%E5%85%83%E6%A0%BC%E5%86%85%E5%AE%B9/"/>
    <id>http://example.com/2021/10/16/%E4%BF%AE%E6%94%B9excel%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%8D%95%E5%85%83%E6%A0%BC%E5%86%85%E5%AE%B9/</id>
    <published>2021-10-16T12:20:02.000Z</published>
    <updated>2021-10-16T12:35:12.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="修改excel表中的单元格内容"><a href="#修改excel表中的单元格内容" class="headerlink" title="修改excel表中的单元格内容"></a>修改excel表中的单元格内容</h1><p>以下代码实现了修改 领料单（每日）.xlsx 中的所有表中某单元格的内容。<br><a href="修改excel表中的单元格内容/领料单（每日）.xlsx">领料单（每日）.xlsx</a></p><pre><code>from openpyxl import load_workbookwb = load_workbook(&quot;领料单（每日）.xlsx&quot;)print(wb.sheetnames)for sheet_name in wb.sheetnames:  # 遍历每个工作表，更改A4单元格的数据    print(sheet_name)    ws = wb[sheet_name]    ws[&#39;A4&#39;].value = &quot;零件测试领料单&quot; #直接将A4单元格的值改为需要的wb.save(&quot;资料单（每日）-更改后.xlsx&quot;)</code></pre><p><a href="https://blog.csdn.net/weixin_41546513/article/details/109555832">openpyxl参考资料</a><br><a href="https://openpyxl.readthedocs.io/en/stable/index.html">openpyxl官方文档</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;修改excel表中的单元格内容&quot;&gt;&lt;a href=&quot;#修改excel表中的单元格内容&quot; class=&quot;headerlink&quot; title=&quot;修改excel表中的单元格内容&quot;&gt;&lt;/a&gt;修改excel表中的单元格内容&lt;/h1&gt;&lt;p&gt;以下代码实现了修改 领料单（每日）.</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="openpyxl" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/openpyxl/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="openpyxl" scheme="http://example.com/tags/openpyxl/"/>
    
  </entry>
  
  <entry>
    <title>python | 68个python内置函数详解</title>
    <link href="http://example.com/2021/10/16/68%E4%B8%AApython%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2021/10/16/68%E4%B8%AApython%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-10-16T09:45:14.000Z</published>
    <updated>2021-10-16T11:27:26.465Z</updated>
    
    <content type="html"><![CDATA[<h1 id="68个python内置函数详解"><a href="#68个python内置函数详解" class="headerlink" title="68个python内置函数详解"></a>68个python内置函数详解</h1><p>内置函数就是Python给你提供的，拿来直接用的函数，比如print.，input等。<br>截止到python版本3.6.2 ，python一共提供了68个内置函数，具体如下👇</p><pre><code>abs()           dict()        help()         min()         setattr()all()           dir()         hex()          next()        slice() any()           divmod()      id()           object()      sorted() ascii()         enumerate()   input()        oct()         staticmethod() bin()           eval()        int()          open()        str() bool()          exec()        isinstance()   ord()         sum() bytearray()     ﬁlter()       issubclass()   pow()         super() bytes()         ﬂoat()        iter()         print()       tuple() callable()      format()      len()          property()    type() chr()           frozenset()   list()         range()       vars() classmethod()   getattr()     locals()       repr()        zip() compile()       globals()     map()          reversed()    __import__() complex()       hasattr()     max()          round() delattr()       hash()        memoryview()   set()</code></pre><span id="more"></span><p>本文将这68个内置函数综合整理为12大类，正在学习Python基础的读者一定不要错过，建议收藏学习！<br>和数字相关</p><ol><li>数据类型</li></ol><p>bool : 布尔型(True,False)<br>int : 整型(整数)<br>float : 浮点型(小数)<br>complex : 复数</p><ol start="2"><li>进制转换</li></ol><p>bin() 将给的参数转换成二进制<br>otc() 将给的参数转换成八进制<br>hex() 将给的参数转换成十六进制</p><pre><code>print(bin(10))  # 二进制:0b1010print(hex(10))  # 十六进制:0xaprint(oct(10))  # 八进制:0o12</code></pre><ol start="3"><li>数学运算</li></ol><p>abs() 返回绝对值<br>divmode() 返回商和余数<br>round() 四舍五入<br>pow(a, b) 求a的b次幂, 如果有三个参数. 则求完次幂后对第三个数取余<br>sum() 求和<br>min() 求最小值<br>max() 求最大值</p><pre><code>print(abs(-2))  # 绝对值:2print(divmod(20,3)) # 求商和余数:(6,2)print(round(4.50))   # 五舍六入:4print(round(4.51))   #5print(pow(10,2,3))  # 如果给了第三个参数. 表示最后取余:1print(sum([1,2,3,4,5,6,7,8,9,10]))  # 求和:55print(min(5,3,9,12,7,2))  #求最小值:2print(max(7,3,15,9,4,13))  #求最大值:15</code></pre><p>和数据结构相关</p><ol><li>序列</li></ol><p>（1）列表和元组</p><p>list() 将一个可迭代对象转换成列表<br>tuple() 将一个可迭代对象转换成元组</p><pre><code>print(list((1,2,3,4,5,6)))  #[1, 2, 3, 4, 5, 6]print(tuple([1,2,3,4,5,6]))  #(1, 2, 3, 4, 5, 6)</code></pre><p>（2）相关内置函数</p><p>reversed() 将一个序列翻转, 返回翻转序列的迭代器<br>slice() 列表的切片</p><pre><code>lst = &quot;你好啊&quot;it = reversed(lst)   # 不会改变原列表. 返回一个迭代器, 设计上的一个规则print(list(it))  #[&#39;啊&#39;, &#39;好&#39;, &#39;你&#39;]lst = [1, 2, 3, 4, 5, 6, 7]print(lst[1:3:1])  #[2,3]s = slice(1, 3, 1)  #  切片用的print(lst[s])  #[2,3]</code></pre><p>（3）字符串</p><p>str() 将数据转化成字符串</p><pre><code>print(str(123)+&#39;456&#39;)  #123456</code></pre><p>format() 与具体数据相关, 用于计算各种小数, 精算等.</p><pre><code>s = &quot;hello world!&quot;print(format(s, &quot;^20&quot;))  #剧中print(format(s, &quot;&lt;20&quot;))  #左对齐print(format(s, &quot;&gt;20&quot;))  #右对齐#     hello world!    # hello world!        #         hello world!print(format(3, &#39;b&#39; ))    # 二进制:11print(format(97, &#39;c&#39; ))   # 转换成unicode字符:aprint(format(11, &#39;d&#39; ))   # ⼗进制:11print(format(11, &#39;o&#39; ))   # 八进制:13 print(format(11, &#39;x&#39; ))   # 十六进制(⼩写字母):bprint(format(11, &#39;X&#39; ))   # 十六进制(大写字母):Bprint(format(11, &#39;n&#39; ))   # 和d⼀样:11print(format(11))         # 和d⼀样:11print(format(123456789, &#39;e&#39; ))      # 科学计数法. 默认保留6位小数:1.234568e+08print(format(123456789, &#39;0.2e&#39; ))   # 科学计数法. 保留2位小数(小写):1.23e+08print(format(123456789, &#39;0.2E&#39; ))   # 科学计数法. 保留2位小数(大写):1.23E+08print(format(1.23456789, &#39;f&#39; ))     # 小数点计数法. 保留6位小数:1.234568print(format(1.23456789, &#39;0.2f&#39; ))  # 小数点计数法. 保留2位小数:1.23print(format(1.23456789, &#39;0.10f&#39;))  # 小数点计数法. 保留10位小数:1.2345678900print(format(1.23456789e+3, &#39;F&#39;))   # 小数点计数法. 很大的时候输出INF:1234.567890</code></pre><p>bytes() 把字符串转化成bytes类型</p><pre><code>bs = bytes(&quot;今天吃饭了吗&quot;, encoding=&quot;utf-8&quot;)print(bs)  #b&#39;\xe4\xbb\x8a\xe5\xa4\xa9\xe5\x90\x83\xe9\xa5\xad\xe4\xba\x86\xe5\x90\x97&#39;</code></pre><p>bytearray()    返回一个新字节数组. 这个数字的元素是可变的, 并且每个元素的值得范围是[0,256)</p><pre><code>ret = bytearray(&quot;alex&quot; ,encoding =&#39;utf-8&#39;)print(ret[0])  #97print(ret)  #bytearray(b&#39;alex&#39;)ret[0] = 65  #把65的位置A赋值给ret[0]print(str(ret))  #bytearray(b&#39;Alex&#39;)</code></pre><p>ord() 输入字符找带字符编码的位置<br>chr() 输入位置数字找出对应的字符<br>ascii() 是ascii码中的返回该值 不是就返回u</p><pre><code>print(ord(&#39;a&#39;))  # 字母a在编码表中的码位:97print(ord(&#39;中&#39;))  # &#39;中&#39;字在编码表中的位置:20013print(chr(65))  # 已知码位,求字符是什么:Aprint(chr(19999))  #丟for i in range(65536):  #打印出0到65535的字符    print(chr(i), end=&quot; &quot;)print(ascii(&quot;@&quot;))  #&#39;@&#39;</code></pre><p>repr() 返回一个对象的string形式</p><pre><code>s = &quot;今天\n吃了%s顿\t饭&quot; % 3print(s)#今天# 吃了3顿    饭print(repr(s))   # 原样输出,过滤掉转义字符 \n \t \r 不管百分号%#&#39;今天\n吃了3顿\t饭&#39;</code></pre><ol start="2"><li>数据集合</li></ol><p>字典：dict 创建一个字典</p><p>集合：set 创建一个集合</p><p>frozenset() 创建一个冻结的集合，冻结的集合不能进行添加和删除操作。<br>3. 相关内置函数</p><p>len() 返回一个对象中的元素的个数<br>sorted() 对可迭代对象进行排序操作 (lamda)</p><p>语法：sorted(Iterable, key=函数(排序规则), reverse=False)</p><p>Iterable: 可迭代对象<br>key: 排序规则(排序函数), 在sorted内部会将可迭代对象中的每一个元素传递给这个函数的参数. 根据函数运算的结果进行排序<br>reverse: 是否是倒叙. True: 倒叙, False: 正序</p><pre><code>lst = [5,7,6,12,1,13,9,18,5]lst.sort()  # sort是list里面的一个方法print(lst)  #[1, 5, 5, 6, 7, 9, 12, 13, 18]ll = sorted(lst) # 内置函数. 返回给你一个新列表  新列表是被排序的print(ll)  #[1, 5, 5, 6, 7, 9, 12, 13, 18]l2 = sorted(lst,reverse=True)  #倒序print(l2)  #[18, 13, 12, 9, 7, 6, 5, 5, 1]</code></pre><p>#根据字符串长度给列表排序<br>    lst = [‘one’, ‘two’, ‘three’, ‘four’, ‘five’, ‘six’]<br>    def f(s):<br>        return len(s)<br>    l1 = sorted(lst, key=f, )<br>    print(l1)  #[‘one’, ‘two’, ‘six’, ‘four’, ‘five’, ‘three’]</p><p>enumerate() 获取集合的枚举对象</p><pre><code>lst = [&#39;one&#39;,&#39;two&#39;,&#39;three&#39;,&#39;four&#39;,&#39;five&#39;]for index, el in enumerate(lst,1):    # 把索引和元素一起获取,索引默认从0开始. 可以更改    print(index)    print(el)# 1# one# 2# two# 3# three# 4# four# 5# five</code></pre><p>all() 可迭代对象中全部是True, 结果才是True<br>any() 可迭代对象中有一个是True, 结果就是True</p><pre><code>print(all([1,&#39;hello&#39;,True,9]))  #Trueprint(any([0,0,0,False,1,&#39;good&#39;]))  #True</code></pre><p>zip() 函数用于将可迭代的对象作为参数, 将对象中对应的元素打包成一个元组, 然后返回由这些元组组成的列表. 如果各个迭代器的元素个数不一致, 则返回列表长度与最短的对象相同</p><pre><code>lst1 = [1, 2, 3, 4, 5, 6]lst2 = [&#39;醉乡民谣&#39;, &#39;驴得水&#39;, &#39;放牛班的春天&#39;, &#39;美丽人生&#39;, &#39;辩护人&#39;, &#39;被嫌弃的松子的一生&#39;]lst3 = [&#39;美国&#39;, &#39;中国&#39;, &#39;法国&#39;, &#39;意大利&#39;, &#39;韩国&#39;, &#39;日本&#39;]print(zip(lst1, lst1, lst3))  #&lt;zip object at 0x00000256CA6C7A88&gt;for el in zip(lst1, lst2, lst3):    print(el)# (1, &#39;醉乡民谣&#39;, &#39;美国&#39;)# (2, &#39;驴得水&#39;, &#39;中国&#39;)# (3, &#39;放牛班的春天&#39;, &#39;法国&#39;)# (4, &#39;美丽人生&#39;, &#39;意大利&#39;)# (5, &#39;辩护人&#39;, &#39;韩国&#39;)# (6, &#39;被嫌弃的松子的一生&#39;, &#39;日本&#39;)</code></pre><p>fiter() 过滤 (lamda)</p><p>语法：fiter(function. Iterable)</p><p>function: 用来筛选的函数. 在ﬁlter中会自动的把iterable中的元素传递给function. 然后根据function返回的True或者False来判断是否保留留此项数据 , Iterable: 可迭代对象</p><pre><code>def func(i):    # 判断奇数    return i % 2 == 1    lst = [1,2,3,4,5,6,7,8,9]l1 = filter(func, lst)  #l1是迭代器print(l1)  #&lt;filter object at 0x000001CE3CA98AC8&gt;print(list(l1))  #[1, 3, 5, 7, 9]</code></pre><p>map() 会根据提供的函数对指定序列列做映射(lamda)</p><p>语法 : map(function, iterable)</p><p>可以对可迭代对象中的每一个元素进行映射. 分别去执行 function</p><pre><code>def f(i):    return ilst = [1,2,3,4,5,6,7,]it = map(f, lst) # 把可迭代对象中的每一个元素传递给前面的函数进行处理. 处理的结果会返回成迭代器print(list(it))  #[1, 2, 3, 4, 5, 6, 7]</code></pre><p>和作用域相关</p><p>locals() 返回当前作用域中的名字<br>globals() 返回全局作用域中的名字</p><pre><code>def func():    a = 10    print(locals())  # 当前作用域中的内容    print(globals())  # 全局作用域中的内容    print(&quot;今天内容很多&quot;)func()# &#123;&#39;a&#39;: 10&#125;# &#123;&#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None, &#39;__package__&#39;: None, &#39;__loader__&#39;: # &lt;_frozen_importlib_external.SourceFileLoader object at 0x0000026F8D566080&gt;, # &#39;__spec__&#39;: None, &#39;__annotations__&#39;: &#123;&#125;, &#39;__builtins__&#39;: &lt;module &#39;builtins&#39; # (built-in)&gt;, &#39;__file__&#39;: &#39;D:/pycharm/练习/week03/new14.py&#39;, &#39;__cached__&#39;: None,#  &#39;func&#39;: &lt;function func at 0x0000026F8D6B97B8&gt;&#125;# 今天内容很多</code></pre><p>和迭代器生成器相关</p><p>range() 生成数据<br>next() 迭代器向下执行一次, 内部实际使⽤用了__ next__()⽅方法返回迭代器的下一个项目<br>iter() 获取迭代器, 内部实际使用的是__ iter__()⽅方法来获取迭代器</p><pre><code>for i in range(15,-1,-5):    print(i)# 15# 10# 5# 0lst = [1,2,3,4,5]it = iter(lst)  #  __iter__()获得迭代器print(it.__next__())  #1print(next(it)) #2  __next__()  print(next(it))  #3print(next(it))  #4</code></pre><p>字符串类型代码的执行</p><p>eval() 执行字符串类型的代码. 并返回最终结果<br>exec() 执行字符串类型的代码<br>compile() 将字符串类型的代码编码. 代码对象能够通过exec语句来执行或者eval()进行求值</p><pre><code>s1 = input(&quot;请输入a+b:&quot;)  #输入:8+9print(eval(s1))  # 17 可以动态的执行代码. 代码必须有返回值s2 = &quot;for i in range(5): print(i)&quot;a = exec(s2) # exec 执行代码不返回任何内容# 0# 1# 2# 3# 4print(a)  #None# 动态执行代码exec(&quot;&quot;&quot;def func():    print(&quot; 我是周杰伦&quot;)&quot;&quot;&quot; )func()  #我是周杰伦code1 = &quot;for i in range(3): print(i)&quot;com = compile(code1, &quot;&quot;, mode=&quot;exec&quot;)   # compile并不会执行你的代码.只是编译exec(com)   # 执行编译的结果# 0# 1# 2code2 = &quot;5+6+7&quot;com2 = compile(code2, &quot;&quot;, mode=&quot;eval&quot;)print(eval(com2))  # 18code3 = &quot;name = input(&#39;请输入你的名字:&#39;)&quot;  #输入:hellocom3 = compile(code3, &quot;&quot;, mode=&quot;single&quot;)exec(com3)print(name)  #hello</code></pre><p>输入输出</p><p>print() : 打印输出<br>input() : 获取用户输出的内容</p><pre><code>print(&quot;hello&quot;, &quot;world&quot;, sep=&quot;*&quot;, end=&quot;@&quot;) # sep:打印出的内容用什么连接,end:以什么为结尾#hello*world@</code></pre><p>内存相关</p><p>hash() : 获取到对象的哈希值(int, str, bool, tuple). hash算法:(1) 目的是唯一性 (2) dict 查找效率非常高, hash表.用空间换的时间 比较耗费内存</p><pre><code>s = &#39;alex&#39;print(hash(s))  #-168324845050430382lst = [1, 2, 3, 4, 5]print(hash(lst))  #报错,列表是不可哈希的  id() :  获取到对象的内存地址s = &#39;alex&#39;print(id(s))  #2278345368944</code></pre><p>文件操作相关</p><p>open() : 用于打开一个文件, 创建一个文件句柄</p><pre><code>f = open(&#39;file&#39;,mode=&#39;r&#39;,encoding=&#39;utf-8&#39;)f.read()f.close()</code></pre><p>模块相关</p><p>__ import__() : 用于动态加载类和函数</p><pre><code># 让用户输入一个要导入的模块import osname = input(&quot;请输入你要导入的模块:&quot;)__import__(name)    # 可以动态导入模块</code></pre><p>帮 助</p><p>help() : 函数用于查看函数或模块用途的详细说明</p><pre><code>print(help(str))  #查看字符串的用途</code></pre><p>调用相关</p><p>callable() : 用于检查一个对象是否是可调用的. 如果返回True, object有可能调用失败, 但如果返回False. 那调用绝对不会成功</p><pre><code>a = 10print(callable(a))  #False  变量a不能被调用#def f():    print(&quot;hello&quot;)    print(callable(f))   # True 函数是可以被调用的</code></pre><p>查看内置属性</p><p>dir() : 查看对象的内置属性, 访问的是对象中的<strong>dir</strong>()方法</p><pre><code>print(dir(tuple))  #查看元组的方法</code></pre><p><a href="https://mp.weixin.qq.com/s/RE07ReitUyQDwG2yYcugPQ">68个python内置函数详解!!!</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;68个python内置函数详解&quot;&gt;&lt;a href=&quot;#68个python内置函数详解&quot; class=&quot;headerlink&quot; title=&quot;68个python内置函数详解&quot;&gt;&lt;/a&gt;68个python内置函数详解&lt;/h1&gt;&lt;p&gt;内置函数就是Python给你提供的，拿来直接用的函数，比如print.，input等。&lt;br&gt;截止到python版本3.6.2 ，python一共提供了68个内置函数，具体如下👇&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;abs()           dict()        help()         min()         setattr()
all()           dir()         hex()          next()        slice() 
any()           divmod()      id()           object()      sorted() 
ascii()         enumerate()   input()        oct()         staticmethod() 
bin()           eval()        int()          open()        str() 
bool()          exec()        isinstance()   ord()         sum() 
bytearray()     ﬁlter()       issubclass()   pow()         super() 
bytes()         ﬂoat()        iter()         print()       tuple() 
callable()      format()      len()          property()    type() 
chr()           frozenset()   list()         range()       vars() 
classmethod()   getattr()     locals()       repr()        zip() 
compile()       globals()     map()          reversed()    __import__() 
complex()       hasattr()     max()          round() 
delattr()       hash()        memoryview()   set()
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="基础" scheme="http://example.com/categories/python/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="内置函数" scheme="http://example.com/tags/%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>python | 50条有趣的python一行代码</title>
    <link href="http://example.com/2021/10/16/50%E6%9D%A1%E6%9C%89%E8%B6%A3%E7%9A%84python%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/"/>
    <id>http://example.com/2021/10/16/50%E6%9D%A1%E6%9C%89%E8%B6%A3%E7%9A%84python%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/</id>
    <published>2021-10-16T08:26:03.000Z</published>
    <updated>2021-10-16T08:34:35.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="50条有趣的python一行代码！"><a href="#50条有趣的python一行代码！" class="headerlink" title="50条有趣的python一行代码！"></a>50条有趣的python一行代码！</h1><p><a href="https://mp.weixin.qq.com/s/LVEPw7QAPqfLvi151aproQ">50条有趣的python一行代码！</a></p><span id="more"></span><p>1.字母异位词</p><pre><code>from collections import Counter# Counter: Elements are stored as dictionary keys and their counts are stored as dictionary values.s1 = &#39;below&#39;s2 = &#39;elbow&#39;print(Counter(s1)) # Counter(&#123;&#39;b&#39;: 1, &#39;e&#39;: 1, &#39;l&#39;: 1, &#39;o&#39;: 1, &#39;w&#39;: 1&#125;)print(&#39;anagram&#39;) if Counter(s1) == Counter(s2) else print(&#39;not an anagram&#39;)</code></pre><p>2.二进制转十进制</p><pre><code>decimal = int(&quot;1010&quot;, 2)print(decimal)</code></pre><p>3.将字符串转换为小写</p><pre><code>print(&quot;Hi my name is XiaoF&quot;.lower())# &#39;hi my name is xiaof&#39;print(&quot;Hi my name is XiaoF&quot;.casefold())# &#39;hi my name is xiaof&#39;</code></pre><p>4.将字符串转换为大写</p><pre><code>print(&quot;hi my name is XiaoF&quot;.upper())# &#39;HI MY NAME IS XIAOF&#39;</code></pre><p>5.将字符串转换为字节</p><pre><code>print(&quot;convert string to bytes using encode method&quot;.encode())print(type(&quot;convert string to bytes using encode method&quot;.encode()))b&#39;convert string to bytes using encode method&#39;</code></pre><p>6.拷贝文件</p><pre><code>import shutilshutil.copyfile(&#39;source.txt&#39;, &#39;dest.txt&#39;)</code></pre><p>7.快速排序</p><pre><code>qsort = lambda l: l if len(l) &lt;= 1 else qsort([x for x in l[1:] if x &lt; l[0]]) + [l[0]] + qsort([x for x in l[1:] if x &gt;= l[0]])print(qsort([1]))print(qsort([17, 29, 11, 97, 103, 5]))</code></pre><p>8.n个连续数的和</p><pre><code>n = 10print(sum(range(0, n+1)))# 55</code></pre><p>9.交换两个变量的值</p><pre><code>a = 1b = 2print(a, b)a,b = b,aprint(a, b)</code></pre><p>10.斐波纳契数列</p><pre><code>fib = lambda x: x if x&lt;=1 else fib(x-1) + fib(x-2)def fib(x):    if x &lt;= 1:        return x    else:        return fib(x-1) + fib(x-2)print(fib(20))# 6765</code></pre><p>11.将嵌套列表合并为一个列表</p><pre><code>main_list = [[0, 1, 2], [11, 12, 13], [52, 53, 54]]result = [item for sublist in main_list for item in sublist]print(result)# [0, 1, 2, 11, 12, 13, 52, 53, 54]</code></pre><p>12.运行一个HTTP服务器</p><pre><code>python3 -m http.server 8000python2 -m SimpleHTTPServer</code></pre><p>13.反转列表</p><pre><code>numbers = [0, 1, 2, 11, 12, 13, 52, 53, 54]print(numbers[::-1])# [54, 53, 52, 13, 12, 11, 2, 1, 0]</code></pre><p>14.阶乘</p><pre><code>import mathfact_5 = math.factorial(5)print(fact_5)# 120</code></pre><p>15.在列表推导式中使用for和if</p><pre><code>even_list = [number for number in [1, 2, 3, 4] if number % 2 == 0]print(even_list)# [2, 4]</code></pre><p>16.列表中最长的字符串</p><pre><code>words = [&#39;This&#39;, &#39;is&#39;, &#39;a&#39;, &#39;list&#39;, &#39;of&#39;, &#39;words&#39;]result = max(words, key=len)print(result)# &#39;words&#39;</code></pre><p>17.列表推导式</p><pre><code>li = [num for num in range(0, 10)]print(li)# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre><p>18.集合推导式</p><pre><code>num_set = &#123;num for num in range(0, 10)&#125;print(num_set)# &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;</code></pre><p>19.字典推导式</p><pre><code>dict_numbers = &#123;x: x*x for x in range(1, 5)&#125;print(dict_numbers)# &#123;1: 1, 2: 4, 3: 9, 4: 16&#125;</code></pre><p>20.if-else</p><pre><code>print(&quot;even&quot;) if 4 % 2==0 else print(&quot;odd&quot;)</code></pre><p>21.无限循环</p><pre><code>while 1:0</code></pre><p>22.检查数据类型</p><pre><code>print(isinstance(2, int))# Trueprint(isinstance(&quot;allwin&quot;, str))# Trueprint(isinstance([3, 4, 1997], list))# True</code></pre><p>23.While循环</p><pre><code>a = 5while a &gt; 0:    a = a - 1print(a)# 0</code></pre><p>24.使用print语句写入文件</p><pre><code>print(&quot;Hello, World!&quot;, file=open(&#39;file.txt&#39;, &#39;w&#39;))# 既可打印出信息，还能将信息保存文件。</code></pre><p>25.计算一个字符在字符串中出现的频率</p><pre><code>print(&quot;umbrella&quot;.count(&#39;l&#39;))# 2</code></pre><p>26.合并列表</p><pre><code>list1 = [1, 2, 4]list2 = [&#39;XiaoF&#39;]list1.extend(list2)print(list1)# [1, 2, 4, &#39;XiaoF&#39;]</code></pre><p>27.合并字典</p><pre><code>dict1 = &#123;&#39;name&#39;: &#39;weiwei&#39;, &#39;age&#39;: 23&#125;dict2 = &#123;&#39;city&#39;: &#39;Beijing&#39;&#125;dict1.update(dict2)print(dict1)# &#123;&#39;name&#39;: &#39;weiwei&#39;, &#39;age&#39;: 23, &#39;city&#39;: &#39;Beijing&#39;&#125;</code></pre><p>28.合并集合</p><pre><code>set1 = &#123;0, 1, 2&#125;set2 = &#123;11, 12, 13&#125;set1.update(set2)print(set1)# &#123;0, 1, 2, 11, 12, 13&#125;</code></pre><p>29.时间戳</p><pre><code>import timeprint(time.time())</code></pre><p>30.列表中出现次数最多的元素</p><pre><code>test_list = [9, 4, 5, 4, 4, 5, 9, 5, 4]most_frequent_element = max(set(test_list), key=test_list.count)print(most_frequent_element)# 4</code></pre><p>31.嵌套列表</p><pre><code>numbers = [[num] for num in range(10)]print(numbers)# [[0], [1], [2], [3], [4], [5], [6], [7], [8], [9]]</code></pre><p>32.八进制转十进制</p><pre><code>print(int(&#39;30&#39;, 8))# 24</code></pre><p>33.将键值对转换为字典</p><pre><code>result = dict(name=&#39;XiaoF&#39;, age=23)print(result)# &#123;&#39;name&#39;: &#39;XiaoF&#39;, &#39;age&#39;: 23&#125;</code></pre><p>34.求商和余数</p><pre><code>quotient, remainder = divmod(4, 5)print(quotient, remainder)# 0 4# divmod()函数返回当参数1除以参数2时，包含商和余数的元组。</code></pre><p>35.删除列表中的重复项</p><pre><code>print(list(set([4, 4, 5, 5, 6])))# [4, 5, 6]</code></pre><p>36.按升序排序列表</p><pre><code>print(sorted([5, 2, 9, 1]))# [1, 2, 5, 9]</code></pre><p>37.按降序排序列表</p><pre><code>print(sorted([5, 2, 9, 1], reverse=True))# [9, 5, 2, 1]</code></pre><p>38.获取小写字母表</p><pre><code>import stringprint(string.ascii_lowercase)print(type(string.ascii_lowercase))# abcdefghijklmnopqrstuvwxyz</code></pre><p>39.获取大写字母表</p><pre><code>import stringprint(string.ascii_uppercase)# ABCDEFGHIJKLMNOPQRSTUVWXYZ</code></pre><p>40.获取0到9字符串</p><pre><code>import stringprint(string.digits)# 0123456789</code></pre><p>41.十六进制转十进制</p><pre><code>print(int(&#39;da9&#39;, 16))# 3497</code></pre><p>42.日期时间</p><pre><code>import timeprint(time.ctime())# Thu Aug 13 20:00:00 2021</code></pre><p>43.将列表中的字符串转换为整数</p><pre><code>print(list(map(int, [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;])))# [1, 2, 3]</code></pre><p>44.用键对字典进行排序</p><pre><code>d = &#123;&#39;one&#39;: 1, &#39;four&#39;: 4, &#39;eight&#39;: 8&#125;result = &#123;key: d[key] for key in sorted(d.keys())&#125;print(result)# &#123;&#39;eight&#39;: 8, &#39;four&#39;: 4, &#39;one&#39;: 1&#125;</code></pre><p>45.用键值对字典进行排序</p><pre><code>x = &#123;1: 2, 3: 4, 4: 3, 2: 1, 0: 0&#125;result = &#123;k: v for k, v in sorted(x.items(), key=lambda item: item[0])&#125;print(result)# &#123;0: 0, 2: 1, 1: 2, 4: 3, 3: 4&#125;</code></pre><p>46.列表旋转</p><pre><code>li = [1, 2, 3, 4, 5]# li[n:] + li[:n], 右变左print(li[2:] + li[:2])# [3, 4, 5, 1, 2]# li[-n:] + li[:-n], 左变右print(li[-1:] + li[:-1])# [5, 1, 2, 3, 4]</code></pre><p>47.将字符串中的数字移除</p><pre><code>message = &#39;&#39;.join(list(filter(lambda x: x.isalpha(), &#39;abc123def4fg56vcg2&#39;)))print(message)# abcdeffgvcg</code></pre><p>48.矩阵变换</p><pre><code>old_list = [[1, 2, 3], [3, 4, 6], [5, 6, 7]]result = list(list(x) for x in zip(*old_list))print(result)# [[1, 3, 5], [2, 4, 6], [3, 6, 7]]</code></pre><p>49.列表过滤</p><pre><code>result = list(filter(lambda x: x % 2 == 0, [1, 2, 3, 4, 5, 6]))print(result)# [2, 4, 6]</code></pre><p>50.解包</p><pre><code>a, *b, c = [1, 2, 3, 4, 5]print(a)  # 1print(b)  # [2, 3, 4]print(c)  # 5</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;50条有趣的python一行代码！&quot;&gt;&lt;a href=&quot;#50条有趣的python一行代码！&quot; class=&quot;headerlink&quot; title=&quot;50条有趣的python一行代码！&quot;&gt;&lt;/a&gt;50条有趣的python一行代码！&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/LVEPw7QAPqfLvi151aproQ&quot;&gt;50条有趣的python一行代码！&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="基础" scheme="http://example.com/categories/python/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>OS | 什么是操作系统</title>
    <link href="http://example.com/2021/10/14/%E4%BB%80%E4%B9%88%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2021/10/14/%E4%BB%80%E4%B9%88%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-10-15T03:10:43.000Z</published>
    <updated>2021-10-15T03:15:21.624Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统?"></a>什么是操作系统?</h1><p>“操作系统（operating system，简称OS）是管理计算机硬件与软件资源的计算机程序,是硬件软件之间的一座桥梁。</p><p><img src="/2021/10/14/%E4%BB%80%E4%B9%88%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.JPG"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是操作系统&quot;&gt;&lt;a href=&quot;#什么是操作系统&quot; class=&quot;headerlink&quot; title=&quot;什么是操作系统?&quot;&gt;&lt;/a&gt;什么是操作系统?&lt;/h1&gt;&lt;p&gt;“操作系统（operating system，简称OS）是管理计算机硬件与软件资源的计算机程序,</summary>
      
    
    
    
    <category term="OS" scheme="http://example.com/categories/OS/"/>
    
    
    <category term="OS" scheme="http://example.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Chicken Soup for the Soul | 生活没有想象的那么糟</title>
    <link href="http://example.com/2021/10/14/%E7%94%9F%E6%B4%BB%E6%B2%A1%E6%9C%89%E6%83%B3%E8%B1%A1%E7%9A%84%E9%82%A3%E4%B9%88%E7%B3%9F/"/>
    <id>http://example.com/2021/10/14/%E7%94%9F%E6%B4%BB%E6%B2%A1%E6%9C%89%E6%83%B3%E8%B1%A1%E7%9A%84%E9%82%A3%E4%B9%88%E7%B3%9F/</id>
    <published>2021-10-14T12:42:51.000Z</published>
    <updated>2021-10-14T12:46:03.663Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生活没有想象的那么糟"><a href="#生活没有想象的那么糟" class="headerlink" title="生活没有想象的那么糟"></a>生活没有想象的那么糟</h1><p>生活可能不像你想象的那么好，但是也不会像你想象的那么糟，人的脆弱和坚强，都超乎了自己的想象，有时候，可能脆弱的一句话就泪流满面，有时候你发现你自己咬着牙，已经走过很长的路。</p><p>2021/10/14</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;生活没有想象的那么糟&quot;&gt;&lt;a href=&quot;#生活没有想象的那么糟&quot; class=&quot;headerlink&quot; title=&quot;生活没有想象的那么糟&quot;&gt;&lt;/a&gt;生活没有想象的那么糟&lt;/h1&gt;&lt;p&gt;生活可能不像你想象的那么好，但是也不会像你想象的那么糟，人的脆弱和坚强，都超</summary>
      
    
    
    
    <category term="Chicken Soup for the Soul" scheme="http://example.com/categories/Chicken-Soup-for-the-Soul/"/>
    
    
    <category term="Chicken Soup for the Soul" scheme="http://example.com/tags/Chicken-Soup-for-the-Soul/"/>
    
  </entry>
  
  <entry>
    <title>MySQL | MySQL常见的表操作语句</title>
    <link href="http://example.com/2021/10/14/MySQL%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A1%A8%E6%93%8D%E4%BD%9C%E8%AF%AD%E5%8F%A5/"/>
    <id>http://example.com/2021/10/14/MySQL%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A1%A8%E6%93%8D%E4%BD%9C%E8%AF%AD%E5%8F%A5/</id>
    <published>2021-10-14T12:13:09.000Z</published>
    <updated>2021-10-16T12:26:39.992Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL常见的表操作语句"><a href="#MySQL常见的表操作语句" class="headerlink" title="MySQL常见的表操作语句"></a>MySQL常见的表操作语句</h1><p>1.表的创建</p><pre><code>create table table_name(id int auto_increment primary key not null,name varchar(11) not null);</code></pre><p>2.增加记录</p><pre><code>insert into table_name values()insert into table_name values(),(),()insert into table_name() values()insert into table_name() values(),(),()</code></pre><p>3.修改记录</p><pre><code>update table_name set attr=val where...</code></pre><p>4.删除记录</p><pre><code>delete from table_name where...</code></pre><p>5.表查询</p><pre><code>条件：select * from table_name where...聚合：select count(*)|min()|max()|avg() from table_name分组：select gender,count(*) from table_name group by gender having....排序：select * from table_name order by...分页：select * from table_name limit start,count</code></pre><p>连接查询：<a href="https://blog.csdn.net/zjt980452483/article/details/82945663">点击此处，查看更多关于连接查询！！！</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL常见的表操作语句&quot;&gt;&lt;a href=&quot;#MySQL常见的表操作语句&quot; class=&quot;headerlink&quot; title=&quot;MySQL常见的表操作语句&quot;&gt;&lt;/a&gt;MySQL常见的表操作语句&lt;/h1&gt;&lt;p&gt;1.表的创建&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;crea</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Chicken Soup for the Soul | 罗曼罗兰英雄主义</title>
    <link href="http://example.com/2021/10/12/%E7%BD%97%E6%9B%BC%E7%BD%97%E5%85%B0%E8%8B%B1%E9%9B%84%E4%B8%BB%E4%B9%89/"/>
    <id>http://example.com/2021/10/12/%E7%BD%97%E6%9B%BC%E7%BD%97%E5%85%B0%E8%8B%B1%E9%9B%84%E4%B8%BB%E4%B9%89/</id>
    <published>2021-10-13T04:09:41.000Z</published>
    <updated>2021-10-13T04:14:21.602Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chicken-Soup"><a href="#Chicken-Soup" class="headerlink" title="Chicken Soup"></a>Chicken Soup</h1><p>人生当中成功只是一时的，失败却是主旋律，但是如何面对失败，却把人分成了不同的样子，有的人会被失败击垮，有的人能够不断地爬起来继续向前，我想真正的成熟，并不是追求完美，而是直面自己的缺憾，这才是生活的本质。罗曼罗兰说过：这个世上只有一种真正的英雄注意，那就是认清生活的真相，并且依然热爱它。</p><p>2021/10/13</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Chicken-Soup&quot;&gt;&lt;a href=&quot;#Chicken-Soup&quot; class=&quot;headerlink&quot; title=&quot;Chicken Soup&quot;&gt;&lt;/a&gt;Chicken Soup&lt;/h1&gt;&lt;p&gt;人生当中成功只是一时的，失败却是主旋律，但是如何面对失败，却</summary>
      
    
    
    
    <category term="Chicken Soup for the Soul" scheme="http://example.com/categories/Chicken-Soup-for-the-Soul/"/>
    
    
    <category term="Chicken Soup for the Soul" scheme="http://example.com/tags/Chicken-Soup-for-the-Soul/"/>
    
  </entry>
  
  <entry>
    <title>matplotlib | 绘制几个模型某性能指标在某个范围内的大小比较图</title>
    <link href="http://example.com/2021/10/12/%E7%BB%98%E5%88%B6%E5%87%A0%E4%B8%AA%E6%A8%A1%E5%9E%8B%E6%9F%90%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E5%9C%A8%E6%9F%90%E4%B8%AA%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%AF%94%E8%BE%83%E5%9B%BE/"/>
    <id>http://example.com/2021/10/12/%E7%BB%98%E5%88%B6%E5%87%A0%E4%B8%AA%E6%A8%A1%E5%9E%8B%E6%9F%90%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E5%9C%A8%E6%9F%90%E4%B8%AA%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%AF%94%E8%BE%83%E5%9B%BE/</id>
    <published>2021-10-12T09:22:18.000Z</published>
    <updated>2021-10-12T09:37:33.057Z</updated>
    
    <content type="html"><![CDATA[<h1 id="绘制几个模型某性能指标在某个范围内的大小比较图"><a href="#绘制几个模型某性能指标在某个范围内的大小比较图" class="headerlink" title="绘制几个模型某性能指标在某个范围内的大小比较图"></a>绘制几个模型某性能指标在某个范围内的大小比较图</h1><p>我们在做深度学习实验时，很多时候会需要对几个模型的性能进行对比并进行可视化，从而清楚地展示模型性能的大小关系。</p><span id="more"></span><p>下面以几个模型的精确度大小比较为例：</p><p><strong>代码：</strong></p><pre><code>import matplotlib.pyplot as pltCNNLSTM_valence_acc = [0.6885742, 0.690625, 0.69453126, 0.69277346, 0.69003904, 0.6965332, 0.6917969, 0.68652344, 0.6916992, 0.69140625, 0.6933594, 0.6972656, 0.69277346, 0.6941406, 0.69501954, 0.69257814, 0.6929687, 0.69208986, 0.6905273, 0.6930664, 0.69384766, 0.6856445, 0.6958984, 0.6929687, 0.693457, 0.69501954, 0.6893555, 0.7, 0.6904297, 0.69628906, 0.6921875, 0.6910156, 0.6988281, 0.69492185, 0.69541013, 0.69443357, 0.69257814, 0.6955078, 0.6942383, 0.69628906, 0.6933594, 0.6976563, 0.69267577, 0.6948242, 0.69277346, 0.6964844, 0.6923828, 0.6959961, 0.6993164, 0.6935547]CNN3Conv_valence_acc = [0.53, 0.57, 0.52, 0.55, 0.57, 0.53, 0.54, 0.55, 0.5, 0.49, 0.53, 0.45, 0.55, 0.56, 0.54, 0.49, 0.54, 0.55, 0.57, 0.52, 0.49, 0.54, 0.5, 0.49, 0.56, 0.52, 0.52, 0.55, 0.55, 0.57, 0.5, 0.5, 0.52, 0.55, 0.54, 0.57, 0.53, 0.55, 0.51, 0.54, 0.54, 0.53, 0.56, 0.52, 0.53, 0.53, 0.54, 0.53, 0.5, 0.54]CNN5Conv_valence_acc = [0.69, 0.6699999999999999, 0.6799999999999999, 0.66, 0.54, 0.57, 0.6699999999999999, 0.6699999999999999, 0.61, 0.61, 0.63, 0.62, 0.63, 0.62, 0.6699999999999999, 0.62, 0.66, 0.6699999999999999, 0.62, 0.58, 0.61, 0.66, 0.61, 0.65, 0.63, 0.62, 0.62, 0.59, 0.62, 0.63, 0.62, 0.63, 0.62, 0.62, 0.63, 0.61, 0.62, 0.62, 0.6699999999999999, 0.63, 0.64, 0.64, 0.65, 0.6699999999999999, 0.62, 0.69, 0.58, 0.59, 0.63, 0.61]print(len(CNNLSTM_valence_acc))print(len(CNN3Conv_valence_acc))print(len(CNN5Conv_valence_acc))x = range(len(CNN5Conv_valence_acc))plt.plot(x, CNNLSTM_valence_acc, label=u&#39;CNN-LSTM&#39;)plt.plot(x, CNN3Conv_valence_acc, label=u&#39;CNN3Conv&#39;)plt.plot(x, CNN5Conv_valence_acc, label=u&#39;CNN5Conv&#39;)plt.legend()plt.xlabel(u&quot;epoch&quot;)plt.ylabel(u&quot;accuracy&quot;)plt.show()</code></pre><p><strong>效果图：</strong><br><img src="/2021/10/12/%E7%BB%98%E5%88%B6%E5%87%A0%E4%B8%AA%E6%A8%A1%E5%9E%8B%E6%9F%90%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E5%9C%A8%E6%9F%90%E4%B8%AA%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%AF%94%E8%BE%83%E5%9B%BE/myplot.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;绘制几个模型某性能指标在某个范围内的大小比较图&quot;&gt;&lt;a href=&quot;#绘制几个模型某性能指标在某个范围内的大小比较图&quot; class=&quot;headerlink&quot; title=&quot;绘制几个模型某性能指标在某个范围内的大小比较图&quot;&gt;&lt;/a&gt;绘制几个模型某性能指标在某个范围内的大小比较图&lt;/h1&gt;&lt;p&gt;我们在做深度学习实验时，很多时候会需要对几个模型的性能进行对比并进行可视化，从而清楚地展示模型性能的大小关系。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="matplotlib" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/matplotlib/"/>
    
    
    <category term="matplotlib" scheme="http://example.com/tags/matplotlib/"/>
    
  </entry>
  
  <entry>
    <title>matplotlib | recorded EEG visualization</title>
    <link href="http://example.com/2021/10/12/recorded-EEG-visualization/"/>
    <id>http://example.com/2021/10/12/recorded-EEG-visualization/</id>
    <published>2021-10-12T09:00:42.000Z</published>
    <updated>2021-10-12T09:13:28.480Z</updated>
    
    <content type="html"><![CDATA[<h1 id="recorded-EEG-visualization"><a href="#recorded-EEG-visualization" class="headerlink" title="recorded EEG visualization"></a>recorded EEG visualization</h1><p>在做脑电（EEG）的相关研究时,通常我们需要使用公开的脑电数据集合，公开数据集包含了以及采集好的脑电数据。<br>我们可以使用python的第三方库matplotlib将数据集中的脑电数据进行可视化。</p><span id="more"></span><p>下面以绘制8个通道的脑电数据为例对脑电数据进行可视化：<br>注意：实例中使用公开数据集DEAP,详细信息可参考<a href="http://www.eecs.qmul.ac.uk/mmv/datasets/deap/">DEAP 官网</a></p><p><strong>示例代码：</strong></p><pre><code>import osimport globimport pickleimport matplotlib.pyplot as plt# 参数设置window_size = 1sampling_rate = 500# 获取数据文件列表并划分(训练文件/测试文件)data_dir = &quot;data_preprocessed_python/&quot;file_list = glob.glob(os.path.join(data_dir, &quot;*&quot;))  # 整个数据集包含32个subject的样本数据print(&quot;len(file_list):&quot;, len(file_list))def get_data_and_label(file_list):    &quot;&quot;&quot;    获得固定窗口大小的数据和对应的标签    Arrray name         Array shape         Array contents    ---------------------------------------------------------------------------------------------    data                40 x 40 x 8064      video/trial x channel x data    labels              40 x 4              videl/trial x label(valence,arousal,dominance,liking)    ---------------------------------------------------------------------------------------------    &quot;&quot;&quot;    data = []    valence_labels = []    arousal_labels = []    for file in file_list:        x = pickle.load(open(file, &#39;rb&#39;), encoding=&#39;latin1&#39;)  # type(x):dict &#123;&#39;labels&#39;:array(),&#39;data&#39;:array()&#125;        labels = x[&#39;labels&#39;]        valence_labels.extend(labels[:, 0])        arousal_labels.extend(labels[:, 1])        dat = x[&#39;data&#39;]        data.extend(dat[:, :, :window_size * sampling_rate])    return dataprint(&quot;开始获取脑电波数据...&quot;)data = get_data_and_label(file_list)print(&quot;脑电波数据已获取，开始绘制脑电波...&quot;)x = range(sampling_rate)fig, ax = plt.subplots(3, 3)ax[0][0].plot(x, list(data[0][0]))ax[0][0].set_title(&#39;Fp1&#39;)ax[0][1].plot(x, list(data[0][1]))ax[0][1].set_title(&#39;AF3&#39;)ax[0][2].plot(x, list(data[0][2]))ax[0][2].set_title(&#39;F3&#39;)ax[1][0].plot(x, list(data[0][3]))ax[1][0].set_title(&#39;F7&#39;)ax[1][1].plot(x, list(data[0][4]))ax[1][1].set_title(&#39;FC5&#39;)ax[1][2].plot(x, list(data[0][5]))ax[1][2].set_title(&#39;FC1&#39;)ax[2][0].plot(x, list(data[0][6]))ax[2][0].set_title(&#39;C3&#39;)ax[2][1].plot(x, list(data[0][7]))ax[2][1].set_title(&#39;T7&#39;)ax[2][2].plot(x, list(data[0][8]))ax[2][2].set_title(&#39;CP5&#39;)plt.show()print(&quot;脑电波绘制完成！&quot;)</code></pre><p><strong>绘制的脑电波：</strong></p><p><img src="/2021/10/12/recorded-EEG-visualization/500_brainwave.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;recorded-EEG-visualization&quot;&gt;&lt;a href=&quot;#recorded-EEG-visualization&quot; class=&quot;headerlink&quot; title=&quot;recorded EEG visualization&quot;&gt;&lt;/a&gt;recorded EEG visualization&lt;/h1&gt;&lt;p&gt;在做脑电（EEG）的相关研究时,通常我们需要使用公开的脑电数据集合，公开数据集包含了以及采集好的脑电数据。&lt;br&gt;我们可以使用python的第三方库matplotlib将数据集中的脑电数据进行可视化。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="matplotlib" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/matplotlib/"/>
    
    
    <category term="matplotlib" scheme="http://example.com/tags/matplotlib/"/>
    
  </entry>
  
  <entry>
    <title>GPU | CPU和GPU的设计区别</title>
    <link href="http://example.com/2021/10/11/CPU%E5%92%8CGPU%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2021/10/11/CPU%E5%92%8CGPU%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8C%BA%E5%88%AB/</id>
    <published>2021-10-11T09:06:56.000Z</published>
    <updated>2021-10-11T09:08:40.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CPU和GPU的设计区别"><a href="#CPU和GPU的设计区别" class="headerlink" title="CPU和GPU的设计区别"></a>CPU和GPU的设计区别</h1><p><a href="https://www.cnblogs.com/biglucky/p/4223565.html">点击链接查看CPU和GPU的设计区别！！！</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CPU和GPU的设计区别&quot;&gt;&lt;a href=&quot;#CPU和GPU的设计区别&quot; class=&quot;headerlink&quot; title=&quot;CPU和GPU的设计区别&quot;&gt;&lt;/a&gt;CPU和GPU的设计区别&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.c</summary>
      
    
    
    
    <category term="深度学习" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="GPU" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/GPU/"/>
    
    
    <category term="GPU" scheme="http://example.com/tags/GPU/"/>
    
    <category term="CPU" scheme="http://example.com/tags/CPU/"/>
    
  </entry>
  
  <entry>
    <title>GPU | GPU利用率低？</title>
    <link href="http://example.com/2021/10/09/GPU%E5%88%A9%E7%94%A8%E7%8E%87%E4%BD%8E%EF%BC%9F/"/>
    <id>http://example.com/2021/10/09/GPU%E5%88%A9%E7%94%A8%E7%8E%87%E4%BD%8E%EF%BC%9F/</id>
    <published>2021-10-10T07:49:06.000Z</published>
    <updated>2021-10-10T08:02:49.888Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GPU利用率低？"><a href="#GPU利用率低？" class="headerlink" title="GPU利用率低？"></a>GPU利用率低？</h1><p><a href="https://blog.csdn.net/qq_32998593/article/details/92849585">GPU利用率低？</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GPU利用率低？&quot;&gt;&lt;a href=&quot;#GPU利用率低？&quot; class=&quot;headerlink&quot; title=&quot;GPU利用率低？&quot;&gt;&lt;/a&gt;GPU利用率低？&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_32998593/art</summary>
      
    
    
    
    <category term="深度学习" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="GPU" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/GPU/"/>
    
    
    <category term="GPU" scheme="http://example.com/tags/GPU/"/>
    
  </entry>
  
  <entry>
    <title>GPU | NVIDIAGeForceGTX1650驱动安装</title>
    <link href="http://example.com/2021/10/09/NVIDIAGeForceGTX1650%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85/"/>
    <id>http://example.com/2021/10/09/NVIDIAGeForceGTX1650%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85/</id>
    <published>2021-10-10T03:03:51.000Z</published>
    <updated>2021-10-10T03:21:27.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NVIDIAGeForceGTX1650驱动安装"><a href="#NVIDIAGeForceGTX1650驱动安装" class="headerlink" title="NVIDIAGeForceGTX1650驱动安装"></a>NVIDIAGeForceGTX1650驱动安装</h1><p>当我们想使用GPU（可以用来加速）来跑深度学习代码前，需要进行显卡驱动安装，我的显卡是NVIDIA GeForce GTX 1650。</p><p><strong>需要安装：</strong><br>1.Cuda<br>2.CuDNN<br><strong>下载地址：</strong><br><a href="https://developer.nvidia.com/cuda-toolkit">Cuda</a><br><a href=" https://developer.nvidia.com/cudnn">CuDNN</a><br><strong>我的显卡使用的Cuda、CuDNN版本：</strong><br>1.Cuda-10.1<br>2.CuDNN-7.6<br>3.Tensorflow-gpu-1.15.0(可选，在这里我是想用来加速Tensorflow代码的训练)</p><p><strong>注意：深度学习框架、python、Cuda、CuDNN版本的对应以及Cuda与自己显卡的兼容性</strong><br><a href="https://blog.csdn.net/s_hikki/article/details/106107778">NVIDIA GeForce GTX 1650驱动安装</a><br><a href="https://tensorflow.google.cn/install/source_windows#configuration_options">版本对应参考资料</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;NVIDIAGeForceGTX1650驱动安装&quot;&gt;&lt;a href=&quot;#NVIDIAGeForceGTX1650驱动安装&quot; class=&quot;headerlink&quot; title=&quot;NVIDIAGeForceGTX1650驱动安装&quot;&gt;&lt;/a&gt;NVIDIAGeForceG</summary>
      
    
    
    
    <category term="深度学习" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="GPU" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/GPU/"/>
    
    
    <category term="深度学习" scheme="http://example.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="GPU" scheme="http://example.com/tags/GPU/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 单词规律</title>
    <link href="http://example.com/2021/09/08/%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B/"/>
    <id>http://example.com/2021/09/08/%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B/</id>
    <published>2021-09-08T18:55:10.000Z</published>
    <updated>2021-09-08T02:58:26.337Z</updated>
    
    <content type="html"><![CDATA[<h1 id="290-单词规律"><a href="#290-单词规律" class="headerlink" title="290.单词规律"></a>290.单词规律</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。<br>这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。</p><p>示例1:<br>输入: pattern = “abba”, str = “dog cat cat dog”<br>输出: true</p><span id="more"></span><p><a href="https://leetcode-cn.com/problems/word-pattern/">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.哈希表<br>在本题中，我们需要判断字符与字符串之间是否恰好一一对应。即任意一个字符都对应着唯一的字符串，任意一个字符串也只被唯一的一个字符对应。在集合论中，这种关系被称为「双射」。<br>想要解决本题，我们可以利用哈希表记录每一个字符对应的字符串，以及每一个字符串对应的字符。然后我们枚举每一对字符与字符串的配对过程，不断更新哈希表，如果发生了冲突，则说明给定的输入不满足双射关系。<br>在实际代码中，我们枚举 pattern 中的每一个字符，利用双指针来均摊线性地找到该字符在 str 中对应的字符串。每次确定一个字符与字符串的组合，我们就检查是否出现冲突，最后我们再检查两字符串是否比较完毕即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):    def wordPattern(self, pattern, s):        &quot;&quot;&quot;        :type pattern: str        :type s: str        :rtype: bool        &quot;&quot;&quot;        word2ch = dict()        ch2word = dict()        words = s.split()        if len(pattern) != len(words):            return False        for ch, word in zip(pattern, words):            if (word in word2ch and word2ch[word] != ch) or (ch in ch2word and ch2word[ch] != word):                return False            word2ch[word] = ch            ch2word[ch] = word        return True    def wordPattern(self, pattern, s):        dct = dict()        s = s.split(&#39; &#39;)        if len(s) != len(pattern):  # 两个字符串长度不相同，返回False            return False        for i in range(len(pattern)):            if pattern[i] not in dct:  # 如果pattern[i]不在字典中，此时要加入pattern[i]                if s[i] not in dct.values():  # 如果s[i]还未存在，则加入新的映射                    dct[pattern[i]] = s[i]                else:                    return False  # 但是如果与dct[pattern[i]]对应的s[i]已经存在字典的值中，说明不是唯一映射            else:                if dct[pattern[i]] != s[i]:  # 如果pattern[i]在字典中，但是dct[pattern[i]]的值不等于s[i]，说明已存在其他映射                    return False        return Trueif __name__ == &#39;__main__&#39;:    slt = Solution()    res = slt.wordPattern1(&quot;abba&quot;, &quot;dog cat cat dog&quot;)    print(res)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;290-单词规律&quot;&gt;&lt;a href=&quot;#290-单词规律&quot; class=&quot;headerlink&quot; title=&quot;290.单词规律&quot;&gt;&lt;/a&gt;290.单词规律&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。&lt;br&gt;这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。&lt;/p&gt;
&lt;p&gt;示例1:&lt;br&gt;输入: pattern = “abba”, str = “dog cat cat dog”&lt;br&gt;输出: true&lt;/p&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="哈希表" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 在系统中查找重复文件</title>
    <link href="http://example.com/2021/09/05/%E5%9C%A8%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%9F%A5%E6%89%BE%E9%87%8D%E5%A4%8D%E6%96%87%E4%BB%B6/"/>
    <id>http://example.com/2021/09/05/%E5%9C%A8%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%9F%A5%E6%89%BE%E9%87%8D%E5%A4%8D%E6%96%87%E4%BB%B6/</id>
    <published>2021-09-06T00:48:33.000Z</published>
    <updated>2021-09-07T10:00:23.629Z</updated>
    
    <content type="html"><![CDATA[<h1 id="609-在系统中查找重复文件"><a href="#609-在系统中查找重复文件" class="headerlink" title="609.在系统中查找重复文件"></a>609.在系统中查找重复文件</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个目录信息列表，包括目录路径，以及该目录中的所有包含内容的文件，您需要找到文件系统中的所有重复文件组的路径。一组重复的文件至少包括二个具有完全相同内容的文件。<br>输入列表中的单个目录信息字符串的格式如下：<br>“root/d1/d2/…/dm f1.txt(f1_content) f2.txt(f2_content) … fn.txt(fn_content)”<br>这意味着有 n 个文件（f1.txt, f2.txt … fn.txt 的内容分别是 f1_content, f2_content … fn_content）在目录 root/d1/d2/…/dm 下。注意：n&gt;=1 且 m&gt;=0。如果 m=0，则表示该目录是根目录。<br>该输出是重复文件路径组的列表。对于每个组，它包含具有相同内容的文件的所有文件路径。文件路径是具有下列格式的字符串：<br>“directory_path/file_name.txt”</p><span id="more"></span><p>示例 1：<br>输入：<br>[“root/a 1.txt(abcd) 2.txt(efgh)”, “root/c 3.txt(abcd)”, “root/c/d 4.txt(efgh)”, “root 4.txt(efgh)”]<br>输出：<br>[[“root/a/2.txt”,”root/c/d/4.txt”,”root/4.txt”],[“root/a/1.txt”,”root/c/3.txt”]]</p><p><a href="https://leetcode-cn.com/problems/find-duplicate-file-in-system">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.哈希表<br>首先我们通过字符串操作获取目录路径、文件名和文件内容。我们使用哈希映射（HashMap）来寻找重复文件，哈希映射中的键（key）是文件内容，值（value）是存储路径和文件名的列表。<br>我们遍历每一个文件，并把它加入哈希映射中。在这之后，我们遍历哈希映射，如果一个键对应的值列表的长度大于 1，说明我们找到了重复文件，可以把这个列表加入到答案中。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):    def findDuplicate(self, paths):        &quot;&quot;&quot;        :type paths: List[str]        :rtype: List[List[str]]        &quot;&quot;&quot;        map = &#123;&#125;        for path in paths:            values = path.split(&quot; &quot;)            for i in range(1, len(values)):                name_cont = values[i].split(&#39;(&#39;)[-1]                name_cont = name_cont.replace(&#39;)&#39;, &#39;&#39;)                value_list = map.get(name_cont, [])                value_list.append(values[0] + &#39;/&#39; + values[i].split(&#39;(&#39;)[0])                map[name_cont] = value_list        res = []        for key in map.keys():            if len(map.get(key)) &gt; 1:                res.append(map.get(key))        return resif __name__ == &#39;__main__&#39;:    slt = Solution()    result = slt.findDuplicate([&quot;root/a 1.txt(abcd) 2.txt(efgh)&quot;, &quot;root/c 3.txt(abcd)&quot;, &quot;root/c/d 4.txt(efgh)&quot;, &quot;root 4.txt(efgh)&quot;])    print(result)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;609-在系统中查找重复文件&quot;&gt;&lt;a href=&quot;#609-在系统中查找重复文件&quot; class=&quot;headerlink&quot; title=&quot;609.在系统中查找重复文件&quot;&gt;&lt;/a&gt;609.在系统中查找重复文件&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个目录信息列表，包括目录路径，以及该目录中的所有包含内容的文件，您需要找到文件系统中的所有重复文件组的路径。一组重复的文件至少包括二个具有完全相同内容的文件。&lt;br&gt;输入列表中的单个目录信息字符串的格式如下：&lt;br&gt;“root/d1/d2/…/dm f1.txt(f1_content) f2.txt(f2_content) … fn.txt(fn_content)”&lt;br&gt;这意味着有 n 个文件（f1.txt, f2.txt … fn.txt 的内容分别是 f1_content, f2_content … fn_content）在目录 root/d1/d2/…/dm 下。注意：n&amp;gt;=1 且 m&amp;gt;=0。如果 m=0，则表示该目录是根目录。&lt;br&gt;该输出是重复文件路径组的列表。对于每个组，它包含具有相同内容的文件的所有文件路径。文件路径是具有下列格式的字符串：&lt;br&gt;“directory_path/file_name.txt”&lt;/p&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="字符串" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 字符串相乘</title>
    <link href="http://example.com/2021/09/05/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/"/>
    <id>http://example.com/2021/09/05/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</id>
    <published>2021-09-06T00:37:34.000Z</published>
    <updated>2021-09-05T08:44:16.177Z</updated>
    
    <content type="html"><![CDATA[<h1 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43.字符串相乘"></a>43.字符串相乘</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p><p>示例 1:<br>输入: num1 = “2”, num2 = “3”<br>输出: “6”</p><span id="more"></span><p><a href="https://leetcode-cn.com/problems/multiply-strings">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.将num1、num2两个字符串转为整数相乘，然后将结果转为字符串返回<br>2.使用python内置函数eval()执行num1 * num2表达式，将eval函数返回结果转为字符串返回<br>3.做加法（<a href="https://leetcode-cn.com/problems/multiply-strings/solution/zi-fu-chuan-xiang-cheng-by-leetcode-solution/">详细思路见leetcode题解</a>）<br>4.做乘法（<a href="https://leetcode-cn.com/problems/multiply-strings/solution/zi-fu-chuan-xiang-cheng-by-leetcode-solution/">详细思路见leetcode题解</a>）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):    def multiply(self, num1, num2):        &quot;&quot;&quot;        将num1、num2两个字符串转为整数相乘，然后将结果转为字符串返回        :type num1: str        :type num2: str        :rtype: str        &quot;&quot;&quot;        return str(int(num1) * int(num2))    def multiply1(self, num1: str, num2: str) -&gt; str:        &quot;&quot;&quot;        将num1、num2两个字符串转为整数相乘，然后将结果转为字符串返回        :param num1:        :param num2:        :return:        &quot;&quot;&quot;        if num1 == &quot;0&quot; or num2 == &quot;0&quot;:            return &quot;0&quot;        num1_to_int = 0        num2_to_int = 0        t = 1        for i in range(1, len(num1)+1):            num1_to_int += int(num1[-i]) * t            t = t * 10        t = 1        for i in range(1, len(num2)+1):            num2_to_int += int(num2[-i]) * t            t = t * 10        return str(num1_to_int * num2_to_int)    def multiply2(self, num1: str, num2: str) -&gt; str:        &quot;&quot;&quot;使用python内置函数eval()执行num1 * num2表达式，将eval函数返回结果转为字符串返回&quot;&quot;&quot;        if num1 == &quot;0&quot; or num2 == &quot;0&quot;:            return &quot;0&quot;        return str(eval(num1 + &#39;*&#39; + num2))  # eval() 函数用来执行一个字符串表达式，并返回表达式的值。    def multiply3(self, num1: str, num2: str) -&gt; str:        &quot;&quot;&quot;做加法&quot;&quot;&quot;        if num1 == &quot;0&quot; or num2 == &quot;0&quot;:            return &quot;0&quot;        ans = &quot;0&quot;        m, n = len(num1), len(num2)        for i in range(n - 1, -1, -1):            add = 0            y = int(num2[i])            curr = [&quot;0&quot;] * (n - i - 1)  # num2除了最低位以外，其余的每一位的运算结果都需要补0            print(&quot;curr:&quot;, curr)            for j in range(m - 1, -1, -1):                product = int(num1[j]) * y + add                curr.append(str(product % 10))                add = product // 10            if add &gt; 0:                curr.append(str(add))            curr = &quot;&quot;.join(curr[::-1])            ans = self.addStrings(ans, curr)        return ans    def addStrings(self, num1: str, num2: str) -&gt; str:        i, j = len(num1) - 1, len(num2) - 1        add = 0        ans = list()        while i &gt;= 0 or j &gt;= 0 or add != 0:            x = int(num1[i]) if i &gt;= 0 else 0            y = int(num2[j]) if j &gt;= 0 else 0            result = x + y + add            ans.append(str(result % 10))            add = result // 10            i -= 1            j -= 1        return &#39;&#39;.join(ans[::-1])    def multiply4(self, num1: str, num2: str) -&gt; str:        &quot;&quot;&quot;做乘法&quot;&quot;&quot;        if num1 == &quot;0&quot; or num2 == &quot;0&quot;:            return &quot;0&quot;        m, n = len(num1), len(num2)        ansArr = [0] * (m + n)        for i in range(m - 1, -1, -1):            x = int(num1[i])            for j in range(n - 1, -1, -1):                ansArr[i + j + 1] += x * int(num2[j])        for i in range(m + n - 1, 0, -1):            ansArr[i-1] += ansArr[i] // 10            ansArr[i] %= 10        index = 1 if ansArr[0] == 0 else 0        ans = &quot;&quot;.join(str(x) for x in ansArr[index:])        return ansif __name__ == &quot;__main__&quot;:    slt = Solution()    result = slt.multiply4(&quot;12&quot;, &quot;34&quot;)    print(result)    print(type(result))</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;43-字符串相乘&quot;&gt;&lt;a href=&quot;#43-字符串相乘&quot; class=&quot;headerlink&quot; title=&quot;43.字符串相乘&quot;&gt;&lt;/a&gt;43.字符串相乘&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br&gt;输入: num1 = “2”, num2 = “3”&lt;br&gt;输出: “6”&lt;/p&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="字符串" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 括号生成</title>
    <link href="http://example.com/2021/09/05/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"/>
    <id>http://example.com/2021/09/05/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</id>
    <published>2021-09-05T19:57:25.000Z</published>
    <updated>2021-09-05T04:01:46.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22.括号生成"></a>22.括号生成</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。<br>有效括号组合需满足：左括号必须以正确的顺序闭合。</p><span id="more"></span><p><a href="https://leetcode-cn.com/problems/generate-parentheses/">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>1.暴力法</strong><br>可以生成所有 2^2n 个 ‘(‘ 和 ‘)’ 字符构成的序列，然后我们检查每一个是否有效即可。<br><strong>2.回溯法</strong><br>方法一还有改进的余地：我们可以只在序列仍然保持有效时才添加 ‘(‘ or ‘)’，而不是像 方法一 那样每次添加。我们可以通过跟踪到目前为止放置的左括号和右括号的数目来做到这一点，<br>如果左括号数量不大于 n，我们可以放一个左括号。如果右括号数量小于左括号的数量，我们可以放一个右括号。<br>3.按括号序列的长度递归</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>from functools import lru_cacheclass Solution(object):    def generateParenthesis(self, n):        &quot;&quot;&quot;        暴力法        :type n: int        :rtype: List[str]        &quot;&quot;&quot;        # 生成所有括号组合，然后判断是否是有效括号        def generate(A):            if len(A) == 2 * n:                # print(A)                if valid(A):                    ans.append(&quot;&quot;.join(A))            else:                A.append(&#39;(&#39;)                generate(A)                A.pop()                A.append(&#39;)&#39;)                generate(A)                A.pop()        def valid(A):            bal = 0  # 表示左括号的数量减去右括号的数量            for c in A:                if c == &#39;(&#39;:                    bal += 1                else:                    bal -= 1                if bal &lt; 0:                    return False            return bal == 0        ans = []        generate([])        return ans    def generateParenthesis1(self, n):        &quot;&quot;&quot;        回溯法        对暴力解法的改进：        只在序列仍然保持有效时才添加 &#39;(&#39; or &#39;)&#39;，而不是像 暴力解法 那样每次添加        我们可以通过跟踪到目前为止放置的左括号和右括号的数目来做到这一点        如果左括号数量不大于 n，我们可以放一个左括号        如果右括号数量小于左括号的数量，我们可以放一个右括号        &quot;&quot;&quot;        def backtrack(S, left, right):            if len(S) == 2 * n:                ans.append(&#39;&#39;.join(S))                return            if left &lt; n:                S.append(&#39;(&#39;)                backtrack(S, left + 1, right)                S.pop()            if right &lt; left:                S.append(&#39;)&#39;)                backtrack(S, left, right + 1)                S.pop()        ans = []        backtrack([], 0, 0)        return ansclass Solution1:    @lru_cache(None)    def generateParenthesis(self, n: int):        &quot;&quot;&quot;按括号序列的长度递归&quot;&quot;&quot;        if n == 0:            return [&#39;&#39;]        ans = []        for c in range(n):            for left in self.generateParenthesis(c):                for right in self.generateParenthesis(n-1-c):                    ans.append(&#39;(&#123;&#125;)&#123;&#125;&#39;.format(left, right))        return ansif __name__ == &#39;__main__&#39;:    slt = Solution1()    parenthesis_list = slt.generateParenthesis(3)    print(parenthesis_list)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;22-括号生成&quot;&gt;&lt;a href=&quot;#22-括号生成&quot; class=&quot;headerlink&quot; title=&quot;22.括号生成&quot;&gt;&lt;/a&gt;22.括号生成&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。&lt;br&gt;有效括号组合需满足：左括号必须以正确的顺序闭合。&lt;/p&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="字符串" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>itertools | product</title>
    <link href="http://example.com/2021/09/04/product/"/>
    <id>http://example.com/2021/09/04/product/</id>
    <published>2021-09-05T01:16:27.000Z</published>
    <updated>2021-09-04T10:54:29.587Z</updated>
    
    <content type="html"><![CDATA[<h1 id="itertools-product"><a href="#itertools-product" class="headerlink" title="itertools.product()"></a>itertools.product()</h1><p>使用product()前需要导入itertools库<br><strong>用法1：</strong></p><pre><code>print(list(itertools.product(‘a&#39;, repeat=4)))   # 等价于 print(list(itertools.product(&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;)))a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]print(list(itertools.product(a, repeat=2)))  # s等价于 print(list(itertools.product(a, a)))</code></pre><p><strong>用法2：</strong></p><pre><code>print(list(itertools.product(a, b)))  # 等价于 print(list((x, y) for x in a for y in b))</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;itertools-product&quot;&gt;&lt;a href=&quot;#itertools-product&quot; class=&quot;headerlink&quot; title=&quot;itertools.product()&quot;&gt;&lt;/a&gt;itertools.product()&lt;/h1&gt;&lt;p&gt;使用prod</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="内置模块" scheme="http://example.com/categories/python/%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/"/>
    
    <category term="itertools" scheme="http://example.com/categories/python/%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/itertools/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="itertools" scheme="http://example.com/tags/itertools/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 电话号码的字母组合</title>
    <link href="http://example.com/2021/09/04/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    <id>http://example.com/2021/09/04/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</id>
    <published>2021-09-04T23:57:00.000Z</published>
    <updated>2021-09-04T10:58:17.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17.电话号码的字母组合"></a>17.电话号码的字母组合</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。<br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><span id="more"></span><p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.遍历并组合每一个数字对应的字母列表 –&gt; letterCombinations()<br><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/zhi-xing-yong-shi-ji-bai-9954nei-cun-xia-gwkb/">点击这里查看完整解题思路！！！</a><br>2.使用内置库 –&gt; letterCombinations1()<br><strong>3.回溯</strong> –&gt; letterCombinations2()<br><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/dian-hua-hao-ma-de-zi-mu-zu-he-by-leetcode-solutio/">回溯法和使用内置库思路见leetcode题解</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:    num2ch = &#123;        &#39;2&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],        &#39;3&#39;: [&#39;d&#39;, &#39;e&#39;, &#39;f&#39;],        &#39;4&#39;: [&#39;g&#39;, &#39;h&#39;, &#39;i&#39;],        &#39;5&#39;: [&#39;j&#39;, &#39;k&#39;, &#39;l&#39;],        &#39;6&#39;: [&#39;m&#39;, &#39;n&#39;, &#39;o&#39;],        &#39;7&#39;: [&#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;],        &#39;8&#39;: [&#39;t&#39;, &#39;u&#39;, &#39;v&#39;],        &#39;9&#39;: [&#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;]    &#125;    def letterCombinations(self, digits: str) -&gt; list:        if len(digits) == 0:            return []        list1 = []  # 用于存储digits数组中每个字符对应的字母列表        for d in digits:            list1.append(self.num2ch[d])        i = 0        j = 1        while j &lt; len(list1):            list1[j] = self.concat(list1[i], list1[j])            i = j            j += 1        return list1[-1]    def concat(self, list1, list2):        res = []        for e1 in list1:            for e2 in list2:                res.append(e1 + e2)        return res    def letterCombinations1(self, digits: str):        if not digits:            return list()        phoneMap = &#123;            &quot;2&quot;: &quot;abc&quot;,            &quot;3&quot;: &quot;def&quot;,            &quot;4&quot;: &quot;ghi&quot;,            &quot;5&quot;: &quot;jkl&quot;,            &quot;6&quot;: &quot;mno&quot;,            &quot;7&quot;: &quot;pqrs&quot;,            &quot;8&quot;: &quot;tuv&quot;,            &quot;9&quot;: &quot;wxyz&quot;,        &#125;        groups = (phoneMap[digit] for digit in digits)        import itertools        return [&quot;&quot;.join(combination) for combination in itertools.product(*groups)]    def letterCombinations2(self, digits: str):        if not digits:            return list()        phoneMap = &#123;            &quot;2&quot;: &quot;abc&quot;,            &quot;3&quot;: &quot;def&quot;,            &quot;4&quot;: &quot;ghi&quot;,            &quot;5&quot;: &quot;jkl&quot;,            &quot;6&quot;: &quot;mno&quot;,            &quot;7&quot;: &quot;pqrs&quot;,            &quot;8&quot;: &quot;tuv&quot;,            &quot;9&quot;: &quot;wxyz&quot;,        &#125;        def backtrack(index: int):            if index == len(digits):                combinations.append(&#39;&#39;.join(combination))            else:                digit = digits[index]                for letter in phoneMap[digit]:                    combination.append(letter)                    backtrack(index + 1)                    combination.pop()        combination = list()        combinations = list()        backtrack(0)        return combinationsif __name__ == &#39;__main__&#39;:    slt = Solution()    digits = &quot;23&quot;    res = slt.letterCombinations2(digits)    print(res)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;17-电话号码的字母组合&quot;&gt;&lt;a href=&quot;#17-电话号码的字母组合&quot; class=&quot;headerlink&quot; title=&quot;17.电话号码的字母组合&quot;&gt;&lt;/a&gt;17.电话号码的字母组合&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。&lt;br&gt;给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。&lt;/p&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="字符串" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
