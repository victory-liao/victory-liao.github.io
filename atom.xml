<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Victory&#39;s Blog</title>
  
  <subtitle>非淡泊无以明志，非宁静无以致远</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-11-07T03:41:46.075Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>victory-liao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>pandas | 文本数据处理</title>
    <link href="http://example.com/2021/11/06/pandas%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    <id>http://example.com/2021/11/06/pandas%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</id>
    <published>2021-11-07T03:39:54.000Z</published>
    <updated>2021-11-07T03:41:46.075Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pandas文本数据处理"><a href="#pandas文本数据处理" class="headerlink" title="pandas文本数据处理"></a>pandas文本数据处理</h1><p><a href="https://mp.weixin.qq.com/s/xmG8QizkbXJIBcqdT3nN-g">参考资料</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;pandas文本数据处理&quot;&gt;&lt;a href=&quot;#pandas文本数据处理&quot; class=&quot;headerlink&quot; title=&quot;pandas文本数据处理&quot;&gt;&lt;/a&gt;pandas文本数据处理&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="pandas" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="pandas" scheme="http://example.com/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>装系统 | 微软官网工具安装纯净win10</title>
    <link href="http://example.com/2021/11/06/%E5%BE%AE%E8%BD%AF%E5%AE%98%E7%BD%91%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E7%BA%AF%E5%87%80win10/"/>
    <id>http://example.com/2021/11/06/%E5%BE%AE%E8%BD%AF%E5%AE%98%E7%BD%91%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E7%BA%AF%E5%87%80win10/</id>
    <published>2021-11-07T03:14:06.000Z</published>
    <updated>2021-11-07T03:16:19.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微软官网工具安装纯净win10"><a href="#微软官网工具安装纯净win10" class="headerlink" title="微软官网工具安装纯净win10"></a>微软官网工具安装纯净win10</h1><p><a href="https://zhuanlan.zhihu.com/p/92129617">参考资料</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;微软官网工具安装纯净win10&quot;&gt;&lt;a href=&quot;#微软官网工具安装纯净win10&quot; class=&quot;headerlink&quot; title=&quot;微软官网工具安装纯净win10&quot;&gt;&lt;/a&gt;微软官网工具安装纯净win10&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://z</summary>
      
    
    
    
    <category term="电脑使用小技巧" scheme="http://example.com/categories/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
    <category term="装系统" scheme="http://example.com/categories/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/%E8%A3%85%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="装系统" scheme="http://example.com/tags/%E8%A3%85%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>多进程 | python实现多任务进程</title>
    <link href="http://example.com/2021/11/06/python%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B/"/>
    <id>http://example.com/2021/11/06/python%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B/</id>
    <published>2021-11-06T12:15:07.000Z</published>
    <updated>2021-11-06T12:19:54.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python实现多任务进程"><a href="#python实现多任务进程" class="headerlink" title="python实现多任务进程"></a>python实现多任务进程</h1><p>以下内容主要阐述了python实现多进程的两种方式、进程间如何通信、进程池以及一个多进程案例：批量复制文件。</p><span id="more"></span><p><strong>Show You the Code:</strong></p><pre><code># 实现多进程# 1.使用process类import multiprocessingdef process(index):    print(f&#39;Process:&#123;index&#125;&#39;)if __name__ == &quot;__main__&quot;:    for i in range(5):        p = multiprocessing.Process(target=process, args=(i,))        p.start()# 2.继承process类import timefrom multiprocessing import Processclass MyProcess(Process):    def __init__(self, loop):        Process.__init__()        self.loop = loop    def run(self):        for count in range(self.loop):            time.sleep(1)            print(f&#39;Pid:&#123;self.pid&#125; LoopCount:&#123;count&#125;&#39;)if __name__ == &#39;__main__&#39;:    for i in range(2, 5):        p = MyProcess(i)        p.start()# 进程间的通信# 1、Queue-队列 先进先出from multiprocessing import Queueimport multiprocessingdef download(p):  # download the data    lst = [11, 22, 33, 44]    for item in lst:        p.put(item)    print(&quot;successfully downloaded data!&quot;)def save_data(p):    lst = []    while True:        data = p.get()        lst.append(data)        if p.empty():            break    print(lst)    print(&quot;successfully saved data!&quot;)def main():    p1 = Queue()    t1 = multiprocessing.Process(target=download, args=(p1,))    t2 = multiprocessing.Process(target=save_data, args=(p1,))    t1.start()    t2.start()if __name__ == &quot;__main__&quot;:    main()# 2、共享全局变量不适用于多进程编程import multiprocessinga = 1  # 全局变量def demo1():    global a    a += 1def demo2():    print(a)def main():    t1 = multiprocessing.Process(target=demo1)    t2 = multiprocessing.Process(target=demo2)    t1.start()    t2.start()if __name__ == &quot;__main__&quot;:    main()# 进程池之间的通信from multiprocessing import Poolimport os, time, randomdef worker(a):    t_start = time.time()    print(&#39;%s开始执行，进程号为%d&#39; % (a, os.getpid()))    time.sleep(random.random() * 2)    t_stop = time.time()    print(a, &#39;执行完成，耗时%0.2f&#39; % (t_stop - t_start))if __name__ == &#39;__main__&#39;:    po = Pool(3)  # 定义一个进程池    for i in range(0, 10):        po.apply_async(worker, (i,))  # 向进程池中添加worker任务    print(&quot;--start--&quot;)    po.close()    po.join()    print(&quot;--end--&quot;)# 案例：文件批量复制import osimport timeimport multiprocessingdef copy_file(Q, oldfolderName, newfolderName, file_name):    # 文件复制,不需要返回    time.sleep(0.5)    # print(&#39;\r从%s文件夹复制到%s文件夹的%s文件&#39;%(oldfolderName,newfolderName,file_name),end=&#39;&#39;)    old_file = open(oldfolderName + &#39;/&#39; + file_name, &#39;rb&#39;)  # 待复制文件    content = old_file.read()    old_file.close()    new_file = open(newfolderName + &#39;/&#39; + file_name, &#39;wb&#39;)  # 复制出的新文件    new_file.write(content)    new_file.close()    Q.put(file_name)  # 向Q队列中添加文件def main():    oldfolderName = input(&#39;请输入要复制的文件夹名字:&#39;)  # 步骤1获取要复制文件夹的名字(可以手动创建,也可以通过代码创建,这里我们手动创建)    newfolderName = oldfolderName + &#39;复件&#39;    # 步骤二 创建一个新的文件夹    if not os.path.exists(newfolderName):        os.mkdir(newfolderName)    filenames = os.listdir(oldfolderName)  # 3.获取文件夹里面所有待复制的文件名    # print(filenames)    pool = multiprocessing.Pool(5)  # 4.创建进程池    Q = multiprocessing.Manager().Queue()  # 创建队列,进行通信    for file_name in filenames:        pool.apply_async(copy_file, args=(Q, oldfolderName, newfolderName, file_name))  # 5.向进程池添加任务    pool.close()    copy_file_num = 0    file_count = len(filenames)    # 不知道什么时候完成,所以定义一个死循环    while True:        file_name = Q.get()        print(f&quot;&#123;file_name&#125;已经复制！&quot;)        copy_file_num += 1        time.sleep(0.2)        print(&#39;\r拷贝进度%.2f %%&#39; % (copy_file_num * 100 / file_count), end=&#39;&#39;)  # 做一个拷贝进度条        if copy_file_num &gt;= file_count:            breakif __name__ == &#39;__main__&#39;:    main()</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;python实现多任务进程&quot;&gt;&lt;a href=&quot;#python实现多任务进程&quot; class=&quot;headerlink&quot; title=&quot;python实现多任务进程&quot;&gt;&lt;/a&gt;python实现多任务进程&lt;/h1&gt;&lt;p&gt;以下内容主要阐述了python实现多进程的两种方式、进程间如何通信、进程池以及一个多进程案例：批量复制文件。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="基础" scheme="http://example.com/categories/python/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="多进程" scheme="http://example.com/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    
    <category term="multiprocessing" scheme="http://example.com/tags/multiprocessing/"/>
    
  </entry>
  
  <entry>
    <title>requests | 爬取精美壁纸</title>
    <link href="http://example.com/2021/11/06/%E7%88%AC%E5%8F%96%E7%B2%BE%E7%BE%8E%E5%A3%81%E7%BA%B8/"/>
    <id>http://example.com/2021/11/06/%E7%88%AC%E5%8F%96%E7%B2%BE%E7%BE%8E%E5%A3%81%E7%BA%B8/</id>
    <published>2021-11-06T09:29:25.000Z</published>
    <updated>2021-11-06T09:32:06.144Z</updated>
    
    <content type="html"><![CDATA[<h1 id="爬取精美壁纸"><a href="#爬取精美壁纸" class="headerlink" title="爬取精美壁纸"></a>爬取精美壁纸</h1><p><strong>爬取目标：</strong> Wallhaven网站中Toplist标签下前50页共1196张精美壁纸。<br><a href="https://mp.weixin.qq.com/s/BiJKm4SnL6qCLEK91xcDIQ">参考资料</a></p><p><strong>代码：</strong></p><pre><code># -*- coding:utf-8 -*-import osimport requestsfrom lxml import etree# 1.获取每页的html信息headers = &#123;    &#39;user-agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) &#39;                  &#39;Chrome/95.0.4638.54 Safari/537.36 &#39;&#125;# 定义获取每页html信息的函数def get_html_info(page):    url = f&#39;https://wallhaven.cc/toplist?page=&#123;page&#125;&#39;    resp = requests.get(url, headers=headers)    print(resp.text)    resp_html = etree.HTML(resp.text)    return resp_html# 2.解析url信息+下载图片def get_pic(resp_html):    pic_url_list = []    lis = resp_html.xpath(&#39;//*[@id=&quot;thumbs&quot;]/section[1]/ul/li&#39;)  # 获取该页所有缩略图包含的信息    for li in lis:        pic_url = li.xpath(&#39;./figure/a/@href&#39;)[0]  # 获取存放在缩略图信息中的缩略图原图网址        pic_url_list.append(pic_url)    for pic_url in pic_url_list:        resp2 = requests.get(pic_url, headers=headers)        r_html2 = etree.HTML(resp2.text)        pic_size = r_html2.xpath(&#39;//*[@id=&quot;showcase-sidebar&quot;]/div/div[1]/h3/text()&#39;)[0]  # 用照片分辨率作为名称一部分        final_url = r_html2.xpath(&#39;//*[@id=&quot;wallpaper&quot;]/@src&#39;)[0]  # 获取原图下载地址        pic = requests.get(url=final_url, headers=headers).content        if not os.path.exists(&#39;Wallhaven&#39;):            os.mkdir(&#39;Wallhaven&#39;)        with open(&#39;Wallhaven\\&#39; + pic_size + final_url[-10:], mode=&#39;wb&#39;) as f:            f.write(pic)  # 保存图片            print(pic_size + final_url[-10:] + &#39;，下载完毕，已下载&#123;&#125;张壁纸&#39;.format(len(os.listdir(&#39;Wallhaven&#39;))))# 3.构建main()函数运行程序def main():    page_range = range(1,51) # 爬取1-50页的壁纸    for i in page_range:        r = get_html_info(i)        get_pic(r)        print(f&#39;===============第&#123;i&#125;页下载完毕=============&#39;)if __name__ == &#39;__main__&#39;:    main()</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;爬取精美壁纸&quot;&gt;&lt;a href=&quot;#爬取精美壁纸&quot; class=&quot;headerlink&quot; title=&quot;爬取精美壁纸&quot;&gt;&lt;/a&gt;爬取精美壁纸&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;爬取目标：&lt;/strong&gt; Wallhaven网站中Toplist标签下前50页共1196</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="requests" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"/>
    
    
    <category term="requests" scheme="http://example.com/tags/requests/"/>
    
    <category term="爬虫" scheme="http://example.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>深度学习 | 大胆新奇的卷积神经网络设计</title>
    <link href="http://example.com/2021/11/05/%E5%A4%A7%E8%83%86%E6%96%B0%E5%A5%87%E7%9A%84%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AE%BE%E8%AE%A1/"/>
    <id>http://example.com/2021/11/05/%E5%A4%A7%E8%83%86%E6%96%B0%E5%A5%87%E7%9A%84%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-11-06T04:15:28.000Z</published>
    <updated>2021-11-06T09:04:25.587Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/6HbPBYQvLMU5okI-tIUBcg">大胆又新奇的卷积网络结构设计</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/6HbPBYQvLMU5okI-tIUBcg&quot;&gt;大胆又新奇的卷积网络结构设计&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="深度学习" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="深度学习" scheme="http://example.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>深度学习基础 | 神经网络模型概览</title>
    <link href="http://example.com/2021/11/05/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%A7%88/"/>
    <id>http://example.com/2021/11/05/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%A7%88/</id>
    <published>2021-11-06T04:15:08.000Z</published>
    <updated>2021-11-06T07:39:18.687Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/ds5YWmyIZTHW55Tkdf3pww">一文概览神经网络模型</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/ds5YWmyIZTHW55Tkdf3pww&quot;&gt;一文概览神经网络模型&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="深度学习" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="深度学习基础" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="深度学习" scheme="http://example.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="神经网络模型" scheme="http://example.com/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>深度学习基础 | 一文看懂各种神经网络优化算法</title>
    <link href="http://example.com/2021/11/05/%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82%E5%90%84%E7%A7%8D%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2021/11/05/%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82%E5%90%84%E7%A7%8D%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/</id>
    <published>2021-11-06T04:14:51.000Z</published>
    <updated>2021-11-06T09:27:38.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一文看懂各种神经网络优化算法"><a href="#一文看懂各种神经网络优化算法" class="headerlink" title="一文看懂各种神经网络优化算法"></a>一文看懂各种神经网络优化算法</h1><p><a href="https://mp.weixin.qq.com/s/gRrZImMydyCDBNCTIgVYXw">一文看懂各种神经网络优化算法</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一文看懂各种神经网络优化算法&quot;&gt;&lt;a href=&quot;#一文看懂各种神经网络优化算法&quot; class=&quot;headerlink&quot; title=&quot;一文看懂各种神经网络优化算法&quot;&gt;&lt;/a&gt;一文看懂各种神经网络优化算法&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://mp.we</summary>
      
    
    
    
    <category term="深度学习" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="深度学习基础" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="优化算法" scheme="http://example.com/tags/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>研究 | 科研方法分享</title>
    <link href="http://example.com/2021/11/05/%E7%A7%91%E7%A0%94%E6%96%B9%E6%B3%95%E5%88%86%E4%BA%AB/"/>
    <id>http://example.com/2021/11/05/%E7%A7%91%E7%A0%94%E6%96%B9%E6%B3%95%E5%88%86%E4%BA%AB/</id>
    <published>2021-11-06T04:14:17.000Z</published>
    <updated>2021-11-06T09:59:21.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="科研方法分享"><a href="#科研方法分享" class="headerlink" title="科研方法分享"></a>科研方法分享</h1><h2 id="科研基本流程"><a href="#科研基本流程" class="headerlink" title="科研基本流程"></a>科研基本流程</h2><p><strong>选题 –&gt; 模型/算法设计 –&gt; 实验验证 –&gt; 论文写作</strong></p><p>论文=50% technique + 50% paper writing</p><p>关注技术、工作的价值、insight.</p><p><a href="https://mp.weixin.qq.com/s/n0Tl6dM7QCM07Ae01Edl4A">上海交大吴齐天的科研思考！</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;科研方法分享&quot;&gt;&lt;a href=&quot;#科研方法分享&quot; class=&quot;headerlink&quot; title=&quot;科研方法分享&quot;&gt;&lt;/a&gt;科研方法分享&lt;/h1&gt;&lt;h2 id=&quot;科研基本流程&quot;&gt;&lt;a href=&quot;#科研基本流程&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="Rsearch and Paper" scheme="http://example.com/categories/Rsearch-and-Paper/"/>
    
    <category term="科研方法" scheme="http://example.com/categories/Rsearch-and-Paper/%E7%A7%91%E7%A0%94%E6%96%B9%E6%B3%95/"/>
    
    
    <category term="科研方法" scheme="http://example.com/tags/%E7%A7%91%E7%A0%94%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>深度学习基础 | 一文深层解决模型过拟合</title>
    <link href="http://example.com/2021/11/05/%E4%B8%80%E6%96%87%E6%B7%B1%E5%B1%82%E8%A7%A3%E5%86%B3%E6%A8%A1%E5%9E%8B%E8%BF%87%E6%8B%9F%E5%90%88/"/>
    <id>http://example.com/2021/11/05/%E4%B8%80%E6%96%87%E6%B7%B1%E5%B1%82%E8%A7%A3%E5%86%B3%E6%A8%A1%E5%9E%8B%E8%BF%87%E6%8B%9F%E5%90%88/</id>
    <published>2021-11-06T04:13:27.000Z</published>
    <updated>2021-11-06T09:43:43.072Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一文深层解决模型过拟合"><a href="#一文深层解决模型过拟合" class="headerlink" title="一文深层解决模型过拟合"></a>一文深层解决模型过拟合</h1><p><a href="https://mp.weixin.qq.com/s/RBSewyWPdUnywKplVDzeLA">参考资料</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一文深层解决模型过拟合&quot;&gt;&lt;a href=&quot;#一文深层解决模型过拟合&quot; class=&quot;headerlink&quot; title=&quot;一文深层解决模型过拟合&quot;&gt;&lt;/a&gt;一文深层解决模型过拟合&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/</summary>
      
    
    
    
    <category term="深度学习" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="深度学习基础" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="深度学习" scheme="http://example.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="过拟合" scheme="http://example.com/tags/%E8%BF%87%E6%8B%9F%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>python | 动态查找列表中的第二个number</title>
    <link href="http://example.com/2021/11/05/%E5%8A%A8%E6%80%81%E6%9F%A5%E6%89%BE%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%BA%8C%E4%B8%AAnumber/"/>
    <id>http://example.com/2021/11/05/%E5%8A%A8%E6%80%81%E6%9F%A5%E6%89%BE%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%BA%8C%E4%B8%AAnumber/</id>
    <published>2021-11-05T10:54:43.000Z</published>
    <updated>2021-11-05T10:56:14.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态查找列表中的第二个number"><a href="#动态查找列表中的第二个number" class="headerlink" title="动态查找列表中的第二个number"></a>动态查找列表中的第二个number</h1><p>方法：先找到第一个2所在位置fist_index，切片new_list=names[index+1:]得到新的列表，<br>再从新列表中找第一个2的位置second_index.最终第二个2的位置为first_index+second_index+1</p><span id="more"></span><p><strong>代码：</strong></p><pre><code>names = [&#39;apple&#39;, &#39;rice&#39;, &#39;jack&#39;, &#39;rose&#39;, 2, &#39;girl&#39;, &#39;boy&#39;, 2, &#39;heather&#39;, 2]first_index = names.index(2)new_list = names[first_index + 1:]second_index = new_list.index(2)second_loction = first_index + second_index + 1  # 第二个2的位置print(&#39;第二个2 的位置为：&#39;, second_loction)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;动态查找列表中的第二个number&quot;&gt;&lt;a href=&quot;#动态查找列表中的第二个number&quot; class=&quot;headerlink&quot; title=&quot;动态查找列表中的第二个number&quot;&gt;&lt;/a&gt;动态查找列表中的第二个number&lt;/h1&gt;&lt;p&gt;方法：先找到第一个2所在位置fist_index，切片new_list=names[index+1:]得到新的列表，&lt;br&gt;再从新列表中找第一个2的位置second_index.最终第二个2的位置为first_index+second_index+1&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="基础" scheme="http://example.com/categories/python/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>xlrd | 从Excel表中批量复制粘贴数据到新表</title>
    <link href="http://example.com/2021/11/05/%E4%BB%8EExcel%E8%A1%A8%E4%B8%AD%E6%89%B9%E9%87%8F%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E6%95%B0%E6%8D%AE%E5%88%B0%E6%96%B0%E8%A1%A8/"/>
    <id>http://example.com/2021/11/05/%E4%BB%8EExcel%E8%A1%A8%E4%B8%AD%E6%89%B9%E9%87%8F%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E6%95%B0%E6%8D%AE%E5%88%B0%E6%96%B0%E8%A1%A8/</id>
    <published>2021-11-05T08:08:25.000Z</published>
    <updated>2021-11-05T08:10:13.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从Excel表中批量复制粘贴数据到新表"><a href="#从Excel表中批量复制粘贴数据到新表" class="headerlink" title="从Excel表中批量复制粘贴数据到新表"></a>从Excel表中批量复制粘贴数据到新表</h1><p>程序实现从Excel表中批量复制粘贴部分数据到新表。</p><span id="more"></span><p>代码：</p><pre><code># 读取xls文件中的数据import xlrdfile = &quot;原表.xls&quot;wb = xlrd.open_workbook(file)  # 读取工作簿ws = wb.sheets()[0]  # 选第一个工作表data = []for row in range(7, ws.nrows):    name = ws.cell(row, 1).value.strip()  # 科室名称    total1 = ws.cell(row, 2).value  # 总计    total2 = ws.cell(row, 3).value  # 计    avg = ws.cell(row, 20).value  # 平均每日人次    info_list = [name, total1, total2, avg]    if info_list[0] != &quot;&quot;:  # 去除空数据        data.append(info_list)from openpyxl import load_workbookfrom openpyxl.styles import Border, Side, PatternFill, Font, GradientFill, Alignment  # 设置单元格格式thin = Side(border_style=&quot;thin&quot;, color=&quot;000000&quot;)  # 定义边框粗细及颜色file = &quot;统计表模板.xlsx&quot;wb = load_workbook(file)ws = wb.active# 写入数据for i in data:    ws.append(i)# 设置字号，对齐，缩小字体填充，加边框# Font(bold=True)可加粗字体for row_number in range(3, ws.max_row + 1):    ws.row_dimensions[row_number].height = 25  # 设置行高    for col_number in range(1, 5):        c = ws.cell(row=row_number, column=col_number)        c.font = Font(size=11, bold=True)        c.border = Border(top=thin, left=thin, right=thin, bottom=thin)        c.alignment = Alignment(horizontal=&quot;center&quot;, vertical=&quot;center&quot;)wb.save(&quot;统计表.xlsx&quot;)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;从Excel表中批量复制粘贴数据到新表&quot;&gt;&lt;a href=&quot;#从Excel表中批量复制粘贴数据到新表&quot; class=&quot;headerlink&quot; title=&quot;从Excel表中批量复制粘贴数据到新表&quot;&gt;&lt;/a&gt;从Excel表中批量复制粘贴数据到新表&lt;/h1&gt;&lt;p&gt;程序实现从Excel表中批量复制粘贴部分数据到新表。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="xlrd" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/xlrd/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="openpyxl" scheme="http://example.com/tags/openpyxl/"/>
    
    <category term="xlrd" scheme="http://example.com/tags/xlrd/"/>
    
  </entry>
  
  <entry>
    <title>requests | 批量下载公众号文章</title>
    <link href="http://example.com/2021/11/05/batch-download-gzh-article/"/>
    <id>http://example.com/2021/11/05/batch-download-gzh-article/</id>
    <published>2021-11-05T08:00:34.000Z</published>
    <updated>2021-11-05T08:02:59.377Z</updated>
    
    <content type="html"><![CDATA[<h1 id="批量下载公众号文章"><a href="#批量下载公众号文章" class="headerlink" title="批量下载公众号文章"></a>批量下载公众号文章</h1><p>程序实现从公众号批量下载文章并保存为pdf.</p><span id="more"></span><p>代码：</p><pre><code># import requests# import json## url = &quot;https://mp.weixin.qq.com/mp/profile_ext&quot;  # 公号的链接# headers = &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) &quot;#                          &quot;Chrome/83.0.4103.116 Safari/537.36 &quot;&#125;# proxies = &#123;#     &#39;https&#39;: None,#     &#39;http&#39;: None,# &#125;# uin = &#39;MjU1Mjg4NjAzNQ==&#39;# # Key会随时间变化，需要获取最新的key，不然抓取不到数据# key = &#39;3390dbef8687839b29dd8a2499d96e7ee28002a981da4f1d962e56d4c93430eef1b27ae1dc2e2304590ee88091fcb33e6f59df16f55cf9fa4516fa6ab77f5db7055f877e3b48007fc57fc07a522d0b0d1d15c3ee0ca047f22cd49301079a0e10b01df3fe4069bbdb4dd2cbe38cfa1dcb3ac01a93dd04c8e01504896fcab7d8be&#39;# # 重要参数# params = &#123;#     &#39;action&#39;: &#39;getmsg&#39;,#     &#39;__biz&#39;: &#39;MzU4ODg3MzAwNw==&#39;,  # 每个公众号的不一样，从Fiddler复制过来#     &#39;f&#39;: &#39;json&#39;,#     &#39;offset&#39;: 0,  # 控制翻页#     &#39;count&#39;: &#39;10&#39;,#     &#39;is_ok&#39;: &#39;1&#39;,#     &#39;scene&#39;: &#39;124&#39;,#     &#39;uin&#39;: uin,  # 每个公众号的不一样，从Fiddler复制过来#     &#39;key&#39;: key,  # 每个公众号的不一样，从Fiddler复制过来#     &#39;wxtoken&#39;: &#39;&#39;,#     &#39;x5&#39;: &#39;0&#39;,# &#125;## # 获取公众号页面信息# response = requests.get(url, headers=headers, params=params, proxies=proxies)# # print(response.text)# # print(type(response.text))# response_dict = json.loads(response.text)  # 将字符串转换成python能识别的格式# # print(response_dict)## general_msg_list = response_dict[&#39;general_msg_list&#39;]  # 此时是字符串# # print(general_msg_list)# data_list = json.loads(general_msg_list)[&#39;list&#39;]  # 转换成python能够识别的格式，并取出文章链接的信息# print(data_list)# print(data_list[0])import requestsimport jsonimport timedef article_links(index):    &quot;&quot;&quot;用于获取单个页面的文章链接，index用于控制页数&quot;&quot;&quot;    links = []    url = &#39;https://mp.weixin.qq.com/mp/profile_ext&#39;    headers = &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) &quot;                             &quot;Chrome/83.0.4103.116 Safari/537.36 &quot;&#125;    proxies = &#123;        &#39;https&#39;: None,        &#39;http&#39;: None,    &#125;    uin = &#39;MjU1Mjg4NjAzNQ==&#39;    # # Key会随时间变化，需要获取最新的key，不然抓取不到数据    key = &#39;3390dbef8687839b29dd8a2499d96e7ee28002a981da4f1d962e56d4c93430eef1b27ae1dc2e2304590ee88091fcb33e6f59df16f55cf9fa4516fa6ab77f5db7055f877e3b48007fc57fc07a522d0b0d1d15c3ee0ca047f22cd49301079a0e10b01df3fe4069bbdb4dd2cbe38cfa1dcb3ac01a93dd04c8e01504896fcab7d8be&#39;    # 重要参数    params = &#123;        &#39;action&#39;: &#39;getmsg&#39;,        &#39;__biz&#39;: &#39;MzU4ODg3MzAwNw==&#39;,  # 每个公众号的不一样，从Fiddler复制过来        &#39;f&#39;: &#39;json&#39;,        &#39;offset&#39;: 0,  # 控制翻页        &#39;count&#39;: &#39;10&#39;,        &#39;is_ok&#39;: &#39;1&#39;,        &#39;scene&#39;: &#39;124&#39;,        &#39;uin&#39;: uin,  # 每个公众号的不一样，从Fiddler复制过来        &#39;key&#39;: key,  # 每个公众号的不一样，从Fiddler复制过来        &#39;wxtoken&#39;: &#39;&#39;,        &#39;x5&#39;: &#39;0&#39;,    &#125;    response = requests.get(url, headers=headers, params=params, proxies=proxies)    response_dict = json.loads(response.text)    can_msg_continue = response_dict.get(&#39;can_msg_continue&#39;)  # 用于判断是否是最后一页，若为0，则表示最后一页    general_msg_list = response_dict.get(&#39;general_msg_list&#39;)    data_list = json.loads(general_msg_list)[&#39;list&#39;]    for data in data_list:        # 部分公众号文章是“消息”，因此data里的数据缺少我们需要的字段，需要跳过        try:            title = data[&#39;app_msg_ext_info&#39;][&#39;title&#39;]  # 文章标题            datetime = data[&#39;comm_msg_info&#39;][&#39;datetime&#39;]  # 获取时间戳            date = time.strftime(&#39;%Y-%m-%d&#39;, time.localtime(datetime))  # 将时间戳转换为本地时间            url = data[&#39;app_msg_ext_info&#39;][&#39;content_url&#39;]  # 文章链接            info = &#123;                &quot;url&quot;: url,                &quot;title&quot;: title,                &quot;date&quot;: date,            &#125;            links.append(info)        except:            pass    return links, can_msg_continueall_links = []for i in range(100):  # 根据实际而定，因为每页10篇文章，100页对应1000篇文章    all_links.extend(article_links(i)[0])    if article_links(i)[1] == 0:        breakprint(all_links[:])print(len(all_links))import pdfkitimport wechatsogoudef link_to_pdf(url, title, date):    ws_api = wechatsogou.WechatSogouAPI(captcha_break_time=3)  # 调用接口    content_info = ws_api.get_article_content(url)  # 请求链接    content = content_info[&#39;content_html&#39;]  # 转换为html格式    # 将标题和文章内容放入如下html中处理以下    html = f&#39;&#39;&#39;            &lt;!DOCTYPE html&gt;            &lt;html lang=&quot;en&quot;&gt;            &lt;head&gt;                &lt;meta charset=&quot;UTF-8&quot;&gt;                &lt;title&gt;&#123;title&#125;&lt;/title&gt;            &lt;/head&gt;            &lt;body&gt;            &lt;h2 style=&quot;text-align: center;font-weight: 400;&quot;&gt;&#123;title&#125;&lt;/h2&gt;            &#123;content&#125;            &lt;/body&gt;            &lt;/html&gt;&#39;&#39;&#39;    path_wkthmltopdf = r&quot;E:\my\python_project\70个python实战项目\实例70_Python批量将公号文章保留原格式下载为PDF\wkhtmltox\bin\wkhtmltopdf.exe&quot;  # wkhtmltopdf可执行程序路径    config = pdfkit.configuration(wkhtmltopdf=path_wkthmltopdf)  # 配置pdfkit    pdfkit.from_string(html, f&quot;&#123;title&#125; &#123;date&#125;.pdf&quot;, configuration=config)  # 转PDF，并按设定好的命名文件    print(f&quot;&#123;title&#125;.pdf 已下载&quot;)for link in all_links:    url = link[&#39;url&#39;]    title = link[&#39;title&#39;]    date = link[&#39;date&#39;]    link_to_pdf(url, title, date)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;批量下载公众号文章&quot;&gt;&lt;a href=&quot;#批量下载公众号文章&quot; class=&quot;headerlink&quot; title=&quot;批量下载公众号文章&quot;&gt;&lt;/a&gt;批量下载公众号文章&lt;/h1&gt;&lt;p&gt;程序实现从公众号批量下载文章并保存为pdf.&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="requests" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="requests" scheme="http://example.com/tags/requests/"/>
    
    <category term="爬虫" scheme="http://example.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>win32com | 汇总excel表</title>
    <link href="http://example.com/2021/11/04/%E6%B1%87%E6%80%BBexcel%E8%A1%A8/"/>
    <id>http://example.com/2021/11/04/%E6%B1%87%E6%80%BBexcel%E8%A1%A8/</id>
    <published>2021-11-05T02:41:31.000Z</published>
    <updated>2021-11-05T02:43:31.691Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇总excel表"><a href="#汇总excel表" class="headerlink" title="汇总excel表"></a>汇总excel表</h1><p>程序实现汇总多个excel表格并生成目录。</p><span id="more"></span><p>代码：</p><pre><code>import os  # 用于获取目标文件所在路径import win32comimport win32compath = os.getcwd() + &quot;\\文件\\&quot;  # 文件夹绝对路径files = []for file in os.listdir(path):    if file.endswith(&quot;.xls&quot;) or file.endswith(&quot;.xlsx&quot;):  # 只获取&quot;.xls&quot;后缀的文件        files.append(path + file)# print(files)excel_app = win32com.client.Dispatch(&quot;Excel.Application&quot;)excel_app.Visible = False  # 不显示Excel文件excel_app.DisplayAlerts = False# 新建excel工作簿wb = excel_app.Workbooks.Add()wb.SaveAs(os.getcwd() + &quot;\\汇总.xlsx&quot;)ws = wb.Worksheets(1)ws.Name = &quot;目录&quot;for i in range(len(files)):    file_name = files[i].split(&quot;\\&quot;)[-1].split(&quot;.&quot;)[0]    ws.Range(&quot;A&quot; + str(i + 1)).Value = file_name    # 读取子文件    wb_sub = excel_app.Workbooks.Open(files[i])    ws_sub = wb_sub.ActiveSheet  # #获取活动工作表    ws_sub.Copy(ws)  # 复制工作表到汇总表    wb.ActiveSheet.Name = file_name  # 更改工作表名    wb_sub.Close()    print(f&quot;已复制文件 &#123;file_name&#125;&quot;)# 将“目录”工作表移动到最前面first_sheet = files[0].split(&quot;\\&quot;)[-1].split(&quot;.&quot;)[0]wb.Worksheets(&quot;目录&quot;).Move(wb.Worksheets(first_sheet))wb.Save()wb.Close()excel_app.Quit()</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;汇总excel表&quot;&gt;&lt;a href=&quot;#汇总excel表&quot; class=&quot;headerlink&quot; title=&quot;汇总excel表&quot;&gt;&lt;/a&gt;汇总excel表&lt;/h1&gt;&lt;p&gt;程序实现汇总多个excel表格并生成目录。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="win32com" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/win32com/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="win32com" scheme="http://example.com/tags/win32com/"/>
    
  </entry>
  
  <entry>
    <title>os | 批量新建文件夹</title>
    <link href="http://example.com/2021/11/04/%E6%89%B9%E9%87%8F%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/"/>
    <id>http://example.com/2021/11/04/%E6%89%B9%E9%87%8F%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/</id>
    <published>2021-11-05T02:22:22.000Z</published>
    <updated>2021-11-05T02:24:08.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="批量新建文件夹"><a href="#批量新建文件夹" class="headerlink" title="批量新建文件夹"></a>批量新建文件夹</h1><p>程序实现在指定目录下批量生成文件夹。</p><span id="more"></span><p>代码：</p><pre><code>import osfrom datetime import datetimefrom time import time, localtime, strftimefrom tkinter import Tk, Entry, Button, Listbox, X, Y, END, Scrollbar, RIGHT, BOTTOM, HORIZONTAL, StringVar, Labelfrom tkinter.filedialog import askdirectoryclass MainGUI():    def __init__(self):        myWindow = Tk()        myWindow.title(&quot;批量新建文件夹&quot;)        # 设置窗口大小        myWindow.geometry(&#39;590x400&#39;)        # 增加标签        self.label_1 = Label(myWindow, text=&#39; 目标目录:&#39;)        self.label_1.place(x=10, y=10, width=70, height=30)        self.label_2 = Label(myWindow, text=&#39;文件夹数量:&#39;)        self.label_2.place(x=10, y=50, width=70, height=30)        # 增加文本框        addr = StringVar(value=&#39;C:\\Users\\xxxx\\Desktop&#39;)  # 文本框默认显示的内容        self.input_entry = Entry(myWindow, highlightcolor=&#39;red&#39;, highlightthickness=1, textvariable=addr)        self.input_entry.place(x=80, y=10, width=410, height=30)        self.btn_in = Button(myWindow, text=&#39;选择目录&#39;, command=self.select_dir1, width=10, height=1)        self.btn_in.place(x=500, y=10)        folder_quantity = str(self.get_folder_qty())  # 从日志文件`log.txt`中读取最近使用过的文件夹数量        def_qty = StringVar(value=folder_quantity)        self.folderQty_entry = Entry(myWindow, highlightcolor=&#39;blue&#39;, highlightthickness=1, textvariable=def_qty)        self.folderQty_entry.place(x=80, y=50, width=410, height=30)        self.btn_exe = Button(myWindow, text=&#39;执行新建&#39;, command=self.create_folders, width=10, height=1)        self.btn_exe.place(x=500, y=50)        # 增加列表框        self.result_show = Listbox(myWindow, bg=&#39;Azure&#39;)        self.result_show.place(x=10, y=100, width=570, height=290)        self.sbY = Scrollbar(self.result_show, command=self.result_show.yview)  # 在列表框中增加Y轴滚动条        self.sbY.pack(side=RIGHT, fill=Y)        self.result_show.config(yscrollcommand=self.sbY.set)        self.sbX = Scrollbar(self.result_show, command=self.result_show.xview, orient=HORIZONTAL)  # 在列表框中增加X轴滚动条        self.sbX.pack(side=BOTTOM, fill=X)        self.result_show.config(xscrollcommand=self.sbX.set)        myWindow.mainloop()    def select_dir1(self):        self.input_entry.delete(0, END)        self.input_entry.insert(0, askdirectory(initialdir=&quot;D:\\&quot;))    def create_folders(self):        date = self.get_current_date()  # 获取日期        qty = int(self.folderQty_entry.get())  # 获取文本框中文件夹数量，并转为整数        for i in range(1, qty + 1):            folder = self.input_entry.get() + &quot;\\&quot; + date + &#39;-&#39; + str(i)            # 判断是否已经存在该目录            if not os.path.exists(folder):                # 目录不存在，进行创建操作                os.makedirs(folder)  # 使用os.makedirs()方法创建目录                f = f&quot;目录新建成功：&#123;folder&#125;&quot;  # 创建一个显示项                self.result_show.insert(&quot;end&quot;, f)  # 将结果添加到列表框中            else:                f = f&quot;目录已存在：&#123;folder&#125;&quot;  # 创建一个显示项                self.result_show.insert(&quot;end&quot;, f)  # 将结果添加到列表框中        f = &quot;-&quot; * 100  # 创建分割线        self.result_show.insert(&quot;end&quot;, f)  # 将分割线添加到列表框        f = f&quot;程序运行完成，请关闭窗口退出.&quot;  # 创建一个显示项        self.result_show.insert(&quot;end&quot;, f)  # 将结果添加到列表框        f = &quot; &quot; * 100        self.result_show.insert(&quot;end&quot;, f)  # 将以上空格添加到列表框        self.save_recent_folder_qty()  # 保存最新的文件夹数量    @staticmethod    def get_current_date():        time_stamp = time()        local_time = localtime(time_stamp)        str_time_month = int(strftime(&#39;%m&#39;, local_time))        str_time_day = int(strftime(&#39;%d&#39;, local_time))        return str(str_time_month) + &quot;.&quot; + str(str_time_day)    @staticmethod    def get_folder_qty():        &#39;&#39;&#39;从log.txt文件中获取最近的文件夹数量，若没有则返回0&#39;&#39;&#39;        log_file = os.getcwd() + &quot;\\log.txt&quot;        if os.path.exists(log_file):            with open(log_file, &quot;r&quot;) as f:                qty = f.readline()                return int(qty)        else:            return 0    def save_recent_folder_qty(self):        &quot;&quot;&quot;保存最近的文件夹数量&quot;&quot;&quot;        log_file = os.getcwd() + &quot;\\log.txt&quot;        with open(log_file, &quot;w&quot;) as f:            recent_qty = str(self.folderQty_entry.get())            f.write(recent_qty)if __name__ == &quot;__main__&quot;:    MainGUI()</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;批量新建文件夹&quot;&gt;&lt;a href=&quot;#批量新建文件夹&quot; class=&quot;headerlink&quot; title=&quot;批量新建文件夹&quot;&gt;&lt;/a&gt;批量新建文件夹&lt;/h1&gt;&lt;p&gt;程序实现在指定目录下批量生成文件夹。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="内置模块" scheme="http://example.com/categories/python/%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/"/>
    
    <category term="os" scheme="http://example.com/categories/python/%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/os/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="os" scheme="http://example.com/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>pandas | 一键更新Excel中的图表</title>
    <link href="http://example.com/2021/11/01/%E4%B8%80%E9%94%AE%E6%9B%B4%E6%96%B0Excel%E4%B8%AD%E7%9A%84%E5%9B%BE%E8%A1%A8/"/>
    <id>http://example.com/2021/11/01/%E4%B8%80%E9%94%AE%E6%9B%B4%E6%96%B0Excel%E4%B8%AD%E7%9A%84%E5%9B%BE%E8%A1%A8/</id>
    <published>2021-11-02T03:41:37.000Z</published>
    <updated>2021-11-05T02:08:35.614Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一键更新Excel中的图表"><a href="#一键更新Excel中的图表" class="headerlink" title="一键更新Excel中的图表"></a>一键更新Excel中的图表</h1><p><strong>场景：</strong> 小编每周都要更新最近12周的“生产订单周报”给老板，而且要对比最近两年相同周数的数据。主要是两张图，一张是“一周生产订单对比”，另一张是“各部门订单比例”。虽然在Excel表中建了数据透视表，但是每周都还是需要花时间进行一通凶猛的操作，才能搞定。可不可以每周一键更新，并得到这两张图呢？</p><span id="more"></span><p><strong>代码实现：</strong></p><pre><code>import pandas as pdfile = &#39;生产订单.xlsx&#39;df = pd.read_excel(file)df.fillna(0, inplace=True)df[&quot;数量&quot;] = df[&quot;数量&quot;].astype(&#39;int&#39;)# 增加周数字段df[&quot;周数&quot;] = df[&quot;日期&quot;].dt.weekdf[&quot;年份&quot;] = df[&quot;日期&quot;].dt.year# print(df.head())# 获取当前周数import datetimeyear, current_week, day = datetime.datetime.now().isocalendar()# print(current_week)# 只获取最近12周的数据df_required = df[(df[&quot;周数&quot;] &gt;= (current_week - 36)) &amp; (df[&quot;周数&quot;] &lt;= (current_week - 24))]# print(df_required[&#39;年份&#39;])result = df_required.groupby([&quot;周数&quot;, &quot;年份&quot;])[&#39;数量&#39;].sum().reset_index()  # reset后才是DF，不然是Series# print(result)## # print(result[result[&quot;年份&quot;]==2019][&quot;数量&quot;])## 如果有中文，需要配置中文字体，不然会显示成方框import matplotlib as mplimport matplotlib.pyplot as pltimport numpy as npplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;SimHei&#39;]  # 用来正常显示中文标签# 数据和标签qty_2019 = result[result[&quot;年份&quot;] == 2019][&quot;数量&quot;]qty_2020 = result[result[&quot;年份&quot;] == 2020][&quot;数量&quot;]print(qty_2020)x_label = result[result[&quot;年份&quot;] == 2019][&quot;周数&quot;]# 设置字体大小mpl.rcParams[&#39;font.size&#39;] = 12# 设置图片大小plt.figure(figsize=(12, 6))# 设置柱形图宽度bar_width = 0.45index = np.arange(13)qty_2019_list = [qty for qty in qty_2019]qty_2020_list = [qty for qty in qty_2020]print(f&quot;index: &#123;len(index)&#125;&quot;)print(len(qty_2019_list))print(len(qty_2020_list))# 绘制2019年数据qty1 = plt.bar(index, qty_2019, bar_width, color=&#39;#336633&#39;, label=&quot;2019&quot;)# 绘制2020年数据qty2 = plt.bar(index + bar_width, qty_2020, bar_width, color=&#39;#6666CC&#39;, label=&quot;2020&quot;)# X,Y轴标题plt.xticks(index + bar_width, x_label)plt.xlabel(&quot;周数&quot;, fontsize=14)plt.ylabel(&quot;产品数量/台&quot;, fontsize=14)# 图表标题plt.title(u&#39;每周生产订单对比&#39;, fontsize=20)# 图例显示plt.legend()# 添加数据标签def add_labels(qtys):    for qty in qtys:        height = qty.get_height()        plt.text(qty.get_x() + qty.get_width() / 2, height, height, ha=&#39;center&#39;, va=&#39;bottom&#39;)        # 柱形图边缘用白色填充        qty.set_edgecolor(&#39;white&#39;)add_labels(qty1)add_labels(qty2)plt.savefig(&#39;prod_order.png&#39;)# 按部门计算订单数量order_2019 = df_required[df_required[&quot;年份&quot;] == 2019]# print(order_2019)dept_2019 = order_2019[&quot;部门&quot;].value_counts()# print(dept_2019)order_2020 = df_required[df_required[&quot;年份&quot;] == 2020]# print(order_2020)dept_2020 = order_2020[&quot;部门&quot;].value_counts()# print(dept_2020)# 绘制饼图import matplotlib as mplimport numpy as npplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;SimHei&#39;]  # 用来正常显示中文标签mpl.rcParams[&#39;font.size&#39;] = 12fig = plt.figure(figsize=(12, 6))axl = fig.add_subplot(1, 2, 1)def my_label(pct, allvals):    absolute = int(pct / 100. * np.sum(allvals))    return &quot;&#123;:.1f&#125;%\n(&#123;:d&#125;)&quot;.format(pct, absolute)explode = (0.1, 0, 0, 0, 0)plt.pie(dept_2019, autopct=lambda x: my_label(x, dept_2019), explode=explode, labels=dept_2019.index, shadow=True,        startangle=150)plt.title(&quot;各部门订单比例\n(最近12周)_2019&quot;, fontsize=20)# plt.label(&quot;2019&quot;,fontsize = 14)ax2 = fig.add_subplot(1, 2, 2)plt.pie(dept_2020, autopct=lambda x: my_label(x, dept_2020), explode=explode, labels=dept_2020.index, shadow=True,        startangle=150)plt.title(&quot;各部门订单比例\n(最近12周)_2020&quot;, fontsize=20)plt.savefig(&#39;order_byDept.png&#39;)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一键更新Excel中的图表&quot;&gt;&lt;a href=&quot;#一键更新Excel中的图表&quot; class=&quot;headerlink&quot; title=&quot;一键更新Excel中的图表&quot;&gt;&lt;/a&gt;一键更新Excel中的图表&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;场景：&lt;/strong&gt; 小编每周都要更新最近12周的“生产订单周报”给老板，而且要对比最近两年相同周数的数据。主要是两张图，一张是“一周生产订单对比”，另一张是“各部门订单比例”。虽然在Excel表中建了数据透视表，但是每周都还是需要花时间进行一通凶猛的操作，才能搞定。可不可以每周一键更新，并得到这两张图呢？&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="pandas" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/"/>
    
    
    <category term="matplotlib" scheme="http://example.com/tags/matplotlib/"/>
    
    <category term="pandas" scheme="http://example.com/tags/pandas/"/>
    
    <category term="numpy" scheme="http://example.com/tags/numpy/"/>
    
    <category term="datetime" scheme="http://example.com/tags/datetime/"/>
    
  </entry>
  
  <entry>
    <title>生成器 | 生成器输出小于maxnum的偶数或奇数</title>
    <link href="http://example.com/2021/11/01/%E7%94%9F%E6%88%90%E5%99%A8%E8%BE%93%E5%87%BA%E5%B0%8F%E4%BA%8Emaxnum%E7%9A%84%E5%81%B6%E6%95%B0%E6%88%96%E5%A5%87%E6%95%B0/"/>
    <id>http://example.com/2021/11/01/%E7%94%9F%E6%88%90%E5%99%A8%E8%BE%93%E5%87%BA%E5%B0%8F%E4%BA%8Emaxnum%E7%9A%84%E5%81%B6%E6%95%B0%E6%88%96%E5%A5%87%E6%95%B0/</id>
    <published>2021-11-01T09:51:53.000Z</published>
    <updated>2021-11-02T02:29:10.162Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生成器输出小于max-num的偶数或奇数"><a href="#生成器输出小于max-num的偶数或奇数" class="headerlink" title="生成器输出小于max_num的偶数或奇数"></a>生成器输出小于max_num的偶数或奇数</h1><p>代码：</p><pre><code># 1.输出小于max_num的偶数或奇数def odd(max_num):        i = 1    while i &lt; max_num:        if i % 2 == 0:  # if % 2 == 1可生成奇数            yield i        i += 1g = odd(10)for n in g:    print(n)# 2.输出任意个偶数或奇数def odd():i = 2while i:    if i % 2 == 0:  # if % 2 == 1可生成奇数        yield i    i += 1g = odd()for i in range(100):    print(next(g))</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;生成器输出小于max-num的偶数或奇数&quot;&gt;&lt;a href=&quot;#生成器输出小于max-num的偶数或奇数&quot; class=&quot;headerlink&quot; title=&quot;生成器输出小于max_num的偶数或奇数&quot;&gt;&lt;/a&gt;生成器输出小于max_num的偶数或奇数&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="生成器" scheme="http://example.com/categories/python/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
    
    <category term="生成器" scheme="http://example.com/tags/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>生成器 | 生成器输出fibonacci数列</title>
    <link href="http://example.com/2021/11/01/%E7%94%9F%E6%88%90%E5%99%A8%E8%BE%93%E5%87%BAfibonacci%E6%95%B0%E5%88%97/"/>
    <id>http://example.com/2021/11/01/%E7%94%9F%E6%88%90%E5%99%A8%E8%BE%93%E5%87%BAfibonacci%E6%95%B0%E5%88%97/</id>
    <published>2021-11-01T09:47:51.000Z</published>
    <updated>2021-11-01T09:49:36.831Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生成器输出小于max-num的fibonacci数列"><a href="#生成器输出小于max-num的fibonacci数列" class="headerlink" title="生成器输出小于max_num的fibonacci数列"></a>生成器输出小于max_num的fibonacci数列</h1><p>代码：</p><pre><code>def feb(max_num):    n_1 = 1    n_2 = 1    n = 0    while n &lt; max_num:        if n == 0 or n == 1:            yield 1            n += 1        else:            yield n_1 + n_2            new_n_2 = n_1            n_1 = n_1 + n_2            n_2 = new_n_2            n += 1g = feb(5)for n in g:    print(n)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;生成器输出小于max-num的fibonacci数列&quot;&gt;&lt;a href=&quot;#生成器输出小于max-num的fibonacci数列&quot; class=&quot;headerlink&quot; title=&quot;生成器输出小于max_num的fibonacci数列&quot;&gt;&lt;/a&gt;生成器输出小于m</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="生成器" scheme="http://example.com/categories/python/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
    
    <category term="生成器" scheme="http://example.com/tags/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>生成器 | 生成器输出质数</title>
    <link href="http://example.com/2021/11/01/%E7%94%9F%E6%88%90%E5%99%A8%E8%BE%93%E5%87%BA%E8%B4%A8%E6%95%B0/"/>
    <id>http://example.com/2021/11/01/%E7%94%9F%E6%88%90%E5%99%A8%E8%BE%93%E5%87%BA%E8%B4%A8%E6%95%B0/</id>
    <published>2021-11-01T09:07:02.000Z</published>
    <updated>2021-11-01T09:29:27.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生成器输出小于max-num的质数"><a href="#生成器输出小于max-num的质数" class="headerlink" title="生成器输出小于max_num的质数"></a>生成器输出小于max_num的质数</h1><p>通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。<br>而且，创建一个包含成百上千完个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前<br>面几个元素，那后面绝大多数元素占用的空间都白白浪费了。生成器有效的解决了这个问题。</p><span id="more"></span><p>代码：</p><pre><code>def factor(max_num):    # 这是一个函数  用于输出所有小于max_num的质数    factor_list = []    n = 2    while n &lt; max_num:        find = False        for f in factor_list:            # 先看看列表里面有没有能整除它的            if n % f == 0:                find = True                break        if not find:            factor_list.append(n)            yield n        n += 1g = factor(10)for n in g:    print(n)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;生成器输出小于max-num的质数&quot;&gt;&lt;a href=&quot;#生成器输出小于max-num的质数&quot; class=&quot;headerlink&quot; title=&quot;生成器输出小于max_num的质数&quot;&gt;&lt;/a&gt;生成器输出小于max_num的质数&lt;/h1&gt;&lt;p&gt;通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。&lt;br&gt;而且，创建一个包含成百上千完个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前&lt;br&gt;面几个元素，那后面绝大多数元素占用的空间都白白浪费了。生成器有效的解决了这个问题。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="生成器" scheme="http://example.com/categories/python/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
    
    <category term="生成器" scheme="http://example.com/tags/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>requests | Python爬取博客的所有文章并存为带目录的word文档</title>
    <link href="http://example.com/2021/10/31/Python%E7%88%AC%E5%8F%96%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E7%AB%A0%E5%B9%B6%E5%AD%98%E4%B8%BA%E5%B8%A6%E7%9B%AE%E5%BD%95%E7%9A%84word%E6%96%87%E6%A1%A3/"/>
    <id>http://example.com/2021/10/31/Python%E7%88%AC%E5%8F%96%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E7%AB%A0%E5%B9%B6%E5%AD%98%E4%B8%BA%E5%B8%A6%E7%9B%AE%E5%BD%95%E7%9A%84word%E6%96%87%E6%A1%A3/</id>
    <published>2021-10-31T14:07:12.000Z</published>
    <updated>2021-10-31T14:09:22.349Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python爬取博客的所有文章并存为带目录的word文档"><a href="#Python爬取博客的所有文章并存为带目录的word文档" class="headerlink" title="Python爬取博客的所有文章并存为带目录的word文档"></a>Python爬取博客的所有文章并存为带目录的word文档</h1><p>Python爬取博客的所有文章并存为带目录的word文档,结果非常美丽！从此阅读博客文章轻松多了！！！</p><span id="more"></span><p>实现代码：</p><pre><code>import requestsfrom bs4 import BeautifulSoupurl = f&#39;http://blog.sina.com.cn/s/articlelist_5119330124_0_1.html&#39;wb_data = requests.get(url)soup = BeautifulSoup(wb_data.content)# 获取当页所有文章的标题和链接# print(soup.select(&#39;.atc_title&#39;))# 获取当页所有文章的发表时间# print(soup.select(&#39;.atc_tm&#39;))# print(soup.select(&#39;.atc_title&#39;)[0].select(&#39;a&#39;))# [&lt;a href=&quot;http://blog.sina.com.cn/s/blog_13122c74c0102zdsy.html&quot; target=&quot;_blank&quot; title=&quot;&quot;&gt;投资难在慢成毁于速成&lt;/a&gt;]# print(soup.select(&#39;.atc_title&#39;)[0].select(&#39;a&#39;)[0].get(&quot;href&quot;))# http://blog.sina.com.cn/s/blog_13122c74c0102zdsy.html# print(soup.select(&#39;.atc_title&#39;)[0].select(&#39;a&#39;)[0].text)# print(soup.select(&#39;.atc_tm&#39;)[0].text)# 获取所有博客文章的链接import requestsfrom bs4 import BeautifulSoupall_links = &#123;&#125;for i in range(1, 6):    url = f&#39;http://blog.sina.com.cn/s/articlelist_5119330124_0_&#123;i&#125;.html&#39;    wb_data = requests.get(url)    soup = BeautifulSoup(wb_data.content)    links = soup.select(&#39;.atc_title&#39;)    times = soup.select(&#39;.atc_tm&#39;)    for i in range(len(links)):        http_link = links[i].select(&#39;a&#39;)[0].get(&#39;href&#39;)        title = links[i].text.strip()        time = times[i].text        all_links[title] = [http_link, time]# print(len(all_links))# 获取单篇文章中的文字url = &#39;http://blog.sina.com.cn/s/blog_13122c74c0102zbt3.html&#39;wb_data = requests.get(url)soup = BeautifulSoup(wb_data.content)article = soup.select(&quot;.articalContent.newfont_family&quot;)# print(article)# print(article[0].text)# print(article[0].text.replace(&quot;\xa0&quot;, &quot;&quot;))# 获取单篇文章中的图片链接url = &#39;http://blog.sina.com.cn/s/blog_13122c74c0102zbud.html&#39;wb_data = requests.get(url)soup = BeautifulSoup(wb_data.content)img_link = soup.select(&quot;.articalContent.newfont_family&quot;)[0].find_all(&quot;img&quot;)[0].get(&quot;real_src&quot;)# 图片下载函数def downloadImg(img_url, file_path):    req = requests.get(url=img_url)    with open(file_path, &#39;wb&#39;) as f:        f.write(req.content)downloadImg(r&#39;http://s8.sinaimg.cn/middle/005AsbCIzy7vEfdM1M599&#39;,            r&#39;..\实例67_Python爬取博客的所有文章并存为带目录的word文档\1.jpg&#39;)# 写入标题，内容到word文件import docxfrom docx.oxml.ns import qn  # 用于应用中文字体def to_word(all_links):    header = &#123;        &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) &quot;                      &quot;Chrome/49.0.2623.221 Safari/537.36 SE 2.X MetaSr 1.0&quot;&#125;    doc = docx.Document()  # 新建word文档    doc.styles[&#39;Normal&#39;].font.name = u&#39;宋体&#39;    doc.styles[&#39;Normal&#39;]._element.rPr.rFonts.set(qn(&#39;w:eastAsia&#39;), u&#39;宋体&#39;)    counter = 0  # 计数器，用于记录写入word的文章数    for title in all_links.keys():        doc.add_heading(title, 1)        date = all_links[title][1][:10]  # 只取日期，不要时间        doc.add_paragraph(date)        wb_data = requests.get(all_links[title][0], headers=header)        soup = BeautifulSoup(wb_data.content)        article = soup.select(&quot;.articalContent.newfont_family&quot;)        # 有些文章被加密，获取不到内容，此时article为空，所以加个if语句判断        if article:            text = article[0].text.replace(&quot;\xa0&quot;, &quot;&quot;)            doc.add_paragraph(text)            print(f&quot;写入文章 &#123;title&#125; 。&quot;)            counter += 1    print(f&quot;共写入 &#123;counter&#125; 篇文章。&quot;)    doc.save(&quot;新浪微博文章.docx&quot;)to_word(all_links)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Python爬取博客的所有文章并存为带目录的word文档&quot;&gt;&lt;a href=&quot;#Python爬取博客的所有文章并存为带目录的word文档&quot; class=&quot;headerlink&quot; title=&quot;Python爬取博客的所有文章并存为带目录的word文档&quot;&gt;&lt;/a&gt;Python爬取博客的所有文章并存为带目录的word文档&lt;/h1&gt;&lt;p&gt;Python爬取博客的所有文章并存为带目录的word文档,结果非常美丽！从此阅读博客文章轻松多了！！！&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="requests" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="requests" scheme="http://example.com/tags/requests/"/>
    
    <category term="BeautifulSoup" scheme="http://example.com/tags/BeautifulSoup/"/>
    
  </entry>
  
  <entry>
    <title>win32com | 识别加密word文件</title>
    <link href="http://example.com/2021/10/31/%E8%AF%86%E5%88%AB%E5%8A%A0%E5%AF%86word%E6%96%87%E4%BB%B6/"/>
    <id>http://example.com/2021/10/31/%E8%AF%86%E5%88%AB%E5%8A%A0%E5%AF%86word%E6%96%87%E4%BB%B6/</id>
    <published>2021-10-31T13:32:56.000Z</published>
    <updated>2021-11-01T09:04:03.208Z</updated>
    
    <content type="html"><![CDATA[<h1 id="识别加密word文件"><a href="#识别加密word文件" class="headerlink" title="识别加密word文件"></a>识别加密word文件</h1><p>Python本身是难以识别word文件的加密状态的，那我们可以考虑利用程序在处理有密码的文档的时候的报错信息来进行处理。word文件有两种密码，一种是“打开密码”，另一种是“修改密码”。对于前者，若不输入正确的密码，是无法打开文件查看内容的；对于后者，即使不知道密码，还是可以用只读模式打开文件，查看内容并另存为新的文件的。<br>因此对于设置了“修改密码”的doc文件，并不影响用如下程序另存为docx文件。只是在另存之前，窗口会弹出如下对话框，我们只需要点击一下“只读”即可，程序就能正常运行下去。<br>如果设置了“打开密码”，程序在运行的时候也会弹出对话框，让输入密码。如果输入正确的密码，程序也是可以运行的；如果不知道密码或输入错误密码，则程序会出现如下的“com_error”错误。如果不知道密码，可以加入try..except..语句，让程序在except语句中将这个文件移动到名字为“有密码文件”的文件夹，以便后续处理。</p><span id="more"></span><p>实现代码：</p><pre><code>from win32com import client as wc  # 导入模块file = r&quot;C:\Users\dywei\python\python_excel\实例65_Python区分出加密的word文件\doc文件\\测试-有打开密码.doc&quot;word = wc.Dispatch(&quot;Word.Application&quot;)  # 打开word应用程序doc = word.Documents.Open(file)  # 打开word文件doc.SaveAs(&quot;&#123;&#125;x&quot;.format(file), 12)  # 另存为后缀为&quot;.docx&quot;的文件，其中参数12指docx文件doc.Close()  # 关闭原来word文件word.Quit()# 增加异常处理语句import shutil  # 用于操作文件和文件夹from win32com import client as wcfile = r&quot;C:\Users\dywei\python\python_excel\实例65_Python区分出加密的word文件\doc文件\\测试-有打开密码.doc&quot;try:    word = wc.Dispatch(&quot;Word.Application&quot;)  # 打开word应用程序    doc = word.Documents.Open(file)  # 打开word文件    doc.SaveAs(&quot;&#123;&#125;x&quot;.format(file), 12)  # 另存为后缀为&quot;.docx&quot;的文件，其中参数12指docx文件    doc.Close()  # 关闭原来word文件    word.Quit()except:    # 将有密码的文件移动到专门的文件夹    shutil.move(file, r&quot;C:\Users\dywei\python\python_excel\实例65_Python区分出加密的word文件\有密码文件&quot;)    print(f&quot;已移动加密文件 &#123;file&#125;&quot;)# #文件有“打开密码”的情况# import docx# doc = docx.Document(&#39;docx文件\\报告-有打开密码.docx&#39;)# PackageNotFoundError: Package not found at &#39;docx文件\报告-有打开密码.docx&#39;# 文件有“修改密码”的情况import docxdoc = docx.Document(&#39;docx文件\\报告-有修改密码.docx&#39;)p = doc.paragraphs[0]pNew = p.insert_paragraph_before()run = pNew.add_run(&quot;测试&quot;)doc.save(&quot;docx文件\\报告-有修改密码.docx&quot;)import docximport shutilfile = &quot;docx文件\\报告-有打开密码.docx&quot;try:    doc = docx.Document(file)    passexcept:    shutil.move(file, &#39;有密码文件&#39;)    print(f&quot;已移动加密文件 &#123;file&#125; 到指定文件夹&quot;)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;识别加密word文件&quot;&gt;&lt;a href=&quot;#识别加密word文件&quot; class=&quot;headerlink&quot; title=&quot;识别加密word文件&quot;&gt;&lt;/a&gt;识别加密word文件&lt;/h1&gt;&lt;p&gt;Python本身是难以识别word文件的加密状态的，那我们可以考虑利用程序在处理有密码的文档的时候的报错信息来进行处理。word文件有两种密码，一种是“打开密码”，另一种是“修改密码”。对于前者，若不输入正确的密码，是无法打开文件查看内容的；对于后者，即使不知道密码，还是可以用只读模式打开文件，查看内容并另存为新的文件的。&lt;br&gt;因此对于设置了“修改密码”的doc文件，并不影响用如下程序另存为docx文件。只是在另存之前，窗口会弹出如下对话框，我们只需要点击一下“只读”即可，程序就能正常运行下去。&lt;br&gt;如果设置了“打开密码”，程序在运行的时候也会弹出对话框，让输入密码。如果输入正确的密码，程序也是可以运行的；如果不知道密码或输入错误密码，则程序会出现如下的“com_error”错误。如果不知道密码，可以加入try..except..语句，让程序在except语句中将这个文件移动到名字为“有密码文件”的文件夹，以便后续处理。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="win32com" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/win32com/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="win32com" scheme="http://example.com/tags/win32com/"/>
    
    <category term="python-docx" scheme="http://example.com/tags/python-docx/"/>
    
    <category term="shutil" scheme="http://example.com/tags/shutil/"/>
    
  </entry>
  
</feed>
