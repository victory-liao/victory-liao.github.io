<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Victory&#39;s Blog</title>
  
  <subtitle>非淡泊无以明志，非宁静无以致远</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-07-18T07:28:55.820Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>victory-liao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode | 617.合并二叉树</title>
    <link href="http://example.com/2022/07/17/%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://example.com/2022/07/17/%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2022-07-18T07:21:21.000Z</published>
    <updated>2022-07-18T07:28:55.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617.合并二叉树"></a>617.合并二叉树</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两棵二叉树： root1 和 root2 。<br>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。<br>返回合并后的二叉树。<br>注意: 合并过程必须从两个树的根节点开始。</p><p>示例 1：<br>输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]<br>输出：[3,4,5,5,4,null,7]</p><p><a href="https://leetcode.cn/problems/merge-two-binary-trees">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>深度优先搜索<br>使用深度优先搜索合并两个二叉树。从根节点开始遍历两个二叉树，并将对应的节点进行合并。</li></ol><p>两个二叉树的对应节点可能存在以下三种情况，对于每种情况使用不同的合并方式。<br>（1）如果两个二叉树的对应节点都为空，则合并后的二叉树的对应节点也为空；<br>（2）如果两个二叉树的对应节点只有一个为空，则合并后的二叉树的对应节点为其中的非空节点；<br>（3）如果两个二叉树的对应节点都不为空，则合并后的二叉树的对应节点的值为两个二叉树的对应节点的值之和，此时需要显性合并两个节点。<br>对一个节点进行合并之后，还要对该节点的左右子树分别进行合并。这是一个递归的过程。<br>2. 广度优先搜索<br>使用广度优先搜索合并两个二叉树。首先判断两个二叉树是否为空，如果两个二叉树都为空，则合并后的二叉树也为空，如果只有一个二叉树为空，则合并后的二叉树为另一个非空的二叉树。</p><p>如果两个二叉树都不为空，则首先计算合并后的根节点的值，然后从合并后的二叉树与两个原始二叉树的根节点开始广度优先搜索，从根节点开始同时遍历每个二叉树，并将对应的节点进行合并。</p><p>使用三个队列分别存储合并后的二叉树的节点以及两个原始二叉树的节点。初始时将每个二叉树的根节点分别加入相应的队列。每次从每个队列中取出一个节点，判断两个原始二叉树的节点的左右子节点是否为空。如果两个原始二叉树的当前节点中至少有一个节点的左子节点不为空，则合并后的二叉树的对应节点的左子节点也不为空。对于右子节点同理。</p><p>如果合并后的二叉树的左子节点不为空，则需要根据两个原始二叉树的左子节点计算合并后的二叉树的左子节点以及整个左子树。考虑以下两种情况：<br>（1）如果两个原始二叉树的左子节点都不为空，则合并后的二叉树的左子节点的值为两个原始二叉树的左子节点的值之和，在创建合并后的二叉树的左子节点之后，将每个二叉树中的左子节点都加入相应的队列；<br>（2）如果两个原始二叉树的左子节点有一个为空，即有一个原始二叉树的左子树为空，则合并后的二叉树的左子树即为另一个原始二叉树的左子树，此时也不需要对非空左子树继续遍历，因此不需要将左子节点加入队列。<br>对于右子节点和右子树，处理方法与左子节点和左子树相同。</p><span id="more"></span><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class TreeNode(object):  # Definition for a binary tree node.    def __init__(self, val=0, left=None, right=None):        self.val = val        self.left = left        self.right = right                class Solution(object):    def mergeTrees(self, root1, root2):        &quot;&quot;&quot;        深度优先搜索        :type root1: TreeNode        :type root2: TreeNode        :rtype: TreeNode        &quot;&quot;&quot;        if not root1:            return root2        if not root2:            return root1        merged = TreeNode(root1.val + root2.val)        merged.left = self.mergeTrees(root1.left, root2.left)        merged.right = self.mergeTrees(root1.right, root2.right)        return merged        def mergeTrees1(self, root1, root2):        &quot;&quot;&quot;广度优先搜索&quot;&quot;&quot;        import collections        if not root1:            return root2        if not root2:            return root1                merged = TreeNode(root1.val + root2.val)        queue = collections.deque([merged])        queue1 = collections.deque([root1])        queue2 = collections.deque([root2])                while queue1 and queue2:            node = queue.popleft()            node1 = queue1.popleft()            node2 = queue2.popleft()            left1, right1 = node1.left, node1.right            left2, right2 = node2.left, node2.right                        if left1 and left2:                left = TreeNode(left1.val + left2.val)                node.left = left                queue.append(left)                queue1.append(left1)                queue2.append(left2)            elif left1:                node.left = left1            elif left2:                node.left = left2                        if right1 and right2:                right = TreeNode(right1.val + right2.val)                node.right = right                queue.append(right)                queue1.append(right1)                queue2.append(right2)            elif right1:                node.right = right1            elif right2:                node.right = right2        return merged        def preorder_traverse(self, root):        if not root:            return        print(root.val, end=&quot; &quot;)        self.preorder_traverse(root.left)        self.preorder_traverse(root.right)                if __name__ == &quot;__main__&quot;:    slt = Solution()        root1 = TreeNode(1)    node12 = TreeNode(3)    node13 = TreeNode(2)    node14 = TreeNode(5)    root1.left = node12    root1.right = node13    node12.left = node14        print(&quot;root1:&quot;, end=&quot;[&quot;)    slt.preorder_traverse(root1)    print(&quot;]&quot;)        root2 = TreeNode(2)    node22 = TreeNode(1)    node23 = TreeNode(3)    node24 = TreeNode(4)    node25 = TreeNode(7)    root2.left = node22    root2.right = node23    node22.right = node24    node23.right = node25        print(&quot;root2:&quot;, end=&quot;[&quot;)    slt.preorder_traverse(root2)    print(&quot;]&quot;)        # merged_tree = slt.mergeTrees(root1, root2)    merged_tree = slt.mergeTrees1(root1, root2)        print(&quot;merger tree:&quot;, end=&quot;[&quot;)    slt.preorder_traverse(merged_tree)    print(&quot;]&quot;)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;617-合并二叉树&quot;&gt;&lt;a href=&quot;#617-合并二叉树&quot; class=&quot;headerlink&quot; title=&quot;617.合并二叉树&quot;&gt;&lt;/a&gt;617.合并二叉树&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你两棵二叉树： root1 和 root2 。&lt;br&gt;想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。&lt;br&gt;返回合并后的二叉树。&lt;br&gt;注意: 合并过程必须从两个树的根节点开始。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;br&gt;输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]&lt;br&gt;输出：[3,4,5,5,4,null,7]&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/merge-two-binary-trees&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;深度优先搜索&lt;br&gt;使用深度优先搜索合并两个二叉树。从根节点开始遍历两个二叉树，并将对应的节点进行合并。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;两个二叉树的对应节点可能存在以下三种情况，对于每种情况使用不同的合并方式。&lt;br&gt;（1）如果两个二叉树的对应节点都为空，则合并后的二叉树的对应节点也为空；&lt;br&gt;（2）如果两个二叉树的对应节点只有一个为空，则合并后的二叉树的对应节点为其中的非空节点；&lt;br&gt;（3）如果两个二叉树的对应节点都不为空，则合并后的二叉树的对应节点的值为两个二叉树的对应节点的值之和，此时需要显性合并两个节点。&lt;br&gt;对一个节点进行合并之后，还要对该节点的左右子树分别进行合并。这是一个递归的过程。&lt;br&gt;2. 广度优先搜索&lt;br&gt;使用广度优先搜索合并两个二叉树。首先判断两个二叉树是否为空，如果两个二叉树都为空，则合并后的二叉树也为空，如果只有一个二叉树为空，则合并后的二叉树为另一个非空的二叉树。&lt;/p&gt;
&lt;p&gt;如果两个二叉树都不为空，则首先计算合并后的根节点的值，然后从合并后的二叉树与两个原始二叉树的根节点开始广度优先搜索，从根节点开始同时遍历每个二叉树，并将对应的节点进行合并。&lt;/p&gt;
&lt;p&gt;使用三个队列分别存储合并后的二叉树的节点以及两个原始二叉树的节点。初始时将每个二叉树的根节点分别加入相应的队列。每次从每个队列中取出一个节点，判断两个原始二叉树的节点的左右子节点是否为空。如果两个原始二叉树的当前节点中至少有一个节点的左子节点不为空，则合并后的二叉树的对应节点的左子节点也不为空。对于右子节点同理。&lt;/p&gt;
&lt;p&gt;如果合并后的二叉树的左子节点不为空，则需要根据两个原始二叉树的左子节点计算合并后的二叉树的左子节点以及整个左子树。考虑以下两种情况：&lt;br&gt;（1）如果两个原始二叉树的左子节点都不为空，则合并后的二叉树的左子节点的值为两个原始二叉树的左子节点的值之和，在创建合并后的二叉树的左子节点之后，将每个二叉树中的左子节点都加入相应的队列；&lt;br&gt;（2）如果两个原始二叉树的左子节点有一个为空，即有一个原始二叉树的左子树为空，则合并后的二叉树的左子树即为另一个原始二叉树的左子树，此时也不需要对非空左子树继续遍历，因此不需要将左子节点加入队列。&lt;br&gt;对于右子节点和右子树，处理方法与左子节点和左子树相同。&lt;/p&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%A0%91/"/>
    
    <category term="617.合并二叉树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%A0%91/617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 543.二叉树的直径</title>
    <link href="http://example.com/2022/07/16/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
    <id>http://example.com/2022/07/16/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</id>
    <published>2022-07-17T03:09:43.000Z</published>
    <updated>2022-07-17T03:22:45.902Z</updated>
    
    <content type="html"><![CDATA[<h1 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543.二叉树的直径"></a>543.二叉树的直径</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><p>示例 :<br>给定二叉树</p><pre><code>      1     / \    2   3   / \       4   5    </code></pre><p>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。<br>注意：两结点之间的路径长度是以它们之间边的数目表示。</p><p><a href="https://leetcode.cn/problems/diameter-of-binary-tree">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>深度优先搜索<br>首先我们知道<strong>一条路径的长度为该路径经过的节点数减一，所以求直径（即求路径长度的最大值）等效于求路径经过节点数的最大值减一</strong>。<br>而任意一条路径均可以被看作由某个节点为起点，从其左儿子和右儿子向下遍历的路径拼接得到。</li></ol><p>假设我们知道对于该节点的左儿子向下遍历经过最多的节点数 LLL （即以左儿子为根的子树的深度） 和其右儿子向下遍历经过最多的节点数 RRR （即以右儿子为根的子树的深度），那么以该节点为起点的路径经过节点数的最大值即为 L+R+1L+R+1L+R+1 。<br>我们记节点 node 为起点的路径经过节点数的最大值为 dnode​ ，那么二叉树的直径就是所有节点 dnode​的最大值减一。</p><p>算法流程为：我们定义一个递归函数 depth(node) 计算 dnode​，函数返回该节点为根的子树的深度。先递归调用左儿子和右儿子求得它们为根的子树的深度 L 和 R ，则该节点为根的子树的深度即为<br>max(L,R)+1，该节点的 dnode​值为 L+R+1，递归搜索每个节点并设一个全局变量 ans 记录 dnode​的最大值，最后返回 ans-1 即为树的直径。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class TreeNode(object):  # Definition for a binary tree node.    def __init__(self, val=0, left=None, right=None):        self.val = val        self.left = left        self.right = rightclass Solution(object):    def diameterOfBinaryTree(self, root):        &quot;&quot;&quot;        这种解法路径必须经过根节点，由题目可知路径可能穿过        也可能不穿过根节点，故此解法不符合题意        :type root: TreeNode        :rtype: int        &quot;&quot;&quot;        left = self.get_depth(root.left)        right = self.get_depth(root.right)        return left + right        def get_depth(self, root):        if not root:            return 0        left_depth = self.get_depth(root.left)        right_depth = self.get_depth(root.right)        return max(left_depth, right_depth) + 1        def diameterOfBinaryTree1(self, root):        self.ans = 1        def depth(node):            if not node:                return 0            L = depth(node.left)            R = depth(node.right)            self.ans = max(self.ans, L + R + 1)            return max(L, R) + 1        depth(root)        return self.ans - 1  # 一条路径的长度为该路径经过的节点数减一if __name__ == &quot;__main__&quot;:    slt = Solution()    root = TreeNode(1)    node2 = TreeNode(2)    node3 = TreeNode(3)    node4 = TreeNode(4)    node5 = TreeNode(5)    root.left = node2    root.right = node3    node2.left = node4    node2.right = node5    # diameter = slt.diameterOfBinaryTree(root)    diameter = slt.diameterOfBinaryTree1(root)    print(&quot;diameter:&quot;, diameter)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;543-二叉树的直径&quot;&gt;&lt;a href=&quot;#543-二叉树的直径&quot; class=&quot;headerlink&quot; title=&quot;543.二叉树的直径&quot;&gt;&lt;/a&gt;543.二叉树的直径&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;head</summary>
      
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%A0%91/"/>
    
    <category term="543.二叉树的直径" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%A0%91/543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 226.翻转二叉树</title>
    <link href="http://example.com/2022/07/16/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://example.com/2022/07/16/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2022-07-16T13:47:31.000Z</published>
    <updated>2022-07-16T13:54:40.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226.翻转二叉树"></a>226.翻转二叉树</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</p><p>示例 1：<br>输入：root = [4,2,7,1,3,6,9]<br>输出：[4,7,2,9,6,3,1]</p><p><a href="https://leetcode.cn/problems/invert-binary-tree">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>递归法<br>分析题目输入和输出发现，输出的左右子树的位置跟输入正好是相反的，于是我们可以递归的交换左右子树来实现。<br>其实就是交换一下左右节点，然后再递归的交换左节点，右节点<br>递归的两个条件如下：<br> 终止条件：当前节点为 null 时返回<br> 交换当前节点的左右节点，再递归的交换当前节点的左节点，递归的交换当前节点的右节点时间复杂度：每个元素都必须访问一次，所以是 O(n)<br>空间复杂度：最坏的情况下，需要存放 O(h) 个函数调用(h是树的高度)，所以是 O(h)<span id="more"></span></li><li>迭代法<br>递归实现也就是深度优先遍历的方式，那么对应的就是广度优先遍历。<br>广度优先遍历需要额外的数据结构–队列，来存放临时遍历到的元素。</li></ol><p>我们需要先将根节点放入到队列中，然后不断的迭代队列中的元素。<br>对当前元素调换其左右子树的位置，然后：<br>    判断其左子树是否为空，不为空就放入队列中<br>    判断其右子树是否为空，不为空就放入队列中</p><p>时间复杂度：同样每个节点都需要入队列/出队列一次，所以是 O(n)<br>空间复杂度：最坏的情况下会包含所有的叶子节点，完全二叉树叶子节点是 n/2个，所以时间复杂度是 0(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class TreeNode(object):  # Definition for a binary tree node.    def __init__(self, val=0, left=None, right=None):        self.val = val        self.left = left        self.right = rightclass Solution(object):    def invertTree(self, root):        &quot;&quot;&quot;        递归法（深度优先遍历方式）        :type root: TreeNode        :rtype: TreeNode        &quot;&quot;&quot;        if not root:            return root                left = self.invertTree(root.left)        right = self.invertTree(root.right)        root.left, root.right = right, left        return root        def invertTree1(self, root):        &quot;&quot;&quot;迭代法（广度优先遍历方式，需要辅助队列）&quot;&quot;&quot;        if not root:            return root        # 将二叉树的节点逐层放入队列中，再迭代处理队列中的元素        queue = [root]        while queue:            # 每次都从队列中拿一个节点，并交换这个节点的左右子树            tmp = queue.pop(0)            tmp.left, tmp.right = tmp.right, tmp.left            # 如果当前节点的左子树不空，则放入队列等待后续处理            if tmp.left:                queue.append(tmp.left)            if tmp.right:                queue.append(tmp.right)        return root        def preorder_traverse(self, root):        if not root:            return        print(root.val)        self.preorder_traverse(root.left)        self.preorder_traverse(root.right)if __name__ == &quot;__main__&quot;:    root = TreeNode(4)    node2 = TreeNode(2)    node3 = TreeNode(7)    node4 = TreeNode(1)    node5 = TreeNode(3)    node6 = TreeNode(6)    node7 = TreeNode(9)    root.left = node2    root.right = node3    node2.left = node4    node2.right = node5    node3.left = node6    node3.right = node7        slt = Solution()    # invertTree = slt.invertTree(root)    invertTree = slt.invertTree1(root)    slt.preorder_traverse(invertTree)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;226-翻转二叉树&quot;&gt;&lt;a href=&quot;#226-翻转二叉树&quot; class=&quot;headerlink&quot; title=&quot;226.翻转二叉树&quot;&gt;&lt;/a&gt;226.翻转二叉树&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;br&gt;输入：root = [4,2,7,1,3,6,9]&lt;br&gt;输出：[4,7,2,9,6,3,1]&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/invert-binary-tree&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;递归法&lt;br&gt;分析题目输入和输出发现，输出的左右子树的位置跟输入正好是相反的，于是我们可以递归的交换左右子树来实现。&lt;br&gt;其实就是交换一下左右节点，然后再递归的交换左节点，右节点&lt;br&gt;递归的两个条件如下：&lt;br&gt; 终止条件：当前节点为 null 时返回&lt;br&gt; 交换当前节点的左右节点，再递归的交换当前节点的左节点，递归的交换当前节点的右节点时间复杂度：每个元素都必须访问一次，所以是 O(n)&lt;br&gt;空间复杂度：最坏的情况下，需要存放 O(h) 个函数调用(h是树的高度)，所以是 O(h)&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%A0%91/"/>
    
    <category term="226.翻转二叉树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%A0%91/226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 101.对称二叉树</title>
    <link href="http://example.com/2022/07/16/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://example.com/2022/07/16/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2022-07-16T10:36:02.000Z</published>
    <updated>2022-07-16T10:38:13.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101.对称二叉树"></a>101.对称二叉树</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个二叉树的根节点 root ， 检查它是否轴对称。</p><p><a href="https://leetcode.cn/problems/symmetric-tree/">题目链接</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># Definition for a binary tree node.class TreeNode(object):    def __init__(self, val=0, left=None, right=None):        self.val = val        self.left = left        self.right = rightclass Solution(object):    def isSymmetric(self, root):        &quot;&quot;&quot;        递归法                两个树互为镜像：            它们的两个根结点具有相同的值            每个树的右子树都与另一个树的左子树镜像对称        :type root: TreeNode        :rtype: bool        &quot;&quot;&quot;        return self.check(root, root)        def check(self, p, q):        if not p and not q:            return True        if not p or not q:            return False        return p.val == q.val and self.check(p.left, q.right) and self.check(p.right, q.left)        def isSymmetric1(self, root):        &quot;&quot;&quot;迭代法&quot;&quot;&quot;        queue = list()        queue.append(root)        queue.append(root)        while len(queue) != 0:            t1 = queue.pop(0)            t2 = queue.pop(0)            if not t1 and not t2:                continue            if not t1 or not t2:                return False            if t1.val != t2.val:                return False            queue.append(t1.left)            queue.append(t2.right)            queue.append(t1.right)            queue.append(t2.left)        return Trueif __name__ == &quot;__main__&quot;:    root = TreeNode(1)    node2 = TreeNode(2)    node3 = TreeNode(2)    node4 = TreeNode(3)    node5 = TreeNode(4)    node6 = TreeNode(4)    node7 = TreeNode(3)        slt = Solution()    # result = slt.isSymmetric(root)    result = slt.isSymmetric(root)    print(result)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;101-对称二叉树&quot;&gt;&lt;a href=&quot;#101-对称二叉树&quot; class=&quot;headerlink&quot; title=&quot;101.对称二叉树&quot;&gt;&lt;/a&gt;101.对称二叉树&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%A0%91/"/>
    
    <category term="101.对称二叉树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%A0%91/101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 53.最大子数组和</title>
    <link href="http://example.com/2022/07/16/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/"/>
    <id>http://example.com/2022/07/16/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</id>
    <published>2022-07-16T09:28:28.000Z</published>
    <updated>2022-07-16T09:57:03.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53.最大子数组和"></a>53.最大子数组和</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>子数组 是数组中的一个连续部分。</p><p>示例 1：<br>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6<br>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</p><p><a href="https://leetcode.cn/problems/maximum-subarray/">题目链接</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):    def maxSubArray(self, nums):        &quot;&quot;&quot;        动态规划                用f(i)代表以第i个数结尾的连续子数组的最大和，那么我们的目标就是求                            max&#123;f(i)&#125;,0&lt;=i&lt;=n-1        如何求 f(i) 呢？        我们可以考虑 nums[i] 单独成为一段还是加入 f(i−1)对应的那一段，这取决于 nums[i] 和 f(i−1)+nums[i] 的大小，        我们希望获得一个比较大的，于是可以写出这样的动态规划转移方程：                            f(i)=max&#123;f(i-1)+nums[i], nums[i]&#125;        :type nums: List[int]        :rtype: int        &quot;&quot;&quot;        # pre = 0        # maxAns = nums[0]        # for x in nums:        #     pre = max(pre + x, x)        #     maxAns = max(maxAns, pre)        # return maxAns                fi_array = [nums[0]]        for i in range(1, len(nums)):            fi_array.append(max(fi_array[i-1]+nums[i], nums[i]))        return max(fi_array)        def maxSubArray1(self, nums):        &quot;&quot;&quot;        动态规划                若前一个元素大于0，则将其加到当前元素上        &quot;&quot;&quot;        for i in range(1, len(nums)):            # 若前一个元素大于0，则将其加到当前元素上            if nums[i - 1] &gt; 0:                nums[i] += nums[i-1]        return max(nums)  # 返回修改过的数组中的最大值            def maxSubArray2(self, nums):        &quot;&quot;&quot;        贪心算法                # 若当前指针所指元素之前的和小于0，则丢弃当前元素之前的数列        &quot;&quot;&quot;        if not nums:  # 设置边界条件（列表为空）            return -2147483648        cur_sum = max_sum = nums[0]  # 当前和和最大和设置为列表第一个元素        for i in range(1, len(nums)):            # 若当前指针所指元素之前的和小于0，则丢弃当前元素之前的数列            cur_sum = max(nums[i], cur_sum+nums[i])                        # 将当前和与最大和作比较，取最大            max_sum = max(cur_sum, max_sum)                return max_sumif __name__ == &quot;__main__&quot;:    slt = Solution()    nums = list([-2, 1, -3, 4, -1, 2, 1, -5, 4])    res = slt.maxSubArray(nums)    # res = slt.maxSubArray1(nums)    print(res)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;53-最大子数组和&quot;&gt;&lt;a href=&quot;#53-最大子数组和&quot; class=&quot;headerlink&quot; title=&quot;53.最大子数组和&quot;&gt;&lt;/a&gt;53.最大子数组和&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="数组" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    <category term="53.最大子数组和" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>appium | 手机App自动化测试</title>
    <link href="http://example.com/2022/07/15/Appium%E6%89%8B%E6%9C%BAApp%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    <id>http://example.com/2022/07/15/Appium%E6%89%8B%E6%9C%BAApp%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</id>
    <published>2022-07-15T12:54:33.000Z</published>
    <updated>2022-07-16T01:46:27.722Z</updated>
    
    <content type="html"><![CDATA[<h1 id="appium手机App自动化测试"><a href="#appium手机App自动化测试" class="headerlink" title="appium手机App自动化测试"></a>appium手机App自动化测试</h1><h2 id="手机App自动化测试环境搭建"><a href="#手机App自动化测试环境搭建" class="headerlink" title="手机App自动化测试环境搭建"></a>手机App自动化测试环境搭建</h2><ol><li>安装appium client编程库</li></ol><pre><code>pip install appium-python-client</code></pre><ol start="2"><li>安装Appium Server<br>下载链接链接：<a href="https://pan.baidu.com/s/19C9fGmoXne8DgfXhrTB2TQ">https://pan.baidu.com/s/19C9fGmoXne8DgfXhrTB2TQ</a><br>提取码：kgwb</li><li>安装JDK<br>下载链接同上。<br>安装好之后，需要添加环境变量JAVA_HOME，例如：</li></ol><pre><code>JAVA_HOME   d:\tools\java\jdk1.8.0_211(jdk安装目录)</code></pre><ol start="4"><li><p>安装Android SDK<br>下载链接同上。<br>下载Android SDK文件包：androidsdk.zip，并解压。<br>解压完成后添加环境变量ANDROID_HOME，例如：</p><span id="more"></span><p> ANDROID_HOME d:\tools\androidsdk(sdk包解压目录)<br>另外，还需要配置环境变量PATH，加入 adb所在目录， d:\tools\androidsdk\platform-tools\</p></li><li><p>连接手机<br>上述的软件环境都准备好以后，要自动化手机APP，需要：<br> 在你运行程序的电脑上 用 USB线 连接上 你的安卓手机<br> 进入 手机设置 -&gt; 关于手机 ，不断点击 版本号 菜单（7次以上），<br> 退出到上级菜单，在开发者模式中，启动USB调试，打开USB安装，打开USB调试（安全设置），如下所示：<br><img src="/2022/07/15/Appium%E6%89%8B%E6%9C%BAApp%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/2.jpg"><br>如果手机连接USB线后，手机界面弹出 类似 如下提示。<br><img src="/2022/07/15/Appium%E6%89%8B%E6%9C%BAApp%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/1.png"><br>选择 允许USB调试。</p></li></ol><p>连接好以后，打开命令行窗口， 执行 adb devices -l 命令来列出连接在电脑上的安卓设备。<br>如果输出 类似如下的内容：</p><pre><code>List of devices attached4d0035dc767a50bb        device product:t03gxx model:GT_N7100 device:t03g</code></pre><p>表示电脑上可以查看到 连接的设备，就可以运行自动化程序了。<br>6. 测试手机app案例<br>下面是一段使用 Appium 自动化的打开 B站 应用，搜索 白月黑羽 发布的教程视频，并且打印视频标题的示例。<br><strong>代码：</strong></p><pre><code>from appium import webdriverfrom selenium.webdriver.common.by import Byfrom appium.webdriver.extensions.android.nativekey import AndroidKeydesired_caps = &#123;    &#39;platformName&#39;: &#39;Android&#39;,  # 被测手机是安卓    &#39;platformVersion&#39;: &#39;12&#39;,  # 手机安卓版本    &#39;deviceName&#39;: &#39;xxx&#39;,  # 设备名，安卓手机可以随意填写    &#39;appPackage&#39;: &#39;tv.danmaku.bili&#39;,  # 启动APP Package名称    &#39;appActivity&#39;: &#39;.MainActivityV2&#39;,  # 启动Activity名称    &#39;unicodeKeyboard&#39;: True,  # 使用自带输入法，输入中文时填True    &#39;resetKeyboard&#39;: True,  # 执行完程序恢复原来输入法    &#39;noReset&#39;: True,  # 不要重置App    &#39;newCommandTimeout&#39;: 6000,    &#39;automationName&#39;: &#39;UiAutomator2&#39;    # &#39;app&#39;: r&#39;d:\apk\bili.apk&#39;,&#125;# 连接Appium Server，初始化自动化环境driver = webdriver.Remote(&#39;http://localhost:4723/wd/hub&#39;, desired_caps)# 设置缺省等待时间driver.implicitly_wait(5)# 如果有`青少年保护`界面，点击`我知道了`iknow = driver.find_elements(By.ID, &quot;text3&quot;)if iknow:    iknow.click()# 根据id定位搜索位置框，点击driver.find_element(By.ID, &#39;expand_search&#39;).click()# 根据id定位搜索输入框，点击sbox = driver.find_element(By.ID, &#39;search_src_text&#39;)sbox.send_keys(&#39;白月黑羽&#39;)# 输入回车键，确定搜索driver.press_keycode(AndroidKey.ENTER)# 选择（定位）所有视频标题eles = driver.find_elements(By.ID, &#39;title&#39;)for ele in eles:    # 打印标题    print(ele.text)input(&#39;**** Press to quit..&#39;)driver.quit()</code></pre><ol start="7"><li>报错解决办法<br>（1）WebDriverException</li></ol><pre><code>selenium.common.exceptions.WebDriverException: Message: An unknown server-side error occurred while processing the command. Original error: Neither ANDROID_HOME nor ANDROID_SDK_ROOT environment variable was exported. Read https://developer.android.com/studio/command-line/variables for more details</code></pre><p>报错原因：未添加ANDROID_HOME<br>解决办法：在环境变量中添加ANDROID_HOME，值为androidsdk的解压目录/安装目录<br>（2）</p><pre><code>Error: Activity used to start app doesn’t exist or cannot ve launched!</code></pre><p>报错原因：desired_caps中的appPackage,appActivtity设置不正确<br>解决办法：手机端打开app –&gt; win+r –&gt; cmd –&gt; 输入adb shell dumpsys activity activities | findstr mResume获取app包名和活动名称<br>例如，打开微信，输入命令后显示如下信息：</p><pre><code>mResumedActivity: ActivityRecord&#123;66ff017 u0 com.tencent.mm/.ui.LauncherUI t6167&#125;</code></pre><p>将appPackage设置为com.tencent.mm,将appActivity设置为.ui.LauncherUI</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;appium手机App自动化测试&quot;&gt;&lt;a href=&quot;#appium手机App自动化测试&quot; class=&quot;headerlink&quot; title=&quot;appium手机App自动化测试&quot;&gt;&lt;/a&gt;appium手机App自动化测试&lt;/h1&gt;&lt;h2 id=&quot;手机App自动化测试环境搭建&quot;&gt;&lt;a href=&quot;#手机App自动化测试环境搭建&quot; class=&quot;headerlink&quot; title=&quot;手机App自动化测试环境搭建&quot;&gt;&lt;/a&gt;手机App自动化测试环境搭建&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;安装appium client编程库&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;pip install appium-python-client
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;安装Appium Server&lt;br&gt;下载链接链接：&lt;a href=&quot;https://pan.baidu.com/s/19C9fGmoXne8DgfXhrTB2TQ&quot;&gt;https://pan.baidu.com/s/19C9fGmoXne8DgfXhrTB2TQ&lt;/a&gt;&lt;br&gt;提取码：kgwb&lt;/li&gt;
&lt;li&gt;安装JDK&lt;br&gt;下载链接同上。&lt;br&gt;安装好之后，需要添加环境变量JAVA_HOME，例如：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;JAVA_HOME   d:\tools\java\jdk1.8.0_211(jdk安装目录)
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;&lt;p&gt;安装Android SDK&lt;br&gt;下载链接同上。&lt;br&gt;下载Android SDK文件包：androidsdk.zip，并解压。&lt;br&gt;解压完成后添加环境变量ANDROID_HOME，例如：&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="自动化测试" scheme="http://example.com/categories/python/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    <category term="appium" scheme="http://example.com/categories/python/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/appium/"/>
    
    <category term="appium手机App自动化测试" scheme="http://example.com/categories/python/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/appium/appium%E6%89%8B%E6%9C%BAApp%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="appium" scheme="http://example.com/tags/appium/"/>
    
    <category term="手机App自动化测试" scheme="http://example.com/tags/%E6%89%8B%E6%9C%BAApp%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>selenium | pyhon+selenium测试WebTours网站登录注册功能</title>
    <link href="http://example.com/2022/07/14/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    <id>http://example.com/2022/07/14/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</id>
    <published>2022-07-15T03:30:30.000Z</published>
    <updated>2022-07-15T12:54:54.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pyhon-selenium测试WebTours网站登录注册功能"><a href="#pyhon-selenium测试WebTours网站登录注册功能" class="headerlink" title="pyhon+selenium测试WebTours网站登录注册功能"></a>pyhon+selenium测试WebTours网站登录注册功能</h1><h2 id="Web-Tours下载、安装"><a href="#Web-Tours下载、安装" class="headerlink" title="Web Tours下载、安装"></a>Web Tours下载、安装</h2><p><a href="https://blog.csdn.net/weixin_45129277/article/details/114013243">WebTours下载、安装</a></p><h2 id="安装selenium"><a href="#安装selenium" class="headerlink" title="安装selenium"></a>安装selenium</h2><p>在终端输入以下命令安装selenium:</p><pre><code>pip install selenium</code></pre><h2 id="测试注册功能"><a href="#测试注册功能" class="headerlink" title="测试注册功能"></a>测试注册功能</h2><p><strong>user.txt</strong></p><pre><code>name1 1name2 2name3 3</code></pre><p>注：本示例使用Firfox浏览器进行测试<br><strong>代码：</strong></p><pre><code>from selenium import webdriverfrom time import sleepfile = open(&quot;user.txt&quot;, &quot;r&quot;)for line in file:    username = line.split()[0]    password = line.split()[1]    # 注册    driver = webdriver.Firefox()    driver.get(&quot;http://localhost:1080/webtours&quot;)    driver.switch_to_default_content()    driver.switch_to_frame(&quot;body&quot;)    driver.switch_to_frame(&quot;info&quot;)    # driver.find_element_by_link_text(&quot;sign up now&quot;).click()    driver.find_element_by_partial_link_text(&quot;sign up&quot;).click()    sleep(3)    driver.switch_to_default_content()    driver.switch_to_frame(&quot;body&quot;)    driver.switch_to_frame(&quot;info&quot;)    driver.find_element_by_name(&quot;username&quot;).send_keys(username)    driver.find_element_by_name(&quot;password&quot;).send_keys(password)    driver.find_element_by_name(&quot;passwordConfirm&quot;).send_keys(password)    driver.find_element_by_name(&quot;register&quot;).click()    sleep(3)    driver.switch_to_default_content()    driver.switch_to_frame(&quot;body&quot;)    driver.switch_to_frame(&quot;info&quot;)    expect = &quot;Thank you, &quot; + username    actual = driver.find_element_by_tag_name(&quot;body&quot;).text    if expect in actual:        print(&quot;测试通过&quot;)    else:        print(&quot;测试失败&quot;)driver.quit()</code></pre><h2 id="测试登录、订票功能"><a href="#测试登录、订票功能" class="headerlink" title="测试登录、订票功能"></a>测试登录、订票功能</h2><pre><code>from selenium import webdriverfrom time import sleepfrom selenium.webdriver.support.select import Selectdriver = webdriver.Firefox()driver.get(&quot;http://localhost:1080/webtours&quot;)sleep(3)driver.switch_to_default_content()driver.switch_to_frame(&quot;body&quot;)driver.switch_to_frame(&quot;info&quot;)actual = driver.find_element_by_tag_name(&quot;body&quot;).textif &quot;Welcome to the Web Tours site&quot; in actual:    print(&quot;打开网站成功&quot;)else:    print(&quot;打开网站失败&quot;)driver.switch_to_default_content()driver.switch_to_frame(&quot;body&quot;)driver.switch_to_frame(&quot;navbar&quot;)driver.find_element_by_name(&quot;username&quot;).send_keys(&quot;jojo&quot;)driver.find_element_by_name(&quot;password&quot;).send_keys(&quot;bean&quot;)driver.find_element_by_name(&quot;login&quot;).click()sleep(3)driver.switch_to_default_content()driver.switch_to_frame(&quot;body&quot;)driver.switch_to_frame(&quot;info&quot;)actual = driver.find_element_by_tag_name(&quot;body&quot;).textif &quot;Welcome, jojo&quot; in actual:    print(&quot;登录成功&quot;)else:    print(&quot;登录失败&quot;)sleep(3)driver.switch_to_default_content()driver.switch_to_frame(&quot;body&quot;)driver.switch_to_frame(&quot;navbar&quot;)driver.find_element_by_xpath(&quot;//img[@alt=&#39;Search Flights Button&#39;]&quot;).click()sleep(3)driver.switch_to_default_content()driver.switch_to_frame(&quot;body&quot;)driver.switch_to_frame(&quot;info&quot;)Select(driver.find_element_by_name(&quot;depart&quot;)).select_by_visible_text(&quot;Denver&quot;)Select(driver.find_element_by_name(&quot;arrive&quot;)).select_by_visible_text(&quot;London&quot;)driver.find_element_by_name(&quot;findFlights&quot;).click()sleep(3)driver.switch_to_default_content()driver.switch_to_frame(&quot;body&quot;)driver.switch_to_frame(&quot;info&quot;)driver.find_elements_by_name(&quot;outboundFlight&quot;)[1].click()driver.find_element_by_name(&quot;reserveFlights&quot;).click()sleep(1)driver.switch_to_default_content()driver.switch_to_frame(&quot;body&quot;)driver.switch_to_frame(&quot;info&quot;)driver.find_element_by_name(&quot;buyFlights&quot;).click()sleep(1)driver.switch_to_default_content()driver.switch_to_frame(&quot;body&quot;)driver.switch_to_frame(&quot;info&quot;)actual = driver.find_element_by_tag_name(&quot;body&quot;).textif &quot;Thank you for booking through Web Tours.&quot; in actual:    print(&quot;订票成功&quot;)else:    print(&quot;订票失败&quot;)sleep(3)driver.switch_to_default_content()driver.switch_to_frame(&quot;body&quot;)driver.switch_to_frame(&quot;info&quot;)driver.find_element_by_name(&quot;Book Another&quot;).click()sleep(1)driver.switch_to_default_content()driver.switch_to_frame(&quot;body&quot;)driver.switch_to_frame(&quot;navbar&quot;)driver.find_element_by_xpath(&quot;//img[@alt=&#39;SignOff Button&#39;]&quot;).click()driver.switch_to_default_content()driver.switch_to_frame(&quot;body&quot;)driver.switch_to_frame(&quot;info&quot;)actual = driver.find_element_by_tag_name(&quot;body&quot;).textif &quot;Welcome to the Web Tours site&quot; in actual:    print(&quot;注销成功&quot;)else:    print(&quot;注销失败&quot;)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;pyhon-selenium测试WebTours网站登录注册功能&quot;&gt;&lt;a href=&quot;#pyhon-selenium测试WebTours网站登录注册功能&quot; class=&quot;headerlink&quot; title=&quot;pyhon+selenium测试WebTours网站登录</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="自动化测试" scheme="http://example.com/categories/python/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    <category term="selenium" scheme="http://example.com/categories/python/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/selenium/"/>
    
    <category term="pyhon+selenium测试webtours网站登录注册功能" scheme="http://example.com/categories/python/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/selenium/pyhon-selenium%E6%B5%8B%E8%AF%95webtours%E7%BD%91%E7%AB%99%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="自动化测试" scheme="http://example.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    <category term="selenium" scheme="http://example.com/tags/selenium/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 104.二叉树的最大深度</title>
    <link href="http://example.com/2022/07/12/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
    <id>http://example.com/2022/07/12/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</id>
    <published>2022-07-12T10:07:30.000Z</published>
    <updated>2022-07-12T10:11:33.961Z</updated>
    
    <content type="html"><![CDATA[<h1 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104.二叉树的最大深度"></a>104.二叉树的最大深度</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，找出其最大深度。<br>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>说明: 叶子节点是指没有子节点的节点。<br>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>方法一：深度优先搜索<br>首先可以想到使用深度优先搜索的方法，遍历整棵树，记录最小深度。<br>对于每一个非叶子节点，我们只需要分别计算其左右子树的最大叶子节点深度。这样就将一个大问题转化为了小问题，可以递归地解决该问题。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># class TreeNode(object):  # Definition for a binary tree node.#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution(object):    def maxDepth(self, root):        &quot;&quot;&quot;        :type root: TreeNode        :rtype: int        &quot;&quot;&quot;        def get_depth(root):            if not root:                return 0            left_depth = get_depth(root.left)            right_depth = get_depth(root.right)            return max(right_depth, left_depth) + 1        return get_depth(root)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;104-二叉树的最大深度&quot;&gt;&lt;a href=&quot;#104-二叉树的最大深度&quot; class=&quot;headerlink&quot; title=&quot;104.二叉树的最大深度&quot;&gt;&lt;/a&gt;104.二叉树的最大深度&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; cla</summary>
      
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%A0%91/"/>
    
    <category term="104.二叉树的最大深度" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%A0%91/104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 102.二叉树的层序遍历</title>
    <link href="http://example.com/2022/07/11/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://example.com/2022/07/11/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2022-07-12T07:58:32.000Z</published>
    <updated>2022-07-12T08:33:33.294Z</updated>
    
    <content type="html"><![CDATA[<h1 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102.二叉树的层序遍历"></a>102.二叉树的层序遍历</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。<br><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">题目链接</a></p><span id="more"></span><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li><p>递归法<br>根据题目要求，我们需要遍历二叉树，并将相同层次的节点归入同一个数组；</p><pre><code> 可以通过传入辅助的level参数决定层次，就可以将同一level的放入同一数组。</code></pre></li><li><p>迭代法（使用队列）<br>使用队列进行实现，弹出当前层节点的同时，依次加入下一层节点；由于队列先进先出的特性，当前层的节点会被先访问。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h1 id="Definition-for-a-binary-tree-node"><a href="#Definition-for-a-binary-tree-node" class="headerlink" title="Definition for a binary tree node."></a>Definition for a binary tree node.</h1><p> class TreeNode(object):</p><pre><code> def __init__(self, val=0, left=None, right=None):     self.val = val     self.left = left     self.right = right</code></pre><p> class Queue(object):</p><pre><code> &quot;&quot;&quot;实现一个队列&quot;&quot;&quot;  def __init__(self):     self.__list = []  def enqueue(self, elem):     &quot;&quot;&quot;入队&quot;&quot;&quot;     self.__list.append(elem)  def dequeue(self):     &quot;&quot;&quot;出队&quot;&quot;&quot;     return self.__list.pop(0)  def is_empty(self):     return not self.__list  def size(self):     &quot;&quot;&quot;队列的大小&quot;&quot;&quot;     return len(self.__list)</code></pre><p> class Solution(object):</p><pre><code> def levelOrder(self, root):     &quot;&quot;&quot;使用队列对树进行层序遍历，无返回值&quot;&quot;&quot;     if not root:         return     queue = Queue()     queue.enqueue(root)     while queue.size() != 0:         node = queue.dequeue()         print(node.val)         if node.left is not None:             queue.enqueue(node.left)         if node.right is not None:             queue.enqueue(node.right)  def levelOrder1(self, root):     &quot;&quot;&quot;     递归法          根据题目要求，我们需要遍历二叉树，并将相同层次的节点归入同一个数组；     可以通过传入辅助的level参数决定层次，就可以将同一level的放入同一数组。     &quot;&quot;&quot;     def helper(node, level):         if len(levels) == level:  # 每一层都需要创建一个数组             levels.append([])                  levels[level].append(node.val)  # 向对应层的数组中加入节点                  # 递归，层次+1         if node.left is not None:             helper(node.left, level + 1)         if node.right is not None:             helper(node.right, level + 1)          levels = []     if root is None:         return levels     helper(root, 0)     return levels  def levelOrder2(self, root):     &quot;&quot;&quot;     迭代法          使用队列进行实现，弹出当前层节点的同时，依次加入下一层节点；由于队列先进先出的特性，当前层的节点会被先访问。     &quot;&quot;&quot;     answer = []     level = []     dummy = TreeNode(1001)     queue = Queue()          if not root:         return answer          queue.enqueue(root)     queue.enqueue(dummy)          while not queue.is_empty():         current = queue.dequeue()         if current == dummy:             answer.append(level)             level = list()             if not queue.is_empty():                 queue.enqueue(dummy)         else:             level.append(current.val)             if current.left is not None:                 queue.enqueue(current.left)             if current.right is not None:                 queue.enqueue(current.right)          return answer</code></pre><p> if <strong>name</strong> == “<strong>main</strong>“:</p><pre><code> # create the binary tree root = TreeNode(3) node2 = TreeNode(9) node3 = TreeNode(20) node4 = TreeNode(15) node5 = TreeNode(7) root.left = node2 root.right = node3 node3.left = node4 node3.right = node5  slt = Solution() # slt.levelOrder(root) # res = slt.levelOrder1(root) res = slt.levelOrder2(root) print(res)</code></pre></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;102-二叉树的层序遍历&quot;&gt;&lt;a href=&quot;#102-二叉树的层序遍历&quot; class=&quot;headerlink&quot; title=&quot;102.二叉树的层序遍历&quot;&gt;&lt;/a&gt;102.二叉树的层序遍历&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。&lt;br&gt;&lt;a href=&quot;https://leetcode.cn/problems/binary-tree-level-order-traversal/&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%A0%91/"/>
    
    <category term="102.二叉树的层序遍历" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%A0%91/102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="层序遍历" scheme="http://example.com/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>pyqrcode | 生成二维码</title>
    <link href="http://example.com/2022/07/09/%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    <id>http://example.com/2022/07/09/%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81/</id>
    <published>2022-07-10T03:12:23.000Z</published>
    <updated>2022-07-10T08:02:50.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生成二维码"><a href="#生成二维码" class="headerlink" title="生成二维码"></a>生成二维码</h1><p><strong>代码：</strong></p><pre><code>import pyqrcode  # pip install pyqrcodeimport png  # pip install pypnglink = &quot;https://victory-liao.github.io/&quot;qrCode = pyqrcode.create(link)qrCode.png(&quot;my blog.png&quot;, scale=10)</code></pre><p><strong>结果：</strong><br><img src="/2022/07/09/%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81/1.png"><br><strong>注：如果要生成其他链接的二维码，只需要替换link变量中的值！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;生成二维码&quot;&gt;&lt;a href=&quot;#生成二维码&quot; class=&quot;headerlink&quot; title=&quot;生成二维码&quot;&gt;&lt;/a&gt;生成二维码&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import pyqrcode  # pip</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="pyqrcode" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pyqrcode/"/>
    
    
    <category term="二维码" scheme="http://example.com/tags/%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    
    <category term="pyqrcode" scheme="http://example.com/tags/pyqrcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 9.回文数</title>
    <link href="http://example.com/2022/07/09/%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <id>http://example.com/2022/07/09/%E5%9B%9E%E6%96%87%E6%95%B0/</id>
    <published>2022-07-10T02:38:18.000Z</published>
    <updated>2022-07-10T02:50:10.240Z</updated>
    
    <content type="html"><![CDATA[<h1 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9.回文数"></a>9.回文数</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。<br>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。<br>例如，121 是回文，而 123 不是。<br><a href="https://leetcode.cn/problems/palindrome-number">题目链接</a></p><span id="more"></span><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.使用栈判断是否回文<br>先将每位数字依次入栈，再将栈中的所有数字依次出栈，如果入栈的数字序列与出战的数字序列相同，则该数为回文数。<br>2.将整数x转化为字符串<br>将整数x转化为字符串，将字符串反转，如果原字符串与反转字符串相等，则该数为回文数。<br>3.反转一半数字<br>反转后一半数字，并将其与前半部分数字进行比较，如果二者相同，则该数为回文数。<br>如何知道反转数字的位数已经达到原始数字位数的一半？当原始数字小于或等于反转后的数字时，就意味着我们已经处理了<br>一半位数的数字了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):    def isPalindrome2(self, x):        &quot;&quot;&quot;        使用栈实现回文                先将每位数字依次入栈，再将栈中的所有数字依次出栈，如果入栈的数字序列与出战的数字序列相同，则该数为回文数。        &quot;&quot;&quot;        if x &lt; 0:  # 负数肯定不是回文数            return False        xCopy = x        stack = list()        while x != 0:            stack.append(x % 10)            x = x // 10                    stack = stack[::-1]  # 从个位数开始取每位数字比较方便，但是入栈的数字序列与原数字序列相反，故反转栈                revertedNumber = 0        while stack:            revertedNumber = revertedNumber * 10 + stack.pop()                if xCopy == revertedNumber:            return True        else:            return False        def isPalindrome1(self, x):        x = str(x)        return x == x[::-1]        def isPalindrome(self, x):        &quot;&quot;&quot;        特殊情况：        1.当x&lt;0时，x不是回文数        2.如果数字的最后一位是0，为了使该数字为回文，则          其第一位数字也应该是0，只有0满足        &quot;&quot;&quot;        if x &lt; 0 or (x % 10 == 0 and x != 0):            return False                revertedNumber = 0        while x &gt; revertedNumber:            revertedNumber = (revertedNumber * 10) + (x % 10)            x //= 10                    # 当数字长度为奇数时，我们可以通过revertedNumber/10去除位于中位的数字。        # 例如，当输入为12321时，在while循环末尾我们可以得到x=12，revertedNumber=123,        # 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。        return x == revertedNumber or x == revertedNumber // 10    if __name__ == &quot;__main__&quot;:    slt = Solution()    # res = slt.isPalindrome(12321)    # res = slt.isPalindrome1(12321)    res = slt.isPalindrome2(12321)    print(&quot;是回文数&quot; if res else &quot;不是回文数&quot;)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;9-回文数&quot;&gt;&lt;a href=&quot;#9-回文数&quot; class=&quot;headerlink&quot; title=&quot;9.回文数&quot;&gt;&lt;/a&gt;9.回文数&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。&lt;br&gt;回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。&lt;br&gt;例如，121 是回文，而 123 不是。&lt;br&gt;&lt;a href=&quot;https://leetcode.cn/problems/palindrome-number&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="回文" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E5%9B%9E%E6%96%87/"/>
    
    <category term="9.回文数" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E5%9B%9E%E6%96%87/9-%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="回文数" scheme="http://example.com/tags/%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 70.爬楼梯</title>
    <link href="http://example.com/2022/07/09/%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <id>http://example.com/2022/07/09/%E7%88%AC%E6%A5%BC%E6%A2%AF/</id>
    <published>2022-07-09T13:40:07.000Z</published>
    <updated>2022-07-09T13:59:59.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br><a href="https://leetcode.cn/problems/climbing-stairs/">题目链接</a></p><span id="more"></span><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>f(n) = f(n-1) + f(n-2)</strong></p><ol><li><p>递归法<br>由f(1)=1,f(2)=2,f(3)=3,…,以此类推,f(n)=f(n-1)+f(n-2),使用递归法实现该问题，递归方程为f(n)=f(n-1)+f(n-2),<br>递归出口为f(1)=1,f(2)=2。</p></li><li><p>记忆化递归法<br>使用数组记录了每次计算的结果，避免递归法中的重复计算。</p></li><li><p>动态规划<br>动态规划转移方程：f(n)=f(n-1)+f(n-2)<br>边界条件：f(1)=1,f(2)=2</p></li><li><p>滚动数组<br>使用长度为3的数组实现爬楼梯问题，问题中涉及三个状态:状态1、状态2、状态3，每次更新状态时，先将状态2移动到状态1<br>的位置，再把状态3移动到状态2的位置，即将状态数组整体向前滚动一位。<br>例：<br>|1|2|3|—&gt;|2|3|5|</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p> class Solution(object):</p><pre><code> def climbStairs(self, n):     &quot;&quot;&quot;     递归法     :type n: int     :rtype: int     &quot;&quot;&quot;     if n == 1:         return 1     if n == 2:         return 2     return self.climbStairs(n - 1) + self.climbStairs(n - 2)  def climbStairs2(self, n):     &quot;&quot;&quot;     记忆化递归法     :type n: int     :rtype: int     &quot;&quot;&quot;     memo = []     return self.climbStairsMemo(n, memo)  def climbStairsMemo(self, n, memo):     if memo[n] &gt; 0:         return memo[n]     if n == 1:         memo[n] = 1     elif n == 2:         memo[n] = 2     else:         memo[n] = self.climbStairsMemo(n - 1, memo) + self.climbStairsMemo(n - 2, memo)     return memo[n]  def climbStairs3(self, n):     &quot;&quot;&quot;     动态规划     :type n: int     :rtype: int     &quot;&quot;&quot;     if n == 1:         return 1     dp = [1, 2]     for i in range(2, n):         dp.append(dp[i-1]+dp[i-2])  # dp[i] = dp[i-1] + dp[i-2]     return dp[n-1]  def climbStairs4(self, n):     &quot;&quot;&quot;     滚动数组（斐波那契数列）     :type n: int     :rtype: int     &quot;&quot;&quot;     if n == 1:         return 1     first = 1     second = 2     for i in range(2, n):         third = first + second         first = second         second = third     return second     </code></pre><p> if <strong>name</strong> == “<strong>main</strong>“:</p><pre><code> slt = Solution() # numberOfSolutions = slt.climbStairs(2) # numberOfSolutions = slt.climbStairs2(2) # numberOfSolutions = slt.climbStairs3(2) numberOfSolutions = slt.climbStairs4(4) print(numberOfSolutions)</code></pre></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;70-爬楼梯&quot;&gt;&lt;a href=&quot;#70-爬楼梯&quot; class=&quot;headerlink&quot; title=&quot;70.爬楼梯&quot;&gt;&lt;/a&gt;70.爬楼梯&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;假设你正在爬楼梯。需要 n 阶你才能到达楼顶。&lt;br&gt;每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;br&gt;&lt;a href=&quot;https://leetcode.cn/problems/climbing-stairs/&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="动态规划" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="70.爬楼梯" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/70-%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 19.删除链表中的倒数第N个节点</title>
    <link href="http://example.com/2022/07/09/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>http://example.com/2022/07/09/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</id>
    <published>2022-07-09T12:32:37.000Z</published>
    <updated>2022-07-17T03:35:05.144Z</updated>
    
    <content type="html"><![CDATA[<h1 id="19-删除链表中的倒数第N个节点"><a href="#19-删除链表中的倒数第N个节点" class="headerlink" title="19. 删除链表中的倒数第N个节点"></a>19. 删除链表中的倒数第N个节点</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li><p>计算链表长度<br>删除链表的倒数第 n 个结点操作就等价于删除正数第L-n+1个节点，L为链表的长度</p></li><li><p>栈<br>遍历链表的同时将所有节点依次入栈，根据栈 先进后出 的原则，弹出栈的第n个节点就是需要删除的节点，并且弹出<br>第n个节点后的栈顶节点为待删除节点的前驱节点。</p><span id="more"></span><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p> class ListNode(object):</p><pre><code> def __init__(self, val=0, next=None):     self.val = val     self.next = next</code></pre><p> class Solution(object):</p><pre><code> def removeNthFromEnd(self, linkedList, n):     &quot;&quot;&quot;     计算链表长度     :type head: ListNode     :type n: int     :rtype: ListNode     &quot;&quot;&quot;     dummy = ListNode(0, linkedList)     length = self.lenOfLinkedList(dummy)     print(length)     cur = dummy     for i in range(1, length - n):         cur = cur.next     cur.next = cur.next.next     return dummy.next  def removeNthFromEnd2(self, head, n):     &quot;&quot;&quot;栈&quot;&quot;&quot;     stack = list()     cur = head     while cur:         stack.append(cur)         cur = cur.next     for i in range(n):         stack.pop()              prev = stack[-1]     prev.next = prev.next.next     return head  def removeNthFromEnd3(self, head, n):     &quot;&quot;&quot;双指针&quot;&quot;&quot;     dummy = ListNode(0, head)     first = head     second = dummy     for i in range(n):         first = first.next          while first:         first = first.next         second = second.next          second.next = second.next.next     return dummy.next  def lenOfLinkedList(self, head):     if not head:         return 0     p = head     count = 0     while p is not None:         count += 1         p = p.next     return count  def createLinkedList(self, list):     head = r = ListNode(list[0])     for num in list[1:]:         node = ListNode(num)         r.next = node         r = node          return head  def traverseLinkedList(self, head):     if not head:         return     p = head     while p is not None:         print(p.val, end=&quot; &quot;)         p = p.next     print(&quot;&quot;)</code></pre><p> if <strong>name</strong> == “<strong>main</strong>“:</p><pre><code> slt = Solution() linkedList = slt.createLinkedList([1, 2, 3, 4, 5]) print(&quot;linked list:&quot;, end=&quot;&quot;) slt.traverseLinkedList(linkedList) length = slt.lenOfLinkedList(linkedList) print(&quot;length of linked list:&quot;, length) # newLinkedList = slt.removeNthFromEnd(linkedList, 2) # newLinkedList = slt.removeNthFromEnd2(linkedList, 2) newLinkedList = slt.removeNthFromEnd3(linkedList, 2) print(&quot;linked list after deleting the reversed n-th node:&quot;, end=&quot;&quot;) slt.traverseLinkedList(newLinkedList)</code></pre></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;19-删除链表中的倒数第N个节点&quot;&gt;&lt;a href=&quot;#19-删除链表中的倒数第N个节点&quot; class=&quot;headerlink&quot; title=&quot;19. 删除链表中的倒数第N个节点&quot;&gt;&lt;/a&gt;19. 删除链表中的倒数第N个节点&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/remove-nth-node-from-end-of-list/&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;计算链表长度&lt;br&gt;删除链表的倒数第 n 个结点操作就等价于删除正数第L-n+1个节点，L为链表的长度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;栈&lt;br&gt;遍历链表的同时将所有节点依次入栈，根据栈 先进后出 的原则，弹出栈的第n个节点就是需要删除的节点，并且弹出&lt;br&gt;第n个节点后的栈顶节点为待删除节点的前驱节点。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="链表" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="19.删除链表中的倒数第N个节点" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E9%93%BE%E8%A1%A8/19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 15.三数之和</title>
    <link href="http://example.com/2022/06/27/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://example.com/2022/06/27/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2022-06-27T14:07:51.000Z</published>
    <updated>2022-06-27T14:10:34.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h1><p><strong>题目描述：</strong><br>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。<br>注意：答案中不可以包含重复的三元组。<br><a href="https://leetcode.cn/problems/3sum">三数之和</a><br><strong>示例 1：</strong></p><pre><code>输入：nums = [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]</code></pre><p><strong>代码</strong></p><pre><code>class Solution:    # 三重循环    def threeSum1(self, nums):        nums.sort()        n = len(nums)        result = []        for first in range(0, n):            if first == 0 or nums[first] != nums[first - 1]:                for second in range(first + 1, n):                    if second == first + 1 or nums[second] != nums[second - 1]:                        for third in range(second + 1, n):                            if third == second + 1 or nums[third] != nums[third - 1]:                                if nums[first] + nums[second] + nums[third] == 0:                                    result.append([nums[first], nums[second], nums[third]])        return result        # 排序+双指针    def threeSum(self, nums):        n = len(nums)        nums.sort()        ans = list()                # 枚举 a        for first in range(n):            # 需要和上一次枚举的数不相同            if first &gt; 0 and nums[first] == nums[first - 1]:                continue            # c 对应的指针初始指向数组的最右端            third = n - 1            target = -nums[first]            # 枚举 b            for second in range(first + 1, n):                # 需要和上一次枚举的数不相同                if second &gt; first + 1 and nums[second] == nums[second - 1]:                    continue                # 需要保证 b 的指针在 c 的指针的左侧                while second &lt; third and nums[second] + nums[third] &gt; target:                    third -= 1                # 如果指针重合，随着 b 后续的增加                # 就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环                if second == third:                    break                if nums[second] + nums[third] == target:                    ans.append([nums[first], nums[second], nums[third]])                return ansif __name__ == &quot;__main__&quot;:    slt = Solution()    nums = [-1, 0, 1, 2, -1, -4]    # res = slt.threeSum(nums)    res = slt.threeSum1(nums)  # [[-1, -1, 2], [-1, 0, 1]]    print(res)        </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;15-三数之和&quot;&gt;&lt;a href=&quot;#15-三数之和&quot; class=&quot;headerlink&quot; title=&quot;15.三数之和&quot;&gt;&lt;/a&gt;15.三数之和&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;br&gt;给你一个包含 n 个整数的数组 nums，判断 </summary>
      
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="数组" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    <category term="15.三数之和" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>JVM | JDK监控和故障处理常用工具总结</title>
    <link href="http://example.com/2022/06/22/JDK%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2022/06/22/JDK%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/</id>
    <published>2022-06-23T03:03:09.000Z</published>
    <updated>2022-07-17T13:33:05.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK监控和故障处理常用工具总结"><a href="#JDK监控和故障处理常用工具总结" class="headerlink" title="JDK监控和故障处理常用工具总结"></a>JDK监控和故障处理常用工具总结</h1><ol><li>jps:查看所有java进程<br>JVM Process Status Tool,用于查看所有Java进程的启动类、传入参数和Java虚拟机参数等信息。</li></ol><p>jps命令类似于Linux中的ps命令。</p><p>jps:显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一ID。</p><p><strong>jps命令常用参数：</strong><br>    jps -q:只输出进程的本地虚拟机唯一ID。<br>    jps -l:输出主类的全名，如果进程执行的是 Jar 包，输出 Jar 路径。<br>    jps -v：输出虚拟机进程启动时 JVM 参数。<br>    jps -m：输出传递给 Java 进程 main() 函数的参数。</p><span id="more"></span><p><strong>示例：</strong> 我们写一个简单的HelloWorld程序来测试以上命令，HelloWorld程序如下：</p><pre><code>package leetcode;public class HelloWorld &#123;    public static void main(String[] args) throws InterruptedException &#123;        System.out.println(&quot;Hello World&quot;);        Thread.sleep(100000);    &#125;&#125;</code></pre><p>运行程序并测试以上命令：<br>运行：Run As –&gt; Run Configurations –&gt; 在Program arguments中添加 a=1 b=2 –&gt; run<br><img src="/2022/06/22/JDK%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/1.png"><br>2. jstat:监视虚拟机各种运行状态信息<br>JVM Statistics Monitoring Tool,用于收集HotSpot虚拟机各方面的运行数据。</p><p>jstat（JVM Statistics Monitoring Tool） 使用于监视虚拟机各种运行状态信息的命令行工具。 它可以显示本地或者远程（需要远程主机提供 RMI 支持）虚拟机进程中的类信息、内存、垃圾收集、JIT 编译等运行数据，在没有 GUI，只提供了纯文本控制台环境的服务器上，它将是运行期间定位虚拟机性能问题的首选工具。</p><p><strong>jstat 命令使用格式：</strong></p><pre><code>jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</code></pre><p>比如 jstat -gc -h3 31736 1000 10表示分析进程 id 为 31736 的 gc 情况，每隔 1000ms 打印一次记录，打印 10 次停止，每 3 行后打印指标头部。</p><p><strong>常见的 option 如下：</strong><br>    jstat -class vmid ：显示 ClassLoader 的相关信息；<br>    jstat -compiler vmid ：显示 JIT 编译的相关信息；<br>    jstat -gc vmid ：显示与 GC 相关的堆信息；<br>    jstat -gccapacity vmid ：显示各个代的容量及使用情况；<br>    jstat -gcnew vmid ：显示新生代信息；<br>    jstat -gcnewcapcacity vmid ：显示新生代大小与使用情况；<br>    jstat -gcold vmid ：显示老年代和永久代的行为统计，从jdk1.8开始,该选项仅表示老年代，因为永久代被移除了；<br>    jstat -gcoldcapacity vmid ：显示老年代的大小；<br>    jstat -gcpermcapacity vmid ：显示永久代大小，从jdk1.8开始,该选项不存在了，因为永久代被移除了；<br>    jstat -gcutil vmid ：显示垃圾收集信息；<br>另外，加上 -t参数可以在输出信息上加一个 Timestamp 列，显示程序的运行时间。<br>3. jinfo：实时地查看和调整虚拟机各项参数<br>Configuration Info for Java,显示虚拟机配置信息。</p><p>jinfo vmid :输出当前 jvm 进程的全部参数和系统属性 (第一部分是系统的属性，第二部分是 JVM 的参数)。</p><p>jinfo -flag name vmid :输出对应名称的参数的具体值。比如输出 MaxHeapSize、查看当前 jvm 进程是否开启打印 GC 日志 ( -XX:PrintGCDetails :详细 GC 日志模式，这两个都是默认关闭的)。</p><pre><code>C:\Users\SnailClimb&gt;jinfo  -flag MaxHeapSize 17340-XX:MaxHeapSize=2124414976C:\Users\SnailClimb&gt;jinfo  -flag PrintGC 17340-XX:-PrintGC</code></pre><p>使用 jinfo 可以在不重启虚拟机的情况下，可以动态的修改 jvm 的参数。尤其在线上的环境特别有用,请看下面的例子：</p><p>jinfo -flag [+|-]name vmid 开启或者关闭对应名称的参数。</p><pre><code>C:\Users\SnailClimb&gt;jinfo  -flag  PrintGC 17340-XX:-PrintGCC:\Users\SnailClimb&gt;jinfo  -flag  +PrintGC 17340C:\Users\SnailClimb&gt;jinfo  -flag  PrintGC 17340-XX:+PrintGC</code></pre><ol start="4"><li>jmap<br>Memory Map for Java,生成虚拟机的内存转储快照（heapdump文件）、</li></ol><p>jmap（Memory Map for Java）命令用于生成堆转储快照。 如果不使用 jmap 命令，要想获取 Java 堆转储，可以使用 “-XX:+HeapDumpOnOutOfMemoryError” 参数，可以让虚拟机在 OOM 异常出现之后自动生成 dump 文件，Linux 命令下可以通过 kill -3 发送进程退出信号也能拿到 dump 文件。</p><p>jmap 的作用并不仅仅是为了获取 dump 文件，它还可以查询 finalizer 执行队列、Java 堆和永久代的详细信息，如空间使用率、当前使用的是哪种收集器等。和jinfo一样，jmap有不少功能在 Windows 平台下也是受限制的。</p><p>示例：将指定应用程序的堆快照输出到桌面。后面，可以通过 jhat、Visual VM 等工具分析该堆文件。</p><pre><code>C:\Users\SnailClimb&gt;jmap -dump:format=b,file=C:\Users\SnailClimb\Desktop\heap.hprof 17340Dumping heap to C:\Users\SnailClimb\Desktop\heap.hprof ...Heap dump file created</code></pre><ol start="5"><li>jhat<br>JVM Heap Analysis Tool,用于分析堆转储快照，它会建立一个HTTP/Web服务器，让用户可以在浏览器上查看分析结果。</li></ol><p>jhat 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果。</p><pre><code>C:\Users\SnailClimb&gt;jhat C:\Users\SnailClimb\Desktop\heap.hprofReading from C:\Users\SnailClimb\Desktop\heap.hprof...Dump file created Sat May 04 12:30:31 CST 2019Snapshot read, resolving...Resolving 131419 objects...Chasing references, expect 26 dots..........................Eliminating duplicate references..........................Snapshot resolved.Started HTTP server on port 7000Server is ready.</code></pre><p>访问 <a href="http://localhost:7000/">http://localhost:7000/</a><br>6. jstack<br>Stack Trace for Java,生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。</p><p>jstack（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合.</p><p>生成线程快照的目的主要是定位线程长时间出现停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的原因。线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者在等待些什么资源。</p><p>下面是一个线程死锁的代码。我们下面会通过 jstack 命令进行死锁检查，输出死锁信息，找到发生死锁的线程。</p><pre><code>public class DeadLockDemo &#123;    private static Object resource1 = new Object();//资源 1    private static Object resource2 = new Object();//资源 2    public static void main(String[] args) &#123;        new Thread(() -&gt; &#123;            synchronized (resource1) &#123;                System.out.println(Thread.currentThread() + &quot;get resource1&quot;);                try &#123;                    Thread.sleep(1000);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                System.out.println(Thread.currentThread() + &quot;waiting get resource2&quot;);                synchronized (resource2) &#123;                    System.out.println(Thread.currentThread() + &quot;get resource2&quot;);                &#125;            &#125;        &#125;, &quot;线程 1&quot;).start();        new Thread(() -&gt; &#123;            synchronized (resource2) &#123;                System.out.println(Thread.currentThread() + &quot;get resource2&quot;);                try &#123;                    Thread.sleep(1000);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                System.out.println(Thread.currentThread() + &quot;waiting get resource1&quot;);                synchronized (resource1) &#123;                    System.out.println(Thread.currentThread() + &quot;get resource1&quot;);                &#125;            &#125;        &#125;, &quot;线程 2&quot;).start();    &#125;&#125;</code></pre><p><strong>Output</strong></p><pre><code>Thread[线程 1,5,main]get resource1Thread[线程 2,5,main]get resource2Thread[线程 1,5,main]waiting get resource2Thread[线程 2,5,main]waiting get resource1</code></pre><p>线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过 Thread.sleep(1000);让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。</p><p><strong>通过 jstack 命令分析：</strong></p><pre><code>C:\Users\SnailClimb&gt;jps13792 KotlinCompileDaemon7360 NettyClient2173967972 Launcher8932 Launcher9256 DeadLockDemo10764 Jps17340 NettyServerC:\Users\SnailClimb&gt;jstack 9256</code></pre><p>输出的部分内容如下：</p><pre><code>Found one Java-level deadlock:=============================&quot;线程 2&quot;:  waiting to lock monitor 0x000000000333e668 (object 0x00000000d5efe1c0, a java.lang.Object),  which is held by &quot;线程 1&quot;&quot;线程 1&quot;:  waiting to lock monitor 0x000000000333be88 (object 0x00000000d5efe1d0, a java.lang.Object),  which is held by &quot;线程 2&quot;Java stack information for the threads listed above:===================================================&quot;线程 2&quot;:        at DeadLockDemo.lambda$main$1(DeadLockDemo.java:31)        - waiting to lock &lt;0x00000000d5efe1c0&gt; (a java.lang.Object)        - locked &lt;0x00000000d5efe1d0&gt; (a java.lang.Object)        at DeadLockDemo$$Lambda$2/1078694789.run(Unknown Source)        at java.lang.Thread.run(Thread.java:748)&quot;线程 1&quot;:        at DeadLockDemo.lambda$main$0(DeadLockDemo.java:16)        - waiting to lock &lt;0x00000000d5efe1d0&gt; (a java.lang.Object)        - locked &lt;0x00000000d5efe1c0&gt; (a java.lang.Object)        at DeadLockDemo$$Lambda$1/1324119927.run(Unknown Source)        at java.lang.Thread.run(Thread.java:748)Found 1 deadlock.</code></pre><p>可以看到 jstack 命令已经帮我们找到发生死锁的线程的具体信息。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JDK监控和故障处理常用工具总结&quot;&gt;&lt;a href=&quot;#JDK监控和故障处理常用工具总结&quot; class=&quot;headerlink&quot; title=&quot;JDK监控和故障处理常用工具总结&quot;&gt;&lt;/a&gt;JDK监控和故障处理常用工具总结&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;jps:查看所有java进程&lt;br&gt;JVM Process Status Tool,用于查看所有Java进程的启动类、传入参数和Java虚拟机参数等信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;jps命令类似于Linux中的ps命令。&lt;/p&gt;
&lt;p&gt;jps:显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一ID。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;jps命令常用参数：&lt;/strong&gt;&lt;br&gt;    jps -q:只输出进程的本地虚拟机唯一ID。&lt;br&gt;    jps -l:输出主类的全名，如果进程执行的是 Jar 包，输出 Jar 路径。&lt;br&gt;    jps -v：输出虚拟机进程启动时 JVM 参数。&lt;br&gt;    jps -m：输出传递给 Java 进程 main() 函数的参数。&lt;/p&gt;</summary>
    
    
    
    <category term="JVM" scheme="http://example.com/categories/JVM/"/>
    
    <category term="JDK监控和故障处理常用工具总结" scheme="http://example.com/categories/JVM/JDK%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 169.多数元素</title>
    <link href="http://example.com/2022/06/19/%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/"/>
    <id>http://example.com/2022/06/19/%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</id>
    <published>2022-06-20T03:48:45.000Z</published>
    <updated>2022-06-27T14:11:10.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169.多数元素"></a>169.多数元素</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊n/2⌋ 的元素。<br>你可以假设数组是非空的，并且给定的数组总是存在多数元素。<br><a href="https://leetcode.cn/problems/majority-element">题目链接</a></p><span id="more"></span><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li><p>HashMap<br>使用哈希表统计每个元素出现的次数，返回哈希表中值最大的键。</p></li><li><p>排序<br>如果将数组 nums 中的所有元素按照单调递增或单调递减的顺序排序，那么下标为 ⌊n/2⌋ 的元素（下标从 0 开始）一定是众数。<br>因此，对数组进行排序并返回下标为⌊n/2⌋的数组元素。</p></li><li><p>随机化<br>因为超过 ⌊n/2⌋ 的数组下标被众数占据了，这样我们随机挑选一个下标对应的元素并验证，有很大的概率能找到众数。</p></li><li><p>分治<br>如果数 a 是数组 nums 的众数，如果我们将 nums 分成两部分，那么 a 必定是至少一部分的众数。<br>我们使用经典的分治算法递归求解，直到所有的子问题都是长度为 1 的数组。长度为 1 的子数组中唯一的数显然是众数，直接返回即可。如果回溯后某区间的长度大于 1，我们必须将左右子区间的值合并。如果它们的众数相同，那么显然这一段区间的众数是它们相同的值。否则，我们需要比较两个众数在整个区间内出现的次数来决定该区间的众数。</p></li><li><p>Boyer-Moore投票算法<br>如果我们把众数记为 +1+1+1，把其他数记为 −1-1−1，将它们全部加起来，显然和大于 0，从结果本身我们可以看出众数比其他数多。</p><h2 id="代码-java版本"><a href="#代码-java版本" class="headerlink" title="代码(java版本)"></a>代码(java版本)</h2><p> import java.util.Arrays;<br> import java.util.HashMap;<br> import java.util.Iterator;<br> import java.util.Map;<br> import java.util.Map.Entry;<br> import java.util.Random;</p><p> public class MajorityElement {</p><pre><code> private int randRange(Random rand, int min, int max)&#123;     return rand.nextInt(max - min) + min; &#125;  private int countOccurences(int[] nums, int num)&#123;     int count = 0;          for(int num1 : nums)&#123;         if(num == num1)&#123;             count++;         &#125;     &#125;          return count; &#125;  public int majorityElement(int[] nums)&#123;     Random rand = new Random();          int majorityCount = nums.length / 2;          while(true)&#123;         int candidate = nums[randRange(rand, 0, nums.length)];         if(countOccurences(nums, candidate) &gt; majorityCount)&#123;             return candidate;         &#125;     &#125; &#125;  private int countInRange(int[] nums, int num, int lo, int hi)&#123;     int count = 0;     for(int i = lo; i &lt;= hi; i++)&#123;         if(nums[i] == num)&#123;             count++;         &#125;     &#125;     return count; &#125;  private int majorityElementRec(int[] nums, int lo, int hi)&#123;     if(lo == hi)&#123;         return nums[lo];     &#125;          int mid = (hi - lo) / 2 + lo;     int left = majorityElementRec(nums, lo, mid);     int right = majorityElementRec(nums, mid + 1, hi);          if(left == right)&#123;         return left;     &#125;          int leftCount = countInRange(nums, left, lo, hi);     int rightCount = countInRange(nums, right, lo, hi);          return leftCount &gt; rightCount ? left : right; &#125;  //方法4：分治 public int majorityElement1(int[] nums)&#123;     return majorityElementRec(nums, 0, nums.length - 1); &#125;  //方法5：Boyer-Moore public int majorityElement2(int[] nums)&#123;     int count = 0;     Integer candidate = null;          for (int num : nums)&#123;         if(count == 0)&#123;             candidate = num;         &#125;         count += (num == candidate) ? 1 : -1;     &#125;          return candidate; &#125;  public static void main(String[] args) &#123;     int[] nums = new int[]&#123;2,2,1,1,1,2,2&#125;;          //方法1：HashMap</code></pre><p> //        Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;();<br> //        for(Integer num : nums){<br> //            String tempNum = num.toString();<br> //            if(!map.keySet().contains(tempNum)){<br> //                map.put(tempNum, 1);<br> //<br> //            }else{<br> //                map.put(tempNum, map.get(tempNum) + 1);<br> //            }<br> //        }<br> //<br> //        Iterator&lt;Entry&lt;String, Integer&gt;&gt; iterator = map.entrySet().iterator();<br> //        for(;iterator.hasNext();){<br> //            Entry&lt;String, Integer&gt; next = iterator.next();<br> //            String key = next.getKey();<br> //            Integer value = next.getValue();<br> //            if(value &gt; (int)(nums.length / 2)){<br> //                System.out.println(key);<br> //            }<br> //        }</p><pre><code>     //方法2：排序</code></pre><p> //        Arrays.sort(nums);<br> //        System.out.println(nums[nums.length / 2]);</p><pre><code>     //方法3：随机化     MajorityElement majorityElement = new MajorityElement();     int majority1 = majorityElement.majorityElement(nums);     System.out.println(majority1);          //方法4：分治     int majority2 = majorityElement.majorityElement1(nums);     System.out.println(majority2);          //方法5：Boyer-Moore投票算法     int majority3 = majorityElement.majorityElement2(nums);     System.out.println(majority3); &#125;</code></pre><p> }</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;169-多数元素&quot;&gt;&lt;a href=&quot;#169-多数元素&quot; class=&quot;headerlink&quot; title=&quot;169.多数元素&quot;&gt;&lt;/a&gt;169.多数元素&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊n/2⌋ 的元素。&lt;br&gt;你可以假设数组是非空的，并且给定的数组总是存在多数元素。&lt;br&gt;&lt;a href=&quot;https://leetcode.cn/problems/majority-element&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="数组" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    <category term="169.多数元素" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>JVM | 垃圾收集器</title>
    <link href="http://example.com/2022/06/13/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>http://example.com/2022/06/13/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</id>
    <published>2022-06-14T03:33:16.000Z</published>
    <updated>2022-06-19T14:04:54.890Z</updated>
    
    <content type="html"><![CDATA[<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><table><thead><tr><th align="center">垃圾收集器</th><th align="center">串行/并行/并发</th><th align="center">新生代/老年代</th><th align="center">算法</th><th align="center">目标</th><th align="center">适用场景</th></tr></thead><tbody><tr><td align="center">Serial</td><td align="center">串行</td><td align="center">新生代</td><td align="center">复制算法</td><td align="center">响应速度优先</td><td align="center">单CPU环境下的Client模式</td></tr><tr><td align="center">Serial Old</td><td align="center">串行</td><td align="center">老年代</td><td align="center">标记-整理</td><td align="center">响应速度优先</td><td align="center">单CPU环境下的Client模式、CMS的后备预案</td></tr><tr><td align="center">ParNew</td><td align="center">并行</td><td align="center">新生代</td><td align="center">复制算法</td><td align="center">响应速度优先</td><td align="center">多CPU环境下在Server模式下与CMS配合</td></tr><tr><td align="center">Parallel Scavenge</td><td align="center">并行</td><td align="center">新生代</td><td align="center">复制算法</td><td align="center">吞吐量优先</td><td align="center">在后台运算而不需要太多交互任务</td></tr><tr><td align="center">Parallel Old</td><td align="center">并行</td><td align="center">老年代</td><td align="center">标记整理</td><td align="center">吞吐量优先</td><td align="center">在后台运算而不需要太多交互任务</td></tr><tr><td align="center">CMS</td><td align="center">并发</td><td align="center">老年代</td><td align="center">标记-清除</td><td align="center">响应速度优先</td><td align="center">集中在互联网网站或者基于浏览器的B/S系统的服务端上的Java应用</td></tr><tr><td align="center">G1</td><td align="center">并发</td><td align="center">Both</td><td align="center">标记-整理+复制算法</td><td align="center">响应速度优先</td><td align="center">面向服务端应用，将来替换CMS</td></tr><tr><td align="center">Shenandoah</td><td align="center">并发</td><td align="center">Both</td><td align="center">标记-整理+复制算法</td><td align="center">低延迟</td><td align="center"></td></tr><tr><td align="center">ZGC</td><td align="center">并发</td><td align="center">Both</td><td align="center">标记-整理+复制算法</td><td align="center">低延迟</td><td align="center"></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;垃圾收集器&quot;&gt;&lt;a href=&quot;#垃圾收集器&quot; class=&quot;headerlink&quot; title=&quot;垃圾收集器&quot;&gt;&lt;/a&gt;垃圾收集器&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;垃圾收集器&lt;/th&gt;
&lt;th align=</summary>
      
    
    
    
    <category term="JVM" scheme="http://example.com/categories/JVM/"/>
    
    <category term="垃圾收集器" scheme="http://example.com/categories/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
    <category term="GC" scheme="http://example.com/tags/GC/"/>
    
    <category term="垃圾收集器" scheme="http://example.com/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>并发 | 线程池</title>
    <link href="http://example.com/2022/06/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0-1/"/>
    <id>http://example.com/2022/06/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0-1/</id>
    <published>2022-06-08T01:59:41.000Z</published>
    <updated>2022-06-08T09:56:54.956Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p><strong>线程池的实现原理</strong><br><img src="/2022/06/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0-1/1.jpg"><br><strong>线程池的使用</strong><br>（1）线程池的创建</p><pre><code>new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime,unit,workQueue, handler)Parameters:    corePoolSize: the number of threads to keep in the pool, even if they are idle, unless allowCoreThreadTimeOut is set    maximumPoolSize: the maximum number of threads to allow in the pool    keepAliveTime: when the number of threads is greater than the core, this is the maximum time that excess idle threads will wait for new tasks before terminating.    unit the time: unit for the keepAliveTime argument    workQueue：the queue to use for holding tasks before they are executed. This queue will hold only the Runnable tasks submitted by the execute method.    threadFactory: set thread factory    handler: the handler to use when execution is blocked because the thread bounds and queue capacities are reached    workQueue:    ArrayBlockingQueue：基于数组结构的有界阻塞队列    LinkedBlockingQueue：基于链表结果的阻塞队列    SynchronousQueue：不存储元素的阻塞队列    PriorityBlockingQueue:具有优先级的无限阻塞队列handler:    AbortPolicy:直接抛出RejectedExecutionException异常    CallerRunsPolicy:使用调用者所在线程来执行任务    DiscardOldestPolicy：丢弃掉在队列中存在时间最久的任务    DiscardPolicy:默认丢弃任务，不进行任何通知</code></pre><p><a href="https://victory-liao.github.io/2022/04/24/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%847%E4%B8%AD%E6%96%B9%E5%BC%8F/">创建线程池的7种方式</a><br><a href="https://blog.csdn.net/qq_45404693/article/details/121020639">Executor框架</a></p><span id="more"></span><p>（2）向线程池提交任务<br>    execute():用于提交不需要返回值的任务。<br>    submit():用于提交需要返回值的任务。<br>（3）关闭线程池<br>    shutdown()<br>    shutdownNow()<br><strong>线程池的配置</strong><br>（1）<br>CPU密集型任务：配置 CPU数量+1 个线程的线程池；<br>IO密集型任务：配置 2*CPU数量 个线程的线程池；<br>混合型任务：两个事务执行时间相差不大，如果可以拆分，将其分解成一个CPU密集型任务和一个IO密集型任务，如果两个任务的执行时间相差太大，则没有必要拆分。<br>（2）优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理，让优先级高的任务先执行。<br>（3）执行时间不同的任务可以交给不同规模的线程池来处理，或者可以使用优先级队列，让执行时间段的任务先执行。<br>（4）依赖数据库连接池的任务，因为线程提交SQL后选哟等待数据库返回结果，等待的时间越长，则CPU空闲时间越长，应该设置较大的线程数。<br>（5）建议使用有界队列。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;线程池&quot;&gt;&lt;a href=&quot;#线程池&quot; class=&quot;headerlink&quot; title=&quot;线程池&quot;&gt;&lt;/a&gt;线程池&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;线程池的实现原理&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;/2022/06/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0-1/1.jpg&quot;&gt;&lt;br&gt;&lt;strong&gt;线程池的使用&lt;/strong&gt;&lt;br&gt;（1）线程池的创建&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime,unit,workQueue, handler)

Parameters:
    corePoolSize: the number of threads to keep in the pool, even if they are idle, unless allowCoreThreadTimeOut is set
    maximumPoolSize: the maximum number of threads to allow in the pool
    keepAliveTime: when the number of threads is greater than the core, this is the maximum time that excess idle threads will wait for new tasks before terminating.
    unit the time: unit for the keepAliveTime argument
    workQueue：the queue to use for holding tasks before they are executed. This queue will hold only the Runnable tasks submitted by the execute method.
    threadFactory: set thread factory
    handler: the handler to use when execution is blocked because the thread bounds and queue capacities are reached
    
workQueue:
    ArrayBlockingQueue：基于数组结构的有界阻塞队列
    LinkedBlockingQueue：基于链表结果的阻塞队列
    SynchronousQueue：不存储元素的阻塞队列
    PriorityBlockingQueue:具有优先级的无限阻塞队列

handler:
    AbortPolicy:直接抛出RejectedExecutionException异常
    CallerRunsPolicy:使用调用者所在线程来执行任务
    DiscardOldestPolicy：丢弃掉在队列中存在时间最久的任务
    DiscardPolicy:默认丢弃任务，不进行任何通知
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://victory-liao.github.io/2022/04/24/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%847%E4%B8%AD%E6%96%B9%E5%BC%8F/&quot;&gt;创建线程池的7种方式&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/qq_45404693/article/details/121020639&quot;&gt;Executor框架&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="并发" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="线程池" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="线程池" scheme="http://example.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    <category term="Executor" scheme="http://example.com/tags/Executor/"/>
    
    <category term="Executors" scheme="http://example.com/tags/Executors/"/>
    
    <category term="ThreadPoolExecutor" scheme="http://example.com/tags/ThreadPoolExecutor/"/>
    
    <category term="ScheduledThreadPoolExecutor" scheme="http://example.com/tags/ScheduledThreadPoolExecutor/"/>
    
  </entry>
  
  <entry>
    <title>并发 | Exchanger</title>
    <link href="http://example.com/2022/06/07/Exchanger/"/>
    <id>http://example.com/2022/06/07/Exchanger/</id>
    <published>2022-06-07T14:14:03.000Z</published>
    <updated>2022-06-07T14:28:19.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h1><p>Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程<br>通过exchange方法交换数据，如果第一个线程先执行exchange方法，它会一直等待第二个线程也执行exchange方法，当<br>两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。<br><strong>应用场景</strong><br>（1）遗传算法<br>遗传算法里需要选出两个人作为交配对象，这时候会交换两个人的数据，并使用交叉规则得出2个交配结果。<br>（2）校对工作<br>例如，我们需要将纸制银行流水通过人工的方式录入成电子银行流水，为了避免错误，采用AB岗两个人进行录入，录入到<br>Excel后，系统需要加载这两个Excel，并对两个Excel数据进行校对，看看是否录入一致。<br><strong>示例代码：</strong></p><pre><code>package concurrency.exchanger;import java.util.concurrent.Exchanger;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class ExchangerTest &#123;    private static final Exchanger&lt;String&gt; exgr = new Exchanger&lt;String&gt;();        private static ExecutorService threadPool = Executors.newFixedThreadPool(2);        public static void main(String[] args) &#123;        threadPool.execute(new Runnable()&#123;            @Override            public void run() &#123;                try&#123;                    String A = &quot;银行流水A&quot;;//A录入银行流水数据                    exgr.exchange(A);                &#125;catch(InterruptedException e)&#123;                    e.printStackTrace();                &#125;            &#125;                    &#125;);                threadPool.execute(new Runnable()&#123;            @Override            public void run() &#123;                try&#123;                    String B = &quot;银行流水B&quot;;//B录入银行流水数据                    String A = exgr.exchange(B);                    System.out.println(&quot;A和B数据是否一致：&quot;+A.equals(B)+&quot;,A录入的是：&quot;+A+&quot;,B录入的是：&quot;+B);                &#125;catch(InterruptedException e)&#123;                    e.printStackTrace();                &#125;            &#125;                    &#125;);    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Exchanger&quot;&gt;&lt;a href=&quot;#Exchanger&quot; class=&quot;headerlink&quot; title=&quot;Exchanger&quot;&gt;&lt;/a&gt;Exchanger&lt;/h1&gt;&lt;p&gt;Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程</summary>
      
    
    
    
    <category term="并发" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="Exchanger" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/Exchanger/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="Exchanger" scheme="http://example.com/tags/Exchanger/"/>
    
  </entry>
  
  <entry>
    <title>并发 | Semaphore</title>
    <link href="http://example.com/2022/06/07/Semaphore/"/>
    <id>http://example.com/2022/06/07/Semaphore/</id>
    <published>2022-06-07T14:02:35.000Z</published>
    <updated>2022-06-07T14:11:47.673Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><p>Semaphore（信号量）是用来控制同时访问特定资源的数量，它通过协调各个线程，以保证合理的使用公共资源。<br><strong>应用场景：</strong><br>Semaphore可以用于做<strong>流量控制</strong>，特别是公共资源优先的应用场景，比如<strong>数据库连接</strong>。<br><strong>示例代码：</strong></p><pre><code>package concurrency.semaphore;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;public class SemaphoreTest &#123;    private static final int THREAD_COUNT = 30;        private static ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);        private static Semaphore s = new Semaphore(10);        public static void main(String[] args) &#123;        for(int i = 0; i &lt; THREAD_COUNT; i++)&#123;//虽然有30个线程在执行，但是只允许10个并发执行            threadPool.execute(new Runnable()&#123;                @Override                public void run()&#123;                    try&#123;                        s.acquire();                        System.out.println(&quot;save data&quot;);                        s.release();                    &#125;catch(InterruptedException e)&#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;);        &#125;        threadPool.shutdown();    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Semaphore&quot;&gt;&lt;a href=&quot;#Semaphore&quot; class=&quot;headerlink&quot; title=&quot;Semaphore&quot;&gt;&lt;/a&gt;Semaphore&lt;/h1&gt;&lt;p&gt;Semaphore（信号量）是用来控制同时访问特定资源的数量，它通过协调各个线程，以</summary>
      
    
    
    
    <category term="并发" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="Semaphore" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/Semaphore/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="Semaphore" scheme="http://example.com/tags/Semaphore/"/>
    
  </entry>
  
</feed>
