<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Victory&#39;s Blog</title>
  
  <subtitle>非淡泊无以明志，非宁静无以致远</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-11-06T09:32:06.144Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>victory-liao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>requests | 爬取精美壁纸</title>
    <link href="http://example.com/2021/11/06/%E7%88%AC%E5%8F%96%E7%B2%BE%E7%BE%8E%E5%A3%81%E7%BA%B8/"/>
    <id>http://example.com/2021/11/06/%E7%88%AC%E5%8F%96%E7%B2%BE%E7%BE%8E%E5%A3%81%E7%BA%B8/</id>
    <published>2021-11-06T09:29:25.000Z</published>
    <updated>2021-11-06T09:32:06.144Z</updated>
    
    <content type="html"><![CDATA[<h1 id="爬取精美壁纸"><a href="#爬取精美壁纸" class="headerlink" title="爬取精美壁纸"></a>爬取精美壁纸</h1><p><strong>爬取目标：</strong> Wallhaven网站中Toplist标签下前50页共1196张精美壁纸。<br><a href="https://mp.weixin.qq.com/s/BiJKm4SnL6qCLEK91xcDIQ">参考资料</a></p><p><strong>代码：</strong></p><pre><code># -*- coding:utf-8 -*-import osimport requestsfrom lxml import etree# 1.获取每页的html信息headers = &#123;    &#39;user-agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) &#39;                  &#39;Chrome/95.0.4638.54 Safari/537.36 &#39;&#125;# 定义获取每页html信息的函数def get_html_info(page):    url = f&#39;https://wallhaven.cc/toplist?page=&#123;page&#125;&#39;    resp = requests.get(url, headers=headers)    print(resp.text)    resp_html = etree.HTML(resp.text)    return resp_html# 2.解析url信息+下载图片def get_pic(resp_html):    pic_url_list = []    lis = resp_html.xpath(&#39;//*[@id=&quot;thumbs&quot;]/section[1]/ul/li&#39;)  # 获取该页所有缩略图包含的信息    for li in lis:        pic_url = li.xpath(&#39;./figure/a/@href&#39;)[0]  # 获取存放在缩略图信息中的缩略图原图网址        pic_url_list.append(pic_url)    for pic_url in pic_url_list:        resp2 = requests.get(pic_url, headers=headers)        r_html2 = etree.HTML(resp2.text)        pic_size = r_html2.xpath(&#39;//*[@id=&quot;showcase-sidebar&quot;]/div/div[1]/h3/text()&#39;)[0]  # 用照片分辨率作为名称一部分        final_url = r_html2.xpath(&#39;//*[@id=&quot;wallpaper&quot;]/@src&#39;)[0]  # 获取原图下载地址        pic = requests.get(url=final_url, headers=headers).content        if not os.path.exists(&#39;Wallhaven&#39;):            os.mkdir(&#39;Wallhaven&#39;)        with open(&#39;Wallhaven\\&#39; + pic_size + final_url[-10:], mode=&#39;wb&#39;) as f:            f.write(pic)  # 保存图片            print(pic_size + final_url[-10:] + &#39;，下载完毕，已下载&#123;&#125;张壁纸&#39;.format(len(os.listdir(&#39;Wallhaven&#39;))))# 3.构建main()函数运行程序def main():    page_range = range(1,51) # 爬取1-50页的壁纸    for i in page_range:        r = get_html_info(i)        get_pic(r)        print(f&#39;===============第&#123;i&#125;页下载完毕=============&#39;)if __name__ == &#39;__main__&#39;:    main()</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;爬取精美壁纸&quot;&gt;&lt;a href=&quot;#爬取精美壁纸&quot; class=&quot;headerlink&quot; title=&quot;爬取精美壁纸&quot;&gt;&lt;/a&gt;爬取精美壁纸&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;爬取目标：&lt;/strong&gt; Wallhaven网站中Toplist标签下前50页共1196</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="requests" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"/>
    
    
    <category term="requests" scheme="http://example.com/tags/requests/"/>
    
    <category term="爬虫" scheme="http://example.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>深度学习 | 大胆新奇的卷积神经网络设计</title>
    <link href="http://example.com/2021/11/05/%E5%A4%A7%E8%83%86%E6%96%B0%E5%A5%87%E7%9A%84%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AE%BE%E8%AE%A1/"/>
    <id>http://example.com/2021/11/05/%E5%A4%A7%E8%83%86%E6%96%B0%E5%A5%87%E7%9A%84%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-11-06T04:15:28.000Z</published>
    <updated>2021-11-06T09:04:25.587Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/6HbPBYQvLMU5okI-tIUBcg">大胆又新奇的卷积网络结构设计</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/6HbPBYQvLMU5okI-tIUBcg&quot;&gt;大胆又新奇的卷积网络结构设计&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="深度学习" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="深度学习" scheme="http://example.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>深度学习基础 | 神经网络模型概览</title>
    <link href="http://example.com/2021/11/05/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%A7%88/"/>
    <id>http://example.com/2021/11/05/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%A7%88/</id>
    <published>2021-11-06T04:15:08.000Z</published>
    <updated>2021-11-06T07:39:18.687Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/ds5YWmyIZTHW55Tkdf3pww">一文概览神经网络模型</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/ds5YWmyIZTHW55Tkdf3pww&quot;&gt;一文概览神经网络模型&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="深度学习" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="深度学习基础" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="深度学习" scheme="http://example.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="神经网络模型" scheme="http://example.com/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>深度学习基础 | 一文看懂各种神经网络优化算法</title>
    <link href="http://example.com/2021/11/05/%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82%E5%90%84%E7%A7%8D%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2021/11/05/%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82%E5%90%84%E7%A7%8D%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/</id>
    <published>2021-11-06T04:14:51.000Z</published>
    <updated>2021-11-06T09:27:38.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一文看懂各种神经网络优化算法"><a href="#一文看懂各种神经网络优化算法" class="headerlink" title="一文看懂各种神经网络优化算法"></a>一文看懂各种神经网络优化算法</h1><p><a href="https://mp.weixin.qq.com/s/gRrZImMydyCDBNCTIgVYXw">一文看懂各种神经网络优化算法</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一文看懂各种神经网络优化算法&quot;&gt;&lt;a href=&quot;#一文看懂各种神经网络优化算法&quot; class=&quot;headerlink&quot; title=&quot;一文看懂各种神经网络优化算法&quot;&gt;&lt;/a&gt;一文看懂各种神经网络优化算法&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://mp.we</summary>
      
    
    
    
    <category term="深度学习" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="深度学习基础" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="优化算法" scheme="http://example.com/tags/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>科研方法分享</title>
    <link href="http://example.com/2021/11/05/%E7%A7%91%E7%A0%94%E6%96%B9%E6%B3%95%E5%88%86%E4%BA%AB/"/>
    <id>http://example.com/2021/11/05/%E7%A7%91%E7%A0%94%E6%96%B9%E6%B3%95%E5%88%86%E4%BA%AB/</id>
    <published>2021-11-06T04:14:17.000Z</published>
    <updated>2021-11-06T04:14:17.845Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>深度学习基础 | 一文深层解决模型过拟合</title>
    <link href="http://example.com/2021/11/05/%E4%B8%80%E6%96%87%E6%B7%B1%E5%B1%82%E8%A7%A3%E5%86%B3%E6%A8%A1%E5%9E%8B%E8%BF%87%E6%8B%9F%E5%90%88/"/>
    <id>http://example.com/2021/11/05/%E4%B8%80%E6%96%87%E6%B7%B1%E5%B1%82%E8%A7%A3%E5%86%B3%E6%A8%A1%E5%9E%8B%E8%BF%87%E6%8B%9F%E5%90%88/</id>
    <published>2021-11-06T04:13:27.000Z</published>
    <updated>2021-11-06T09:43:43.072Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一文深层解决模型过拟合"><a href="#一文深层解决模型过拟合" class="headerlink" title="一文深层解决模型过拟合"></a>一文深层解决模型过拟合</h1><p><a href="https://mp.weixin.qq.com/s/RBSewyWPdUnywKplVDzeLA">参考资料</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一文深层解决模型过拟合&quot;&gt;&lt;a href=&quot;#一文深层解决模型过拟合&quot; class=&quot;headerlink&quot; title=&quot;一文深层解决模型过拟合&quot;&gt;&lt;/a&gt;一文深层解决模型过拟合&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/</summary>
      
    
    
    
    <category term="深度学习" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="深度学习基础" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="深度学习" scheme="http://example.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="过拟合" scheme="http://example.com/tags/%E8%BF%87%E6%8B%9F%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>python | 动态查找列表中的第二个number</title>
    <link href="http://example.com/2021/11/05/%E5%8A%A8%E6%80%81%E6%9F%A5%E6%89%BE%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%BA%8C%E4%B8%AAnumber/"/>
    <id>http://example.com/2021/11/05/%E5%8A%A8%E6%80%81%E6%9F%A5%E6%89%BE%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%BA%8C%E4%B8%AAnumber/</id>
    <published>2021-11-05T10:54:43.000Z</published>
    <updated>2021-11-05T10:56:14.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态查找列表中的第二个number"><a href="#动态查找列表中的第二个number" class="headerlink" title="动态查找列表中的第二个number"></a>动态查找列表中的第二个number</h1><p>方法：先找到第一个2所在位置fist_index，切片new_list=names[index+1:]得到新的列表，<br>再从新列表中找第一个2的位置second_index.最终第二个2的位置为first_index+second_index+1</p><span id="more"></span><p><strong>代码：</strong></p><pre><code>names = [&#39;apple&#39;, &#39;rice&#39;, &#39;jack&#39;, &#39;rose&#39;, 2, &#39;girl&#39;, &#39;boy&#39;, 2, &#39;heather&#39;, 2]first_index = names.index(2)new_list = names[first_index + 1:]second_index = new_list.index(2)second_loction = first_index + second_index + 1  # 第二个2的位置print(&#39;第二个2 的位置为：&#39;, second_loction)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;动态查找列表中的第二个number&quot;&gt;&lt;a href=&quot;#动态查找列表中的第二个number&quot; class=&quot;headerlink&quot; title=&quot;动态查找列表中的第二个number&quot;&gt;&lt;/a&gt;动态查找列表中的第二个number&lt;/h1&gt;&lt;p&gt;方法：先找到第一个2所在位置fist_index，切片new_list=names[index+1:]得到新的列表，&lt;br&gt;再从新列表中找第一个2的位置second_index.最终第二个2的位置为first_index+second_index+1&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="基础" scheme="http://example.com/categories/python/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>xlrd | 从Excel表中批量复制粘贴数据到新表</title>
    <link href="http://example.com/2021/11/05/%E4%BB%8EExcel%E8%A1%A8%E4%B8%AD%E6%89%B9%E9%87%8F%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E6%95%B0%E6%8D%AE%E5%88%B0%E6%96%B0%E8%A1%A8/"/>
    <id>http://example.com/2021/11/05/%E4%BB%8EExcel%E8%A1%A8%E4%B8%AD%E6%89%B9%E9%87%8F%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E6%95%B0%E6%8D%AE%E5%88%B0%E6%96%B0%E8%A1%A8/</id>
    <published>2021-11-05T08:08:25.000Z</published>
    <updated>2021-11-05T08:10:13.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从Excel表中批量复制粘贴数据到新表"><a href="#从Excel表中批量复制粘贴数据到新表" class="headerlink" title="从Excel表中批量复制粘贴数据到新表"></a>从Excel表中批量复制粘贴数据到新表</h1><p>程序实现从Excel表中批量复制粘贴部分数据到新表。</p><span id="more"></span><p>代码：</p><pre><code># 读取xls文件中的数据import xlrdfile = &quot;原表.xls&quot;wb = xlrd.open_workbook(file)  # 读取工作簿ws = wb.sheets()[0]  # 选第一个工作表data = []for row in range(7, ws.nrows):    name = ws.cell(row, 1).value.strip()  # 科室名称    total1 = ws.cell(row, 2).value  # 总计    total2 = ws.cell(row, 3).value  # 计    avg = ws.cell(row, 20).value  # 平均每日人次    info_list = [name, total1, total2, avg]    if info_list[0] != &quot;&quot;:  # 去除空数据        data.append(info_list)from openpyxl import load_workbookfrom openpyxl.styles import Border, Side, PatternFill, Font, GradientFill, Alignment  # 设置单元格格式thin = Side(border_style=&quot;thin&quot;, color=&quot;000000&quot;)  # 定义边框粗细及颜色file = &quot;统计表模板.xlsx&quot;wb = load_workbook(file)ws = wb.active# 写入数据for i in data:    ws.append(i)# 设置字号，对齐，缩小字体填充，加边框# Font(bold=True)可加粗字体for row_number in range(3, ws.max_row + 1):    ws.row_dimensions[row_number].height = 25  # 设置行高    for col_number in range(1, 5):        c = ws.cell(row=row_number, column=col_number)        c.font = Font(size=11, bold=True)        c.border = Border(top=thin, left=thin, right=thin, bottom=thin)        c.alignment = Alignment(horizontal=&quot;center&quot;, vertical=&quot;center&quot;)wb.save(&quot;统计表.xlsx&quot;)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;从Excel表中批量复制粘贴数据到新表&quot;&gt;&lt;a href=&quot;#从Excel表中批量复制粘贴数据到新表&quot; class=&quot;headerlink&quot; title=&quot;从Excel表中批量复制粘贴数据到新表&quot;&gt;&lt;/a&gt;从Excel表中批量复制粘贴数据到新表&lt;/h1&gt;&lt;p&gt;程序实现从Excel表中批量复制粘贴部分数据到新表。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="xlrd" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/xlrd/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="openpyxl" scheme="http://example.com/tags/openpyxl/"/>
    
    <category term="xlrd" scheme="http://example.com/tags/xlrd/"/>
    
  </entry>
  
  <entry>
    <title>requests | 批量下载公众号文章</title>
    <link href="http://example.com/2021/11/05/batch-download-gzh-article/"/>
    <id>http://example.com/2021/11/05/batch-download-gzh-article/</id>
    <published>2021-11-05T08:00:34.000Z</published>
    <updated>2021-11-05T08:02:59.377Z</updated>
    
    <content type="html"><![CDATA[<h1 id="批量下载公众号文章"><a href="#批量下载公众号文章" class="headerlink" title="批量下载公众号文章"></a>批量下载公众号文章</h1><p>程序实现从公众号批量下载文章并保存为pdf.</p><span id="more"></span><p>代码：</p><pre><code># import requests# import json## url = &quot;https://mp.weixin.qq.com/mp/profile_ext&quot;  # 公号的链接# headers = &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) &quot;#                          &quot;Chrome/83.0.4103.116 Safari/537.36 &quot;&#125;# proxies = &#123;#     &#39;https&#39;: None,#     &#39;http&#39;: None,# &#125;# uin = &#39;MjU1Mjg4NjAzNQ==&#39;# # Key会随时间变化，需要获取最新的key，不然抓取不到数据# key = &#39;3390dbef8687839b29dd8a2499d96e7ee28002a981da4f1d962e56d4c93430eef1b27ae1dc2e2304590ee88091fcb33e6f59df16f55cf9fa4516fa6ab77f5db7055f877e3b48007fc57fc07a522d0b0d1d15c3ee0ca047f22cd49301079a0e10b01df3fe4069bbdb4dd2cbe38cfa1dcb3ac01a93dd04c8e01504896fcab7d8be&#39;# # 重要参数# params = &#123;#     &#39;action&#39;: &#39;getmsg&#39;,#     &#39;__biz&#39;: &#39;MzU4ODg3MzAwNw==&#39;,  # 每个公众号的不一样，从Fiddler复制过来#     &#39;f&#39;: &#39;json&#39;,#     &#39;offset&#39;: 0,  # 控制翻页#     &#39;count&#39;: &#39;10&#39;,#     &#39;is_ok&#39;: &#39;1&#39;,#     &#39;scene&#39;: &#39;124&#39;,#     &#39;uin&#39;: uin,  # 每个公众号的不一样，从Fiddler复制过来#     &#39;key&#39;: key,  # 每个公众号的不一样，从Fiddler复制过来#     &#39;wxtoken&#39;: &#39;&#39;,#     &#39;x5&#39;: &#39;0&#39;,# &#125;## # 获取公众号页面信息# response = requests.get(url, headers=headers, params=params, proxies=proxies)# # print(response.text)# # print(type(response.text))# response_dict = json.loads(response.text)  # 将字符串转换成python能识别的格式# # print(response_dict)## general_msg_list = response_dict[&#39;general_msg_list&#39;]  # 此时是字符串# # print(general_msg_list)# data_list = json.loads(general_msg_list)[&#39;list&#39;]  # 转换成python能够识别的格式，并取出文章链接的信息# print(data_list)# print(data_list[0])import requestsimport jsonimport timedef article_links(index):    &quot;&quot;&quot;用于获取单个页面的文章链接，index用于控制页数&quot;&quot;&quot;    links = []    url = &#39;https://mp.weixin.qq.com/mp/profile_ext&#39;    headers = &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) &quot;                             &quot;Chrome/83.0.4103.116 Safari/537.36 &quot;&#125;    proxies = &#123;        &#39;https&#39;: None,        &#39;http&#39;: None,    &#125;    uin = &#39;MjU1Mjg4NjAzNQ==&#39;    # # Key会随时间变化，需要获取最新的key，不然抓取不到数据    key = &#39;3390dbef8687839b29dd8a2499d96e7ee28002a981da4f1d962e56d4c93430eef1b27ae1dc2e2304590ee88091fcb33e6f59df16f55cf9fa4516fa6ab77f5db7055f877e3b48007fc57fc07a522d0b0d1d15c3ee0ca047f22cd49301079a0e10b01df3fe4069bbdb4dd2cbe38cfa1dcb3ac01a93dd04c8e01504896fcab7d8be&#39;    # 重要参数    params = &#123;        &#39;action&#39;: &#39;getmsg&#39;,        &#39;__biz&#39;: &#39;MzU4ODg3MzAwNw==&#39;,  # 每个公众号的不一样，从Fiddler复制过来        &#39;f&#39;: &#39;json&#39;,        &#39;offset&#39;: 0,  # 控制翻页        &#39;count&#39;: &#39;10&#39;,        &#39;is_ok&#39;: &#39;1&#39;,        &#39;scene&#39;: &#39;124&#39;,        &#39;uin&#39;: uin,  # 每个公众号的不一样，从Fiddler复制过来        &#39;key&#39;: key,  # 每个公众号的不一样，从Fiddler复制过来        &#39;wxtoken&#39;: &#39;&#39;,        &#39;x5&#39;: &#39;0&#39;,    &#125;    response = requests.get(url, headers=headers, params=params, proxies=proxies)    response_dict = json.loads(response.text)    can_msg_continue = response_dict.get(&#39;can_msg_continue&#39;)  # 用于判断是否是最后一页，若为0，则表示最后一页    general_msg_list = response_dict.get(&#39;general_msg_list&#39;)    data_list = json.loads(general_msg_list)[&#39;list&#39;]    for data in data_list:        # 部分公众号文章是“消息”，因此data里的数据缺少我们需要的字段，需要跳过        try:            title = data[&#39;app_msg_ext_info&#39;][&#39;title&#39;]  # 文章标题            datetime = data[&#39;comm_msg_info&#39;][&#39;datetime&#39;]  # 获取时间戳            date = time.strftime(&#39;%Y-%m-%d&#39;, time.localtime(datetime))  # 将时间戳转换为本地时间            url = data[&#39;app_msg_ext_info&#39;][&#39;content_url&#39;]  # 文章链接            info = &#123;                &quot;url&quot;: url,                &quot;title&quot;: title,                &quot;date&quot;: date,            &#125;            links.append(info)        except:            pass    return links, can_msg_continueall_links = []for i in range(100):  # 根据实际而定，因为每页10篇文章，100页对应1000篇文章    all_links.extend(article_links(i)[0])    if article_links(i)[1] == 0:        breakprint(all_links[:])print(len(all_links))import pdfkitimport wechatsogoudef link_to_pdf(url, title, date):    ws_api = wechatsogou.WechatSogouAPI(captcha_break_time=3)  # 调用接口    content_info = ws_api.get_article_content(url)  # 请求链接    content = content_info[&#39;content_html&#39;]  # 转换为html格式    # 将标题和文章内容放入如下html中处理以下    html = f&#39;&#39;&#39;            &lt;!DOCTYPE html&gt;            &lt;html lang=&quot;en&quot;&gt;            &lt;head&gt;                &lt;meta charset=&quot;UTF-8&quot;&gt;                &lt;title&gt;&#123;title&#125;&lt;/title&gt;            &lt;/head&gt;            &lt;body&gt;            &lt;h2 style=&quot;text-align: center;font-weight: 400;&quot;&gt;&#123;title&#125;&lt;/h2&gt;            &#123;content&#125;            &lt;/body&gt;            &lt;/html&gt;&#39;&#39;&#39;    path_wkthmltopdf = r&quot;E:\my\python_project\70个python实战项目\实例70_Python批量将公号文章保留原格式下载为PDF\wkhtmltox\bin\wkhtmltopdf.exe&quot;  # wkhtmltopdf可执行程序路径    config = pdfkit.configuration(wkhtmltopdf=path_wkthmltopdf)  # 配置pdfkit    pdfkit.from_string(html, f&quot;&#123;title&#125; &#123;date&#125;.pdf&quot;, configuration=config)  # 转PDF，并按设定好的命名文件    print(f&quot;&#123;title&#125;.pdf 已下载&quot;)for link in all_links:    url = link[&#39;url&#39;]    title = link[&#39;title&#39;]    date = link[&#39;date&#39;]    link_to_pdf(url, title, date)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;批量下载公众号文章&quot;&gt;&lt;a href=&quot;#批量下载公众号文章&quot; class=&quot;headerlink&quot; title=&quot;批量下载公众号文章&quot;&gt;&lt;/a&gt;批量下载公众号文章&lt;/h1&gt;&lt;p&gt;程序实现从公众号批量下载文章并保存为pdf.&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="requests" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="requests" scheme="http://example.com/tags/requests/"/>
    
    <category term="爬虫" scheme="http://example.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>win32com | 汇总excel表</title>
    <link href="http://example.com/2021/11/04/%E6%B1%87%E6%80%BBexcel%E8%A1%A8/"/>
    <id>http://example.com/2021/11/04/%E6%B1%87%E6%80%BBexcel%E8%A1%A8/</id>
    <published>2021-11-05T02:41:31.000Z</published>
    <updated>2021-11-05T02:43:31.691Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇总excel表"><a href="#汇总excel表" class="headerlink" title="汇总excel表"></a>汇总excel表</h1><p>程序实现汇总多个excel表格并生成目录。</p><span id="more"></span><p>代码：</p><pre><code>import os  # 用于获取目标文件所在路径import win32comimport win32compath = os.getcwd() + &quot;\\文件\\&quot;  # 文件夹绝对路径files = []for file in os.listdir(path):    if file.endswith(&quot;.xls&quot;) or file.endswith(&quot;.xlsx&quot;):  # 只获取&quot;.xls&quot;后缀的文件        files.append(path + file)# print(files)excel_app = win32com.client.Dispatch(&quot;Excel.Application&quot;)excel_app.Visible = False  # 不显示Excel文件excel_app.DisplayAlerts = False# 新建excel工作簿wb = excel_app.Workbooks.Add()wb.SaveAs(os.getcwd() + &quot;\\汇总.xlsx&quot;)ws = wb.Worksheets(1)ws.Name = &quot;目录&quot;for i in range(len(files)):    file_name = files[i].split(&quot;\\&quot;)[-1].split(&quot;.&quot;)[0]    ws.Range(&quot;A&quot; + str(i + 1)).Value = file_name    # 读取子文件    wb_sub = excel_app.Workbooks.Open(files[i])    ws_sub = wb_sub.ActiveSheet  # #获取活动工作表    ws_sub.Copy(ws)  # 复制工作表到汇总表    wb.ActiveSheet.Name = file_name  # 更改工作表名    wb_sub.Close()    print(f&quot;已复制文件 &#123;file_name&#125;&quot;)# 将“目录”工作表移动到最前面first_sheet = files[0].split(&quot;\\&quot;)[-1].split(&quot;.&quot;)[0]wb.Worksheets(&quot;目录&quot;).Move(wb.Worksheets(first_sheet))wb.Save()wb.Close()excel_app.Quit()</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;汇总excel表&quot;&gt;&lt;a href=&quot;#汇总excel表&quot; class=&quot;headerlink&quot; title=&quot;汇总excel表&quot;&gt;&lt;/a&gt;汇总excel表&lt;/h1&gt;&lt;p&gt;程序实现汇总多个excel表格并生成目录。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="win32com" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/win32com/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="win32com" scheme="http://example.com/tags/win32com/"/>
    
  </entry>
  
  <entry>
    <title>os | 批量新建文件夹</title>
    <link href="http://example.com/2021/11/04/%E6%89%B9%E9%87%8F%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/"/>
    <id>http://example.com/2021/11/04/%E6%89%B9%E9%87%8F%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/</id>
    <published>2021-11-05T02:22:22.000Z</published>
    <updated>2021-11-05T02:24:08.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="批量新建文件夹"><a href="#批量新建文件夹" class="headerlink" title="批量新建文件夹"></a>批量新建文件夹</h1><p>程序实现在指定目录下批量生成文件夹。</p><span id="more"></span><p>代码：</p><pre><code>import osfrom datetime import datetimefrom time import time, localtime, strftimefrom tkinter import Tk, Entry, Button, Listbox, X, Y, END, Scrollbar, RIGHT, BOTTOM, HORIZONTAL, StringVar, Labelfrom tkinter.filedialog import askdirectoryclass MainGUI():    def __init__(self):        myWindow = Tk()        myWindow.title(&quot;批量新建文件夹&quot;)        # 设置窗口大小        myWindow.geometry(&#39;590x400&#39;)        # 增加标签        self.label_1 = Label(myWindow, text=&#39; 目标目录:&#39;)        self.label_1.place(x=10, y=10, width=70, height=30)        self.label_2 = Label(myWindow, text=&#39;文件夹数量:&#39;)        self.label_2.place(x=10, y=50, width=70, height=30)        # 增加文本框        addr = StringVar(value=&#39;C:\\Users\\xxxx\\Desktop&#39;)  # 文本框默认显示的内容        self.input_entry = Entry(myWindow, highlightcolor=&#39;red&#39;, highlightthickness=1, textvariable=addr)        self.input_entry.place(x=80, y=10, width=410, height=30)        self.btn_in = Button(myWindow, text=&#39;选择目录&#39;, command=self.select_dir1, width=10, height=1)        self.btn_in.place(x=500, y=10)        folder_quantity = str(self.get_folder_qty())  # 从日志文件`log.txt`中读取最近使用过的文件夹数量        def_qty = StringVar(value=folder_quantity)        self.folderQty_entry = Entry(myWindow, highlightcolor=&#39;blue&#39;, highlightthickness=1, textvariable=def_qty)        self.folderQty_entry.place(x=80, y=50, width=410, height=30)        self.btn_exe = Button(myWindow, text=&#39;执行新建&#39;, command=self.create_folders, width=10, height=1)        self.btn_exe.place(x=500, y=50)        # 增加列表框        self.result_show = Listbox(myWindow, bg=&#39;Azure&#39;)        self.result_show.place(x=10, y=100, width=570, height=290)        self.sbY = Scrollbar(self.result_show, command=self.result_show.yview)  # 在列表框中增加Y轴滚动条        self.sbY.pack(side=RIGHT, fill=Y)        self.result_show.config(yscrollcommand=self.sbY.set)        self.sbX = Scrollbar(self.result_show, command=self.result_show.xview, orient=HORIZONTAL)  # 在列表框中增加X轴滚动条        self.sbX.pack(side=BOTTOM, fill=X)        self.result_show.config(xscrollcommand=self.sbX.set)        myWindow.mainloop()    def select_dir1(self):        self.input_entry.delete(0, END)        self.input_entry.insert(0, askdirectory(initialdir=&quot;D:\\&quot;))    def create_folders(self):        date = self.get_current_date()  # 获取日期        qty = int(self.folderQty_entry.get())  # 获取文本框中文件夹数量，并转为整数        for i in range(1, qty + 1):            folder = self.input_entry.get() + &quot;\\&quot; + date + &#39;-&#39; + str(i)            # 判断是否已经存在该目录            if not os.path.exists(folder):                # 目录不存在，进行创建操作                os.makedirs(folder)  # 使用os.makedirs()方法创建目录                f = f&quot;目录新建成功：&#123;folder&#125;&quot;  # 创建一个显示项                self.result_show.insert(&quot;end&quot;, f)  # 将结果添加到列表框中            else:                f = f&quot;目录已存在：&#123;folder&#125;&quot;  # 创建一个显示项                self.result_show.insert(&quot;end&quot;, f)  # 将结果添加到列表框中        f = &quot;-&quot; * 100  # 创建分割线        self.result_show.insert(&quot;end&quot;, f)  # 将分割线添加到列表框        f = f&quot;程序运行完成，请关闭窗口退出.&quot;  # 创建一个显示项        self.result_show.insert(&quot;end&quot;, f)  # 将结果添加到列表框        f = &quot; &quot; * 100        self.result_show.insert(&quot;end&quot;, f)  # 将以上空格添加到列表框        self.save_recent_folder_qty()  # 保存最新的文件夹数量    @staticmethod    def get_current_date():        time_stamp = time()        local_time = localtime(time_stamp)        str_time_month = int(strftime(&#39;%m&#39;, local_time))        str_time_day = int(strftime(&#39;%d&#39;, local_time))        return str(str_time_month) + &quot;.&quot; + str(str_time_day)    @staticmethod    def get_folder_qty():        &#39;&#39;&#39;从log.txt文件中获取最近的文件夹数量，若没有则返回0&#39;&#39;&#39;        log_file = os.getcwd() + &quot;\\log.txt&quot;        if os.path.exists(log_file):            with open(log_file, &quot;r&quot;) as f:                qty = f.readline()                return int(qty)        else:            return 0    def save_recent_folder_qty(self):        &quot;&quot;&quot;保存最近的文件夹数量&quot;&quot;&quot;        log_file = os.getcwd() + &quot;\\log.txt&quot;        with open(log_file, &quot;w&quot;) as f:            recent_qty = str(self.folderQty_entry.get())            f.write(recent_qty)if __name__ == &quot;__main__&quot;:    MainGUI()</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;批量新建文件夹&quot;&gt;&lt;a href=&quot;#批量新建文件夹&quot; class=&quot;headerlink&quot; title=&quot;批量新建文件夹&quot;&gt;&lt;/a&gt;批量新建文件夹&lt;/h1&gt;&lt;p&gt;程序实现在指定目录下批量生成文件夹。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="内置模块" scheme="http://example.com/categories/python/%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/"/>
    
    <category term="os" scheme="http://example.com/categories/python/%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/os/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="os" scheme="http://example.com/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>pandas | 一键更新Excel中的图表</title>
    <link href="http://example.com/2021/11/01/%E4%B8%80%E9%94%AE%E6%9B%B4%E6%96%B0Excel%E4%B8%AD%E7%9A%84%E5%9B%BE%E8%A1%A8/"/>
    <id>http://example.com/2021/11/01/%E4%B8%80%E9%94%AE%E6%9B%B4%E6%96%B0Excel%E4%B8%AD%E7%9A%84%E5%9B%BE%E8%A1%A8/</id>
    <published>2021-11-02T03:41:37.000Z</published>
    <updated>2021-11-05T02:08:35.614Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一键更新Excel中的图表"><a href="#一键更新Excel中的图表" class="headerlink" title="一键更新Excel中的图表"></a>一键更新Excel中的图表</h1><p><strong>场景：</strong> 小编每周都要更新最近12周的“生产订单周报”给老板，而且要对比最近两年相同周数的数据。主要是两张图，一张是“一周生产订单对比”，另一张是“各部门订单比例”。虽然在Excel表中建了数据透视表，但是每周都还是需要花时间进行一通凶猛的操作，才能搞定。可不可以每周一键更新，并得到这两张图呢？</p><span id="more"></span><p><strong>代码实现：</strong></p><pre><code>import pandas as pdfile = &#39;生产订单.xlsx&#39;df = pd.read_excel(file)df.fillna(0, inplace=True)df[&quot;数量&quot;] = df[&quot;数量&quot;].astype(&#39;int&#39;)# 增加周数字段df[&quot;周数&quot;] = df[&quot;日期&quot;].dt.weekdf[&quot;年份&quot;] = df[&quot;日期&quot;].dt.year# print(df.head())# 获取当前周数import datetimeyear, current_week, day = datetime.datetime.now().isocalendar()# print(current_week)# 只获取最近12周的数据df_required = df[(df[&quot;周数&quot;] &gt;= (current_week - 36)) &amp; (df[&quot;周数&quot;] &lt;= (current_week - 24))]# print(df_required[&#39;年份&#39;])result = df_required.groupby([&quot;周数&quot;, &quot;年份&quot;])[&#39;数量&#39;].sum().reset_index()  # reset后才是DF，不然是Series# print(result)## # print(result[result[&quot;年份&quot;]==2019][&quot;数量&quot;])## 如果有中文，需要配置中文字体，不然会显示成方框import matplotlib as mplimport matplotlib.pyplot as pltimport numpy as npplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;SimHei&#39;]  # 用来正常显示中文标签# 数据和标签qty_2019 = result[result[&quot;年份&quot;] == 2019][&quot;数量&quot;]qty_2020 = result[result[&quot;年份&quot;] == 2020][&quot;数量&quot;]print(qty_2020)x_label = result[result[&quot;年份&quot;] == 2019][&quot;周数&quot;]# 设置字体大小mpl.rcParams[&#39;font.size&#39;] = 12# 设置图片大小plt.figure(figsize=(12, 6))# 设置柱形图宽度bar_width = 0.45index = np.arange(13)qty_2019_list = [qty for qty in qty_2019]qty_2020_list = [qty for qty in qty_2020]print(f&quot;index: &#123;len(index)&#125;&quot;)print(len(qty_2019_list))print(len(qty_2020_list))# 绘制2019年数据qty1 = plt.bar(index, qty_2019, bar_width, color=&#39;#336633&#39;, label=&quot;2019&quot;)# 绘制2020年数据qty2 = plt.bar(index + bar_width, qty_2020, bar_width, color=&#39;#6666CC&#39;, label=&quot;2020&quot;)# X,Y轴标题plt.xticks(index + bar_width, x_label)plt.xlabel(&quot;周数&quot;, fontsize=14)plt.ylabel(&quot;产品数量/台&quot;, fontsize=14)# 图表标题plt.title(u&#39;每周生产订单对比&#39;, fontsize=20)# 图例显示plt.legend()# 添加数据标签def add_labels(qtys):    for qty in qtys:        height = qty.get_height()        plt.text(qty.get_x() + qty.get_width() / 2, height, height, ha=&#39;center&#39;, va=&#39;bottom&#39;)        # 柱形图边缘用白色填充        qty.set_edgecolor(&#39;white&#39;)add_labels(qty1)add_labels(qty2)plt.savefig(&#39;prod_order.png&#39;)# 按部门计算订单数量order_2019 = df_required[df_required[&quot;年份&quot;] == 2019]# print(order_2019)dept_2019 = order_2019[&quot;部门&quot;].value_counts()# print(dept_2019)order_2020 = df_required[df_required[&quot;年份&quot;] == 2020]# print(order_2020)dept_2020 = order_2020[&quot;部门&quot;].value_counts()# print(dept_2020)# 绘制饼图import matplotlib as mplimport numpy as npplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;SimHei&#39;]  # 用来正常显示中文标签mpl.rcParams[&#39;font.size&#39;] = 12fig = plt.figure(figsize=(12, 6))axl = fig.add_subplot(1, 2, 1)def my_label(pct, allvals):    absolute = int(pct / 100. * np.sum(allvals))    return &quot;&#123;:.1f&#125;%\n(&#123;:d&#125;)&quot;.format(pct, absolute)explode = (0.1, 0, 0, 0, 0)plt.pie(dept_2019, autopct=lambda x: my_label(x, dept_2019), explode=explode, labels=dept_2019.index, shadow=True,        startangle=150)plt.title(&quot;各部门订单比例\n(最近12周)_2019&quot;, fontsize=20)# plt.label(&quot;2019&quot;,fontsize = 14)ax2 = fig.add_subplot(1, 2, 2)plt.pie(dept_2020, autopct=lambda x: my_label(x, dept_2020), explode=explode, labels=dept_2020.index, shadow=True,        startangle=150)plt.title(&quot;各部门订单比例\n(最近12周)_2020&quot;, fontsize=20)plt.savefig(&#39;order_byDept.png&#39;)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一键更新Excel中的图表&quot;&gt;&lt;a href=&quot;#一键更新Excel中的图表&quot; class=&quot;headerlink&quot; title=&quot;一键更新Excel中的图表&quot;&gt;&lt;/a&gt;一键更新Excel中的图表&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;场景：&lt;/strong&gt; 小编每周都要更新最近12周的“生产订单周报”给老板，而且要对比最近两年相同周数的数据。主要是两张图，一张是“一周生产订单对比”，另一张是“各部门订单比例”。虽然在Excel表中建了数据透视表，但是每周都还是需要花时间进行一通凶猛的操作，才能搞定。可不可以每周一键更新，并得到这两张图呢？&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="pandas" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/"/>
    
    
    <category term="matplotlib" scheme="http://example.com/tags/matplotlib/"/>
    
    <category term="pandas" scheme="http://example.com/tags/pandas/"/>
    
    <category term="numpy" scheme="http://example.com/tags/numpy/"/>
    
    <category term="datetime" scheme="http://example.com/tags/datetime/"/>
    
  </entry>
  
  <entry>
    <title>生成器 | 生成器输出小于maxnum的偶数或奇数</title>
    <link href="http://example.com/2021/11/01/%E7%94%9F%E6%88%90%E5%99%A8%E8%BE%93%E5%87%BA%E5%B0%8F%E4%BA%8Emaxnum%E7%9A%84%E5%81%B6%E6%95%B0%E6%88%96%E5%A5%87%E6%95%B0/"/>
    <id>http://example.com/2021/11/01/%E7%94%9F%E6%88%90%E5%99%A8%E8%BE%93%E5%87%BA%E5%B0%8F%E4%BA%8Emaxnum%E7%9A%84%E5%81%B6%E6%95%B0%E6%88%96%E5%A5%87%E6%95%B0/</id>
    <published>2021-11-01T09:51:53.000Z</published>
    <updated>2021-11-02T02:29:10.162Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生成器输出小于max-num的偶数或奇数"><a href="#生成器输出小于max-num的偶数或奇数" class="headerlink" title="生成器输出小于max_num的偶数或奇数"></a>生成器输出小于max_num的偶数或奇数</h1><p>代码：</p><pre><code># 1.输出小于max_num的偶数或奇数def odd(max_num):        i = 1    while i &lt; max_num:        if i % 2 == 0:  # if % 2 == 1可生成奇数            yield i        i += 1g = odd(10)for n in g:    print(n)# 2.输出任意个偶数或奇数def odd():i = 2while i:    if i % 2 == 0:  # if % 2 == 1可生成奇数        yield i    i += 1g = odd()for i in range(100):    print(next(g))</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;生成器输出小于max-num的偶数或奇数&quot;&gt;&lt;a href=&quot;#生成器输出小于max-num的偶数或奇数&quot; class=&quot;headerlink&quot; title=&quot;生成器输出小于max_num的偶数或奇数&quot;&gt;&lt;/a&gt;生成器输出小于max_num的偶数或奇数&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="生成器" scheme="http://example.com/categories/python/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
    
    <category term="生成器" scheme="http://example.com/tags/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>生成器 | 生成器输出fibonacci数列</title>
    <link href="http://example.com/2021/11/01/%E7%94%9F%E6%88%90%E5%99%A8%E8%BE%93%E5%87%BAfibonacci%E6%95%B0%E5%88%97/"/>
    <id>http://example.com/2021/11/01/%E7%94%9F%E6%88%90%E5%99%A8%E8%BE%93%E5%87%BAfibonacci%E6%95%B0%E5%88%97/</id>
    <published>2021-11-01T09:47:51.000Z</published>
    <updated>2021-11-01T09:49:36.831Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生成器输出小于max-num的fibonacci数列"><a href="#生成器输出小于max-num的fibonacci数列" class="headerlink" title="生成器输出小于max_num的fibonacci数列"></a>生成器输出小于max_num的fibonacci数列</h1><p>代码：</p><pre><code>def feb(max_num):    n_1 = 1    n_2 = 1    n = 0    while n &lt; max_num:        if n == 0 or n == 1:            yield 1            n += 1        else:            yield n_1 + n_2            new_n_2 = n_1            n_1 = n_1 + n_2            n_2 = new_n_2            n += 1g = feb(5)for n in g:    print(n)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;生成器输出小于max-num的fibonacci数列&quot;&gt;&lt;a href=&quot;#生成器输出小于max-num的fibonacci数列&quot; class=&quot;headerlink&quot; title=&quot;生成器输出小于max_num的fibonacci数列&quot;&gt;&lt;/a&gt;生成器输出小于m</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="生成器" scheme="http://example.com/categories/python/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
    
    <category term="生成器" scheme="http://example.com/tags/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>生成器 | 生成器输出质数</title>
    <link href="http://example.com/2021/11/01/%E7%94%9F%E6%88%90%E5%99%A8%E8%BE%93%E5%87%BA%E8%B4%A8%E6%95%B0/"/>
    <id>http://example.com/2021/11/01/%E7%94%9F%E6%88%90%E5%99%A8%E8%BE%93%E5%87%BA%E8%B4%A8%E6%95%B0/</id>
    <published>2021-11-01T09:07:02.000Z</published>
    <updated>2021-11-01T09:29:27.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生成器输出小于max-num的质数"><a href="#生成器输出小于max-num的质数" class="headerlink" title="生成器输出小于max_num的质数"></a>生成器输出小于max_num的质数</h1><p>通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。<br>而且，创建一个包含成百上千完个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前<br>面几个元素，那后面绝大多数元素占用的空间都白白浪费了。生成器有效的解决了这个问题。</p><span id="more"></span><p>代码：</p><pre><code>def factor(max_num):    # 这是一个函数  用于输出所有小于max_num的质数    factor_list = []    n = 2    while n &lt; max_num:        find = False        for f in factor_list:            # 先看看列表里面有没有能整除它的            if n % f == 0:                find = True                break        if not find:            factor_list.append(n)            yield n        n += 1g = factor(10)for n in g:    print(n)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;生成器输出小于max-num的质数&quot;&gt;&lt;a href=&quot;#生成器输出小于max-num的质数&quot; class=&quot;headerlink&quot; title=&quot;生成器输出小于max_num的质数&quot;&gt;&lt;/a&gt;生成器输出小于max_num的质数&lt;/h1&gt;&lt;p&gt;通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。&lt;br&gt;而且，创建一个包含成百上千完个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前&lt;br&gt;面几个元素，那后面绝大多数元素占用的空间都白白浪费了。生成器有效的解决了这个问题。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="生成器" scheme="http://example.com/categories/python/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
    
    <category term="生成器" scheme="http://example.com/tags/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>requests | Python爬取博客的所有文章并存为带目录的word文档</title>
    <link href="http://example.com/2021/10/31/Python%E7%88%AC%E5%8F%96%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E7%AB%A0%E5%B9%B6%E5%AD%98%E4%B8%BA%E5%B8%A6%E7%9B%AE%E5%BD%95%E7%9A%84word%E6%96%87%E6%A1%A3/"/>
    <id>http://example.com/2021/10/31/Python%E7%88%AC%E5%8F%96%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E7%AB%A0%E5%B9%B6%E5%AD%98%E4%B8%BA%E5%B8%A6%E7%9B%AE%E5%BD%95%E7%9A%84word%E6%96%87%E6%A1%A3/</id>
    <published>2021-10-31T14:07:12.000Z</published>
    <updated>2021-10-31T14:09:22.349Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python爬取博客的所有文章并存为带目录的word文档"><a href="#Python爬取博客的所有文章并存为带目录的word文档" class="headerlink" title="Python爬取博客的所有文章并存为带目录的word文档"></a>Python爬取博客的所有文章并存为带目录的word文档</h1><p>Python爬取博客的所有文章并存为带目录的word文档,结果非常美丽！从此阅读博客文章轻松多了！！！</p><span id="more"></span><p>实现代码：</p><pre><code>import requestsfrom bs4 import BeautifulSoupurl = f&#39;http://blog.sina.com.cn/s/articlelist_5119330124_0_1.html&#39;wb_data = requests.get(url)soup = BeautifulSoup(wb_data.content)# 获取当页所有文章的标题和链接# print(soup.select(&#39;.atc_title&#39;))# 获取当页所有文章的发表时间# print(soup.select(&#39;.atc_tm&#39;))# print(soup.select(&#39;.atc_title&#39;)[0].select(&#39;a&#39;))# [&lt;a href=&quot;http://blog.sina.com.cn/s/blog_13122c74c0102zdsy.html&quot; target=&quot;_blank&quot; title=&quot;&quot;&gt;投资难在慢成毁于速成&lt;/a&gt;]# print(soup.select(&#39;.atc_title&#39;)[0].select(&#39;a&#39;)[0].get(&quot;href&quot;))# http://blog.sina.com.cn/s/blog_13122c74c0102zdsy.html# print(soup.select(&#39;.atc_title&#39;)[0].select(&#39;a&#39;)[0].text)# print(soup.select(&#39;.atc_tm&#39;)[0].text)# 获取所有博客文章的链接import requestsfrom bs4 import BeautifulSoupall_links = &#123;&#125;for i in range(1, 6):    url = f&#39;http://blog.sina.com.cn/s/articlelist_5119330124_0_&#123;i&#125;.html&#39;    wb_data = requests.get(url)    soup = BeautifulSoup(wb_data.content)    links = soup.select(&#39;.atc_title&#39;)    times = soup.select(&#39;.atc_tm&#39;)    for i in range(len(links)):        http_link = links[i].select(&#39;a&#39;)[0].get(&#39;href&#39;)        title = links[i].text.strip()        time = times[i].text        all_links[title] = [http_link, time]# print(len(all_links))# 获取单篇文章中的文字url = &#39;http://blog.sina.com.cn/s/blog_13122c74c0102zbt3.html&#39;wb_data = requests.get(url)soup = BeautifulSoup(wb_data.content)article = soup.select(&quot;.articalContent.newfont_family&quot;)# print(article)# print(article[0].text)# print(article[0].text.replace(&quot;\xa0&quot;, &quot;&quot;))# 获取单篇文章中的图片链接url = &#39;http://blog.sina.com.cn/s/blog_13122c74c0102zbud.html&#39;wb_data = requests.get(url)soup = BeautifulSoup(wb_data.content)img_link = soup.select(&quot;.articalContent.newfont_family&quot;)[0].find_all(&quot;img&quot;)[0].get(&quot;real_src&quot;)# 图片下载函数def downloadImg(img_url, file_path):    req = requests.get(url=img_url)    with open(file_path, &#39;wb&#39;) as f:        f.write(req.content)downloadImg(r&#39;http://s8.sinaimg.cn/middle/005AsbCIzy7vEfdM1M599&#39;,            r&#39;..\实例67_Python爬取博客的所有文章并存为带目录的word文档\1.jpg&#39;)# 写入标题，内容到word文件import docxfrom docx.oxml.ns import qn  # 用于应用中文字体def to_word(all_links):    header = &#123;        &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) &quot;                      &quot;Chrome/49.0.2623.221 Safari/537.36 SE 2.X MetaSr 1.0&quot;&#125;    doc = docx.Document()  # 新建word文档    doc.styles[&#39;Normal&#39;].font.name = u&#39;宋体&#39;    doc.styles[&#39;Normal&#39;]._element.rPr.rFonts.set(qn(&#39;w:eastAsia&#39;), u&#39;宋体&#39;)    counter = 0  # 计数器，用于记录写入word的文章数    for title in all_links.keys():        doc.add_heading(title, 1)        date = all_links[title][1][:10]  # 只取日期，不要时间        doc.add_paragraph(date)        wb_data = requests.get(all_links[title][0], headers=header)        soup = BeautifulSoup(wb_data.content)        article = soup.select(&quot;.articalContent.newfont_family&quot;)        # 有些文章被加密，获取不到内容，此时article为空，所以加个if语句判断        if article:            text = article[0].text.replace(&quot;\xa0&quot;, &quot;&quot;)            doc.add_paragraph(text)            print(f&quot;写入文章 &#123;title&#125; 。&quot;)            counter += 1    print(f&quot;共写入 &#123;counter&#125; 篇文章。&quot;)    doc.save(&quot;新浪微博文章.docx&quot;)to_word(all_links)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Python爬取博客的所有文章并存为带目录的word文档&quot;&gt;&lt;a href=&quot;#Python爬取博客的所有文章并存为带目录的word文档&quot; class=&quot;headerlink&quot; title=&quot;Python爬取博客的所有文章并存为带目录的word文档&quot;&gt;&lt;/a&gt;Python爬取博客的所有文章并存为带目录的word文档&lt;/h1&gt;&lt;p&gt;Python爬取博客的所有文章并存为带目录的word文档,结果非常美丽！从此阅读博客文章轻松多了！！！&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="requests" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="requests" scheme="http://example.com/tags/requests/"/>
    
    <category term="BeautifulSoup" scheme="http://example.com/tags/BeautifulSoup/"/>
    
  </entry>
  
  <entry>
    <title>win32com | 识别加密word文件</title>
    <link href="http://example.com/2021/10/31/%E8%AF%86%E5%88%AB%E5%8A%A0%E5%AF%86word%E6%96%87%E4%BB%B6/"/>
    <id>http://example.com/2021/10/31/%E8%AF%86%E5%88%AB%E5%8A%A0%E5%AF%86word%E6%96%87%E4%BB%B6/</id>
    <published>2021-10-31T13:32:56.000Z</published>
    <updated>2021-11-01T09:04:03.208Z</updated>
    
    <content type="html"><![CDATA[<h1 id="识别加密word文件"><a href="#识别加密word文件" class="headerlink" title="识别加密word文件"></a>识别加密word文件</h1><p>Python本身是难以识别word文件的加密状态的，那我们可以考虑利用程序在处理有密码的文档的时候的报错信息来进行处理。word文件有两种密码，一种是“打开密码”，另一种是“修改密码”。对于前者，若不输入正确的密码，是无法打开文件查看内容的；对于后者，即使不知道密码，还是可以用只读模式打开文件，查看内容并另存为新的文件的。<br>因此对于设置了“修改密码”的doc文件，并不影响用如下程序另存为docx文件。只是在另存之前，窗口会弹出如下对话框，我们只需要点击一下“只读”即可，程序就能正常运行下去。<br>如果设置了“打开密码”，程序在运行的时候也会弹出对话框，让输入密码。如果输入正确的密码，程序也是可以运行的；如果不知道密码或输入错误密码，则程序会出现如下的“com_error”错误。如果不知道密码，可以加入try..except..语句，让程序在except语句中将这个文件移动到名字为“有密码文件”的文件夹，以便后续处理。</p><span id="more"></span><p>实现代码：</p><pre><code>from win32com import client as wc  # 导入模块file = r&quot;C:\Users\dywei\python\python_excel\实例65_Python区分出加密的word文件\doc文件\\测试-有打开密码.doc&quot;word = wc.Dispatch(&quot;Word.Application&quot;)  # 打开word应用程序doc = word.Documents.Open(file)  # 打开word文件doc.SaveAs(&quot;&#123;&#125;x&quot;.format(file), 12)  # 另存为后缀为&quot;.docx&quot;的文件，其中参数12指docx文件doc.Close()  # 关闭原来word文件word.Quit()# 增加异常处理语句import shutil  # 用于操作文件和文件夹from win32com import client as wcfile = r&quot;C:\Users\dywei\python\python_excel\实例65_Python区分出加密的word文件\doc文件\\测试-有打开密码.doc&quot;try:    word = wc.Dispatch(&quot;Word.Application&quot;)  # 打开word应用程序    doc = word.Documents.Open(file)  # 打开word文件    doc.SaveAs(&quot;&#123;&#125;x&quot;.format(file), 12)  # 另存为后缀为&quot;.docx&quot;的文件，其中参数12指docx文件    doc.Close()  # 关闭原来word文件    word.Quit()except:    # 将有密码的文件移动到专门的文件夹    shutil.move(file, r&quot;C:\Users\dywei\python\python_excel\实例65_Python区分出加密的word文件\有密码文件&quot;)    print(f&quot;已移动加密文件 &#123;file&#125;&quot;)# #文件有“打开密码”的情况# import docx# doc = docx.Document(&#39;docx文件\\报告-有打开密码.docx&#39;)# PackageNotFoundError: Package not found at &#39;docx文件\报告-有打开密码.docx&#39;# 文件有“修改密码”的情况import docxdoc = docx.Document(&#39;docx文件\\报告-有修改密码.docx&#39;)p = doc.paragraphs[0]pNew = p.insert_paragraph_before()run = pNew.add_run(&quot;测试&quot;)doc.save(&quot;docx文件\\报告-有修改密码.docx&quot;)import docximport shutilfile = &quot;docx文件\\报告-有打开密码.docx&quot;try:    doc = docx.Document(file)    passexcept:    shutil.move(file, &#39;有密码文件&#39;)    print(f&quot;已移动加密文件 &#123;file&#125; 到指定文件夹&quot;)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;识别加密word文件&quot;&gt;&lt;a href=&quot;#识别加密word文件&quot; class=&quot;headerlink&quot; title=&quot;识别加密word文件&quot;&gt;&lt;/a&gt;识别加密word文件&lt;/h1&gt;&lt;p&gt;Python本身是难以识别word文件的加密状态的，那我们可以考虑利用程序在处理有密码的文档的时候的报错信息来进行处理。word文件有两种密码，一种是“打开密码”，另一种是“修改密码”。对于前者，若不输入正确的密码，是无法打开文件查看内容的；对于后者，即使不知道密码，还是可以用只读模式打开文件，查看内容并另存为新的文件的。&lt;br&gt;因此对于设置了“修改密码”的doc文件，并不影响用如下程序另存为docx文件。只是在另存之前，窗口会弹出如下对话框，我们只需要点击一下“只读”即可，程序就能正常运行下去。&lt;br&gt;如果设置了“打开密码”，程序在运行的时候也会弹出对话框，让输入密码。如果输入正确的密码，程序也是可以运行的；如果不知道密码或输入错误密码，则程序会出现如下的“com_error”错误。如果不知道密码，可以加入try..except..语句，让程序在except语句中将这个文件移动到名字为“有密码文件”的文件夹，以便后续处理。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="win32com" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/win32com/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="win32com" scheme="http://example.com/tags/win32com/"/>
    
    <category term="python-docx" scheme="http://example.com/tags/python-docx/"/>
    
    <category term="shutil" scheme="http://example.com/tags/shutil/"/>
    
  </entry>
  
  <entry>
    <title>python | 分块拆分txt文件中的数据</title>
    <link href="http://example.com/2021/10/30/python%E5%88%86%E5%9D%97%E6%8B%86%E5%88%86txt%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE/"/>
    <id>http://example.com/2021/10/30/python%E5%88%86%E5%9D%97%E6%8B%86%E5%88%86txt%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE/</id>
    <published>2021-10-31T02:50:47.000Z</published>
    <updated>2021-10-31T03:23:28.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分块拆分txt文件中的数据"><a href="#分块拆分txt文件中的数据" class="headerlink" title="分块拆分txt文件中的数据"></a>分块拆分txt文件中的数据</h1><p>代码：</p><pre><code># -*- coding:utf-8 -*-# 读取txt文件中的数据file = open(&quot;数据.txt&quot;)lines = file.readlines()# print(lines[:5])data = &#123;&#125;  # 储存分割的数据line_list = []  # 中转列表last_id = &quot;start&quot;  # 数据分块标识for line in lines:    row_data = line.split(&quot; &quot;)  # 将一行数据按空格分隔    ID = row_data[0]  # 获得ID    if last_id == &quot;start&quot;:  # 用于处理数据第一行        line_list.append(line)  # 将第一行数据放入中转列表    else:  # 不是第一行数据，则按如下执行        if ID != last_id:  # 如果出现新的数据块            if last_id in data:  # 新的数据块的ID已存在字典data中                data[last_id].append(line_list)  # 将中转列表的数据添加到对应的ID中            else:  # 新的数据快的ID不在字典data中                data[last_id] = [line_list]  # 将上一个数据块加入对应的ID            line_list = [line]  # 将中转列表清空，并放入新数据快的第一行数据        else:  # 没出现新的数据块            line_list.append(line)  # 将数据继续加入中转列表    last_id = ID  # 每处理一行，将分块标识last_id更行为最新的ID# 将最后一个文字块的数据放入字典if last_id in data:    data[last_id].append(line_list)else:    data[last_id] = [line_list]# print(data[&#39;89031&#39;])# for i in data.keys():#     for block in data[i]:#         print(block)#         print(&quot;- -&quot;*50)# 写入数据函数def to_txt(filename, data_list):  # filename为写入文件的名字，data为要写入数据列表    file = open(&quot;分块\\&quot; + filename + &#39;.txt&#39;, &#39;a&#39;)    for i in range(len(data_list)):        file.write(data_list[i])    file.close()  # 保存数据并关闭# 批量写入数据for ID in data.keys():    for i in range(len(data[ID])):        to_txt(f&quot;&#123;ID&#125;_&#123;i+1&#125;&quot;, data[ID][i])        </code></pre><p><a href="数据.txt">数据.txt</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分块拆分txt文件中的数据&quot;&gt;&lt;a href=&quot;#分块拆分txt文件中的数据&quot; class=&quot;headerlink&quot; title=&quot;分块拆分txt文件中的数据&quot;&gt;&lt;/a&gt;分块拆分txt文件中的数据&lt;/h1&gt;&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# -*- c</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="基础" scheme="http://example.com/categories/python/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>tkinter | Tkinter制作python程序的图形化界面</title>
    <link href="http://example.com/2021/10/30/Tkinter%E5%88%B6%E4%BD%9Cpython%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2/"/>
    <id>http://example.com/2021/10/30/Tkinter%E5%88%B6%E4%BD%9Cpython%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2/</id>
    <published>2021-10-31T02:42:14.000Z</published>
    <updated>2021-10-31T02:45:32.044Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tkinter制作python程序的图形化界面"><a href="#Tkinter制作python程序的图形化界面" class="headerlink" title="Tkinter制作python程序的图形化界面"></a>Tkinter制作python程序的图形化界面</h1><p>代码：</p><pre><code>from os import listdir, getcwdfrom xlrd import open_workbook, xldatefrom datetime import datetimefrom time import time, localtime, strftimefrom openpyxl import Workbookfrom openpyxl.styles import Border, Side, PatternFill, Font, GradientFill, Alignmentfrom tkinter import Tk, Entry, Button, Listbox, X, Y, END, Scrollbar, RIGHT, BOTTOM, HORIZONTALfrom tkinter.filedialog import askdirectoryclass MainGUI():    def __init__(self):        myWindow = Tk()        myWindow.title(&quot;领料记录汇总&quot;)        # 设置窗口大小        myWindow.geometry(&#39;590x400&#39;)        myWindow.iconbitmap(getcwd() + &quot;\\PO.ico&quot;)        # 增加文本框        self.input_entry = Entry(myWindow, highlightcolor=&#39;red&#39;, highlightthickness=1)        self.input_entry.place(x=10, y=10, width=480, height=30)        self.btn_in = Button(myWindow, text=&#39;输入文件目录&#39;, command=self.select_dir1, width=10, height=1)        self.btn_in.place(x=500, y=10)        self.output_entry = Entry(myWindow, highlightcolor=&#39;blue&#39;, highlightthickness=1)        self.output_entry.place(x=10, y=50, width=480, height=30)        self.btn_out = Button(myWindow, text=&#39;输出文件目录&#39;, command=self.select_dir2, width=10, height=1)        self.btn_out.place(x=500, y=50)        self.btn_run = Button(myWindow, text=&#39;执行汇总&#39;, width=10, height=1, command=self.Summary_data)        self.btn_run.place(x=500, y=90)        # 增加列表框        self.result_show = Listbox(myWindow, bg=&#39;DarkSeaGreen&#39;)  # yscrollcommand = scroll_bar,        self.result_show.place(x=10, y=130, width=570, height=260)        self.sbY = Scrollbar(self.result_show, command=self.result_show.yview)  # 在列表框中增加Y轴滚动条        self.sbY.pack(side=RIGHT, fill=Y)        self.result_show.config(yscrollcommand=self.sbY.set)        self.sbX = Scrollbar(self.result_show, command=self.result_show.xview, orient=HORIZONTAL)  # 在列表框中增加X轴滚动条        self.sbX.pack(side=BOTTOM, fill=X)        self.result_show.config(xscrollcommand=self.sbX.set)        myWindow.mainloop()    def select_dir1(self):        self.input_entry.delete(0, END)        self.input_entry.insert(0, askdirectory(initialdir=&quot;D:\\&quot;))    def select_dir2(self):        self.output_entry.delete(0, END)        self.output_entry.insert(0, askdirectory(initialdir=&quot;D:\\&quot;))    # 读取xls文件中的数据    def Get_data(self, file):        wb = open_workbook(file)  # 读取工作簿        ws = wb.sheets()[0]  # 选第一个工作表        data = &#123;&#125;        for row in range(7, ws.nrows - 2):            dept = ws.cell(2, 16).value  # 部门            dept_id = ws.cell(3, 16).value  # 部门编号            dt = ws.cell(row, 0).value  # 时间            if type(dt) is float:                date_time = xldate.xldate_as_datetime(dt, 0)            else:                date_time = datetime.strptime(dt, &#39;%Y-%m-%d %H:%M:%S&#39;)            business = ws.cell(row, 2).value  # 业务类型            model = ws.cell(row, 3).value  # 品种            qty = ws.cell(row, 4).value  # 数量            unit_price = ws.cell(row, 6).value  # 单价            price = ws.cell(row, 8).value  # 总价            reward = ws.cell(row, 9).value  # 额外值            discount = ws.cell(row, 11).value  # 调整            balance = ws.cell(row, 13).value  # 剩余            location = str(ws.cell(row, 15).value).strip()  # 库位            operator = ws.cell(row, 17).value  # 操作员            date = date_time.date()  # 日期            time = date_time.time()  # 时间            info_list = [dept, dept_id, date_time, business, model, qty, unit_price, price, reward, discount,                         balance, location, operator, date, time]            data.setdefault(date, [])  # 以日期为键            if info_list[3] != &quot;备注&quot;:  # 不要业务类型为“备注”的数据                data[date].append(info_list)        # 增加当日领取次数        for key in data.keys():            for i in data[key]:                i.append(len(data[key]))        return data    def Get_file_path(self, path):        files = []        for file in listdir(path):            if file.endswith(&quot;.xls&quot;):  # 排除文件夹内的其它干扰文件                files.append(path + &quot;\\&quot; + file)        return files    def Get_current_time(self):        time_stamp = time()  # 当前时间的时间戳        local_time = localtime(time_stamp)  #        str_time = strftime(&#39;%Y-%m-%d %H.%M.%S&#39;, local_time)        return str_time    def Summary_data(self):        thin = Side(border_style=&quot;thin&quot;, color=&quot;000000&quot;)  # 定义边框粗细及颜色        title = [&#39;部门&#39;, &#39;部门编号&#39;, &#39;时间&#39;, &#39;业务类型&#39;, &#39;品种&#39;, &#39;数量&#39;, &#39;单价&#39;, &#39;金额&#39;, &#39;额外值&#39;,                 &#39;调整&#39;, &#39;剩余&#39;, &#39;库位&#39;, &#39;操作员&#39;, &#39;领取日期&#39;, &#39;领取时间&#39;, &#39;领取次数&#39;]        wb = Workbook()        ws = wb.active        ws.merge_cells(&quot;A1:P1&quot;)        ws.cell(1, 1).value = &quot;领料明细汇总表&quot;        ws.cell(1, 1).font = Font(name=u&#39;黑体&#39;, bold=True, size=18)        ws.row_dimensions[1].height = 22.2        ws.cell(1, 1).alignment = Alignment(horizontal=&quot;center&quot;, vertical=&quot;center&quot;)        ws.append(title)        # 插入数据        files = self.Get_file_path(self.input_entry.get())  # get()获取文本编辑框中的输入文件目录，并获取目录下的xls文件        for file in files:            data = self.Get_data(file)            for key in data.keys():                for i in data[key]:                    ws.append(i)            f = f&quot;&#123;file&#125; 的内容已加入总表.&quot;  # 创建一个显示项            self.result_show.insert(&quot;end&quot;, f)  # 将结果添加到列表框中        # 设置字号，对齐，缩小字体填充，加边框        # Font(bold=True)可加粗字体        for row_number in range(2, ws.max_row + 1):            for col_number in range(1, 17):                c = ws.cell(row=row_number, column=col_number)                c.font = Font(size=9)                c.border = Border(top=thin, left=thin, right=thin, bottom=thin)                c.alignment = Alignment(horizontal=&quot;left&quot;, vertical=&quot;center&quot;)        col_name = list(&quot;ABCDEFGHIJKLMNOP&quot;)        col_width = [8, 8, 16, 8, 16, 8, 8, 9.8, 8, 8, 8, 11, 8.3, 9, 8, 8]        for i in range(len(col_name)):            ws.column_dimensions[col_name[i]].width = col_width[i]        ws.column_dimensions.group(&#39;I&#39;, &#39;K&#39;, hidden=True)        ws.column_dimensions.group(&#39;N&#39;, &#39;O&#39;, hidden=True)        wb.save(f&quot;&#123;self.output_entry.get()&#125;\\领料明细汇总表&#123;self.Get_current_time()&#125;.xlsx&quot;)        f = &quot;-&quot; * 100  # 创建分割线        self.result_show.insert(&quot;end&quot;, f)  # 将分割线添加到列表框        f = f&quot;领料明细汇总表&#123;self.Get_current_time()&#125;.xlsx 已生成，请去输出文件夹查看.&quot;  # 创建一个显示项        self.result_show.insert(&quot;end&quot;, f)  # 将结果添加到列表框        f = &quot; &quot; * 100        self.result_show.insert(&quot;end&quot;, f)  # 将以上空格添加到列表框if __name__ == &quot;__main__&quot;:    MainGUI()</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Tkinter制作python程序的图形化界面&quot;&gt;&lt;a href=&quot;#Tkinter制作python程序的图形化界面&quot; class=&quot;headerlink&quot; title=&quot;Tkinter制作python程序的图形化界面&quot;&gt;&lt;/a&gt;Tkinter制作python程序</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="tkinter" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/tkinter/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="tkinter" scheme="http://example.com/tags/tkinter/"/>
    
  </entry>
  
  <entry>
    <title>pyinstaller | python程序打包</title>
    <link href="http://example.com/2021/10/29/python%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85/"/>
    <id>http://example.com/2021/10/29/python%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85/</id>
    <published>2021-10-30T07:42:35.000Z</published>
    <updated>2021-10-30T08:53:44.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python程序打包"><a href="#python程序打包" class="headerlink" title="python程序打包"></a>python程序打包</h1><p>通常情况我们在pycharm中写的python程序只能在安装了python的电脑上运行，那么如何移植到其他电脑上也能运行呢？<br>我们可以将py文件打包成可执行程序(exe文件).</p><h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><h3 id="1-pyinstaller库安装"><a href="#1-pyinstaller库安装" class="headerlink" title="1. pyinstaller库安装"></a>1. pyinstaller库安装</h3><pre><code>pip install pyinstaller -i https://pypi.doubanio.com/simple/</code></pre><h3 id="2-打包"><a href="#2-打包" class="headerlink" title="2.打包"></a>2.打包</h3><pre><code>pyinstaller -D program.py ---&gt; 打包成一个文件夹（默认操作）pyinstaller -F program.py ---&gt; 打包成单个可执行文件</code></pre><p>程序运行后，会在目录生成一个文件：<br>1.program.spec(打包规则)<br>三个文件夹：<br>1.__pycache __(Python版本信息)<br>2.build(存储日志文件)<br>3.dist(储存可执行文件即相关的文件夹)<br><strong>注：打包完成后，除了dist文件夹，其它都可以删除，没什么用。</strong></p><h3 id="3-将打包好的文件制作成一个安装文件"><a href="#3-将打包好的文件制作成一个安装文件" class="headerlink" title="3.将打包好的文件制作成一个安装文件"></a>3.将打包好的文件制作成一个安装文件</h3><p>使用NSIS文件夹压缩器来制作安装文件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;python程序打包&quot;&gt;&lt;a href=&quot;#python程序打包&quot; class=&quot;headerlink&quot; title=&quot;python程序打包&quot;&gt;&lt;/a&gt;python程序打包&lt;/h1&gt;&lt;p&gt;通常情况我们在pycharm中写的python程序只能在安装了python的</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="pyinstaller" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pyinstaller/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="pyinstaller" scheme="http://example.com/tags/pyinstaller/"/>
    
    <category term="程序打包" scheme="http://example.com/tags/%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85/"/>
    
  </entry>
  
</feed>
