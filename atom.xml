<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Victory&#39;s Blog</title>
  
  <subtitle>非宁静无以致远</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-05-16T12:48:14.628Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>victory-liao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2024年5月坚持清单</title>
    <link href="http://example.com/2024/05/16/2024%E5%B9%B45%E6%9C%88%E5%9D%9A%E6%8C%81%E6%B8%85%E5%8D%95/"/>
    <id>http://example.com/2024/05/16/2024%E5%B9%B45%E6%9C%88%E5%9D%9A%E6%8C%81%E6%B8%85%E5%8D%95/</id>
    <published>2024-05-16T12:46:11.000Z</published>
    <updated>2024-05-16T12:48:14.628Z</updated>
    
    <content type="html"><![CDATA[<p>列下后两年的坚持清单，两年后回来更新，希望在后面的2年时间里能够不负时光。</p><span id="more"></span><ul><li><p>未来坚持清单</p><ul><li>坚持阅读2年，一年5本书</li><li>坚持健身2年，每周锻炼3次</li><li>坚持写笔记，每年发博客笔记&gt;300篇</li><li>以2年为周期，每2年掌握一个核心技能</li></ul></li><li><p>留下激励自己的两句话</p><ul><li>流水不争先，争的是滔滔不绝。人生没有奇迹，只有努力的轨迹。如果要说奇迹。那奇迹一定藏在坚持的背后。</li><li>希望我20几岁做的事情，会让我在30岁时，让我更加自信，更加从容，更加有光芒</li></ul></li><li><p>2026.5.16日回来更新这篇笔记。加油我自己，不负时光。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;列下后两年的坚持清单，两年后回来更新，希望在后面的2年时间里能够不负时光。&lt;/p&gt;</summary>
    
    
    
    <category term="多一点思考" scheme="http://example.com/categories/%E5%A4%9A%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/"/>
    
    <category term="2024年5月坚持清单" scheme="http://example.com/categories/%E5%A4%9A%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/2024%E5%B9%B45%E6%9C%88%E5%9D%9A%E6%8C%81%E6%B8%85%E5%8D%95/"/>
    
    
    <category term="坚持清单" scheme="http://example.com/tags/%E5%9D%9A%E6%8C%81%E6%B8%85%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>Python | generator用于大文件读取</title>
    <link href="http://example.com/2024/05/16/generator%E7%94%A8%E4%BA%8E%E5%A4%A7%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"/>
    <id>http://example.com/2024/05/16/generator%E7%94%A8%E4%BA%8E%E5%A4%A7%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/</id>
    <published>2024-05-16T12:42:50.000Z</published>
    <updated>2024-05-16T12:45:30.419Z</updated>
    
    <content type="html"><![CDATA[<p>python生成器最常见的应用是大文件的读取，节省内存空间。</p><span id="more"></span><p>以下是使用生成器读取大文件的python代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_in_chunks</span>(<span class="params">file_object, chunk_size=<span class="number">1024</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Lazy function (generator) to read a file piece by piece.</span></span><br><span class="line"><span class="string">    Default chunk size: 1k.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = file_object.read(chunk_size)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">yield</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_data</span>(<span class="params">piece</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;piece of data is processing.&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;really_big_file.dat&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> piece <span class="keyword">in</span> read_in_chunks(f):</span><br><span class="line">    process_data(piece)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;python生成器最常见的应用是大文件的读取，节省内存空间。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="基础" scheme="http://example.com/categories/python/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="生成器" scheme="http://example.com/categories/python/%E5%9F%BA%E7%A1%80/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
    
    <category term="生成器" scheme="http://example.com/tags/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
    <category term="大文件读取" scheme="http://example.com/tags/%E5%A4%A7%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"/>
    
  </entry>
  
  <entry>
    <title>Python | 协程</title>
    <link href="http://example.com/2024/05/16/%E5%8D%8F%E7%A8%8B/"/>
    <id>http://example.com/2024/05/16/%E5%8D%8F%E7%A8%8B/</id>
    <published>2024-05-16T12:37:42.000Z</published>
    <updated>2024-05-16T12:41:51.132Z</updated>
    
    <content type="html"><![CDATA[<p>Python中的协程基于yield实现。</p><p><a href="https://www.bookstack.cn/read/explore-python/Process-Thread-Coroutine-coroutine.md">进程、线程和协程 - 协程 - 《Python 之旅》 - 书栈网 · BookStack</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Python中的协程基于yield实现。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bookstack.cn/read/explore-python/Process-Thread-Coroutine-coroutine.md&quot;&gt;进程、线程和协程 - 协程 - </summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="基础" scheme="http://example.com/categories/python/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="协程" scheme="http://example.com/categories/python/%E5%9F%BA%E7%A1%80/%E5%8D%8F%E7%A8%8B/"/>
    
    
    <category term="协程" scheme="http://example.com/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>图编译 | 几种Dialect的区别</title>
    <link href="http://example.com/2024/05/16/%E5%9B%BE%E7%BC%96%E8%AF%91%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8DDialect%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2024/05/16/%E5%9B%BE%E7%BC%96%E8%AF%91%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8DDialect%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2024-05-16T12:35:11.000Z</published>
    <updated>2024-05-16T12:37:17.640Z</updated>
    
    <content type="html"><![CDATA[<p>分析计算图编译中的几种Dialect的区别。</p><span id="more"></span><p>Torch Dialect、Relay Dialect 和 Spirv Dialect 都是编译器领域中的术语，它们代表了不同类型的中间表示（Intermediate Representation, IR）。尽管它们都用于描述程序的某种形式，但它们在设计目标、应用场景和使用的技术细节上存在差异。</p><ol><li><strong>相同点</strong>：</li></ol><ul><li><strong>中间表示</strong>：三者都是某种形式的中间表示，它们将源代码转换为一种更接近硬件的表现形式，以便进行优化和编译。</li><li><strong>编译器组件</strong>：它们都是编译器或运行时系统的一部分，用于处理代码生成、调度同步等任务。</li></ul><ol><li><strong>不同点</strong>：</li></ol><ul><li><strong>设计目标</strong>：Torch Dialect 主要用于支持 PyTorch 相关的操作，它是 MLIR 中的一种方言，用于表示 PyTorch 中的张量操作和计算图。Relay Dialect 是 TVM 项目中的一种方言，它用于表示机器学习模型的计算图，特别是在进行模型优化和部署时使用。Spirv Dialect 则是一种图形和并行计算领域的统一中间表示，主要被用于实现 Shader 和 Kernel 编译器，支持 Vulkan、OpenGL、OpenCL 等标准。</li><li><strong>应用场景</strong>：Torch Dialect 主要应用于 PyTorch 框架中，用于优化和执行 PyTorch 模型。Relay Dialect 主要应用于 TVM 框架中，用于端到端的机器学习模型编译流程。Spirv Dialect 广泛应用于图形渲染和GPU计算领域，它是一种与硬件无关的中间表示，可以在不同的图形和计算API之间进行转换。</li><li><strong>技术细节</strong>：Torch Dialect 和 Relay Dialect 通常包含了对机器学习操作的高度抽象，而 Spirv Dialect 则更侧重于图形和并行计算领域的底层操作。</li></ul><p>总的来说，Torch Dialect、Relay Dialect 和 Spirv Dialect 分别针对不同的应用场景和需求，提供了各自独特的中间表示形式。虽然它们在概念上有共通之处，但在具体实现和用途上各有侧重点，反映了编译器设计和机器学习框架的多样性。 </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;分析计算图编译中的几种Dialect的区别。&lt;/p&gt;</summary>
    
    
    
    <category term="编译器" scheme="http://example.com/categories/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
    <category term="计算图编译" scheme="http://example.com/categories/%E7%BC%96%E8%AF%91%E5%99%A8/%E8%AE%A1%E7%AE%97%E5%9B%BE%E7%BC%96%E8%AF%91/"/>
    
    <category term="几种Dialect的区别" scheme="http://example.com/categories/%E7%BC%96%E8%AF%91%E5%99%A8/%E8%AE%A1%E7%AE%97%E5%9B%BE%E7%BC%96%E8%AF%91/%E5%87%A0%E7%A7%8DDialect%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    
    
    <category term="图编译" scheme="http://example.com/tags/%E5%9B%BE%E7%BC%96%E8%AF%91/"/>
    
    <category term="Dialect" scheme="http://example.com/tags/Dialect/"/>
    
    <category term="Torch Dialect" scheme="http://example.com/tags/Torch-Dialect/"/>
    
    <category term="Relay Dialect" scheme="http://example.com/tags/Relay-Dialect/"/>
    
    <category term="Spirv Dialect" scheme="http://example.com/tags/Spirv-Dialect/"/>
    
  </entry>
  
  <entry>
    <title>clang | clang parser和clang sema的作用</title>
    <link href="http://example.com/2024/05/16/Sema%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>http://example.com/2024/05/16/Sema%E7%9A%84%E4%BD%9C%E7%94%A8/</id>
    <published>2024-05-16T12:31:30.000Z</published>
    <updated>2024-05-16T12:34:26.651Z</updated>
    
    <content type="html"><![CDATA[<p>clang前端中的parser和sema的作用。</p><span id="more"></span><ul><li><p>Clang Parser</p><p>clang parser的作用是<strong>解析C、C++等编程语言的源代码，构建出抽象语法树（AST）</strong>。</p><p>具体来说，clang parser的工作包括以下几个方面：</p><ol><li><strong>词法分析</strong>：将源代码分解成一个个的词素（tokens），例如关键字、标识符、常量等。</li><li><strong>语法分析</strong>：根据语言的语法规则，将这些词素组织成语法结构，如表达式、语句和函数定义等。</li><li><strong>构建抽象语法树</strong>：将语法结构转换成抽象语法树的形式，树上的每个节点对应源代码中的一个构造或实体。</li><li><strong>语义分析</strong>：在抽象语法树的基础上进行语义分析，检查代码中的错误，如类型不匹配、未声明的变量等。</li><li><strong>支持条件解析</strong>：例如，对于if语句的条件部分，clang parser会特别处理，确保正确地解析条件表达式。</li><li><strong>遵循语言标准</strong>：clang parser在解析时会参照相应的语言标准，如C99或C89，确保解析的准确性。</li><li><strong>性能优势</strong>：clang parser在速度上相比其他编译器有显著优势，它能快速完成预处理、词法分析、语法分析和语义分析等步骤。</li></ol></li><li><p>Clang Sema</p><p>clang sema是Clang编译器前端的一个重要组件，主要负责语义分析和类型检查，它的主要职责包括：</p></li></ul><ol><li><strong>语义分析</strong>：Sema负责处理抽象语法树（AST）中的语义信息，确保代码在语义上是正确的。这包括检查变量是否已经声明，函数是否正确调用，以及表达式是否符合语言规范等。</li><li><strong>类型检查</strong>：Sema还会进行类型检查，确保表达式和语句中的类型匹配，例如在赋值操作中，右侧的值的类型需要与左侧变量的类型兼容。</li><li><strong>符号解析</strong>：它负责解析符号，比如变量名、函数名等，确保它们在使用前已经被正确声明。</li><li><strong>重载解析</strong>：对于支持函数重载的语言，Sema还要负责选择合适的函数版本来调用。</li><li><strong>模板实例化</strong>：在处理C++等支持模板的语言时，Sema还负责模板的实例化过程。</li><li><strong>诊断报告</strong>：如果在语义分析过程中发现问题，Sema会生成相应的诊断报告，帮助开发者定位和修复问题。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;clang前端中的parser和sema的作用。&lt;/p&gt;</summary>
    
    
    
    <category term="编译器" scheme="http://example.com/categories/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
    <category term="clang" scheme="http://example.com/categories/%E7%BC%96%E8%AF%91%E5%99%A8/clang/"/>
    
    <category term="clang parser和clang sema的作用" scheme="http://example.com/categories/%E7%BC%96%E8%AF%91%E5%99%A8/clang/clang-parser%E5%92%8Cclang-sema%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    
    
    <category term="clang" scheme="http://example.com/tags/clang/"/>
    
    <category term="parser" scheme="http://example.com/tags/parser/"/>
    
    <category term="sema" scheme="http://example.com/tags/sema/"/>
    
  </entry>
  
  <entry>
    <title>HTTP | HTTP代理</title>
    <link href="http://example.com/2024/05/16/HTTP%E4%BB%A3%E7%90%86/"/>
    <id>http://example.com/2024/05/16/HTTP%E4%BB%A3%E7%90%86/</id>
    <published>2024-05-16T11:56:52.000Z</published>
    <updated>2024-05-16T12:00:18.263Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>什么是HTTP代理？代理的作用？</p><span id="more"></span><p>HTTP代理是一种充当客户端和服务器之间的<code>中间人</code>的服务器。当客户端发起请求时，HTTP代理会<code>拦截请求</code>并将其<code>转发</code>给目标服务器。一旦目标服务器响应，HTTP代理会<code>拦截响应</code>并将其转发回客户端。HTTP代理可以被用于多种场景，例如<code>加强安全</code>、<code>缓存内容</code>以<code>加速访问</code>、<code>访问受限资源</code>等等。</p><p>以实际生活中找中介租房为例，将租房人看做客户端，将中介看做代理服务器，将房产拥有者看做服务器，</p><p>租房人向中介提出想要租房的意愿（相当于发起一个请求），中介收到租房请求后，根据租房人的需求联系（转发请求）房产拥有者，谈好价钱且确认好租房事项后，中介再将这些信息返回给租房人（响应）。通常情况下，想要租房的人不能直接联系到房产拥有者，但通过中介这个媒介就可以顺利的租到房子。从访问服务器的角度来说，客户端不具备直接访问服务器的权限，通过代理服务器可以突破这种限制，例如访问YouTube等国外网站。</p></li><li><p>代理类型</p><ul><li><code>正向代理（Forward Proxy）</code>：为了从外部网络访问内部网络的资源，客户端将请求发送到代理服务器，然后由代理服务器代为转发到目标服务器。在这个过程中，代理服务器对外隐藏了客户端的真实IP地址，同时可以对流量进行控制和过滤。正向代理主要用于<code>提高访问速度</code>、<code>突破访问限制</code>以及<code>用户隐私保护</code>。正向代理即是客户端代理, 代理客户端, 服务端不知道实际发起请求的客户端.</li><li><code>反向代理（Reverse Proxy）</code>：为服务器接收来自外部网络的连接请求。客户端直接与反向代理服务器建立连接，而反向代理服务器再将请求转发到内部网络的实际服务器上。反向代理常用于<code>负载均衡</code>、<code>提供安全防护</code>等。反向代理即是服务端代理, 代理服务端, 客户端不知道实际提供服务的服务端.</li></ul></li><li><p>linux系统配置代码的方法</p><p>在linux系统中<code>配置HTTP代理</code>，只需在命令行执行以下两天命令，<code>=</code>后的字符串为代理服务器（proxy server）的ip地址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export HTTP_PROXY=&quot;http://10.10.1.10:3128&quot;</span><br><span class="line">export HTTPS_PROXY=&quot;http://10.10.1.10:1080&quot;</span><br></pre></td></tr></table></figure></li><li><p>windows系统配置代理的方法</p><ul><li>打开“设置”应用程序，并点击“网络和Internet”。</li><li>点击“代理”，然后在“手动代理设置”下选择“使用代理服务器”。</li><li>输入代理服务器的IP地址和端口号，然后点击“保存”。</li></ul></li><li><p>git配置HTTP代理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy &#x27;http://192.168.0.1:1080&#x27;  # 使用时需修改代理服务器ip为实际的代理服务器ip</span><br><span class="line">git config --global https.proxy &#x27;http://192.168.0.1:1080&#x27;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;什么是HTTP代理？代理的作用？&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="HTTP" scheme="http://example.com/categories/HTTP/"/>
    
    <category term="HTTP代理" scheme="http://example.com/categories/HTTP/HTTP%E4%BB%A3%E7%90%86/"/>
    
    
    <category term="HTTP" scheme="http://example.com/tags/HTTP/"/>
    
    <category term="代理" scheme="http://example.com/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>如何制定短期、长期目标？</title>
    <link href="http://example.com/2024/03/14/%E5%A6%82%E4%BD%95%E5%88%B6%E5%AE%9A%E7%9F%AD%E6%9C%9F%E3%80%81%E9%95%BF%E6%9C%9F%E7%9B%AE%E6%A0%87%EF%BC%9F/"/>
    <id>http://example.com/2024/03/14/%E5%A6%82%E4%BD%95%E5%88%B6%E5%AE%9A%E7%9F%AD%E6%9C%9F%E3%80%81%E9%95%BF%E6%9C%9F%E7%9B%AE%E6%A0%87%EF%BC%9F/</id>
    <published>2024-03-14T14:07:36.000Z</published>
    <updated>2024-03-14T14:31:26.799Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何制定短、长期目标？"><a href="#如何制定短、长期目标？" class="headerlink" title="如何制定短、长期目标？"></a>如何制定短、长期目标？</h3><p>首先，这是一个问句。其次，问题下面的文字不是答案，是在寻找答案。</p><span id="more"></span><p>先说说不制定短期目标会造成哪些现象吧。就自己来说，如果没有短期目标会直接的造成当下执行力的直线减弱，会陷入“无所事事”的焦虑与内耗之中，会喜欢在“短且快”的事物中结束当下的焦虑，比如:刷抖音，或者说会选择“躺平”，没有心情去干其他的事。</p><p>如果有一个短期目标，那么自己就会有来自完成这个目标的微小的压力，而这微小压力会增强执行力，这是自我分析的结果，希望后面能够验证(结果是对的)或调整(结果错了)这个结果。比如，我计划三天看一本不那么厚的书，那么我的手脚这三天就有地方去了，脚应该放在阅读桌的正下方，手应该放在这本书的右下角去翻页，在这个短的周期里，这本书会对我的行为有指导作用，或许这就是我的结论的含义吧。短期的目标会增加执行力，那么如何正确的制定短期目标是我需要去探索、去实践的。</p><p>进一步分析，不制定或者说没有一个长期目标的话，对我个人而言会在焦虑与内耗下造成迷茫，缺少动力的情况。若说短期目标是当下手和脚应该放在哪里的问题，那么长期目标就是“心所往”，也就是说，你想要去到哪里。一个长的周期内，我们有可能会精力充沛，信心满满的做一些事，也有可能会无所事事，迷茫焦虑，不知道该干什么，不知道我要去哪，不知道人生该如何度过。</p><p>再像上一段那样出个结论的话那就是，长期目标是一块磁铁，会在一个长的周期内在你迷茫的时候，将你的心拉回来，让你幡然醒悟，哦，我是要去到哪里，从里结束迷茫，继续前行。比如，在大三到大四考研的哪一年中，上岸就是一个相对长期的目标，在这主线任务中，当然大部分的时间是复习，但免不了放纵，迷茫的时刻，但是有了上岸的目标，在放纵一日，迷茫一日，焦虑一日之后，这个目标就会把我拉回来，如上所说，那是心去的地方，也许这是我的结论的当前解释吧。这个结论也是自我分析的结果，需要与制定长期目标这个问题一起去探索，去实践。</p><p>2024.3.13<br>victory</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;如何制定短、长期目标？&quot;&gt;&lt;a href=&quot;#如何制定短、长期目标？&quot; class=&quot;headerlink&quot; title=&quot;如何制定短、长期目标？&quot;&gt;&lt;/a&gt;如何制定短、长期目标？&lt;/h3&gt;&lt;p&gt;首先，这是一个问句。其次，问题下面的文字不是答案，是在寻找答案。&lt;/p&gt;</summary>
    
    
    
    <category term="多一点思考" scheme="http://example.com/categories/%E5%A4%9A%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/"/>
    
    <category term="如何制定短、长期目标？" scheme="http://example.com/categories/%E5%A4%9A%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/%E5%A6%82%E4%BD%95%E5%88%B6%E5%AE%9A%E7%9F%AD%E3%80%81%E9%95%BF%E6%9C%9F%E7%9B%AE%E6%A0%87%EF%BC%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>CUDA | CUDA源程序结构</title>
    <link href="http://example.com/2024/03/14/CUDA%E6%BA%90%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2024/03/14/CUDA%E6%BA%90%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/</id>
    <published>2024-03-14T13:55:46.000Z</published>
    <updated>2024-03-14T14:04:58.177Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CUDA源程序的结构"><a href="#CUDA源程序的结构" class="headerlink" title="CUDA源程序的结构"></a>CUDA源程序的结构</h3><p>采用CUDA并行计算编程模型进行编程一般分为以下几个步骤：</p><ol><li><p>分配GPU内存（使用cudaMalloc()函数进行分配）。</p></li><li><p>从CPU内存中拷贝数据到GPU内存（cudaMemcpy()）。</p></li><li><p>调用CUDA内核函数来完成程序指定的运算（xxxKernel&lt;&lt;&lt;block, grid&gt;&gt;&gt;()）。</p><p>在此过程中注意线程的组织方式，通过设置不同block、grid来进行组织。</p></li><li><p>将数据从GPU拷回CPU内存（cudaMemcpy()）。</p></li><li><p>释放GPU内存空间（cudaFree）。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;CUDA源程序的结构&quot;&gt;&lt;a href=&quot;#CUDA源程序的结构&quot; class=&quot;headerlink&quot; title=&quot;CUDA源程序的结构&quot;&gt;&lt;/a&gt;CUDA源程序的结构&lt;/h3&gt;&lt;p&gt;采用CUDA并行计算编程模型进行编程一般分为以下几个步骤：&lt;/p&gt;
&lt;ol&gt;</summary>
      
    
    
    
    <category term="并行计算" scheme="http://example.com/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
    <category term="CUDA" scheme="http://example.com/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/CUDA/"/>
    
    <category term="CUDA源程序结构" scheme="http://example.com/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/CUDA/CUDA%E6%BA%90%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="CUDA" scheme="http://example.com/tags/CUDA/"/>
    
  </entry>
  
  <entry>
    <title>CUDA | 数据划分形式</title>
    <link href="http://example.com/2024/03/14/%E6%95%B0%E6%8D%AE%E5%88%92%E5%88%86%E5%BD%A2%E5%BC%8F/"/>
    <id>http://example.com/2024/03/14/%E6%95%B0%E6%8D%AE%E5%88%92%E5%88%86%E5%BD%A2%E5%BC%8F/</id>
    <published>2024-03-14T13:55:25.000Z</published>
    <updated>2024-03-14T13:57:37.667Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据划分形式"><a href="#数据划分形式" class="headerlink" title="数据划分形式"></a>数据划分形式</h3><p>块划分和周期划分是数据分配给线程的两种不同策略，它们在一些方面存在差异。以下是具体分析：</p><ul><li><strong>块划分</strong>：在块划分中，<strong>一组连续的数据被分到一个块内</strong>。<strong>每个数据块通常具有相同的大小</strong>，并以任意次序被安排给一个线程进行处理。线程在同一时间只处理一个数据块，这种方式简化了同步和调度的问题，因为每个线程独立工作在自己的数据块上。</li><li><strong>周期划分</strong>：周期划分将更少的数据分到一个块内。在这种策略下，每个线程负责处理多个数据块，且这些<strong>数据块之间通常是不连续的</strong>。相邻的线程会处理相邻的数据块，当一个线程需要选择一个新的数据块时，它必须跳过与当前线程数一样多的数据块。这种划分方式可以提高缓存的利用率，并可能减少内存访问延迟。</li></ul><p>总的来说，<strong>块划分适合每个线程处理大块连续数据的任务</strong>，而<strong>周期划分更适合于需要细粒度并行和数据局部性</strong>优化的场景。实际选择哪种划分方式取决于具体的应用场景和目标架构的特点。 </p><p>以下是块划分和周期划分的代码示例：</p><p>块划分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义数据大小和线程数</span></span><br><span class="line">data_size = <span class="number">20</span></span><br><span class="line">num_threads = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算每个线程处理的数据量</span></span><br><span class="line">chunk_size = data_size // num_threads</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据分成块，并分配给线程</span></span><br><span class="line">data = np.random.rand(data_size)</span><br><span class="line">chunks = [data[i*chunk_size:(i+<span class="number">1</span>)*chunk_size] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_threads)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在每个线程中处理数据块</span></span><br><span class="line"><span class="keyword">for</span> chunk <span class="keyword">in</span> chunks:</span><br><span class="line">    <span class="comment"># 在这里进行数据处理</span></span><br><span class="line">    <span class="built_in">print</span>(chunk)</span><br></pre></td></tr></table></figure><p>周期划分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义数据大小和线程数</span></span><br><span class="line">data_size = <span class="number">20</span></span><br><span class="line">num_threads = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算每个线程处理的数据量</span></span><br><span class="line">chunk_size = data_size // num_threads</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据分成块，并分配给线程</span></span><br><span class="line">data = np.random.rand(data_size)</span><br><span class="line">chunks = [data[i::num_threads] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_threads)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在每个线程中处理数据块</span></span><br><span class="line"><span class="keyword">for</span> chunk <span class="keyword">in</span> chunks:</span><br><span class="line">    <span class="comment"># 在这里进行数据处理</span></span><br><span class="line">    <span class="built_in">print</span>(chunk)</span><br></pre></td></tr></table></figure><p>以上代码示例展示了如何将数据划分为块，并将这些块分配给不同的线程进行处理。在块划分中，每个线程处理一个连续的数据块；而在周期划分中，每个线程处理多个不连续的数据块。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;数据划分形式&quot;&gt;&lt;a href=&quot;#数据划分形式&quot; class=&quot;headerlink&quot; title=&quot;数据划分形式&quot;&gt;&lt;/a&gt;数据划分形式&lt;/h3&gt;&lt;p&gt;块划分和周期划分是数据分配给线程的两种不同策略，它们在一些方面存在差异。以下是具体分析：&lt;/p&gt;
&lt;ul&gt;
</summary>
      
    
    
    
    <category term="并行计算" scheme="http://example.com/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
    <category term="CUDA" scheme="http://example.com/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/CUDA/"/>
    
    <category term="数据划分形式" scheme="http://example.com/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/CUDA/%E6%95%B0%E6%8D%AE%E5%88%92%E5%88%86%E5%BD%A2%E5%BC%8F/"/>
    
    
    <category term="CUDA" scheme="http://example.com/tags/CUDA/"/>
    
    <category term="数据划分" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%88%92%E5%88%86/"/>
    
    <category term="块划分" scheme="http://example.com/tags/%E5%9D%97%E5%88%92%E5%88%86/"/>
    
    <category term="周期划分" scheme="http://example.com/tags/%E5%91%A8%E6%9C%9F%E5%88%92%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>pytest | fixtures执行顺序及清理顺序</title>
    <link href="http://example.com/2024/03/07/fixtures%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E5%8F%8A%E6%B8%85%E7%90%86%E9%A1%BA%E5%BA%8F/"/>
    <id>http://example.com/2024/03/07/fixtures%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E5%8F%8A%E6%B8%85%E7%90%86%E9%A1%BA%E5%BA%8F/</id>
    <published>2024-03-07T13:56:45.000Z</published>
    <updated>2024-03-07T13:59:46.185Z</updated>
    
    <content type="html"><![CDATA[<h3 id="pytest-fixtures执行顺序和清理顺序"><a href="#pytest-fixtures执行顺序和清理顺序" class="headerlink" title="pytest fixtures执行顺序和清理顺序"></a>pytest fixtures执行顺序和清理顺序</h3><ol><li>fixtures执行顺序</li></ol><p>pytest一个test请求多个fixture时，fixtures的执行顺序是什么？</p><span id="more"></span><p>以下面的demo为例，在这段代码中test_string_only请求了append_first，order，fisrt_entry三个fixtures，从代码中可以看出append_first fixture依赖于order和first_entry fixtures。</p><p>pytest会对多个fixtures进行<strong>依赖解析</strong>，<strong>如果一个fixture依赖于其他fixture(s)，那么被依赖的fixtures会先于依赖它们的fixture执行</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># contents of test_append.py</span></span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Arrange</span></span><br><span class="line"><span class="meta">@pytest.fixture</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first_entry</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;3 - first_entry fixture has been executed.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;a&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Arrange</span></span><br><span class="line"><span class="meta">@pytest.fixture</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">order</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;2 - order fixture has been executed.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Act</span></span><br><span class="line"><span class="meta">@pytest.fixture</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">append_first</span>(<span class="params">order, first_entry</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;1 - append_first fixture has been executed.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> order.append(first_entry)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_string_only</span>(<span class="params">append_first, order, first_entry</span>):</span></span><br><span class="line">    <span class="comment"># Assert</span></span><br><span class="line">    <span class="keyword">assert</span> order == [first_entry]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行以上代码的结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">============================= test session starts =============================</span><br><span class="line">collecting ... collected 1 item</span><br><span class="line"></span><br><span class="line">test_append.py::test_string_only </span><br><span class="line">2 - order fixture has been executed.</span><br><span class="line">3 - first_entry fixture has been executed.</span><br><span class="line">1 - append_first fixture has been executed.</span><br><span class="line">PASSED                                  [100%]</span><br><span class="line"></span><br><span class="line">============================== 1 passed in 0.04s ==============================</span><br></pre></td></tr></table></figure><p>从运行结果可以看出，order fixture和first_entry fixture先于append_firt fixture执行。</p><p><strong>fixtures之间不存在依赖关系的，按照它们被声明的顺序执行</strong>，以下面的demo为例，假设有两个 fixtures，fixture A 和 fixture B，其中 fixture A 依赖于 fixture B。下面是一个示例来说明它们按照声明顺序执行的情况：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fixture_b</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Executing fixture B&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Cleaning up fixture B&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fixture_a</span>(<span class="params">fixture_b</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Executing fixture A&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Cleaning up fixture A&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_example</span>(<span class="params">fixture_a, fixture_b</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Executing test example&quot;</span>)</span><br><span class="line">    <span class="keyword">assert</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>fixture_b</code> 和 <code>fixture_a</code> 都使用了 <code>@pytest.fixture</code> 装饰器进行声明。在测试函数 <code>test_example</code> 的参数列表中，<code>fixture_b</code> 在 <code>fixture_a</code> 之前声明。</p><p>当运行这个测试时，pytest 会首先执行 <code>fixture_b</code>，然后执行 <code>fixture_a</code>。这是因为 <code>fixture_a</code> 依赖于 <code>fixture_b</code>，所以需要先执行它。最后，测试函数 <code>test_example</code> 会被执行。</p><p>输出结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Executing fixture B</span><br><span class="line">Executing fixture A</span><br><span class="line">Executing test example</span><br><span class="line">Cleaning up fixture A</span><br><span class="line">Cleaning up fixture B</span><br></pre></td></tr></table></figure><p>可以看到，fixtures 是按照它们被声明的顺序执行的，首先是 <code>fixture_b</code>，然后是 <code>fixture_a</code>。 </p><ol><li>fixtures清理顺序</li></ol><p>每个fixture在它自己的代码块执行完毕后立即进行清理。有依赖关系的fixtures的清理工作先从清理被依赖fixture开始，例如fixture A依赖于fixture B，那么执行顺序将会是：首先执行fixture B，然后执行fixture A，最后清理工作会先从fixture A开始，然后是fixture B。这种设计确保了每个fixture能及时清理自己使用的资源，避免了潜在的资源冲突或泄露问题。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;pytest-fixtures执行顺序和清理顺序&quot;&gt;&lt;a href=&quot;#pytest-fixtures执行顺序和清理顺序&quot; class=&quot;headerlink&quot; title=&quot;pytest fixtures执行顺序和清理顺序&quot;&gt;&lt;/a&gt;pytest fixtures执行顺序和清理顺序&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;fixtures执行顺序&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;pytest一个test请求多个fixture时，fixtures的执行顺序是什么？&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="python测试框架" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="pytest" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/pytest/"/>
    
    <category term="fixtures执行顺序及清理顺序" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/pytest/fixtures%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E5%8F%8A%E6%B8%85%E7%90%86%E9%A1%BA%E5%BA%8F/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="pytest" scheme="http://example.com/tags/pytest/"/>
    
    <category term="fixtures" scheme="http://example.com/tags/fixtures/"/>
    
  </entry>
  
  <entry>
    <title>pytest | 自定义失败断言解释</title>
    <link href="http://example.com/2024/03/07/%E6%96%AD%E8%A8%80%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E9%87%8D%E5%86%99/"/>
    <id>http://example.com/2024/03/07/%E6%96%AD%E8%A8%80%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E9%87%8D%E5%86%99/</id>
    <published>2024-03-07T13:52:36.000Z</published>
    <updated>2024-03-07T13:55:32.432Z</updated>
    
    <content type="html"><![CDATA[<h3 id="自定义失败断言解释"><a href="#自定义失败断言解释" class="headerlink" title="自定义失败断言解释"></a>自定义失败断言解释</h3><p>使用pytest测试代码块（Code Block）或函数（Functions）时，通常使用assert语句对代码块或函数的执行结果与预期结果进行比较，从而判断代码块或函数的正确性。如果在测试过程中某测试用例中的断言失败，即代码块或函数的实际执行结果与预期结果不一致，pytest将会报告错误信息。</p><span id="more"></span><p>在pytest中我们可以通过实现pytest_assertrepr_coompare钩子函数（Hook Function）来自定义失败断言的错误信息。</p><p>pytest_assertrepr_coompare钩子函数的语法如下：</p><p><strong>pytest_assertrepr_compare</strong>(<em>config</em>, <em>op</em>, <em>left</em>, <em>right</em>)[<a href="https://docs.pytest.org/en/8.0.x/_modules/_pytest/hookspec.html#pytest_assertrepr_compare">source]</a></p><p>​    Return explanation for comparisons in failing assert expressions.（返回失败断言表达式的解释信息）</p><p>​    Parameters:</p><p>​        <strong>config</strong> (<a href="https://docs.pytest.org/en/8.0.x/reference/reference.html#pytest.Config"><em>Config</em></a>) – The pytest config object.（pytest配置对象）</p><p>​        <strong>op</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#str"><em>str</em></a>) – The operator, e.g. <code>&quot;==&quot;</code>, <code>&quot;!=&quot;</code>, <code>&quot;not in&quot;</code>.（操作符）</p><p>​        <strong>left</strong> (<a href="https://docs.python.org/3/library/functions.html#object"><em>object</em></a>) – The left operand.（操作数1）</p><p>​        <strong>right</strong> (<a href="https://docs.python.org/3/library/functions.html#object"><em>object</em></a>) – The right operand.（操作数2）</p><p>通过钩子函数自定义错误断言信息的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># content of conftest.py</span></span><br><span class="line"><span class="keyword">from</span> test_foocompare <span class="keyword">import</span> Foo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 钩子函数，自定义断言信息</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pytest_assertrepr_compare</span>(<span class="params">op, left, right</span>):</span></span><br><span class="line">    <span class="comment"># 若Foo对象作相等断言（==）时失败，则输入自定义信息</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(left, Foo) <span class="keyword">and</span> <span class="built_in">isinstance</span>(right, Foo) <span class="keyword">and</span> op == <span class="string">&quot;==&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            <span class="string">&quot;Comparing Foo instances:&quot;</span>,</span><br><span class="line">            <span class="string">f&quot;   vals: <span class="subst">&#123;left.val&#125;</span> != <span class="subst">&#123;right.val&#125;</span>&quot;</span>,</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># content of test_foocompare.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.val == other.val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_compare</span>():</span></span><br><span class="line">    f1 = Foo(<span class="number">1</span>)</span><br><span class="line">    f2 = Foo(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">assert</span> f1 == f2</span><br></pre></td></tr></table></figure><p>运行test_foocompare.py模块，控制台会输出一下信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E       assert Comparing Foo instances:</span><br><span class="line">E            vals: 1 != 2</span><br></pre></td></tr></table></figure><p>自定义失败断言信息时通过重写断言表达式实现的，我们可以通过在代码中关闭”断言重写“功能：</p><ul><li><p>关闭特定模块的断言重写：在docstring中增加PYTEST_DONT_REWRITE字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    PYTEST_DONT_REWRITE</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">......</span><br><span class="line">python test code</span><br><span class="line">......</span><br></pre></td></tr></table></figure></li><li><p>关闭所有模块的断言重写：使用–assert=plain</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest --assert=plain</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;自定义失败断言解释&quot;&gt;&lt;a href=&quot;#自定义失败断言解释&quot; class=&quot;headerlink&quot; title=&quot;自定义失败断言解释&quot;&gt;&lt;/a&gt;自定义失败断言解释&lt;/h3&gt;&lt;p&gt;使用pytest测试代码块（Code Block）或函数（Functions）时，通常使用assert语句对代码块或函数的执行结果与预期结果进行比较，从而判断代码块或函数的正确性。如果在测试过程中某测试用例中的断言失败，即代码块或函数的实际执行结果与预期结果不一致，pytest将会报告错误信息。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="python测试框架" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="pytest" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/pytest/"/>
    
    <category term="自定义失败断言解释" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/pytest/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%B1%E8%B4%A5%E6%96%AD%E8%A8%80%E8%A7%A3%E9%87%8A/"/>
    
    
    <category term="pytest" scheme="http://example.com/tags/pytest/"/>
    
    <category term="断言" scheme="http://example.com/tags/%E6%96%AD%E8%A8%80/"/>
    
    <category term="钩子函数" scheme="http://example.com/tags/%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>python | 钩子函数、python中定义钩子函数</title>
    <link href="http://example.com/2024/03/06/%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E3%80%81python%E4%B8%AD%E5%AE%9A%E4%B9%89%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2024/03/06/%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E3%80%81python%E4%B8%AD%E5%AE%9A%E4%B9%89%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/</id>
    <published>2024-03-07T03:45:38.000Z</published>
    <updated>2024-03-07T03:50:24.308Z</updated>
    
    <content type="html"><![CDATA[<h3 id="钩子函数、python中定义钩子函数"><a href="#钩子函数、python中定义钩子函数" class="headerlink" title="钩子函数、python中定义钩子函数"></a>钩子函数、python中定义钩子函数</h3><p>钩子函数的概念来源于其工作原理，即<strong>在系统或框架的特定阶段“钩住”某一刻以执行自定义代码</strong>。</p><p>钩子函数是一种在特定事件发生时由系统自动调用的自定义函数。这个术语“钩子”（hook）形象地描述了这种机制：它允许开发者“钩住”程序执行过程中的某些点，以便在这些点上插入自己的代码。这些函数通常用于响应系统事件、修改程序行为或执行特定任务。以下是钩子函数由来的几个方面：</p><ul><li><strong>系统级钩子函数</strong>：在操作系统层面，钩子函数可以监视和处理系统消息，如键盘按键、鼠标动作或窗口消息等。这些函数在消息传递到目标之前截获它们，允许开发者执行自定义操作。</li><li><strong>编程框架中的钩子函数</strong>：在应用程序框架中，钩子函数用于扩展框架的功能而无需修改框架本身的代码。</li><li><strong>函数式编程中的钩子函数</strong>：在函数式编程中，钩子函数可以用来实现纯函数，确保函数的输出仅依赖于输入并且不产生副作用。</li></ul><p>总的来说，钩子函数提供了一种灵活的方式来处理程序流程中的特定事件，使得开发者能够在不改变原有程序结构的情况下，添加或修改功能。 </p><p>在Python中，可以使用<strong>装饰器</strong>来实现钩子函数。以下是一个简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hook_decorator</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;在函数执行前执行的钩子函数&quot;</span>)</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;在函数执行后执行的钩子函数&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@hook_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">example_function</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;这是一个示例函数&quot;</span>)</span><br><span class="line"></span><br><span class="line">example_function()</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输出结果：</span></span><br><span class="line"><span class="string">在函数执行前执行的钩子函数</span></span><br><span class="line"><span class="string">这是一个示例函数</span></span><br><span class="line"><span class="string">在函数执行后执行的钩子函数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;钩子函数、python中定义钩子函数&quot;&gt;&lt;a href=&quot;#钩子函数、python中定义钩子函数&quot; class=&quot;headerlink&quot; title=&quot;钩子函数、python中定义钩子函数&quot;&gt;&lt;/a&gt;钩子函数、python中定义钩子函数&lt;/h3&gt;&lt;p&gt;钩子函数的概</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="基础" scheme="http://example.com/categories/python/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="钩子函数" scheme="http://example.com/categories/python/%E5%9F%BA%E7%A1%80/%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="钩子函数" scheme="http://example.com/tags/%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/"/>
    
    <category term="装饰器" scheme="http://example.com/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    
    <category term="hook" scheme="http://example.com/tags/hook/"/>
    
  </entry>
  
  <entry>
    <title>纯函数</title>
    <link href="http://example.com/2024/03/06/%E7%BA%AF%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2024/03/06/%E7%BA%AF%E5%87%BD%E6%95%B0/</id>
    <published>2024-03-07T03:45:08.000Z</published>
    <updated>2024-03-07T03:49:11.775Z</updated>
    
    <content type="html"><![CDATA[<h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><p><strong>纯函数（Pure Function）是一种在函数式编程中非常重要的概念，它指的是那些给定相同的输入，总是返回相同输出，并且在执行过程中不会产生副作用的函数</strong>。</p><p>纯函数的核心特征包括：</p><ul><li><strong>相同的输入产生相同的输出</strong>：这意味着如果两次调用函数时的参数完全相同，那么这两次调用的结果也应该是相同的。</li><li><strong>无副作用</strong>：纯函数在执行过程中不会改变任何状态，也不会与系统外部有任何可观察的交互，例如修改全局变量、进行I/O操作等。</li><li><strong>结果只依赖于输入参数</strong>：函数的返回值只能由它的参数决定，不依赖于任何外部状态或额外的输入。</li></ul><p>纯函数的优势在于它们具有可预测性，易于测试和重用。由于它们的输出完全由输入决定，因此可以在不产生副作用的情况下自由地替换和使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;纯函数&quot;&gt;&lt;a href=&quot;#纯函数&quot; class=&quot;headerlink&quot; title=&quot;纯函数&quot;&gt;&lt;/a&gt;纯函数&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;纯函数（Pure Function）是一种在函数式编程中非常重要的概念，它指的是那些给定相同的输入，总是返回相同输出</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="基础" scheme="http://example.com/categories/python/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="纯函数" scheme="http://example.com/categories/python/%E5%9F%BA%E7%A1%80/%E7%BA%AF%E5%87%BD%E6%95%B0/"/>
    
    
    <category term="纯函数" scheme="http://example.com/tags/%E7%BA%AF%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>pytest | 异常断言</title>
    <link href="http://example.com/2024/03/06/pytest%E5%BC%82%E5%B8%B8%E6%96%AD%E8%A8%80/"/>
    <id>http://example.com/2024/03/06/pytest%E5%BC%82%E5%B8%B8%E6%96%AD%E8%A8%80/</id>
    <published>2024-03-07T03:44:37.000Z</published>
    <updated>2024-03-07T03:48:08.198Z</updated>
    
    <content type="html"><![CDATA[<h3 id="pytest异常断言"><a href="#pytest异常断言" class="headerlink" title="pytest异常断言"></a>pytest异常断言</h3><p><strong>异常断言</strong>即测试待测代码段是否会抛出特定的异常。异常断言最常用的两种方式如下：</p><ol><li>pytest.raises()</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_zero_division</span>():</span></span><br><span class="line">    <span class="comment"># pytest.raises(ZeroDivisionError)作为一个上下文管理器（context manageer）断言with后的代码块是否会抛出“ZeroDivisionError”除零异常</span></span><br><span class="line">    <span class="keyword">with</span> pytest.raises(ZeroDivisionError) <span class="keyword">as</span> excpinfo:</span><br><span class="line">        <span class="number">1</span> / <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 异常信息excpinfo中匹配除零异常信息“division by zero”</span></span><br><span class="line">    <span class="keyword">assert</span> excpinfo.match(<span class="string">&quot;division by zero&quot;</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li>@pytest.mark.xfail</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>():</span></span><br><span class="line">    <span class="keyword">raise</span> IndexError()</span><br><span class="line"></span><br><span class="line"><span class="comment"># @pytest.mark.xfail(raises=IndexError)是一个python装饰器，用于标记（mark）一个测试用例为预期失败，该例子中若f()函数抛出IndexError异常，则标记该测试为预期失败，测试报告（report）中会报告一个1 xfail，若f()函数未抛出IndexError异常，则测试报告中会报告一个1 xpass</span></span><br><span class="line"><span class="meta">@pytest.mark.xfail(<span class="params">raises=IndexError</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_f</span>():</span></span><br><span class="line">    f()</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>将<code>pytest.mark.xfail</code>与<code>raises</code>参数一起使用可能更适合于记录未修复的bug，使用<code>pytest.reises()</code>可能更适合于测试自己的代码故意引发的异常的情况。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;pytest异常断言&quot;&gt;&lt;a href=&quot;#pytest异常断言&quot; class=&quot;headerlink&quot; title=&quot;pytest异常断言&quot;&gt;&lt;/a&gt;pytest异常断言&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;异常断言&lt;/strong&gt;即测试待测代码段是否会抛出特定的异</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="python测试框架" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="pytest" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/pytest/"/>
    
    <category term="异常断言" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/pytest/%E5%BC%82%E5%B8%B8%E6%96%AD%E8%A8%80/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="pytest" scheme="http://example.com/tags/pytest/"/>
    
    <category term="python测试框架" scheme="http://example.com/tags/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="异常断言" scheme="http://example.com/tags/%E5%BC%82%E5%B8%B8%E6%96%AD%E8%A8%80/"/>
    
    <category term="pytest.mark.xfail" scheme="http://example.com/tags/pytest-mark-xfail/"/>
    
    <category term="pytest.raises" scheme="http://example.com/tags/pytest-raises/"/>
    
  </entry>
  
  <entry>
    <title>并行计算 | GPU加速原理</title>
    <link href="http://example.com/2024/03/01/GPU%E5%8A%A0%E9%80%9F%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2024/03/01/GPU%E5%8A%A0%E9%80%9F%E5%8E%9F%E7%90%86/</id>
    <published>2024-03-01T13:32:48.000Z</published>
    <updated>2024-03-01T13:35:08.092Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GPU加速原理"><a href="#GPU加速原理" class="headerlink" title="GPU加速原理"></a>GPU加速原理</h3><p>GPU加速的原理是利用多核处理器进行并行运算来实现程序的加速运行**。与CPU不同，GPU拥有数以千计的核心，专门为同时处理多任务而设计，可以高效地处理并行任务。</p><p>CPU几倍很强的通用性，可以处理不同类型的数据，同时擅长处理逻辑判断导致的大量分支跳转和中断处理，CPU相当于一个博学多闻的博士在完成一项工作。而GPU处理的数据类型高度统一，且GPU有数以千计的核心，可以并行计算任务，相当于1000个小学生在完成一个任务，呈现“人多力量大”的优势。</p><p>实际使用中，GPU需要CPU的配合来完成任务的计算，并行计算部分会运行在GPU上，串行计算部分运行在CPU上，CPU负责总体的程序流程。</p><p><a href="https://blog.csdn.net/qq_41632117/article/details/118737557">参考资料：GPU加速原理，博主写的非常详细！</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;GPU加速原理&quot;&gt;&lt;a href=&quot;#GPU加速原理&quot; class=&quot;headerlink&quot; title=&quot;GPU加速原理&quot;&gt;&lt;/a&gt;GPU加速原理&lt;/h3&gt;&lt;p&gt;GPU加速的原理是利用多核处理器进行并行运算来实现程序的加速运行**。与CPU不同，GPU拥有数以千</summary>
      
    
    
    
    <category term="并行计算" scheme="http://example.com/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
    <category term="GPU" scheme="http://example.com/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/GPU/"/>
    
    <category term="GPU加速原理" scheme="http://example.com/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/GPU/GPU%E5%8A%A0%E9%80%9F%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="GPU" scheme="http://example.com/tags/GPU/"/>
    
    <category term="CPU" scheme="http://example.com/tags/CPU/"/>
    
    <category term="并行计算" scheme="http://example.com/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
    <category term="串行计算" scheme="http://example.com/tags/%E4%B8%B2%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
    <category term="GPU加速原理" scheme="http://example.com/tags/GPU%E5%8A%A0%E9%80%9F%E5%8E%9F%E7%90%86/"/>
    
    <category term="多核处理器" scheme="http://example.com/tags/%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>pytest | 如何调用pytest</title>
    <link href="http://example.com/2024/02/29/%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8pytest/"/>
    <id>http://example.com/2024/02/29/%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8pytest/</id>
    <published>2024-02-29T11:38:53.000Z</published>
    <updated>2024-02-29T11:42:48.245Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何调用pytest"><a href="#如何调用pytest" class="headerlink" title="如何调用pytest"></a>如何调用pytest</h3><p>pytest支持命令行参数选择特定的tests去执行，以下是常见的一些选择方法。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> run tests <span class="keyword">in</span> a module</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行测试文件中的所有符合pytest测试发现规则的测试用例(测试文件中符合test_*()的函数、TestXxx类中的测试用例)</span></span><br><span class="line">pytest test_mod.py</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> run tests <span class="keyword">in</span> a directory</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行testing目录下的所有文件名符合test_*.py或*_test.py的测试文件中的测试用例</span></span><br><span class="line">pytest testing/</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># run tests by keyword expressions</span></span><br><span class="line">pytest -k <span class="string">&quot;MyClass and not method&quot;</span></span><br><span class="line"><span class="comment"># 通过关键词表达式指定pytest运行的测试用例，pytest会在testpaths或者当前目录下找到类名为TestMyClass的类中的方法名不带method的方法去执行。如下示例，运行pytest -k &quot;MyClass and not method&quot;会执行test_a方法而不会运行test_method_add()方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编写测试文件test_keyword_exp.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestMyClass</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_a</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="string">&quot;a&quot;</span> == <span class="string">&quot;a&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_method_add</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> add(<span class="number">1</span>, <span class="number">2</span>) == <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> run tests by collection arguments</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> To run a specific <span class="built_in">test</span> within a module</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行test_mod.py测试文件中的test_func测试用例</span></span><br><span class="line">pytest tests/test_mod.py::test_func</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> To run all tests <span class="keyword">in</span> a class:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行test_mod.py测试文件中的TestClass类中的测试用例</span></span><br><span class="line">pytest tests/test_mod.py::TestClass</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Specifying a specific <span class="built_in">test</span> method:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行test_mod.py测试文件中的TestClass类中的test_method测试用例</span></span><br><span class="line">pytest tests/test_mod.py::TestClass::test_method</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Specifying a specific parametrization of a <span class="built_in">test</span>:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行test_mod.py测试文件中的带参数的test_func测试用例</span></span><br><span class="line">pytest tests/test_mod.py::test_func[x1,y2]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Run tests by marker expressions</span></span><br><span class="line"><span class="comment"># 运行带有@pytest.mark.slow装饰器的测试</span></span><br><span class="line">pytest -m slow</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下示例中，pytest将运行test_a测试用例，而不会运行test_b测试用例</span></span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestMarkDecoration</span>:</span></span><br><span class="line"><span class="meta">    @pytest.mark.slow</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_a</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="number">1</span> == <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @pytest.mark.quick</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_b</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="number">2</span> == <span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> run tests from packages</span></span><br><span class="line">pytest --pyargs pkg.testing</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这将导入pkg.testing，并使用其文件系统位置从中查找和运行测试</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;如何调用pytest&quot;&gt;&lt;a href=&quot;#如何调用pytest&quot; class=&quot;headerlink&quot; title=&quot;如何调用pytest&quot;&gt;&lt;/a&gt;如何调用pytest&lt;/h3&gt;&lt;p&gt;pytest支持命令行参数选择特定的tests去执行，以下是常见的一些选择方</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="python测试框架" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="pytest" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/pytest/"/>
    
    <category term="如何调用pytest" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/pytest/%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8pytest/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="pytest" scheme="http://example.com/tags/pytest/"/>
    
    <category term="测试框架" scheme="http://example.com/tags/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>pytest | pytest使用规则及示例</title>
    <link href="http://example.com/2024/02/29/pytest%E6%B5%8B%E8%AF%95%E7%A4%BA%E4%BE%8B/"/>
    <id>http://example.com/2024/02/29/pytest%E6%B5%8B%E8%AF%95%E7%A4%BA%E4%BE%8B/</id>
    <published>2024-02-29T11:10:36.000Z</published>
    <updated>2024-02-29T11:36:05.332Z</updated>
    
    <content type="html"><![CDATA[<h3 id="pytest使用规则及示例"><a href="#pytest使用规则及示例" class="headerlink" title="pytest使用规则及示例"></a>pytest使用规则及示例</h3><p>Pytest是一个功能强大且易于使用的<code>python测试框架</code>，支持编写<code>单元测试</code>、<code>集成测试</code>和<code>功能测试</code>。</p><p>Pytest使用规则：</p><ol><li>测试文件命名应符合<code>test_*.py</code>或<code>*_test.py</code></li><li>若使用class对测试用例进行分组，测试类名应符合<code>TestXxx</code></li><li>测试用例函数/方法名称应符合<code>test_*()</code></li></ol><p>另外，值得注意的是，pytest支持在测试类中定义<code>setup</code>和<code>teardown</code>方法，这写方法会<strong>在每个测试方法运行前后分别调用</strong>，用于设置测试环境和清理资源。<code>setup_class</code>和<code>teardown_class</code>方法在测试类中的<strong>所有测试方法之前和之后分别只运行一次</strong>。</p><p>下面编写一个计算器类Calculator，并使用pytest进行测试。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test_calculator.py 测试文件名称符合test_*.py</span></span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义计算器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sub</span>(<span class="params">a, b</span>):</span></span><br><span class="line">        <span class="keyword">return</span> a - b</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mul</span>(<span class="params">a, b</span>):</span></span><br><span class="line">        <span class="keyword">return</span> a * b</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">div</span>(<span class="params">a, b</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> a / b</span><br><span class="line">        <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;zero Division Error Exception&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义测试类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCalc</span>:</span>  <span class="comment"># 测试类名符合TestXxx</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_calc_add</span>(<span class="params">self</span>):</span>  <span class="comment"># 测试用例方法名符合test_*()</span></span><br><span class="line">        <span class="keyword">assert</span> Calculator.add(<span class="number">1</span>, <span class="number">2</span>) == <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_calc_sub</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> Calculator.sub(<span class="number">3</span>, <span class="number">1</span>) == <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_calc_mul</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> Calculator.mul(<span class="number">2</span>, <span class="number">4</span>) == <span class="number">8</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_calc_div</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> Calculator.div(<span class="number">8</span>, <span class="number">4</span>) == <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_calc_div_zero_div_exp</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">with</span> pytest.raises(ZeroDivisionError):</span><br><span class="line">            Calculator.div(<span class="number">3</span>, <span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;pytest使用规则及示例&quot;&gt;&lt;a href=&quot;#pytest使用规则及示例&quot; class=&quot;headerlink&quot; title=&quot;pytest使用规则及示例&quot;&gt;&lt;/a&gt;pytest使用规则及示例&lt;/h3&gt;&lt;p&gt;Pytest是一个功能强大且易于使用的&lt;code&gt;p</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="python测试框架" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="pytest" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/pytest/"/>
    
    <category term="pytest使用规则及示例" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/pytest/pytest%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99%E5%8F%8A%E7%A4%BA%E4%BE%8B/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="pytest" scheme="http://example.com/tags/pytest/"/>
    
    <category term="单元测试" scheme="http://example.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
    <category term="集成测试" scheme="http://example.com/tags/%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95/"/>
    
    <category term="功能测试" scheme="http://example.com/tags/%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
    <category term="测试框架" scheme="http://example.com/tags/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>DevOps | CI/CD</title>
    <link href="http://example.com/2024/02/28/CI-CD/"/>
    <id>http://example.com/2024/02/28/CI-CD/</id>
    <published>2024-02-28T11:41:24.000Z</published>
    <updated>2024-02-28T11:55:43.510Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI/CD"></a>CI/CD</h3><p><strong>CI/CD</strong>:持续集成和持续交付/持续部署，是DevOps实践中的关键组成部分，包括<strong>代码的自动构建、测试和部署</strong>，以确保软件的快速和健壮开发。</p><p><code>DevOps</code>是软件开发中的一种文化和实践，强调开发（Development），测试，运维（Operations）三个领域的合并，通过自动化软件交付和架构变更的流程，实现构建、测试、发布软件的快捷、频繁和可靠。</p><p><a href="https://www.redhat.com/zh/topics/devops/what-is-ci-cd">参考资料1：什么是 CI/CD？</a></p><p><a href="https://zhuanlan.zhihu.com/p/136843588">参考资料2：使用gitlab实现CI/CD</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;CI-CD&quot;&gt;&lt;a href=&quot;#CI-CD&quot; class=&quot;headerlink&quot; title=&quot;CI/CD&quot;&gt;&lt;/a&gt;CI/CD&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;CI/CD&lt;/strong&gt;:持续集成和持续交付/持续部署，是DevOps实践中的关键组成部分，包括</summary>
      
    
    
    
    <category term="DevOps" scheme="http://example.com/categories/DevOps/"/>
    
    <category term="CI/CD" scheme="http://example.com/categories/DevOps/CI-CD/"/>
    
    
    <category term="DevOps" scheme="http://example.com/tags/DevOps/"/>
    
    <category term="CI" scheme="http://example.com/tags/CI/"/>
    
    <category term="CD" scheme="http://example.com/tags/CD/"/>
    
    <category term="持续集成" scheme="http://example.com/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
    <category term="持续交付" scheme="http://example.com/tags/%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98/"/>
    
    <category term="持续部署" scheme="http://example.com/tags/%E6%8C%81%E7%BB%AD%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>python | 迭代器与生成器的区别</title>
    <link href="http://example.com/2024/02/28/python%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2024/02/28/python%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2024-02-28T11:30:00.000Z</published>
    <updated>2024-02-28T11:32:59.296Z</updated>
    
    <content type="html"><![CDATA[<h3 id="迭代器与生成器的区别"><a href="#迭代器与生成器的区别" class="headerlink" title="迭代器与生成器的区别"></a>迭代器与生成器的区别</h3><ol><li><p>python迭代器</p><p>Python中的迭代器是一个可以记住遍历位置的对象，用于访问集合元素的一种方式。迭代器是Python中处理数据集合的一种高效机制，它们<strong>允许开发者逐个访问集合中的元素，而不需要一次性将所有数据加载到内存中</strong>。</p><p>迭代器通过实现<code>__iter__()</code>和<code>__next__()</code>方法来定义其行为。<code>__iter__()</code>方法返回迭代器对象本身，而<code>__next__()</code>方法负责返回容器中的下一个值。当没有更多元素可以返回时，<code>__next__()</code>方法会抛出<code>StopIteration</code>异常，通知调用者所有元素已经被遍历完毕。</p><span id="more"></span><p>​    在Python中，可以使用<code>iter()</code>函数获取一个对象的迭代器，然后使用<code>next()</code>函数来访问迭代器中的下一个元素。此外，Python的for循环本质上就是在使用迭代器，它可以自动处理<code>StopIteration</code>异常，使得代码更加简洁易读。以下是使用for循环遍历可迭代对象中元素的示例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用for循环遍历list、tuple、dict、str、set等可迭代对象</span></span><br><span class="line"><span class="comment"># 遍历列表list</span></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line">    <span class="built_in">print</span>(element)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 编译元组tuple</span></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(element)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 遍历字典dict</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> &#123;<span class="string">&#x27;one&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>: <span class="number">2</span>&#125;:</span><br><span class="line">    <span class="built_in">print</span>(key)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 遍历字符串str</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> <span class="string">&quot;123&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(char)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 遍历集合</span></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> &#123;<span class="string">&#x27;1&#x27;</span>, <span class="number">2</span>, <span class="number">3.0</span>&#125;:</span><br><span class="line">    <span class="built_in">print</span>(element)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 使用python内置方法iter()获取对象的迭代器iterator</span></span><br><span class="line"><span class="comment"># 获取字符串迭代器</span></span><br><span class="line">s = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">it_s = <span class="built_in">iter</span>(s)</span><br><span class="line"><span class="built_in">print</span>(it_s)  <span class="comment"># &lt;str_iterator object at 0x10c90e650&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_s))  <span class="comment"># &#x27;a&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_s))  <span class="comment"># &#x27;b&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_s))  <span class="comment"># &#x27;c&#x27;</span></span><br><span class="line"><span class="comment"># print(next(it)) # StopIteration</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取列表迭代器</span></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">it_list1 = <span class="built_in">iter</span>(list1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_list1))  <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_list1))  <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_list1))  <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取集合迭代器</span></span><br><span class="line">set1 = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line">it_set1 = <span class="built_in">iter</span>(set1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_set1))  <span class="comment"># &#x27;a&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_set1))  <span class="comment"># &#x27;b&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_set1))  <span class="comment"># &#x27;c&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取字典迭代器</span></span><br><span class="line">dict1 = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line">it_dict1 = <span class="built_in">iter</span>(dict1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_dict1))  <span class="comment"># ’a‘</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_dict1))  <span class="comment"># ’b‘</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_dict1))  <span class="comment"># ’c‘</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取元组迭代器</span></span><br><span class="line">tuple1 = (<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>)</span><br><span class="line">it_tuple1 = <span class="built_in">iter</span>(tuple1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_tuple1))  <span class="comment"># 1.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_tuple1))  <span class="comment"># 2.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_tuple1))  <span class="comment"># 3.0</span></span><br></pre></td></tr></table></figure></li><li><p>python生成器</p><p>Python中的生成器是一种<strong>特殊类型的迭代器</strong>，它使用<code>yield</code>关键字来返回数据。</p><p>生成器是一种特殊的函数，它可以在执行过程中暂停并保存其状态，以便稍后从上次停止的位置继续执行。当生成器被调用时，它不会立即执行，而是返回一个生成器对象。只有当开始迭代该对象时，生成器才会逐步执行，并在每次遇到<code>yield</code>语句时返回一个值。</p><p><strong>生成器的主要优点是它们可以按需生成数据，而不是一次性生成所有数据</strong>。这在<strong>处理大量数据</strong>或需要<strong>延迟计算结果</strong>的情况下非常有用。生成器还可以用于实现协程（coroutines），这是一种允许多个任务协作执行的编程模式。</p><p>以下是一个简单的生成器示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_up_to</span>(<span class="params"><span class="built_in">max</span></span>):</span></span><br><span class="line">    count = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> count &lt;= <span class="built_in">max</span>:</span><br><span class="line">        <span class="keyword">yield</span> count</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个生成器对象</span></span><br><span class="line">counter = count_up_to(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代生成器对象</span></span><br><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> counter:</span><br><span class="line">    <span class="built_in">print</span>(number)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 使用生成器表达式定义生成器，采用()</span></span><br><span class="line">num_iterator = (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(num_iterator)</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> num_iterator:</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line"></span><br><span class="line">num_iterator2 = (i*i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(num_iterator2))  <span class="comment"># 求平方和</span></span><br><span class="line"></span><br><span class="line">xvec = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line">yvec = [<span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(x*y <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(xvec, yvec)))  <span class="comment"># 点积</span></span><br><span class="line"></span><br><span class="line">data = <span class="string">&#x27;golf&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(data[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>)))  <span class="comment"># 反转输出字符串</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;迭代器与生成器的区别&quot;&gt;&lt;a href=&quot;#迭代器与生成器的区别&quot; class=&quot;headerlink&quot; title=&quot;迭代器与生成器的区别&quot;&gt;&lt;/a&gt;迭代器与生成器的区别&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;python迭代器&lt;/p&gt;
&lt;p&gt;Python中的迭代器是一个可以记住遍历位置的对象，用于访问集合元素的一种方式。迭代器是Python中处理数据集合的一种高效机制，它们&lt;strong&gt;允许开发者逐个访问集合中的元素，而不需要一次性将所有数据加载到内存中&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;迭代器通过实现&lt;code&gt;__iter__()&lt;/code&gt;和&lt;code&gt;__next__()&lt;/code&gt;方法来定义其行为。&lt;code&gt;__iter__()&lt;/code&gt;方法返回迭代器对象本身，而&lt;code&gt;__next__()&lt;/code&gt;方法负责返回容器中的下一个值。当没有更多元素可以返回时，&lt;code&gt;__next__()&lt;/code&gt;方法会抛出&lt;code&gt;StopIteration&lt;/code&gt;异常，通知调用者所有元素已经被遍历完毕。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="基础" scheme="http://example.com/categories/python/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="迭代器与生成器的区别" scheme="http://example.com/categories/python/%E5%9F%BA%E7%A1%80/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="生成器" scheme="http://example.com/tags/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
    <category term="迭代器" scheme="http://example.com/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    
    <category term="yield" scheme="http://example.com/tags/yield/"/>
    
    <category term="iter()" scheme="http://example.com/tags/iter/"/>
    
    <category term="next()" scheme="http://example.com/tags/next/"/>
    
  </entry>
  
  <entry>
    <title>C++ | GCC或Clang头文件搜索路径</title>
    <link href="http://example.com/2024/02/26/GCC%E6%88%96Clang%E5%A4%B4%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84/"/>
    <id>http://example.com/2024/02/26/GCC%E6%88%96Clang%E5%A4%B4%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84/</id>
    <published>2024-02-26T12:45:07.000Z</published>
    <updated>2024-02-26T12:56:19.195Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GCC-Clang的头文件搜索路径"><a href="#GCC-Clang的头文件搜索路径" class="headerlink" title="GCC/Clang的头文件搜索路径"></a>GCC/Clang的头文件搜索路径</h3><ul><li><p>GCC/Clang编译器在对C++源代码文件进行预处理时，会对C++源代码头部包含的头文件进行搜索，搜索时根据环境变量CPLUS_INCLUDE_PATH中的路径进行搜索，如果搜索不到某头文件会报错。若CPLUS_INCLUDE_PATH中没有包含所使用头文件所在路径，也可以通过-I参数制定使用到的头文件的路径，例如，gcc -I /your/header/file/ test.cpp。</p></li><li><p>添加GCC头文件搜索路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export CPLUS_INCLUDE_PATH=$CPLUS_INCLUDE_PATH:/xxx/include</span><br></pre></td></tr></table></figure></li><li><p>查看C++编译器（GCC）的头文件搜索路径命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gcc -x c++ -v -E -</span><br><span class="line"><span class="meta">#</span><span class="bash"> gcc：表示使用GCC编译器进行编译。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -x c++：表示指定编译的语言为C++。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -v：表示显示详细的编译过程信息。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -E：表示仅执行预处理阶段，不进行编译和链接。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -：表示从标准输入读取源代码。</span></span><br></pre></td></tr></table></figure></li><li><p>查看C++编译器（Clang）的头文件搜索路径命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">clang -x c++ -v -E -</span><br><span class="line"><span class="meta">#</span><span class="bash"> clang：表示使用GCC编译器进行编译。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -x c++：表示指定编译的语言为C++。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -v：表示显示详细的编译过程信息。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -E：表示仅执行预处理阶段，不进行编译和链接。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -：表示从标准输入读取源代码。</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;GCC-Clang的头文件搜索路径&quot;&gt;&lt;a href=&quot;#GCC-Clang的头文件搜索路径&quot; class=&quot;headerlink&quot; title=&quot;GCC/Clang的头文件搜索路径&quot;&gt;&lt;/a&gt;GCC/Clang的头文件搜索路径&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;G</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    <category term="头文件搜索路径" scheme="http://example.com/categories/C/%E5%A4%B4%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="GCC" scheme="http://example.com/tags/GCC/"/>
    
    <category term="Clang" scheme="http://example.com/tags/Clang/"/>
    
    <category term="头文件搜索路径" scheme="http://example.com/tags/%E5%A4%B4%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
</feed>
