<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Victory&#39;s Blog</title>
  
  <subtitle>非淡泊无以明志，非宁静无以致远</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-09-01T03:09:46.003Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>victory-liao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode | 反转字符串中的元音字母</title>
    <link href="http://example.com/2021/09/01/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D/"/>
    <id>http://example.com/2021/09/01/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D/</id>
    <published>2021-09-01T03:05:01.000Z</published>
    <updated>2021-09-01T03:09:46.003Z</updated>
    
    <content type="html"><![CDATA[<h1 id="345-反转字符串中的元音字母"><a href="#345-反转字符串中的元音字母" class="headerlink" title="345.反转字符串中的元音字母"></a>345.反转字符串中的元音字母</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 s ，仅反转字符串中的所有元音字母，并返回结果字符串。<br>元音字母包括 ‘a’、’e’、’i’、’o’、’u’，且可能以大小写两种形式出现。</p><p><a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string">题目链接</a>+</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.先将字符串中的元音字母的位置找出来，然后再将各元音字母反转<br>2.双指针<br>我们可以使用两个指针 i 和 j 对字符串相向地进行遍历。<br>具体地，指针 i 初始时指向字符串 s 的首位，指针 j 初始时指向字符串 s 的末位。在遍历的过程中，我们不停地将 i 向右移动，直到 i 指向一个元音字母（或者超出字符串的边界范围）；同时，我们不停地将 j 向左移动，直到 j 指向一个元音字母。此时，如果 i&lt;j，那么我们交换 i 和 j 指向的元音字母，否则说明所有的元音字母均已遍历过，就可以退出遍历的过程。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:    def reverseVowels(self, s: str) -&gt; str:        &quot;&quot;&quot;        find ans reverse        :param s:        :return:        &quot;&quot;&quot;        vowels = list()        s = list(s)        for i in range(len(s)):            ch = s[i].lower()            if ch == &#39;a&#39; or ch == &#39;e&#39; or ch == &#39;i&#39; or ch == &#39;o&#39; or ch == &#39;u&#39;:                vowels.append(i)        for i in range(len(vowels)//2):            s[vowels[i]], s[vowels[len(vowels) - i -1]] = s[vowels[len(vowels) - i -1]], s[vowels[i]]        return &#39;&#39;.join(s)    def reverseVowels1(self, s: str) -&gt; str:        &quot;&quot;&quot;双指针&quot;&quot;&quot;        def isVowel(ch: str) -&gt; bool:            return ch in &quot;aeiouAEIOU&quot;        n = len(s)        s = list(s)        i, j = 0, n - 1        while i &lt; j:            while i &lt; n and not isVowel(s[i]):                i += 1            while j &gt; 0 and not isVowel(s[j]):                j -= 1            if i &lt; j:                s[i], s[j] = s[j], s[i]                i += 1                j -= 1        return &#39;&#39;.join(s)if __name__ == &quot;__main__&quot;:    s = Solution()    string = &quot;hello&quot;    res = s.reverseVowels(string)    print(res)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;345-反转字符串中的元音字母&quot;&gt;&lt;a href=&quot;#345-反转字符串中的元音字母&quot; class=&quot;headerlink&quot; title=&quot;345.反转字符串中的元音字母&quot;&gt;&lt;/a&gt;345.反转字符串中的元音字母&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="字符串" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>hexo | hexo博客换电脑了怎么办</title>
    <link href="http://example.com/2021/08/30/hexo%E5%8D%9A%E5%AE%A2%E6%8D%A2%E7%94%B5%E8%84%91%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E/"/>
    <id>http://example.com/2021/08/30/hexo%E5%8D%9A%E5%AE%A2%E6%8D%A2%E7%94%B5%E8%84%91%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E/</id>
    <published>2021-08-30T02:41:12.000Z</published>
    <updated>2021-08-30T02:57:30.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hexo博客换电脑了怎么办"><a href="#hexo博客换电脑了怎么办" class="headerlink" title="hexo博客换电脑了怎么办"></a>hexo博客换电脑了怎么办</h1><p>我们搭建的hexo博客在更换电脑之后，如果重新搭建博客比较费时费力，可以按照以下资料快速在新的电脑上使用hexo博客发布内容。</p><p><a href="https://www.cnblogs.com/study-everyday/p/8902136.html">参考资料链接</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;hexo博客换电脑了怎么办&quot;&gt;&lt;a href=&quot;#hexo博客换电脑了怎么办&quot; class=&quot;headerlink&quot; title=&quot;hexo博客换电脑了怎么办&quot;&gt;&lt;/a&gt;hexo博客换电脑了怎么办&lt;/h1&gt;&lt;p&gt;我们搭建的hexo博客在更换电脑之后，如果重新搭建博</summary>
      
    
    
    
    <category term="hexo" scheme="http://example.com/categories/hexo/"/>
    
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 反转字符串</title>
    <link href="http://example.com/2021/08/29/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://example.com/2021/08/29/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2021-08-29T03:05:55.000Z</published>
    <updated>2021-08-29T03:09:54.442Z</updated>
    
    <content type="html"><![CDATA[<h1 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。<br>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。<br>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><p>示例 1：<br>输入：[“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]</p><p><a href="https://leetcode-cn.com/problems/reverse-string">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.字符串切片 —&gt; reversString()<br>2.使用list.reverse()方法 —&gt; reversString1()<br>3.使用reversed()函数 —&gt; reversString2()<br>4.使用栈 —&gt; reversString3()<br>将s列表看作一个栈，低端作为栈底，高端作为栈顶，依次将栈顶元素出栈即可。<br>5.for —&gt; reversString4()<br>将列表中的第i个元素与倒数第i个元素交换（0&lt; i &lt; len(s)//2）<br>6.递归 —&gt; reversString5()</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):    def reverseString(self, s):        &quot;&quot;&quot;        :type s: List[str]        :rtype: None Do not return anything, modify s in-place instead.        &quot;&quot;&quot;        return s[::-1]    def reverseString1(self, s):        s.reverse()    def reverseString2(self, s):        s[:] = list(reversed(s))    def reverseString3(self, s):        result = list()        while len(s) &gt; 0:            result.append(s.pop())        s[:] = result    def reverseString4(self, s):        for i in range(len(s)//2):            s[i], s[len(s) - i - 1] = s[len(s) - i - 1], s[i]    # def reverseString5(self, s):    #     if len(s) &lt; 1:    #         return s    #     return self.reverseString4(s[1:]) + s[0]</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;344-反转字符串&quot;&gt;&lt;a href=&quot;#344-反转字符串&quot; class=&quot;headerlink&quot; title=&quot;344.反转字符串&quot;&gt;&lt;/a&gt;344.反转字符串&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="字符串" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 二进制求和</title>
    <link href="http://example.com/2021/08/29/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/"/>
    <id>http://example.com/2021/08/29/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/</id>
    <published>2021-08-29T02:49:05.000Z</published>
    <updated>2021-08-29T02:55:17.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67.二进制求和"></a>67.二进制求和</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两个二进制字符串，返回它们的和（用二进制表示）。<br>输入为 非空 字符串且只包含数字 1 和 0。</p><p>示例 1:<br>输入: a = “11”, b = “1”<br>输出: “100”</p><p><a href="https://leetcode-cn.com/problems/add-binary/">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.先将 a 和 b 转化成十进制数，求和后再转化为二进制数<br>2.列竖式<br>末尾对齐，逐位相加，逢二进一<br>具体的，我们可以取 n=max{∣a∣,∣b∣}，循环 n 次，从最低位开始遍历。我们使用一个变量 carry 表示上一个位置的进位，初始值为 0。记当前位置对其的两个位为 ai​ 和 bi​，则每一位的答案为 (carry+ai+bi) mod 2，下一位的进位为 ⌊(carry+ai+bi)/2⌋。重复上述步骤，直到数字 a 和 b 的每一位计算完毕。最后如果 carry 的最高位不为 0，则将最高位添加到计算结果的末尾。<br>注意，为了让各个位置对齐，你可以先反转这个代表二进制数字的字符串，然后低下标对应低位，高下标对应高位。当然你也可以直接把 a 和 b 中短的那一个补 0 直到和长的那个一样长，然后从高位向低位遍历，对应位置的答案按照顺序存入答案字符串内，最终将答案串反转。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:    def addBinary(self, a: str, b: str) -&gt; str:        &quot;&quot;&quot;        先将 aaa 和 bbb 转化成十进制数，求和后再转化为二进制数        :param a:        :param b:        :return:        &quot;&quot;&quot;        # a = int(a, 2)  # 将二进制数转为十进制        # b = int(b, 2)        # print(a)        # print(b)        # return bin(a+b)[2:]        return &#39;&#123;0:b&#125;&#39;.format(int(a, 2) + int(b, 2))    def addBinary1(self, a: str, b: str) -&gt; str:        ans = list()        n = max(len(a), len(b))        carry = 0        list_a = []        list_b = []        for e in a:            list_a.append(int(e))        for e in b:            list_b.append(int(e))        print(list_a)        print(list_b)        for i in range(n):            carry += list_a[len(a) - i - 1] if i &lt; len(a) else 0            carry += list_b[len(b) - i - 1] if i &lt; len(b) else 0            ans.append(str(int(carry % 2)))            carry /= 2        if carry &gt; 0:            ans.append(&#39;1&#39;)        return &#39;&#39;.join(ans[::-1])if __name__ == &#39;__main__&#39;:    s = Solution()    a = &quot;11&quot;    b = &quot;1&quot;    res = s.addBinary1(a, b)    print(res)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;67-二进制求和&quot;&gt;&lt;a href=&quot;#67-二进制求和&quot; class=&quot;headerlink&quot; title=&quot;67.二进制求和&quot;&gt;&lt;/a&gt;67.二进制求和&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="字符串" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 验证回文串</title>
    <link href="http://example.com/2021/08/28/%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    <id>http://example.com/2021/08/28/%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/</id>
    <published>2021-08-28T02:58:08.000Z</published>
    <updated>2021-08-28T03:04:40.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125.验证回文串"></a>125.验证回文串</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。<br>说明：本题中，我们将空字符串定义为有效的回文串。</p><p>示例 1:<br>输入: “A man, a plan, a canal: Panama”<br>输出: true<br>解释：”amanaplanacanalpanama” 是回文串</p><p><a href="https://leetcode-cn.com/problems/count-and-say/">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.判断第i(0 &lt; i &lt; len(new_s)//2)个字符与倒数第i个字符是否相等来确定字符串是否回文，其中new_s是去除了除数字字母外字符的字符串<br>2.判断反转字符串是否与原字符串相同<br>3.双指针（去除除数字字母外的其他字符）<br>初始时，左右指针分别指向字符串的两侧，随后我们不断地将这两个指针相向移动，每次移动一步，并判断这两个指针指向的字符是否相同。当这两个指针相遇时，就说明是回文串。<br>4.双指针（直接在原字符串上进行判断）<br>与3.相同</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:    def isPalindrome(self, s: str) -&gt; bool:        import re        new_s = re.sub(r&#39;\W|_&#39;, &#39;&#39;, s).lower()        len_new_s = len(new_s)        i = 0        while i &lt; len_new_s // 2:            if new_s[i] == new_s[len_new_s-i-1]:                i += 1            else:                break        if i == len_new_s // 2:            return True        else:            return False    def isPalindrome1(self, s: str) -&gt; bool:        &quot;&quot;&quot;        筛选+判断（判断反转字符串是否与原字符串相同）        :param s:        :return:        &quot;&quot;&quot;        new_s = &quot;&quot;.join(ch.lower() for ch in s if ch.isalnum())        return new_s == new_s[::-1]    def isPalindrome2(self, s: str) -&gt; bool:        &quot;&quot;&quot;        双指针        &quot;&quot;&quot;        new_s = &quot;&quot;.join(ch.lower() for ch in s if ch.isalnum())        left, right = 0, len(new_s) - 1        while left &lt; right:            if new_s[left] != new_s[right]:                return False            left, right = left + 1, right - 1        return True    def isPalindrome3(self, s: str) -&gt; bool:        &quot;&quot;&quot;在原字符串上直接判断&quot;&quot;&quot;        n = len(s)        left, right = 0, n - 1        while left &lt; right:            while left &lt; right and not s[left].isalnum():                left += 1            while left &lt; right and not s[right].isalnum():                right -= 1            if left &lt; right:                if s[left].lower() != s[right].lower():                    return False                left, right = left + 1, right - 1        return Trueif __name__ == &quot;__main__&quot;:    slt = Solution()    string = &quot;abcb&quot;    res = slt.isPalindrome(string)    print(res)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;125-验证回文串&quot;&gt;&lt;a href=&quot;#125-验证回文串&quot; class=&quot;headerlink&quot; title=&quot;125.验证回文串&quot;&gt;&lt;/a&gt;125.验证回文串&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="字符串" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 外观数列</title>
    <link href="http://example.com/2021/08/28/%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/"/>
    <id>http://example.com/2021/08/28/%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/</id>
    <published>2021-08-28T01:45:20.000Z</published>
    <updated>2021-08-28T02:06:38.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="38-外观数列"><a href="#38-外观数列" class="headerlink" title="38.外观数列"></a>38.外观数列</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个正整数 n ，输出外观数列的第 n 项。<br>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。</p><span id="more"></span><p>你可以将其视作是由递归公式定义的数字字符串序列：<br>    countAndSay(1) = “1”<br>    countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。<br>前五项如下：</p><ol><li><pre><code>1</code></pre></li><li><pre><code>11</code></pre></li><li><pre><code>21</code></pre></li><li><pre><code>1211</code></pre></li><li><pre><code>111221</code></pre>第一项是数字 1<br>描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 “11”<br>描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 “21”<br>描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 “1211”<br>描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 “111221”<br>要 描述 一个数字字符串，首先要将字符串分割为 最小 数量的组，每个组都由连续的最多 相同字符 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。</li></ol><p><a href="https://leetcode-cn.com/problems/count-and-say/">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.递归<br>递归出口为n == 1时，返回”1”；<br>当n &gt; 1时，我们只需要计算countAndSay(n - 1)中每个数字的个数：<br>对于计算字符串中每个数字出现的个数，使用双指针i, j，其中i表示当前字符，j则是计数指针，向后移动判断；<br>以求n = 5，lastStr = countAndSay(4) = “1211”为例，answer = “”，一开始让i = 0, j = 1，此时’1’ != ‘2’，<br>故answer += (j - i) + lastStr.charAt(i)，ans = “11”；然后让i = j（第二个不同字符起始位置），<br>然后j++往后移动；此时i = j = 1，j = j + 1 = 2，又’2’ != ‘1’，<br>所以answer += (j - i) + lastStr.charAt(i),ans = “1112”,重复i = j = 2， j = ++j = 3；此时’1’ = ‘1’；<br>故直接j = ++j = 4 == lastStr.length()，所以跳出循环，然后把最后一次的字符个数字符加上，即执行：<br>answer += (j - i) + lastStr.charAt(i),ans = “111221”，即countAndSay(5) = “111221”。<br>2.正则表达式<br>用正则表达式匹配一个数字的重复序列和数字本身，然后将匹配的序列的长度加上数字本身替换原字符串中重复序列，…，以此类推。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:    def countAndSay(self, n: int) -&gt; str:        &quot;&quot;&quot;        递归法        :param n:        :return:        &quot;&quot;&quot;        if n == 1:  # 递归出口            return &quot;1&quot;        else:            lastStr = self.countAndSay(n - 1)            ans = &quot;&quot;            i = 0            j = 1            while j &lt; len(lastStr):                if lastStr[i] != lastStr[j]:                    ans += str(j-i)                    ans += str(lastStr[i])                    i = j  # 下一个不同字符的起始位置                j += 1            ans += str(j - i)            ans += str(lastStr[i])            return str(ans)    def countAndSay1(self, n):        &quot;&quot;&quot;        :type n: int        :rtype: str        &quot;&quot;&quot;        import re        s = &#39;1&#39;        for _ in range(n - 1):            s = re.sub(r&#39;(.)\1*&#39;, lambda a: str(len(a.group(0))) + a.group(1), s)  # sub(pattern, repl, string)            # r&#39;(.)\1*&#39; (.)匹配一个任意字符作为一个分组 \1*匹配与第一个分组相同内容0次/多次        return sif __name__ == &#39;__main__&#39;:    s = Solution()    res = s.countAndSay1(5)    print(res)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;38-外观数列&quot;&gt;&lt;a href=&quot;#38-外观数列&quot; class=&quot;headerlink&quot; title=&quot;38.外观数列&quot;&gt;&lt;/a&gt;38.外观数列&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个正整数 n ，输出外观数列的第 n 项。&lt;br&gt;「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。&lt;/p&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="字符串" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>python | 匹配第n个分组的内容</title>
    <link href="http://example.com/2021/08/28/%E5%8C%B9%E9%85%8D%E7%AC%ACn%E4%B8%AA%E5%88%86%E7%BB%84%E7%9A%84%E5%86%85%E5%AE%B9/"/>
    <id>http://example.com/2021/08/28/%E5%8C%B9%E9%85%8D%E7%AC%ACn%E4%B8%AA%E5%88%86%E7%BB%84%E7%9A%84%E5%86%85%E5%AE%B9/</id>
    <published>2021-08-28T01:22:29.000Z</published>
    <updated>2021-08-28T01:35:00.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1…-9"><a href="#1…-9" class="headerlink" title="\1…\9"></a>\1…\9</h1><p>\1…\9用来匹配与第n(1~9)个分组的内容，必须与()配合使用<br>例：在以下代码段中\2表示匹配第2个分组（一个括号代表一个分组）的内容，即\2匹配”world”字符串</p><pre><code>import restring = &quot;helloworld world&quot;pattern = r&#39;^(\w+)(world) \2$&#39;print(re.search(pattern, string))</code></pre><p><a href="https://www.jianshu.com/p/8a4ce87ef4b2">参考资料</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1…-9&quot;&gt;&lt;a href=&quot;#1…-9&quot; class=&quot;headerlink&quot; title=&quot;\1…\9&quot;&gt;&lt;/a&gt;\1…\9&lt;/h1&gt;&lt;p&gt;\1…\9用来匹配与第n(1~9)个分组的内容，必须与()配合使用&lt;br&gt;例：在以下代码段中\2表示匹配第2个分组（一个</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="re" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/re/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="re" scheme="http://example.com/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>python | re sub的使用方法</title>
    <link href="http://example.com/2021/08/27/re-sub%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2021/08/27/re-sub%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</id>
    <published>2021-08-27T12:20:52.000Z</published>
    <updated>2021-08-27T12:28:57.692Z</updated>
    
    <content type="html"><![CDATA[<h1 id="re-sub的使用方法"><a href="#re-sub的使用方法" class="headerlink" title="re.sub的使用方法"></a>re.sub的使用方法</h1><p>re.sub()实现相对复杂的替换</p><p><a href="https://www.jianshu.com/p/8c1d1a38f9b9">使用方法</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;re-sub的使用方法&quot;&gt;&lt;a href=&quot;#re-sub的使用方法&quot; class=&quot;headerlink&quot; title=&quot;re.sub的使用方法&quot;&gt;&lt;/a&gt;re.sub的使用方法&lt;/h1&gt;&lt;p&gt;re.sub()实现相对复杂的替换&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="re" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/re/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="re" scheme="http://example.com/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>实现strStr方法</title>
    <link href="http://example.com/2021/08/27/%E5%AE%9E%E7%8E%B0strStr%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2021/08/27/%E5%AE%9E%E7%8E%B0strStr%E6%96%B9%E6%B3%95/</id>
    <published>2021-08-27T09:55:12.000Z</published>
    <updated>2021-08-27T10:05:49.936Z</updated>
    
    <content type="html"><![CDATA[<h1 id="28-实现strStr"><a href="#28-实现strStr" class="headerlink" title="28.实现strStr()"></a>28.实现strStr()</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>实现 strStr() 函数。<br>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。<br><a href="https://leetcode-cn.com/problems/implement-strstr/">题目链接</a></p><span id="more"></span><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.直接调用python内置方法<br>2.暴力匹配<br>让字符串 needle 与字符串 haystack 的所有长度为 m（needle字符串的长度） 的子串均匹配一次。<br>为了减少不必要的匹配，我们每次匹配失败即立刻停止当前子串的匹配，对下一个子串继续匹配。如果当前子串匹配成功，我们返回当前子串的开始位置即可。如果所有子串都匹配失败，则返回 −1-1−1。<br><strong style="color:red">3.kmp算法</strong><br>kmp算法的目的：为了避免不必要的指针回溯<br>主串指针i不回溯，模式串指针j的变化取决于模式串的结构是否有重复<br>pi数组值的计算：<br>pi数组的值为最长相同前后缀长度+1(串本身不能作为前后缀)<br>pi[1]=0,其他情况next[]=1.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:    &quot;&quot;&quot;    kmp算法的目的：为了避免不必要的指针回溯    主串指针i不回溯，模式串指针j的变化取决于模式串的结构是否有重复    pi数组值的计算：    pi数组的值为最长相同前后缀长度+1(串本身不能作为前后缀)    pi[1]=0,其他情况next[]=1.    &quot;&quot;&quot;    def strStr(self, haystack: str, needle: str) -&gt; int:        # 获取主串和模式串的长度        n = len(haystack)        m = len(needle)        # 如果模式串的长度为0，则返回0        if m == 0:            return 0        pi = [0]*m        # 求模式串的前缀函数值        i = 1        j = 0        while i &lt; m:            while j &gt; 0 and needle[i] != needle[j]:                j = pi[j-1]  # 回溯            if needle[i] == needle[j]:                j += 1            pi[i] = j            i += 1        print(&quot;模式串的前缀函数值:&quot;, pi)        # kmp        i = 0        j = 0        while i &lt; n:            while j &gt; 0 and haystack[i] != needle[j]:                j = pi[j-1]  # 回溯            if haystack[i] == needle[j]:                j += 1            if j == m:                return i - m + 1            i += 1        return -1    def strStr1(self, haystack: str, needle: str) -&gt; int:        &quot;&quot;&quot;调用内置方法&quot;&quot;&quot;        # 方法1        # return haystack.find(needle)        # 方法2        if not needle:            return 0        try:            return haystack.index(needle)        except ValueError:            return -1    def strStr2(self, haystack: str, needle: str) -&gt; int:        &quot;&quot;&quot;暴力匹配&quot;&quot;&quot;        n = len(haystack)        m = len(needle)        i = 0        while i + m &lt;= n:            flag = True            j = 0            while j &lt; m:                if haystack[i + j] != needle[j]:                    flag = False                    break                j += 1            if flag:                return i            i += 1        return -1if __name__ == &quot;__main__&quot;:    s = Solution()    # print(s.strStr(&quot;mississippi&quot;, &quot;issip&quot;))  # [0, 0, 0, 1, 0]    # print(s.strStr1(&quot;mississippi&quot;, &quot;issip&quot;))  # [0, 0, 0, 1, 0]    print(s.strStr2(&quot;mississippi&quot;, &quot;issip&quot;))  # [0, 0, 0, 1, 0]</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;28-实现strStr&quot;&gt;&lt;a href=&quot;#28-实现strStr&quot; class=&quot;headerlink&quot; title=&quot;28.实现strStr()&quot;&gt;&lt;/a&gt;28.实现strStr()&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;实现 strStr() 函数。&lt;br&gt;给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。&lt;br&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/implement-strstr/&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="字符串" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="kmp算法" scheme="http://example.com/tags/kmp%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 下一个更大元素</title>
    <link href="http://example.com/2021/08/27/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
    <id>http://example.com/2021/08/27/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0/</id>
    <published>2021-08-27T02:06:24.000Z</published>
    <updated>2021-08-27T03:06:31.798Z</updated>
    
    <content type="html"><![CDATA[<h1 id="496-下一个更大元素"><a href="#496-下一个更大元素" class="headerlink" title="496.下一个更大元素"></a>496.下一个更大元素</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。<br>请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。<br>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。<br><a href="https://leetcode-cn.com/problems/next-greater-element-i/">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.暴力解法<br>对于每一个 nums1[i] 中的元素，先在 nums2 中找到它，然后向右遍历找到第 1 个大于 nums1[i] 的元素。<br>2.单调栈<br>步骤：<br>1）使用单调栈先对 nums2 中的每一个元素，求出它的右边第一个更大的元素；<br>2）将上一步的对应关系放入哈希表（HashMap）中；<br>3）再遍历数组 nums1，根据哈希表找出答案。<br>维护单调栈：<br>我们维护的栈恰好保证了单调性：栈中的元素从栈顶到栈底是单调不降的。<br>当我们遇到一个新的元素 nums2[i] 时，我们判断栈顶元素是否小于 nums2[i]，<br>如果是，那么栈顶元素的下一个更大元素即为 nums2[i]，我们将栈顶元素出栈。<br>重复这一操作，直到栈为空或者栈顶元素大于 nums2[i]。此时我们将 nums2[i] 入栈，<br>保持栈的单调性，并对接下来的 nums2[i + 1], nums2[i + 2] … 执行同样的操作。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):    def nextGreaterElement(self, nums1, nums2):        &quot;&quot;&quot;        暴力解法        对于每一个 nums1[i] 中的元素，先在 nums2 中找到它，然后向右遍历找到第 1 个大于 nums1[i] 的元素。        :type nums1: List[int]        :type nums2: List[int]        :rtype: List[int]        &quot;&quot;&quot;        # 使用内置方法list.index()/list.append()        # next_greater_index = []  # 存储下一个更大元素下标的列表        #        # if len(nums1) &lt; 1:        #     return next_greater_index        #        # for num in nums1:  # 遍历nums1中的每一个元素        #     index = nums2.index(num)  # 定位nums1中的元素在nums2中的下标        #     for i in range(index+1, len(nums2)):  # 遍历nums1中元素在nums2中所在位置之后的元素        #         if nums2[i] &gt; num:  # 如果找到比nums1中元素更大的元素，则将下标加入下标列表        #             next_greater_index.append(nums2[i])        #             break        #     else:        #         next_greater_index.append(-1)        #        # return next_greater_index        # 不使用内置方法list.index()/list.append()        len1 = len(nums1)        len2 = len(nums2)        res = list()        if len1 &lt; 1:            return res        for i in range(len1):            cur_val = nums1[i]            j = 0            while j &lt; len2 and nums2[j] != cur_val:                j += 1            # nums2[j] = nums1[i]            j += 1            while j &lt; len2 and nums2[j] &lt; cur_val:                j += 1            if j == len2:                res[i] = -1                continue            res[i] = nums2[j]        return res    def nextGreaterElement1(self, nums1, nums2):        &quot;&quot;&quot;        栈（单调栈）        :type nums1: List[int]        :type nums2: List[int]        :rtype: List[int]        &quot;&quot;&quot;        stack = list()        map = &#123;&#125;        # 对nums2中的每一个元素，求出它的右边第一个更大的元素；        # 将对应关系放入哈希表（HashMap）中        for i in range(len(nums2)):            while len(stack) != 0 and stack[-1] &lt; nums2[i]:                map[stack.pop()] = nums2[i]            stack.append(nums2[i])        # 遍历数组nums1，根据哈希表找出答案        res = list()        for j in range(len(nums1)):            res.append(map.get(nums1[j], -1))        return resif __name__ == &quot;__main__&quot;:    slt = Solution()    res_list = slt.nextGreaterElement1([4, 1, 2], [1, 3, 4, 2])    print(res_list)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;496-下一个更大元素&quot;&gt;&lt;a href=&quot;#496-下一个更大元素&quot; class=&quot;headerlink&quot; title=&quot;496.下一个更大元素&quot;&gt;&lt;/a&gt;496.下一个更大元素&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;</summary>
      
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="栈" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%A0%88/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 删除链表中的节点</title>
    <link href="http://example.com/2021/08/27/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>http://example.com/2021/08/27/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</id>
    <published>2021-08-27T02:06:14.000Z</published>
    <updated>2021-08-27T02:55:12.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="237.删除链表中的节点"></a>237.删除链表中的节点</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。<br><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>由于单链表不能直接访问当前节点的前一个节点，现要删除当前节点，我们可以将当前节点的下一个节点的值复制到当前节点，然后改变当前节点的next指针删除当前节点的下一个节点即可达到删除当前节点的效果。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># Definition for singly-linked list.# class ListNode(object):#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution(object):    def deleteNode(self, node):        &quot;&quot;&quot;        :type node: ListNode        :rtype: void Do not return anything, modify node in-place instead.        &quot;&quot;&quot;        node.val = node.next.val        node.next = node.next.next</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;237-删除链表中的节点&quot;&gt;&lt;a href=&quot;#237-删除链表中的节点&quot; class=&quot;headerlink&quot; title=&quot;237.删除链表中的节点&quot;&gt;&lt;/a&gt;237.删除链表中的节点&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; cla</summary>
      
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="链表" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 回文链表</title>
    <link href="http://example.com/2021/08/27/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2021/08/27/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</id>
    <published>2021-08-27T02:05:58.000Z</published>
    <updated>2021-08-27T03:00:29.155Z</updated>
    
    <content type="html"><![CDATA[<h1 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234.回文链表"></a>234.回文链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。<br><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.按照原链表构建一个反向链表，如果两个链表完全相同则为回文链表<br>2.将原链表中的所有节点的val顺序存储在数组中后使用双指针（array[::] == array[::-1]）<br>3.递归<br>4.快慢指针<br>将链表的后半部分反转，然后将前半部分和后半部分进行比较。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># Definition for singly-linked list.class ListNode(object):    def __init__(self, val=0, next=None):        self.val = val        self.next = nextclass Solution(object):    def isPalindrome(self, head):        &quot;&quot;&quot;        按照原链表构建一个反向链表，如果两个链表完全相同则为回文链表        :type head: ListNode        :rtype: bool        &quot;&quot;&quot;        # p = head        # reversed = ListNode()        # while p is not None:        #     node = ListNode(p.val)        #     node.next = reversed.next        #     reversed.next = node        #        #     p = p.next        #        # p1 = head        # p2 = reversed.next        # while p1 and p2:        #     if p1.val == p2.val:        #         p1 = p1.next        #         p2 = p2.next        #     else:        #         break        # if p1 is None and p2 is None:        #     return True        # else:        #     return False        reversed = self.reverseList(head)        p1 = head        p2 = reversed        while p1 and p2:            if p1.val == p2.val:                p1 = p1.next                p2 = p2.next            else:                break        if p1 is None and p2 is None:            return True        else:            return False    def isPalindrome1(self, head):        &quot;&quot;&quot;        将原链表中的所有节点的val顺序存储在数组中后使用双指针        :type head: ListNode        :rtype: bool        &quot;&quot;&quot;        p = head        vals = []        while p:            vals.append(p.val)            p = p.next        return vals[::] == vals[::-1]    def isPalindrome2(self, head):        &quot;&quot;&quot;        递归法        :type head: ListNode        :rtype: bool        &quot;&quot;&quot;        self.front_pointer = head        def recursively_check(current_node=head):            if current_node is not None:                if not recursively_check(current_node.next):                    return False                if self.front_pointer.val != current_node.val:                    return False                self.front_pointer = self.front_pointer.next            return True        return recursively_check()    def isPalindrome3(self, head):        &quot;&quot;&quot;        快慢指针        将链表的后半部分反转（修改链表结构），然后将前半部分和后半部分进行比较。        :type head: ListNode        :rtype: bool        &quot;&quot;&quot;        if head is None:            return True        # 找到前半部分链表的尾节点并反转后半部分链表        first_half_end = self.end_of_first_half(head)        second_half_start = self.reverseList(first_half_end.next)        # 判断是否回文        result = True        first_position = head        second_position =second_half_start        while result and second_position is not None:            if first_position.val != second_position.val:                result = False            first_position = first_position.next            second_position = second_position.next        # 还原链表并返回结果        first_half_end.next = self.reverseList((second_half_start))        return result    def end_of_first_half(self, head):        fast = head        slow = head        while fast.next is not None and fast.next.next is not None:            fast = fast.next.next            slow = slow.next        return slow    def reverseList(self, head):        &quot;&quot;&quot;        递归法反转链表        :type head: ListNode        :rtype: ListNode        &quot;&quot;&quot;        if not head or not head.next:            return head        new_head = self.reverseList(head.next)        head.next.next = head        head.next = None        return new_head    def create_linked_list(self, list):        &quot;&quot;&quot;根据list中的所有元素构建单链表&quot;&quot;&quot;        l = ListNode()  # 单链表头节点        r = l  # 起始尾指针r指向头节点        for e in list:            node = ListNode(e)            r.next = node            r = r.next        return l.next    def print_linked_list(self, linked_list) -&gt; None:        &quot;&quot;&quot;        打印单链表中的所有元素        :param linked_list: 单链表        :return: 无        &quot;&quot;&quot;        print(&quot;----------------------------------------&quot;)        pointer = linked_list        while pointer is not None:            print(pointer.val)            pointer = pointer.nextif __name__ == &quot;__main__&quot;:    slt = Solution()    linked_list = slt.create_linked_list([1, 2, 2, 1])    slt.print_linked_list(linked_list)    res = slt.isPalindrome3(linked_list)    print(res)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;234-回文链表&quot;&gt;&lt;a href=&quot;#234-回文链表&quot; class=&quot;headerlink&quot; title=&quot;234.回文链表&quot;&gt;&lt;/a&gt;234.回文链表&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="链表" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 用栈实现队列</title>
    <link href="http://example.com/2021/08/27/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>http://example.com/2021/08/27/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</id>
    <published>2021-08-27T02:05:47.000Z</published>
    <updated>2021-08-28T01:47:14.068Z</updated>
    
    <content type="html"><![CDATA[<h1 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232.用栈实现队列"></a>232.用栈实现队列</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：<br>实现 MyQueue 类：<br>    void push(int x) 将元素 x 推到队列的末尾<br>    int pop() 从队列的开头移除并返回元素<br>    int peek() 返回队列开头的元素<br>    boolean empty() 如果队列为空，返回 true ；否则，返回 false<br>说明：<br>    你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。<br>    你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。<br><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用两个栈实现队列，一个栈作为输入栈（入队），一个对作为输出栈（出队/取队头元素）。<br>入队操作的实现：将元素压入输入栈<br>出队操作的实现：弹出输出栈栈顶元素，若输出栈为空，输入栈不为空，则将输入栈所有元素出栈并压入输出栈，接着再弹出输出栈栈顶元素。<br>队列判空：输入栈和输出栈同时为空时队列为空。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class MyQueue(object):    &quot;&quot;&quot;用2个栈实现队列&quot;&quot;&quot;    def __init__(self):        &quot;&quot;&quot;        Initialize your data structure here.        &quot;&quot;&quot;        self.stack1 = list()        self.stack2 = list()    def push(self, x):        &quot;&quot;&quot;        Push element x to the back of queue.        :type x: int        :rtype: None        &quot;&quot;&quot;        self.stack1.append(x)    def pop(self):        &quot;&quot;&quot;        Removes the element from in front of queue and returns that element.        :rtype: int        &quot;&quot;&quot;        if len(self.stack2) != 0:            return self.stack2.pop()        else:            for _ in range(len(self.stack1)):                self.stack2.append(self.stack1.pop())            return self.stack2.pop()    def peek(self):        &quot;&quot;&quot;        Get the front element.        :rtype: int        &quot;&quot;&quot;        if len(self.stack2) != 0:            return self.stack2[-1]        else:            for _ in range(len(self.stack1)):                self.stack2.append(self.stack1.pop())            return self.stack2[-1]    def empty(self):        &quot;&quot;&quot;        Returns whether the queue is empty.        :rtype: bool        &quot;&quot;&quot;        return not self.stack1 and not self.stack2# Your MyQueue object will be instantiated and called as such:# obj = MyQueue()# obj.push(x)# param_2 = obj.pop()# param_3 = obj.peek()# param_4 = obj.empty()if __name__ == &quot;__main__&quot;:    my_queue = MyQueue()    my_queue.push(1)    my_queue.push(2)    print(&quot;当前队头元素为：&#123;&#125;&quot;.format(my_queue.peek()))    print(&quot;当前出队元素为：&#123;&#125;&quot;.format(my_queue.pop()))    print(&quot;当前队列空：&#123;&#125;&quot;.format(&quot;yes&quot; if my_queue.empty() is True else &quot;no&quot;))</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;232-用栈实现队列&quot;&gt;&lt;a href=&quot;#232-用栈实现队列&quot; class=&quot;headerlink&quot; title=&quot;232.用栈实现队列&quot;&gt;&lt;/a&gt;232.用栈实现队列&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;head</summary>
      
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="栈" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%A0%88/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 用两个队列实现栈</title>
    <link href="http://example.com/2021/08/27/%E7%94%A8%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
    <id>http://example.com/2021/08/27/%E7%94%A8%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</id>
    <published>2021-08-27T02:05:35.000Z</published>
    <updated>2021-08-27T02:59:32.417Z</updated>
    
    <content type="html"><![CDATA[<h1 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225.用队列实现栈"></a>225.用队列实现栈</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。<br>实现 MyStack 类：<br>    void push(int x) 将元素 x 压入栈顶。<br>    int pop() 移除并返回栈顶元素。<br>    int top() 返回栈顶元素。<br>    boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。</p><p>注意：<br>    你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。<br>    你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。<br><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>1.使用两个队列实现栈</strong><br>使用两个队列实现栈的操作，其中 queue1 用于存储栈内的元素，queue2 作为入栈操作的辅助队列。<br>入栈操作时，首先将元素入队到 queue2，然后将 queue1 的全部元素依次出队并入队到 queue2，此时 queue2 的前端的元素即为新入栈的元素，再将 queue1 和 queue2 互换，则 queue1 的元素即为栈内的元素，queue1 的前端和后端分别对应栈顶和栈底。<br>由于每次入栈操作都确保 queue1 的前端元素为栈顶元素，因此出栈操作和获得栈顶元素操作都可以简单实现。出栈操作只需要移除 queue1 的前端元素并返回即可，获得栈顶元素操作只需要获得 queue1 的前端元素并返回即可（不移除元素）。<br>由于 queue1 用于存储栈内的元素，判断栈是否为空时，只需要判断 queue1 是否为空即可。<br><strong>2.使用一个队列实现栈</strong><br>使用一个队列时，为了满足栈的特性，即最后入栈的元素最先出栈，同样需要满足队列前端的元素是最后入栈的元素。<br>入栈操作时，首先获得入栈前的元素个数 n，然后将元素入队到队列，再将队列中的前 n 个元素（即除了新入栈的元素之外的全部元素）依次出队并入队到队列，此时队列的前端的元素即为新入栈的元素，且队列的前端和后端分别对应栈顶和栈底。<br>由于每次入栈操作都确保队列的前端元素为栈顶元素，因此出栈操作和获得栈顶元素操作都可以简单实现。出栈操作只需要移除队列的前端元素并返回即可，获得栈顶元素操作只需要获得队列的前端元素并返回即可（不移除元素）。<br>由于队列用于存储栈内的元素，判断栈是否为空时，只需要判断队列是否为空即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>import collectionsclass MyStack(object):    &quot;&quot;&quot;使用两个队列实现栈&quot;&quot;&quot;    def __init__(self):        &quot;&quot;&quot;        Initialize your data structure here.        &quot;&quot;&quot;        self.queue1 = collections.deque()        self.queue2 = collections.deque()    def push(self, x):        &quot;&quot;&quot;        Push element x onto stack.        :type x: int        :rtype: None        &quot;&quot;&quot;        self.queue2.append(x)        while self.queue1:            self.queue2.append(self.queue1.popleft())        self.queue1, self.queue2 = self.queue2, self.queue1    def pop(self):        &quot;&quot;&quot;        Removes the element on top of the stack and returns that element.        :rtype: int        &quot;&quot;&quot;        return self.queue1.popleft()    def top(self):        &quot;&quot;&quot;        Get the top element.        :rtype: int        &quot;&quot;&quot;        return self.queue1[0]    def empty(self):        &quot;&quot;&quot;        Returns whether the stack is empty.        :rtype: bool        &quot;&quot;&quot;        return not self.queue1class MyStack1(object):    &quot;&quot;&quot;使用1个队列实现栈&quot;&quot;&quot;    def __init__(self):        &quot;&quot;&quot;        Initialize your data structure here.        &quot;&quot;&quot;        self.queue = collections.deque()    def push(self, x):        &quot;&quot;&quot;        Push element x onto stack.        :type x: int        :rtype: None        &quot;&quot;&quot;        n = len(self.queue)        self.queue.append(x)        for _ in range(n):            self.queue.append(self.queue.popleft())    def pop(self):        &quot;&quot;&quot;        Removes the element on top of the stack and returns that element.        :rtype: int        &quot;&quot;&quot;        return self.queue.popleft()    def top(self):        &quot;&quot;&quot;        Get the top element.        :rtype: int        &quot;&quot;&quot;        return self.queue[0]    def empty(self):        &quot;&quot;&quot;        Returns whether the stack is empty.        :rtype: bool        &quot;&quot;&quot;        return not self.queue# Your MyStack object will be instantiated and called as such:# obj = MyStack()# obj.push(x)# param_2 = obj.pop()# param_3 = obj.top()# param_4 = obj.empty()if __name__ == &quot;__main__&quot;:    my_stack = MyStack()    my_stack = MyStack1()    my_stack.push(1)    my_stack.push(2)    print(&quot;当前栈顶元素为: &#123;&#125;&quot;.format(my_stack.top()))    print(&quot;当前弹出的元素为: &#123;&#125;&quot;.format(my_stack.pop()))    print(&quot;当前栈空：&#123;&#125;&quot;.format(&quot;yes&quot; if my_stack.empty() is True else &quot;no&quot;))</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;225-用队列实现栈&quot;&gt;&lt;a href=&quot;#225-用队列实现栈&quot; class=&quot;headerlink&quot; title=&quot;225.用队列实现栈&quot;&gt;&lt;/a&gt;225.用队列实现栈&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;head</summary>
      
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="栈" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%A0%88/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 反转链表</title>
    <link href="http://example.com/2021/08/27/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2021/08/27/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2021-08-27T02:05:20.000Z</published>
    <updated>2021-08-27T02:56:21.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。<br><a href="https://leetcode-cn.com/problems/reverse-linked-list/">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.递归<br>递：将大问题分解为小问题，将整个链表依次拆解直到只剩下一个节点<br>归：在链表只剩下一个节点时开始”归“，使用head.next.next = head,head.next = None这两行代码从后往前（从原链表的视角看）将链表中的每一个连接改为反向的<br>2.迭代<br>假设链表为 1→2→3→∅，我们想要把它改成 ∅←1←2←3。<br>在遍历链表时，将当前节点的 next 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。<br>3.头插法<br>首先创建一个只有头节点的反转链表，从头到尾遍历原链表，将每次遍历到的节点按照头插法插入反转链表中，以此类推，当我们遍历完整个链表时就得到一个反转链表。<br>头插法：即每次都将将要插入的节点作为链表的首节点（不是头节点）<br>头插法代码实现：</p><pre><code>node.next = head.nexthead.next = node</code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># Definition for singly-linked list.class ListNode(object):    def __init__(self, val=0, next=None):        self.val = val        self.next = nextclass Solution(object):    def reverseList(self, head):        &quot;&quot;&quot;        迭代法        :type head: ListNode        :rtype: ListNode        &quot;&quot;&quot;        # if not head:        #     return head        #        # p = head        #        # reversed = ListNode()        # while p is not None:        #     node = ListNode(p.val)        #     node.next = reversed.next        #     reversed.next = node        #        #     p = p.next        #        # return reversed.next        prev = None        curr = head        while curr is not None:            next = curr.next            curr.next = prev            prev = curr            curr = next        return prev    def reverseList1(self, head):        &quot;&quot;&quot;        递归法        :type head: ListNode        :rtype: ListNode        &quot;&quot;&quot;        if not head or not head.next:            return head        new_head = self.reverseList1(head.next)        head.next.next = head        head.next = None        return new_head    def reverseList2(self, head):        &quot;&quot;&quot;        头插法        :type head: ListNode        :rtype: ListNode        &quot;&quot;&quot;        if not head:            return head        p = head        reversed = ListNode()        while p is not None:            node = ListNode(p.val)            node.next = reversed.next            reversed.next = node            p = p.next        return reversed.next    def create_linked_list(self, list):        &quot;&quot;&quot;根据list中的所有元素构建单链表&quot;&quot;&quot;        l = ListNode()  # 单链表头节点        r = l  # 起始尾指针r指向头节点        for e in list:            node = ListNode(e)            r.next = node            r = r.next        return l.next    def print_linked_list(self, linked_list) -&gt; None:        &quot;&quot;&quot;        打印单链表中的所有元素        :param linked_list: 单链表        :return: 无        &quot;&quot;&quot;        print(&quot;----------------------------------------&quot;)        pointer = linked_list        while pointer is not None:            print(pointer.val)            pointer = pointer.nextif __name__ == &quot;__main__&quot;:    slt = Solution()    linked_list = slt.create_linked_list([1, 2, 3, 4, 5])    slt.print_linked_list(linked_list)    reversed_linked_list = slt.reverseList1(linked_list)    slt.print_linked_list(reversed_linked_list)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;206-反转链表&quot;&gt;&lt;a href=&quot;#206-反转链表&quot; class=&quot;headerlink&quot; title=&quot;206.反转链表&quot;&gt;&lt;/a&gt;206.反转链表&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="链表" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 删除链表元素</title>
    <link href="http://example.com/2021/08/27/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/"/>
    <id>http://example.com/2021/08/27/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</id>
    <published>2021-08-27T02:05:09.000Z</published>
    <updated>2021-08-27T02:54:26.706Z</updated>
    
    <content type="html"><![CDATA[<h1 id="203-删除链表元素"><a href="#203-删除链表元素" class="headerlink" title="203.删除链表元素"></a>203.删除链表元素</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。<br><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.递归<br>链表的定义具有递归的性质，因此链表题目常可以用递归的方法求解。<br>对于给定的链表，首先对除了头节点 head 以外的节点进行删除操作，然后判断 head 的节点值是否等于给定的 val。如果 head 的节点值等于 val，则 head 需要被删除，因此删除操作后的头节点为 head.next；如果 head 的节点值不等于 val，则 head\ 保留，因此删除操作后的头节点还是 head。<br>递归的终止条件是 head 为空，此时直接返回 head。当 head 不为空时，递归地进行删除操作，然后判断 head 的节点值是否等于 val 并决定是否要删除 head。<br>2.迭代<br>用 temp 表示当前节点。如果 temp 的下一个节点不为空且下一个节点的节点值等于给定的 val，则需要删除下一个节点。删除下一个节点可以通过以下做法实现：<br>temp.next=temp.next.next<br>如果 temp 的下一个节点的节点值不等于给定的 val，则保留下一个节点，将 temp 移动到下一个节点即可。<br>当 temp 的下一个节点为空时，链表遍历结束，此时所有节点值等于 val 的节点都被删除。<br>具体实现方面，由于链表的头节点 head 有可能需要被删除，因此创建哑节点 dummyHead，令 dummyHead.next=head，初始化 temp=dummyHead，然后遍历链表进行删除操作。最终返回 dummyHead.next 即为删除操作后的头节点。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># Definition for singly-linked list.class ListNode(object):    def __init__(self, val=0, next=None):        self.val = val        self.next = nextclass Solution(object):    def removeElements(self, head, val):        &quot;&quot;&quot;        移除单链表head中所有值为val的节点（迭代法）        时间复杂度：O(n)        空间复杂度：O(1)        :type head: ListNode        :type val: int        :rtype: ListNode        &quot;&quot;&quot;        # # 为单链表怎加一个头节点        # head_node = ListNode()        # head_node.next = head        #        # # 定义工作指针p和工作指针的前一个节点指针prev        # prev = head_node  # prev指向头节点        # p = prev.next  # p指向链表的第一个节点        #        # while p is not None:        #     if p.val == val:        #         prev.next = p.next        #         p = p.next        #     else:        #         prev = p        #         p = p.next        #        # return head_node.next        dummyHead = ListNode()        dummyHead.next = head        temp = dummyHead        while temp.next is not None:            if temp.next.val == val:                temp.next = temp.next.next            else:                temp = temp.next        return dummyHead.next    def removeElements1(self, head, val):        &quot;&quot;&quot;        移除单链表head中所有值为val的节点（递归法）        时间复杂度：O(n)        空间复杂度：O(n)        :param head:        :param val:        :return:        &quot;&quot;&quot;        if head is None:            return head        head.next = self.removeElements1(head.next, val)        return head.next if head.val == val else head    def create_linked_list(self, list):        &quot;&quot;&quot;根据list中的所有元素构建单链表&quot;&quot;&quot;        l = ListNode()  # 单链表头节点        r = l  # 起始尾指针r指向头节点        for e in list:            node = ListNode(e)            r.next = node            r = r.next        return l.next    def print_linked_list(self, linked_list) -&gt; None:        &quot;&quot;&quot;        打印单链表中的所有元素        :param linked_list: 单链表        :return: 无        &quot;&quot;&quot;        print(&quot;----------------------------------------&quot;)        pointer = linked_list        while pointer is not None:            print(pointer.val)            pointer = pointer.nextif __name__ == &quot;__main__&quot;:    slt = Solution()    linked_list = slt.create_linked_list([1, 2, 6, 3, 4, 5, 6])    # linked_list = slt.create_linked_list([7, 7, 7, 7])    slt.print_linked_list(linked_list)    deleted_linked_list = slt.removeElements1(linked_list, 6)    slt.print_linked_list(deleted_linked_list)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;203-删除链表元素&quot;&gt;&lt;a href=&quot;#203-删除链表元素&quot; class=&quot;headerlink&quot; title=&quot;203.删除链表元素&quot;&gt;&lt;/a&gt;203.删除链表元素&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;head</summary>
      
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="链表" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 相交链表</title>
    <link href="http://example.com/2021/08/27/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2021/08/27/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</id>
    <published>2021-08-27T02:04:55.000Z</published>
    <updated>2021-08-27T03:05:31.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="160-环形链表"><a href="#160-环形链表" class="headerlink" title="160.环形链表"></a>160.环形链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。<br><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.哈希表<br>判断两个链表是否相交，可以使用哈希集合存储链表节点。<br>首先遍历链表 headA，并将链表 headA 中的每个节点加入哈希集合中。然后遍历链表 headB，对于遍历到的每个节点，判断该节点是否在哈希集合中：<br>    如果当前节点不在哈希集合中，则继续遍历下一个节点；<br>    如果当前节点在哈希集合中，则后面的节点都在哈希集合中，即从当前节点开始的所有节点都在两个链表的相交部分，因此在链表 headB 中遍历到的第一个在哈希集合中的节点就是两个链表相交的节点，返回该节点。<br>如果链表 headB 中的所有节点都不在哈希集合中，则两个链表不相交，返回 null。<br>2.双指针<br>只有当链表 headA 和 headB 都不为空时，两个链表才可能相交。因此首先判断链表 headA 和 headB 是否为空，如果其中至少有一个链表为空，则两个链表一定不相交，返回 null。<br>当链表 headA 和 headB 都不为空时，创建两个指针 pA 和 pB，初始时分别指向两个链表的头节点 headA 和 headB，然后将两个指针依次遍历两个链表的每个节点。具体做法如下：<br>    每步操作需要同时更新指针 pA 和 pB。<br>    如果指针 pA 不为空，则将指针 pA 移到下一个节点；如果指针 pB 不为空，则将指针 pB 移到下一个节点。<br>    如果指针 pA 为空，则将指针 pA 移到链表 headB 的头节点；如果指针 pB 为空，则将指针 pB 移到链表 headA 的头节点。<br>    当指针 pA 和 pB 指向同一个节点或者都为空时，返回它们指向的节点或者 null。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># Definition for singly-linked list.class ListNode(object):    def __init__(self, x):        self.val = x        self.next = Noneclass Solution(object):    def getIntersectionNode(self, headA, headB):        &quot;&quot;&quot;        哈希表        :type head1, head1: ListNode        :rtype: ListNode        &quot;&quot;&quot;        if not headA or not headB:            return None        seen = set()        p1 = headA        p2 = headB        while p1 is not None:            seen.add(p1)            p1 = p1.next        while p2 is not None:            if p2 in seen:                return p2.val            p2 = p2.next        return None    def getIntersectionNode1(self, headA, headB):        &quot;&quot;&quot;        双指针        :param headA:        :param headB:        :return:        &quot;&quot;&quot;        if not headA or not headB:            return None        p_A = headA        p_B = headB        while p_A != p_B:            p_A = headB if p_A is None else p_A.next            p_B = headA if p_B is None else p_B.next        return p_A    def create_linked_list(self):        &quot;&quot;&quot;        创建两个相交的单链表        :return:两个相交但表表的头指针        &quot;&quot;&quot;        a_node1 = ListNode(4)        a_node2 = ListNode(1)        b_node1 = ListNode(5)        b_node2 = ListNode(0)        b_node3 = ListNode(1)        common_node1 = ListNode(8)        common_node2 = ListNode(4)        common_node3 = ListNode(5)        a_node1.next = a_node2        a_node2.next = common_node1        common_node1.next = common_node2        common_node2.next = common_node3        b_node1.next = b_node2        b_node2.next = b_node3        b_node3.next = common_node1        common_node1.next = common_node2        common_node2.next = common_node3        return a_node1, b_node2if __name__ ==&quot;__main__&quot;:    slt = Solution()    head_a, head_b = slt.create_linked_list()    intersected_node = slt.getIntersectionNode1(head_a, head_b)    print(intersected_node.val)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;160-环形链表&quot;&gt;&lt;a href=&quot;#160-环形链表&quot; class=&quot;headerlink&quot; title=&quot;160.环形链表&quot;&gt;&lt;/a&gt;160.环形链表&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="链表" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 最小栈</title>
    <link href="http://example.com/2021/08/27/%E6%9C%80%E5%B0%8F%E6%A0%88/"/>
    <id>http://example.com/2021/08/27/%E6%9C%80%E5%B0%8F%E6%A0%88/</id>
    <published>2021-08-27T02:04:42.000Z</published>
    <updated>2021-08-27T02:52:07.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155.最小栈"></a>155.最小栈</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。<br>    push(x) —— 将元素 x 推入栈中。<br>    pop() —— 删除栈顶的元素。<br>    top() —— 获取栈顶元素。<br>    getMin() —— 检索栈中的最小元素。<br><a href="https://leetcode-cn.com/problems/min-stack/">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>栈的性质：先进后出</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class MinStack(object):    def __init__(self):        &quot;&quot;&quot;        initialize your data structure here.        &quot;&quot;&quot;        self.stack = list()    def push(self, val):        &quot;&quot;&quot;        :type val: int        :rtype: None        &quot;&quot;&quot;        self.stack.append(val)    def pop(self):        &quot;&quot;&quot;        :rtype: None        &quot;&quot;&quot;        if len(self.stack) != 0:            self.stack.pop()    def top(self):        &quot;&quot;&quot;        :rtype: int        &quot;&quot;&quot;        if len(self.stack) != 0:            return self.stack[-1]    def getMin(self):        &quot;&quot;&quot;        :rtype: int        &quot;&quot;&quot;        if len(self.stack) != 0:            return min(self.stack)# Your MinStack object will be instantiated and called as such:# obj = MinStack()# obj.push(val)# obj.pop()# param_3 = obj.top()# param_4 = obj.getMin()import mathclass MinStack1:    &quot;&quot;&quot;辅助栈&quot;&quot;&quot;    def __init__(self):        self.stack = []        self.min_stack = [math.inf]    def push(self, x: int) -&gt; None:        self.stack.append(x)        self.min_stack.append(min(x, self.min_stack[-1]))    def pop(self) -&gt; None:        self.stack.pop()        self.min_stack.pop()    def top(self) -&gt; int:        return self.stack[-1]    def getMin(self) -&gt; int:        return self.min_stack[-1]if __name__ == &quot;__main__&quot;:    # min_stack = MinStack()    min_stack = MinStack1()    min_stack.push(-2)    min_stack.push(0)    min_stack.push(-3)    print(min_stack.getMin())    min_stack.pop()    print(min_stack.top())    print(min_stack.getMin())    print(math.inf)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;155-最小栈&quot;&gt;&lt;a href=&quot;#155-最小栈&quot; class=&quot;headerlink&quot; title=&quot;155.最小栈&quot;&gt;&lt;/a&gt;155.最小栈&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="栈" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%A0%88/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 逆波兰表达式求值</title>
    <link href="http://example.com/2021/08/27/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"/>
    <id>http://example.com/2021/08/27/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</id>
    <published>2021-08-27T02:04:26.000Z</published>
    <updated>2021-08-27T02:51:06.321Z</updated>
    
    <content type="html"><![CDATA[<h1 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150.逆波兰表达式求值"></a>150.逆波兰表达式求值</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>根据 逆波兰表示法，求表达式的值。<br>有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。<br>说明：<br>    整数除法只保留整数部分。<br>    给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p><p>示例 1：<br>输入：tokens = [“2”,”1”,”+”,”3”,”*”]<br>输出：9<br>解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9<br><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.栈<br>遍历逆波兰表达式中的每一个字符，遇到数字则将数字入栈，遇到运算符则将栈顶的两个操作数出栈作此运算符对应的运算，再将运算结果入栈，…，以此类推，直到遍历完整个表达式，栈中剩余的元素就是表达式的结果。<br>2.数组模拟栈<br>对于一个有效的逆波兰表达式，其长度 n 一定是奇数，且操作数的个数一定比运算符的个数多 1 个，即包含 (n+1)/2 个操作数和 (n-1)/2 个运算符。考虑遇到操作数和运算符时，栈内元素个数分别会如何变化：<br>    如果遇到操作数，则将操作数入栈，因此栈内元素增加 1 个；<br>    如果遇到运算符，则将两个操作数出栈，然后将一个新操作数入栈，因此栈内元素先减少 2 个再增加 1 个，结果是栈内元素减少 1 个。<br>由此可以得到操作数和运算符与栈内元素个数变化的关系：遇到操作数时，栈内元素增加 1 个；遇到运算符时，栈内元素减少 1 个。<br>最坏情况下，(n+1)/2 个操作数都在表达式的前面，(n-1)/2 个运算符都在表达式的后面，此时栈内元素最多为 (n+1)/2 个。在其余情况下，栈内元素总是少于 (n+1)/2 个。因此，在任何情况下，栈内元素最多可能有 (n+1)/2 个，将数组的长度定义为 (n+1)/2 即可。<br>具体实现方面，创建数组 stack 模拟栈，数组下标 0 的位置对应栈底，定义 index 表示栈顶元素的下标位置，初始时栈为空，index=−1。当遇到操作数和运算符时，进行如下操作：<br>    如果遇到操作数，则将 index 的值加 111，然后将操作数赋给 stack[index]；<br>    如果遇到运算符，则将 index 的值减 111，此时 stack[index] 和 stack[index+1] 的元素分别是左操作数和右操作数，使用运算符对两个操作数进行运算，将运算得到的新操作数赋给 stack[index]。<br>整个逆波兰表达式遍历完毕之后，栈内只有一个元素，因此 index=0，此时 stack[index] 即为逆波兰表达式的值。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):    def evalRPN(self, tokens):        &quot;&quot;&quot;        使用栈进行表达式求值        :type tokens: List[str]        :rtype: int        &quot;&quot;&quot;        op_to_binary_fn = &#123;            &quot;+&quot;: lambda x, y: x + y,            &#39;-&#39;: lambda x, y: x - y,            &#39;*&#39;: lambda x, y: x * y,            &#39;/&#39;: lambda x, y: int(x / y),        &#125;        stack = list()        for token in tokens:            try:                num = int(token)            except ValueError:                num2 = stack.pop()                num1 = stack.pop()                num = op_to_binary_fn[token](num1, num2)            finally:                stack.append(num)        return stack[0]    def evalRPN1(self, tokens):        &quot;&quot;&quot;        使用数组模拟栈进行表达式求值        :type tokens: List[str]        :rtype: int        &quot;&quot;&quot;        op_to_binary_fn = &#123;            &quot;+&quot;: lambda x, y: x + y,            &#39;-&#39;: lambda x, y: x - y,            &#39;*&#39;: lambda x, y: x * y,            &#39;/&#39;: lambda x, y: int(x / y),        &#125;        n = len(tokens)        stack = [0] * ((n + 1) // 2)        index = -1        for token in tokens:            try:                num = int(token)                index += 1                stack[index] = num            except ValueError:                index -= 1                stack[index] = op_to_binary_fn[token](stack[index], stack[index + 1])        return stack[0]if __name__ == &quot;__main__&quot;:    slt = Solution()    # tokens = [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]    # tokens = [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]    tokens = [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]    print(&quot;表达式的值为：&#123;&#125;&quot;.format(slt.evalRPN1(tokens)))</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;150-逆波兰表达式求值&quot;&gt;&lt;a href=&quot;#150-逆波兰表达式求值&quot; class=&quot;headerlink&quot; title=&quot;150.逆波兰表达式求值&quot;&gt;&lt;/a&gt;150.逆波兰表达式求值&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; cla</summary>
      
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="栈" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%A0%88/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 环形链表</title>
    <link href="http://example.com/2021/08/27/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2021/08/27/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</id>
    <published>2021-08-27T02:04:00.000Z</published>
    <updated>2021-08-27T02:48:55.883Z</updated>
    
    <content type="html"><![CDATA[<h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141.环形链表"></a>141.环形链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个链表，判断链表中是否有环。<br>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。<br>如果链表中存在环，则返回 true 。 否则，返回 false 。<br><a href="https://leetcode-cn.com/problems/linked-list-cycle/">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.哈希表<br>最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。<br>具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。<br>2.快慢指针<br>定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># Definition for singly-linked list.class ListNode(object):    def __init__(self, val=0, next=None):        self.val = val        self.next = nextclass Solution:    def hasCycle(self, head: ListNode) -&gt; bool:        &quot;&quot;&quot;        哈希表        :param head:单链表头节点        :return:True-linked list has cycle/False-linked list has not cycle        &quot;&quot;&quot;        seen = set()        while head:            if head in seen:                return True            seen.add(head)            head = head.next        return False    def hasCycle1(self, head: ListNode) -&gt; bool:        &quot;&quot;&quot;        快慢指针        :param head:单链表头节点        :return:True-linked list has cycle/False-linked list has not cycle        &quot;&quot;&quot;        if not head or not head.next:  # 如果头节点为空，或者链表第一个节点为空，则链表没有环            return False        slow = head        fast = head.next        while slow != fast:            if not fast or not fast.next:                return False            slow = slow.next            fast = fast.next.next        return True    def create_linked_list(self):        node4 = ListNode(-4)        node3 = ListNode(0)        node2 = ListNode(2)        node1 = ListNode(3)        node1.next = node2        node2.next = node3        node3.next = node4        node4.next = node2        return node1    def print_linked_list(self, linked_list) -&gt; None:        &quot;&quot;&quot;        打印单链表中的所有元素        :param linked_list: 单链表        :return: 无        &quot;&quot;&quot;        print(&quot;----------------------------------------&quot;)        pointer = linked_list        while pointer is not None:            print(pointer.val)            pointer = pointer.nextif __name__ == &quot;__main__&quot;:    slt = Solution()    linked_list = slt.create_linked_list()    print(slt.hasCycle1(linked_list))</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;141-环形链表&quot;&gt;&lt;a href=&quot;#141-环形链表&quot; class=&quot;headerlink&quot; title=&quot;141.环形链表&quot;&gt;&lt;/a&gt;141.环形链表&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="链表" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
