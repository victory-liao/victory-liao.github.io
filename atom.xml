<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Victory&#39;s Blog</title>
  
  <subtitle>非淡泊无以明志，非宁静无以致远</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-07-19T08:51:11.958Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>victory-liao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode | 26.删除有序数组中的重复项</title>
    <link href="http://example.com/2022/07/19/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <id>http://example.com/2022/07/19/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</id>
    <published>2022-07-19T08:41:08.000Z</published>
    <updated>2022-07-19T08:51:11.958Z</updated>
    
    <content type="html"><![CDATA[<h1 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26.删除有序数组中的重复项"></a>26.删除有序数组中的重复项</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。<br>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。<br>将最终结果插入 nums 的前 k 个位置后返回 k 。<br>不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p>示例 1：<br>输入：nums = [1,1,2]<br>输出：2, nums = [1,2,_]<br>解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</p><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li><p>双指针<br>（1）如果数组为空，返回0<br>（2）如果数组只有一个元素，返回1<br>（3）如果数组中有超过两个元素，第一个元素肯定不会被删除，所以从第二位位置开始删除重复元素，设置两个指针，一个快指针<br>fast，一个慢指针slow，快指针fast用来遍历数组寻找下一个不重复元素，慢指针slow指向存放下一个不重复元素的位置；每当<br>fast指针遍历到一个新的不重复元素（fast指向的元素不等于fast-1位置的元素），就将该元素复制到慢指针slow执行的位置，<br>同时慢指针slow指向下一个位置，快指针fast继续寻找下一个不重复元素，依次类推。</p><span id="more"></span><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p> class Solution(object):</p><pre><code> def removeDuplicates(self, nums):     &quot;&quot;&quot;     双指针     :type nums: List[int]     :rtype: int     &quot;&quot;&quot;     if not nums:         return 0          n = len(nums)     fast = slow = 1     while fast &lt; n:         if nums[fast] != nums[fast - 1]:             nums[slow] = nums[fast]             slow += 1         fast += 1     return slow </code></pre><p> if <strong>name</strong> == “<strong>main</strong>“:</p><pre><code> slt = Solution() nums = [1, 1, 2] result = slt.removeDuplicates(nums) print(result)</code></pre></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;26-删除有序数组中的重复项&quot;&gt;&lt;a href=&quot;#26-删除有序数组中的重复项&quot; class=&quot;headerlink&quot; title=&quot;26.删除有序数组中的重复项&quot;&gt;&lt;/a&gt;26.删除有序数组中的重复项&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。&lt;br&gt;由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。&lt;br&gt;将最终结果插入 nums 的前 k 个位置后返回 k 。&lt;br&gt;不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;br&gt;输入：nums = [1,1,2]&lt;br&gt;输出：2, nums = [1,2,_]&lt;br&gt;解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/remove-duplicates-from-sorted-array&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;双指针&lt;br&gt;（1）如果数组为空，返回0&lt;br&gt;（2）如果数组只有一个元素，返回1&lt;br&gt;（3）如果数组中有超过两个元素，第一个元素肯定不会被删除，所以从第二位位置开始删除重复元素，设置两个指针，一个快指针&lt;br&gt;fast，一个慢指针slow，快指针fast用来遍历数组寻找下一个不重复元素，慢指针slow指向存放下一个不重复元素的位置；每当&lt;br&gt;fast指针遍历到一个新的不重复元素（fast指向的元素不等于fast-1位置的元素），就将该元素复制到慢指针slow执行的位置，&lt;br&gt;同时慢指针slow指向下一个位置，快指针fast继续寻找下一个不重复元素，依次类推。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="数组" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    <category term="26.删除有序数组中的重复项" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="双指针" scheme="http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 121.买卖股票的最佳时机</title>
    <link href="http://example.com/2022/07/18/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
    <id>http://example.com/2022/07/18/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</id>
    <published>2022-07-19T07:11:24.000Z</published>
    <updated>2022-07-19T07:47:43.441Z</updated>
    
    <content type="html"><![CDATA[<h1 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121.买卖股票的最佳时机"></a>121.买卖股票的最佳时机</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。<br>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。<br>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><p>示例 1：<br>输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</p><p>示例 2：<br>输入：prices = [7,6,4,3,1]<br>输出：0<br>解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</p><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li><p>暴力法</p></li><li><p>一次遍历<br>遍历一遍数组，计算每次 到当天为止 的最小股票价格和最大利润。</p></li></ol><p><strong>3. 动态规划</strong><br>动态规划一般分为一维、二维、多维（使用状态压缩），对应形式为 dp(i)、dp(i)(j)、二进制dp(i)(j)。<br>（1）动态规划做题步骤<br>    明确 dp(i) 应该表示什么（二维情况：dp(i)(j)）；<br>    根据 dp(i)和 dp(i−1) 的关系得出状态转移方程；<br>    确定初始条件，如 dp(0)。<br>（2）本题思路<br>其实方法一的思路不是凭空想象的，而是由动态规划的思想演变而来。这里介绍一维动态规划思想。<br>dp[i] 表示前 i 天的最大利润，因为我们始终要使利润最大化，则：</p><pre><code>dp[i]=max(dp[i−1],prices[i]−minprice)</code></pre><span id="more"></span><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):    def maxProfit(self, prices):        &quot;&quot;&quot;        暴力法(超出时间限制)        :type prices: List[int]        :rtype: int        &quot;&quot;&quot;        # ans = 0        #        # for i in range(0, len(prices)):        #     for j in range(i + 1, len(prices)):        #         ans = max(ans, prices[j] - prices[i])        #        # return ans                if len(prices) &lt; 2:            return 0        result = max([prices[j] - prices[i] for i in range(0, len(prices)) for j in range(i + 1, len(prices))])        return result if result &gt; 0 else 0        def maxProfit1(self, prices):        &quot;&quot;&quot;一次遍历&quot;&quot;&quot;        minprice = max(prices)  # 记录最小的股值        maxprofit = 0  #                # 循环迭代输入的prices，当前价格小于最小的股值时修改minprice，        # 当前获得的利润大于最大的利润时修改maxprofit        for price in prices:            maxprofit = max(price - minprice, maxprofit)            minprice = min(price, minprice)                    return maxprofit        def maxProfit2(self, prices):        &quot;&quot;&quot;动态规划（按照估值最低点列动态规划方程）&quot;&quot;&quot;        maxprofit = 0        dp = [prices[0] for j in range(0, len(prices))]        for i in range(1, len(prices)):            dp[i] = min(dp[i-1], prices[i])            maxprofit = max(maxprofit, prices[i] - dp[i])        return maxprofit        def maxProfit3(self, prices):        &quot;&quot;&quot;动态规划（按照最大利润列动态规划方程）&quot;&quot;&quot;        minprice = prices[0]        dp = [0]*len(prices)                for i in range(0, len(prices)):            minprice = min(minprice, prices[i])            dp[i] = max(dp[i - 1], prices[i] - minprice)                return dp[-1]if __name__ == &quot;__main__&quot;:    slt = Solution()    prices = [7, 1, 5, 3, 6, 4]    # prices = [7, 6, 4, 3, 1]    # profit = slt.maxProfit(prices)    # profit = slt.maxProfit1(prices)    # profit = slt.maxProfit2(prices)    profit = slt.maxProfit3(prices)    print(profit)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;121-买卖股票的最佳时机&quot;&gt;&lt;a href=&quot;#121-买卖股票的最佳时机&quot; class=&quot;headerlink&quot; title=&quot;121.买卖股票的最佳时机&quot;&gt;&lt;/a&gt;121.买卖股票的最佳时机&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。&lt;br&gt;你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。&lt;br&gt;返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;br&gt;输入：[7,1,5,3,6,4]&lt;br&gt;输出：5&lt;br&gt;解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。&lt;br&gt;     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。&lt;/p&gt;
&lt;p&gt;示例 2：&lt;br&gt;输入：prices = [7,6,4,3,1]&lt;br&gt;输出：0&lt;br&gt;解释：在这种情况下, 没有交易完成, 所以最大利润为 0。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/best-time-to-buy-and-sell-stock&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;暴力法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一次遍历&lt;br&gt;遍历一遍数组，计算每次 到当天为止 的最小股票价格和最大利润。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;3. 动态规划&lt;/strong&gt;&lt;br&gt;动态规划一般分为一维、二维、多维（使用状态压缩），对应形式为 dp(i)、dp(i)(j)、二进制dp(i)(j)。&lt;br&gt;（1）动态规划做题步骤&lt;br&gt;    明确 dp(i) 应该表示什么（二维情况：dp(i)(j)）；&lt;br&gt;    根据 dp(i)和 dp(i−1) 的关系得出状态转移方程；&lt;br&gt;    确定初始条件，如 dp(0)。&lt;br&gt;（2）本题思路&lt;br&gt;其实方法一的思路不是凭空想象的，而是由动态规划的思想演变而来。这里介绍一维动态规划思想。&lt;br&gt;dp[i] 表示前 i 天的最大利润，因为我们始终要使利润最大化，则：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dp[i]=max(dp[i−1],prices[i]−minprice)
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="数组" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    <category term="121.买卖股票的最佳时机" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 136.只出现一次的数字</title>
    <link href="http://example.com/2022/07/18/%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://example.com/2022/07/18/%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2022-07-18T12:20:37.000Z</published>
    <updated>2022-07-18T12:25:38.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136.只出现一次的数字"></a>136.只出现一次的数字</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。<br>说明：<br>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p>示例 1:<br>输入: [2,2,1]<br>输出: 1</p><p><a href="https://leetcode.cn/problems/single-number">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>python版本<br>遍历nums数组中的每一个数num，并使用list.count(num)统计num在nums中出现的次数，如果次数为1，返回num。</li><li>java版本<br>遍历nums数组中的每一个数num，使用HashMap记录每个num出现的次数，然后返回出现次数为1的num。<span id="more"></span><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2></li><li>python代码</li></ol><pre><code>class Solution(object):    def singleNumber(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: int        &quot;&quot;&quot;        for num in nums:            if nums.count(num) == 1:                return numif __name__ == &quot;__main__&quot;:    slt = Solution()    nums = [2, 2, 1]    result = slt.singleNumber(nums)    print(result)</code></pre><ol start="2"><li>java代码</li></ol><pre><code>import java.util.*;class Solution &#123;    public int singleNumber(int[] nums) &#123;        Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();        for(int num : nums)&#123;            if(map.get(num) == null)&#123;                map.put(num, 1);            &#125;else&#123;                map.put(num, map.get(num)+1);            &#125;        &#125;                for(int key: map.keySet())&#123;            if(map.get(key)==1)&#123;                return key;            &#125;        &#125;        return -1;    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;136-只出现一次的数字&quot;&gt;&lt;a href=&quot;#136-只出现一次的数字&quot; class=&quot;headerlink&quot; title=&quot;136.只出现一次的数字&quot;&gt;&lt;/a&gt;136.只出现一次的数字&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。&lt;br&gt;说明：&lt;br&gt;你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br&gt;输入: [2,2,1]&lt;br&gt;输出: 1&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/single-number&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;python版本&lt;br&gt;遍历nums数组中的每一个数num，并使用list.count(num)统计num在nums中出现的次数，如果次数为1，返回num。&lt;/li&gt;
&lt;li&gt;java版本&lt;br&gt;遍历nums数组中的每一个数num，使用HashMap记录每个num出现的次数，然后返回出现次数为1的num。&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="数组" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    <category term="136.只出现一次的数字" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 283.移动零</title>
    <link href="http://example.com/2022/07/18/%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
    <id>http://example.com/2022/07/18/%E7%A7%BB%E5%8A%A8%E9%9B%B6/</id>
    <published>2022-07-18T11:50:37.000Z</published>
    <updated>2022-07-18T11:53:33.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283.移动零"></a>283.移动零</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。<br>请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p><p>示例 1:<br>输入: nums = [0,1,0,3,12]<br>输出: [1,3,12,0,0]</p><p><a href="https://leetcode.cn/problems/move-zeroes">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。<br>右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。</p><p>注意到以下性质：<br>（1）左指针左边均为非零数；<br>（2）右指针左边直到左指针处均为零。</p><p>因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。</p><span id="more"></span><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):    def moveZeroes(self, nums):        &quot;&quot;&quot;        双指针        :type nums: List[int]        :rtype: None Do not return anything, modify nums in-place instead.        &quot;&quot;&quot;        n = len(nums)        left = right = 0        while right &lt; n:            if nums[right] != 0:                nums[left], nums[right] = nums[right], nums[left]                left += 1            right += 1if __name__ == &quot;__main__&quot;:    slt = Solution()    nums = [0, 1, 0, 3, 12]    slt.moveZeroes(nums)    print(nums)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;283-移动零&quot;&gt;&lt;a href=&quot;#283-移动零&quot; class=&quot;headerlink&quot; title=&quot;283.移动零&quot;&gt;&lt;/a&gt;283.移动零&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。&lt;br&gt;请注意 ，必须在不复制数组的情况下原地对数组进行操作。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br&gt;输入: nums = [0,1,0,3,12]&lt;br&gt;输出: [1,3,12,0,0]&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/move-zeroes&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。&lt;br&gt;右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。&lt;/p&gt;
&lt;p&gt;注意到以下性质：&lt;br&gt;（1）左指针左边均为非零数；&lt;br&gt;（2）右指针左边直到左指针处均为零。&lt;/p&gt;
&lt;p&gt;因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。&lt;/p&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="数组" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    <category term="283.移动零" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/283-%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 448.找到所有数组中消失的数字</title>
    <link href="http://example.com/2022/07/18/%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://example.com/2022/07/18/%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2022-07-18T09:52:00.000Z</published>
    <updated>2022-07-18T09:55:34.362Z</updated>
    
    <content type="html"><![CDATA[<h1 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="448.找到所有数组中消失的数字"></a>448.找到所有数组中消失的数字</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。</p><p>示例 1：<br>输入：nums = [4,3,2,7,8,2,3,1]<br>输出：[5,6]</p><p><a href="https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>可以通过集合求差集的方式实现<br>set1 = {4,3,2,7,8,2,3,1}<br>set2 = {1,2,3,4,5,6}<br>set2 - set1即为题目所求</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):    def findDisappearedNumbers(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: List[int]        &quot;&quot;&quot;        # 超出时间限制        # result = []        # for i in range(1, len(nums)+1):        #     if i not in nums:        #         result.append(i)        # return result        # 超出时间限制        # return [i for i in range(1, len(nums)+1) if i not in nums]        # 集合求差集        set1 = set(nums)        set2 = set([i for i in range(1, len(nums) + 1)])        return list(set2.difference(set1))if __name__ == &quot;__main__&quot;:    slt = Solution()    nums = [4, 3, 2, 7, 8, 2, 3, 1]    result = slt.findDisappearedNumbers(nums)    print(result)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;448-找到所有数组中消失的数字&quot;&gt;&lt;a href=&quot;#448-找到所有数组中消失的数字&quot; class=&quot;headerlink&quot; title=&quot;448.找到所有数组中消失的数字&quot;&gt;&lt;/a&gt;448.找到所有数组中消失的数字&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="数组" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    <category term="448.找到所有数组中消失的数字" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/448-%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="集合" scheme="http://example.com/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 338.比特位计数</title>
    <link href="http://example.com/2022/07/18/%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/"/>
    <id>http://example.com/2022/07/18/%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/</id>
    <published>2022-07-18T08:05:16.000Z</published>
    <updated>2022-07-18T08:10:55.110Z</updated>
    
    <content type="html"><![CDATA[<h1 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="338.比特位计数"></a>338.比特位计数</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数 n ，对于 0 &lt;= i &lt;= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。</p><p>示例 1：<br>输入：n = 2<br>输出：[0,1,1]<br>解释：<br>0 –&gt; 0<br>1 –&gt; 1<br>2 –&gt; 10</p><p><a href="https://leetcode.cn/problems/counting-bits">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><a href="https://leetcode.cn/problems/counting-bits/solution/python-by-sentiment-wsy3/">我的题解</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):    def countBits(self, n):        &quot;&quot;&quot;        :type n: int        :rtype: List[int]        &quot;&quot;&quot;        # result = []        # for i in range(0, n+1):        #     result.append(bin(i).count(&#39;1&#39;))        # return result        return [bin(i).count(&#39;1&#39;) for i in range(0, n+1)]</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;338-比特位计数&quot;&gt;&lt;a href=&quot;#338-比特位计数&quot; class=&quot;headerlink&quot; title=&quot;338.比特位计数&quot;&gt;&lt;/a&gt;338.比特位计数&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="进制转换" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    
    <category term="338.比特位计数" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/338-%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="进制转换" scheme="http://example.com/tags/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 461.汉明距离</title>
    <link href="http://example.com/2022/07/17/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/"/>
    <id>http://example.com/2022/07/17/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/</id>
    <published>2022-07-18T07:56:55.000Z</published>
    <updated>2022-07-18T08:00:37.372Z</updated>
    
    <content type="html"><![CDATA[<h1 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="461.汉明距离"></a>461.汉明距离</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。<br>给你两个整数 x 和 y，计算并返回它们之间的汉明距离。</p><p>示例 1：<br>输入：x = 1, y = 4<br>输出：2<br>解释：<br>1   (0 0 0 1)<br>4   (0 1 0 0)<br>       ↑   ↑<br>上面的箭头指出了对应二进制位不同的位置。</p><p><a href="https://leetcode.cn/problems/hamming-distance">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><a href="https://leetcode.cn/problems/hamming-distance/solution/pythonyi-xing-gao-ding-by-sentiment-sfk0/">我的题解</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):    def hammingDistance(self, x, y):        &quot;&quot;&quot;        :type x: int        :type y: int        :rtype: int        &quot;&quot;&quot;        return bin(x ^ y).count(&#39;1&#39;)if __name__ == &quot;__main__&quot;:    # # 十进制转二进制：bin(10)    # print(bin(10))    # # 十进制转八进制：oct(10)    # print(oct(10))    # # 十进制转十六进制：hex(10)    # print(hex(10))    #    # # 二进制转十进制：int(&quot;1010&quot;,2)    # print(int(&quot;1010&quot;, 2))    # # 八进制转十进制：int(&quot;0o12&quot;,8)    # print(int(&quot;0o12&quot;, 8))    # # 十六进制转十进制：int(&quot;0xa&quot;,16)    # print(int(&quot;0xa&quot;, 16))        # print(str(bin(1 ^ 4)).count(&#39;1&#39;))    # print(str(bin(3 ^ 1)).count(&#39;1&#39;))        slt = Solution()    result = slt.hammingDistance(1, 4)    print(result)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;461-汉明距离&quot;&gt;&lt;a href=&quot;#461-汉明距离&quot; class=&quot;headerlink&quot; title=&quot;461.汉明距离&quot;&gt;&lt;/a&gt;461.汉明距离&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="进制转换" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    
    <category term="461.汉明距离" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/461-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="进制转换" scheme="http://example.com/tags/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    
    <category term="汉明距离" scheme="http://example.com/tags/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 617.合并二叉树</title>
    <link href="http://example.com/2022/07/17/%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://example.com/2022/07/17/%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2022-07-18T07:21:21.000Z</published>
    <updated>2022-07-18T07:28:55.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617.合并二叉树"></a>617.合并二叉树</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两棵二叉树： root1 和 root2 。<br>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。<br>返回合并后的二叉树。<br>注意: 合并过程必须从两个树的根节点开始。</p><p>示例 1：<br>输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]<br>输出：[3,4,5,5,4,null,7]</p><p><a href="https://leetcode.cn/problems/merge-two-binary-trees">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>深度优先搜索<br>使用深度优先搜索合并两个二叉树。从根节点开始遍历两个二叉树，并将对应的节点进行合并。</li></ol><p>两个二叉树的对应节点可能存在以下三种情况，对于每种情况使用不同的合并方式。<br>（1）如果两个二叉树的对应节点都为空，则合并后的二叉树的对应节点也为空；<br>（2）如果两个二叉树的对应节点只有一个为空，则合并后的二叉树的对应节点为其中的非空节点；<br>（3）如果两个二叉树的对应节点都不为空，则合并后的二叉树的对应节点的值为两个二叉树的对应节点的值之和，此时需要显性合并两个节点。<br>对一个节点进行合并之后，还要对该节点的左右子树分别进行合并。这是一个递归的过程。<br>2. 广度优先搜索<br>使用广度优先搜索合并两个二叉树。首先判断两个二叉树是否为空，如果两个二叉树都为空，则合并后的二叉树也为空，如果只有一个二叉树为空，则合并后的二叉树为另一个非空的二叉树。</p><p>如果两个二叉树都不为空，则首先计算合并后的根节点的值，然后从合并后的二叉树与两个原始二叉树的根节点开始广度优先搜索，从根节点开始同时遍历每个二叉树，并将对应的节点进行合并。</p><p>使用三个队列分别存储合并后的二叉树的节点以及两个原始二叉树的节点。初始时将每个二叉树的根节点分别加入相应的队列。每次从每个队列中取出一个节点，判断两个原始二叉树的节点的左右子节点是否为空。如果两个原始二叉树的当前节点中至少有一个节点的左子节点不为空，则合并后的二叉树的对应节点的左子节点也不为空。对于右子节点同理。</p><p>如果合并后的二叉树的左子节点不为空，则需要根据两个原始二叉树的左子节点计算合并后的二叉树的左子节点以及整个左子树。考虑以下两种情况：<br>（1）如果两个原始二叉树的左子节点都不为空，则合并后的二叉树的左子节点的值为两个原始二叉树的左子节点的值之和，在创建合并后的二叉树的左子节点之后，将每个二叉树中的左子节点都加入相应的队列；<br>（2）如果两个原始二叉树的左子节点有一个为空，即有一个原始二叉树的左子树为空，则合并后的二叉树的左子树即为另一个原始二叉树的左子树，此时也不需要对非空左子树继续遍历，因此不需要将左子节点加入队列。<br>对于右子节点和右子树，处理方法与左子节点和左子树相同。</p><span id="more"></span><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class TreeNode(object):  # Definition for a binary tree node.    def __init__(self, val=0, left=None, right=None):        self.val = val        self.left = left        self.right = right                class Solution(object):    def mergeTrees(self, root1, root2):        &quot;&quot;&quot;        深度优先搜索        :type root1: TreeNode        :type root2: TreeNode        :rtype: TreeNode        &quot;&quot;&quot;        if not root1:            return root2        if not root2:            return root1        merged = TreeNode(root1.val + root2.val)        merged.left = self.mergeTrees(root1.left, root2.left)        merged.right = self.mergeTrees(root1.right, root2.right)        return merged        def mergeTrees1(self, root1, root2):        &quot;&quot;&quot;广度优先搜索&quot;&quot;&quot;        import collections        if not root1:            return root2        if not root2:            return root1                merged = TreeNode(root1.val + root2.val)        queue = collections.deque([merged])        queue1 = collections.deque([root1])        queue2 = collections.deque([root2])                while queue1 and queue2:            node = queue.popleft()            node1 = queue1.popleft()            node2 = queue2.popleft()            left1, right1 = node1.left, node1.right            left2, right2 = node2.left, node2.right                        if left1 and left2:                left = TreeNode(left1.val + left2.val)                node.left = left                queue.append(left)                queue1.append(left1)                queue2.append(left2)            elif left1:                node.left = left1            elif left2:                node.left = left2                        if right1 and right2:                right = TreeNode(right1.val + right2.val)                node.right = right                queue.append(right)                queue1.append(right1)                queue2.append(right2)            elif right1:                node.right = right1            elif right2:                node.right = right2        return merged        def preorder_traverse(self, root):        if not root:            return        print(root.val, end=&quot; &quot;)        self.preorder_traverse(root.left)        self.preorder_traverse(root.right)                if __name__ == &quot;__main__&quot;:    slt = Solution()        root1 = TreeNode(1)    node12 = TreeNode(3)    node13 = TreeNode(2)    node14 = TreeNode(5)    root1.left = node12    root1.right = node13    node12.left = node14        print(&quot;root1:&quot;, end=&quot;[&quot;)    slt.preorder_traverse(root1)    print(&quot;]&quot;)        root2 = TreeNode(2)    node22 = TreeNode(1)    node23 = TreeNode(3)    node24 = TreeNode(4)    node25 = TreeNode(7)    root2.left = node22    root2.right = node23    node22.right = node24    node23.right = node25        print(&quot;root2:&quot;, end=&quot;[&quot;)    slt.preorder_traverse(root2)    print(&quot;]&quot;)        # merged_tree = slt.mergeTrees(root1, root2)    merged_tree = slt.mergeTrees1(root1, root2)        print(&quot;merger tree:&quot;, end=&quot;[&quot;)    slt.preorder_traverse(merged_tree)    print(&quot;]&quot;)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;617-合并二叉树&quot;&gt;&lt;a href=&quot;#617-合并二叉树&quot; class=&quot;headerlink&quot; title=&quot;617.合并二叉树&quot;&gt;&lt;/a&gt;617.合并二叉树&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你两棵二叉树： root1 和 root2 。&lt;br&gt;想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。&lt;br&gt;返回合并后的二叉树。&lt;br&gt;注意: 合并过程必须从两个树的根节点开始。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;br&gt;输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]&lt;br&gt;输出：[3,4,5,5,4,null,7]&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/merge-two-binary-trees&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;深度优先搜索&lt;br&gt;使用深度优先搜索合并两个二叉树。从根节点开始遍历两个二叉树，并将对应的节点进行合并。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;两个二叉树的对应节点可能存在以下三种情况，对于每种情况使用不同的合并方式。&lt;br&gt;（1）如果两个二叉树的对应节点都为空，则合并后的二叉树的对应节点也为空；&lt;br&gt;（2）如果两个二叉树的对应节点只有一个为空，则合并后的二叉树的对应节点为其中的非空节点；&lt;br&gt;（3）如果两个二叉树的对应节点都不为空，则合并后的二叉树的对应节点的值为两个二叉树的对应节点的值之和，此时需要显性合并两个节点。&lt;br&gt;对一个节点进行合并之后，还要对该节点的左右子树分别进行合并。这是一个递归的过程。&lt;br&gt;2. 广度优先搜索&lt;br&gt;使用广度优先搜索合并两个二叉树。首先判断两个二叉树是否为空，如果两个二叉树都为空，则合并后的二叉树也为空，如果只有一个二叉树为空，则合并后的二叉树为另一个非空的二叉树。&lt;/p&gt;
&lt;p&gt;如果两个二叉树都不为空，则首先计算合并后的根节点的值，然后从合并后的二叉树与两个原始二叉树的根节点开始广度优先搜索，从根节点开始同时遍历每个二叉树，并将对应的节点进行合并。&lt;/p&gt;
&lt;p&gt;使用三个队列分别存储合并后的二叉树的节点以及两个原始二叉树的节点。初始时将每个二叉树的根节点分别加入相应的队列。每次从每个队列中取出一个节点，判断两个原始二叉树的节点的左右子节点是否为空。如果两个原始二叉树的当前节点中至少有一个节点的左子节点不为空，则合并后的二叉树的对应节点的左子节点也不为空。对于右子节点同理。&lt;/p&gt;
&lt;p&gt;如果合并后的二叉树的左子节点不为空，则需要根据两个原始二叉树的左子节点计算合并后的二叉树的左子节点以及整个左子树。考虑以下两种情况：&lt;br&gt;（1）如果两个原始二叉树的左子节点都不为空，则合并后的二叉树的左子节点的值为两个原始二叉树的左子节点的值之和，在创建合并后的二叉树的左子节点之后，将每个二叉树中的左子节点都加入相应的队列；&lt;br&gt;（2）如果两个原始二叉树的左子节点有一个为空，即有一个原始二叉树的左子树为空，则合并后的二叉树的左子树即为另一个原始二叉树的左子树，此时也不需要对非空左子树继续遍历，因此不需要将左子节点加入队列。&lt;br&gt;对于右子节点和右子树，处理方法与左子节点和左子树相同。&lt;/p&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%A0%91/"/>
    
    <category term="617.合并二叉树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%A0%91/617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 543.二叉树的直径</title>
    <link href="http://example.com/2022/07/16/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
    <id>http://example.com/2022/07/16/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</id>
    <published>2022-07-17T03:09:43.000Z</published>
    <updated>2022-07-17T03:22:45.902Z</updated>
    
    <content type="html"><![CDATA[<h1 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543.二叉树的直径"></a>543.二叉树的直径</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><p>示例 :<br>给定二叉树</p><pre><code>      1     / \    2   3   / \       4   5    </code></pre><p>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。<br>注意：两结点之间的路径长度是以它们之间边的数目表示。</p><p><a href="https://leetcode.cn/problems/diameter-of-binary-tree">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>深度优先搜索<br>首先我们知道<strong>一条路径的长度为该路径经过的节点数减一，所以求直径（即求路径长度的最大值）等效于求路径经过节点数的最大值减一</strong>。<br>而任意一条路径均可以被看作由某个节点为起点，从其左儿子和右儿子向下遍历的路径拼接得到。</li></ol><p>假设我们知道对于该节点的左儿子向下遍历经过最多的节点数 LLL （即以左儿子为根的子树的深度） 和其右儿子向下遍历经过最多的节点数 RRR （即以右儿子为根的子树的深度），那么以该节点为起点的路径经过节点数的最大值即为 L+R+1L+R+1L+R+1 。<br>我们记节点 node 为起点的路径经过节点数的最大值为 dnode​ ，那么二叉树的直径就是所有节点 dnode​的最大值减一。</p><p>算法流程为：我们定义一个递归函数 depth(node) 计算 dnode​，函数返回该节点为根的子树的深度。先递归调用左儿子和右儿子求得它们为根的子树的深度 L 和 R ，则该节点为根的子树的深度即为<br>max(L,R)+1，该节点的 dnode​值为 L+R+1，递归搜索每个节点并设一个全局变量 ans 记录 dnode​的最大值，最后返回 ans-1 即为树的直径。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class TreeNode(object):  # Definition for a binary tree node.    def __init__(self, val=0, left=None, right=None):        self.val = val        self.left = left        self.right = rightclass Solution(object):    def diameterOfBinaryTree(self, root):        &quot;&quot;&quot;        这种解法路径必须经过根节点，由题目可知路径可能穿过        也可能不穿过根节点，故此解法不符合题意        :type root: TreeNode        :rtype: int        &quot;&quot;&quot;        left = self.get_depth(root.left)        right = self.get_depth(root.right)        return left + right        def get_depth(self, root):        if not root:            return 0        left_depth = self.get_depth(root.left)        right_depth = self.get_depth(root.right)        return max(left_depth, right_depth) + 1        def diameterOfBinaryTree1(self, root):        self.ans = 1        def depth(node):            if not node:                return 0            L = depth(node.left)            R = depth(node.right)            self.ans = max(self.ans, L + R + 1)            return max(L, R) + 1        depth(root)        return self.ans - 1  # 一条路径的长度为该路径经过的节点数减一if __name__ == &quot;__main__&quot;:    slt = Solution()    root = TreeNode(1)    node2 = TreeNode(2)    node3 = TreeNode(3)    node4 = TreeNode(4)    node5 = TreeNode(5)    root.left = node2    root.right = node3    node2.left = node4    node2.right = node5    # diameter = slt.diameterOfBinaryTree(root)    diameter = slt.diameterOfBinaryTree1(root)    print(&quot;diameter:&quot;, diameter)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;543-二叉树的直径&quot;&gt;&lt;a href=&quot;#543-二叉树的直径&quot; class=&quot;headerlink&quot; title=&quot;543.二叉树的直径&quot;&gt;&lt;/a&gt;543.二叉树的直径&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;head</summary>
      
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%A0%91/"/>
    
    <category term="543.二叉树的直径" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%A0%91/543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 226.翻转二叉树</title>
    <link href="http://example.com/2022/07/16/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://example.com/2022/07/16/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2022-07-16T13:47:31.000Z</published>
    <updated>2022-07-16T13:54:40.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226.翻转二叉树"></a>226.翻转二叉树</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</p><p>示例 1：<br>输入：root = [4,2,7,1,3,6,9]<br>输出：[4,7,2,9,6,3,1]</p><p><a href="https://leetcode.cn/problems/invert-binary-tree">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>递归法<br>分析题目输入和输出发现，输出的左右子树的位置跟输入正好是相反的，于是我们可以递归的交换左右子树来实现。<br>其实就是交换一下左右节点，然后再递归的交换左节点，右节点<br>递归的两个条件如下：<br> 终止条件：当前节点为 null 时返回<br> 交换当前节点的左右节点，再递归的交换当前节点的左节点，递归的交换当前节点的右节点时间复杂度：每个元素都必须访问一次，所以是 O(n)<br>空间复杂度：最坏的情况下，需要存放 O(h) 个函数调用(h是树的高度)，所以是 O(h)<span id="more"></span></li><li>迭代法<br>递归实现也就是深度优先遍历的方式，那么对应的就是广度优先遍历。<br>广度优先遍历需要额外的数据结构–队列，来存放临时遍历到的元素。</li></ol><p>我们需要先将根节点放入到队列中，然后不断的迭代队列中的元素。<br>对当前元素调换其左右子树的位置，然后：<br>    判断其左子树是否为空，不为空就放入队列中<br>    判断其右子树是否为空，不为空就放入队列中</p><p>时间复杂度：同样每个节点都需要入队列/出队列一次，所以是 O(n)<br>空间复杂度：最坏的情况下会包含所有的叶子节点，完全二叉树叶子节点是 n/2个，所以时间复杂度是 0(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class TreeNode(object):  # Definition for a binary tree node.    def __init__(self, val=0, left=None, right=None):        self.val = val        self.left = left        self.right = rightclass Solution(object):    def invertTree(self, root):        &quot;&quot;&quot;        递归法（深度优先遍历方式）        :type root: TreeNode        :rtype: TreeNode        &quot;&quot;&quot;        if not root:            return root                left = self.invertTree(root.left)        right = self.invertTree(root.right)        root.left, root.right = right, left        return root        def invertTree1(self, root):        &quot;&quot;&quot;迭代法（广度优先遍历方式，需要辅助队列）&quot;&quot;&quot;        if not root:            return root        # 将二叉树的节点逐层放入队列中，再迭代处理队列中的元素        queue = [root]        while queue:            # 每次都从队列中拿一个节点，并交换这个节点的左右子树            tmp = queue.pop(0)            tmp.left, tmp.right = tmp.right, tmp.left            # 如果当前节点的左子树不空，则放入队列等待后续处理            if tmp.left:                queue.append(tmp.left)            if tmp.right:                queue.append(tmp.right)        return root        def preorder_traverse(self, root):        if not root:            return        print(root.val)        self.preorder_traverse(root.left)        self.preorder_traverse(root.right)if __name__ == &quot;__main__&quot;:    root = TreeNode(4)    node2 = TreeNode(2)    node3 = TreeNode(7)    node4 = TreeNode(1)    node5 = TreeNode(3)    node6 = TreeNode(6)    node7 = TreeNode(9)    root.left = node2    root.right = node3    node2.left = node4    node2.right = node5    node3.left = node6    node3.right = node7        slt = Solution()    # invertTree = slt.invertTree(root)    invertTree = slt.invertTree1(root)    slt.preorder_traverse(invertTree)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;226-翻转二叉树&quot;&gt;&lt;a href=&quot;#226-翻转二叉树&quot; class=&quot;headerlink&quot; title=&quot;226.翻转二叉树&quot;&gt;&lt;/a&gt;226.翻转二叉树&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;br&gt;输入：root = [4,2,7,1,3,6,9]&lt;br&gt;输出：[4,7,2,9,6,3,1]&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/invert-binary-tree&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;递归法&lt;br&gt;分析题目输入和输出发现，输出的左右子树的位置跟输入正好是相反的，于是我们可以递归的交换左右子树来实现。&lt;br&gt;其实就是交换一下左右节点，然后再递归的交换左节点，右节点&lt;br&gt;递归的两个条件如下：&lt;br&gt; 终止条件：当前节点为 null 时返回&lt;br&gt; 交换当前节点的左右节点，再递归的交换当前节点的左节点，递归的交换当前节点的右节点时间复杂度：每个元素都必须访问一次，所以是 O(n)&lt;br&gt;空间复杂度：最坏的情况下，需要存放 O(h) 个函数调用(h是树的高度)，所以是 O(h)&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%A0%91/"/>
    
    <category term="226.翻转二叉树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%A0%91/226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 101.对称二叉树</title>
    <link href="http://example.com/2022/07/16/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://example.com/2022/07/16/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2022-07-16T10:36:02.000Z</published>
    <updated>2022-07-16T10:38:13.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101.对称二叉树"></a>101.对称二叉树</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个二叉树的根节点 root ， 检查它是否轴对称。</p><p><a href="https://leetcode.cn/problems/symmetric-tree/">题目链接</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># Definition for a binary tree node.class TreeNode(object):    def __init__(self, val=0, left=None, right=None):        self.val = val        self.left = left        self.right = rightclass Solution(object):    def isSymmetric(self, root):        &quot;&quot;&quot;        递归法                两个树互为镜像：            它们的两个根结点具有相同的值            每个树的右子树都与另一个树的左子树镜像对称        :type root: TreeNode        :rtype: bool        &quot;&quot;&quot;        return self.check(root, root)        def check(self, p, q):        if not p and not q:            return True        if not p or not q:            return False        return p.val == q.val and self.check(p.left, q.right) and self.check(p.right, q.left)        def isSymmetric1(self, root):        &quot;&quot;&quot;迭代法&quot;&quot;&quot;        queue = list()        queue.append(root)        queue.append(root)        while len(queue) != 0:            t1 = queue.pop(0)            t2 = queue.pop(0)            if not t1 and not t2:                continue            if not t1 or not t2:                return False            if t1.val != t2.val:                return False            queue.append(t1.left)            queue.append(t2.right)            queue.append(t1.right)            queue.append(t2.left)        return Trueif __name__ == &quot;__main__&quot;:    root = TreeNode(1)    node2 = TreeNode(2)    node3 = TreeNode(2)    node4 = TreeNode(3)    node5 = TreeNode(4)    node6 = TreeNode(4)    node7 = TreeNode(3)        slt = Solution()    # result = slt.isSymmetric(root)    result = slt.isSymmetric(root)    print(result)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;101-对称二叉树&quot;&gt;&lt;a href=&quot;#101-对称二叉树&quot; class=&quot;headerlink&quot; title=&quot;101.对称二叉树&quot;&gt;&lt;/a&gt;101.对称二叉树&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%A0%91/"/>
    
    <category term="101.对称二叉树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%A0%91/101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 53.最大子数组和</title>
    <link href="http://example.com/2022/07/16/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/"/>
    <id>http://example.com/2022/07/16/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</id>
    <published>2022-07-16T09:28:28.000Z</published>
    <updated>2022-07-16T09:57:03.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53.最大子数组和"></a>53.最大子数组和</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>子数组 是数组中的一个连续部分。</p><p>示例 1：<br>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6<br>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</p><p><a href="https://leetcode.cn/problems/maximum-subarray/">题目链接</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):    def maxSubArray(self, nums):        &quot;&quot;&quot;        动态规划                用f(i)代表以第i个数结尾的连续子数组的最大和，那么我们的目标就是求                            max&#123;f(i)&#125;,0&lt;=i&lt;=n-1        如何求 f(i) 呢？        我们可以考虑 nums[i] 单独成为一段还是加入 f(i−1)对应的那一段，这取决于 nums[i] 和 f(i−1)+nums[i] 的大小，        我们希望获得一个比较大的，于是可以写出这样的动态规划转移方程：                            f(i)=max&#123;f(i-1)+nums[i], nums[i]&#125;        :type nums: List[int]        :rtype: int        &quot;&quot;&quot;        # pre = 0        # maxAns = nums[0]        # for x in nums:        #     pre = max(pre + x, x)        #     maxAns = max(maxAns, pre)        # return maxAns                fi_array = [nums[0]]        for i in range(1, len(nums)):            fi_array.append(max(fi_array[i-1]+nums[i], nums[i]))        return max(fi_array)        def maxSubArray1(self, nums):        &quot;&quot;&quot;        动态规划                若前一个元素大于0，则将其加到当前元素上        &quot;&quot;&quot;        for i in range(1, len(nums)):            # 若前一个元素大于0，则将其加到当前元素上            if nums[i - 1] &gt; 0:                nums[i] += nums[i-1]        return max(nums)  # 返回修改过的数组中的最大值            def maxSubArray2(self, nums):        &quot;&quot;&quot;        贪心算法                # 若当前指针所指元素之前的和小于0，则丢弃当前元素之前的数列        &quot;&quot;&quot;        if not nums:  # 设置边界条件（列表为空）            return -2147483648        cur_sum = max_sum = nums[0]  # 当前和和最大和设置为列表第一个元素        for i in range(1, len(nums)):            # 若当前指针所指元素之前的和小于0，则丢弃当前元素之前的数列            cur_sum = max(nums[i], cur_sum+nums[i])                        # 将当前和与最大和作比较，取最大            max_sum = max(cur_sum, max_sum)                return max_sumif __name__ == &quot;__main__&quot;:    slt = Solution()    nums = list([-2, 1, -3, 4, -1, 2, 1, -5, 4])    res = slt.maxSubArray(nums)    # res = slt.maxSubArray1(nums)    print(res)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;53-最大子数组和&quot;&gt;&lt;a href=&quot;#53-最大子数组和&quot; class=&quot;headerlink&quot; title=&quot;53.最大子数组和&quot;&gt;&lt;/a&gt;53.最大子数组和&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="数组" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    <category term="53.最大子数组和" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>appium | 手机App自动化测试</title>
    <link href="http://example.com/2022/07/15/Appium%E6%89%8B%E6%9C%BAApp%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    <id>http://example.com/2022/07/15/Appium%E6%89%8B%E6%9C%BAApp%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</id>
    <published>2022-07-15T12:54:33.000Z</published>
    <updated>2022-07-16T01:46:27.722Z</updated>
    
    <content type="html"><![CDATA[<h1 id="appium手机App自动化测试"><a href="#appium手机App自动化测试" class="headerlink" title="appium手机App自动化测试"></a>appium手机App自动化测试</h1><h2 id="手机App自动化测试环境搭建"><a href="#手机App自动化测试环境搭建" class="headerlink" title="手机App自动化测试环境搭建"></a>手机App自动化测试环境搭建</h2><ol><li>安装appium client编程库</li></ol><pre><code>pip install appium-python-client</code></pre><ol start="2"><li>安装Appium Server<br>下载链接链接：<a href="https://pan.baidu.com/s/19C9fGmoXne8DgfXhrTB2TQ">https://pan.baidu.com/s/19C9fGmoXne8DgfXhrTB2TQ</a><br>提取码：kgwb</li><li>安装JDK<br>下载链接同上。<br>安装好之后，需要添加环境变量JAVA_HOME，例如：</li></ol><pre><code>JAVA_HOME   d:\tools\java\jdk1.8.0_211(jdk安装目录)</code></pre><ol start="4"><li><p>安装Android SDK<br>下载链接同上。<br>下载Android SDK文件包：androidsdk.zip，并解压。<br>解压完成后添加环境变量ANDROID_HOME，例如：</p><span id="more"></span><p> ANDROID_HOME d:\tools\androidsdk(sdk包解压目录)<br>另外，还需要配置环境变量PATH，加入 adb所在目录， d:\tools\androidsdk\platform-tools\</p></li><li><p>连接手机<br>上述的软件环境都准备好以后，要自动化手机APP，需要：<br> 在你运行程序的电脑上 用 USB线 连接上 你的安卓手机<br> 进入 手机设置 -&gt; 关于手机 ，不断点击 版本号 菜单（7次以上），<br> 退出到上级菜单，在开发者模式中，启动USB调试，打开USB安装，打开USB调试（安全设置），如下所示：<br><img src="/2022/07/15/Appium%E6%89%8B%E6%9C%BAApp%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/2.jpg"><br>如果手机连接USB线后，手机界面弹出 类似 如下提示。<br><img src="/2022/07/15/Appium%E6%89%8B%E6%9C%BAApp%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/1.png"><br>选择 允许USB调试。</p></li></ol><p>连接好以后，打开命令行窗口， 执行 adb devices -l 命令来列出连接在电脑上的安卓设备。<br>如果输出 类似如下的内容：</p><pre><code>List of devices attached4d0035dc767a50bb        device product:t03gxx model:GT_N7100 device:t03g</code></pre><p>表示电脑上可以查看到 连接的设备，就可以运行自动化程序了。<br>6. 测试手机app案例<br>下面是一段使用 Appium 自动化的打开 B站 应用，搜索 白月黑羽 发布的教程视频，并且打印视频标题的示例。<br><strong>代码：</strong></p><pre><code>from appium import webdriverfrom selenium.webdriver.common.by import Byfrom appium.webdriver.extensions.android.nativekey import AndroidKeydesired_caps = &#123;    &#39;platformName&#39;: &#39;Android&#39;,  # 被测手机是安卓    &#39;platformVersion&#39;: &#39;12&#39;,  # 手机安卓版本    &#39;deviceName&#39;: &#39;xxx&#39;,  # 设备名，安卓手机可以随意填写    &#39;appPackage&#39;: &#39;tv.danmaku.bili&#39;,  # 启动APP Package名称    &#39;appActivity&#39;: &#39;.MainActivityV2&#39;,  # 启动Activity名称    &#39;unicodeKeyboard&#39;: True,  # 使用自带输入法，输入中文时填True    &#39;resetKeyboard&#39;: True,  # 执行完程序恢复原来输入法    &#39;noReset&#39;: True,  # 不要重置App    &#39;newCommandTimeout&#39;: 6000,    &#39;automationName&#39;: &#39;UiAutomator2&#39;    # &#39;app&#39;: r&#39;d:\apk\bili.apk&#39;,&#125;# 连接Appium Server，初始化自动化环境driver = webdriver.Remote(&#39;http://localhost:4723/wd/hub&#39;, desired_caps)# 设置缺省等待时间driver.implicitly_wait(5)# 如果有`青少年保护`界面，点击`我知道了`iknow = driver.find_elements(By.ID, &quot;text3&quot;)if iknow:    iknow.click()# 根据id定位搜索位置框，点击driver.find_element(By.ID, &#39;expand_search&#39;).click()# 根据id定位搜索输入框，点击sbox = driver.find_element(By.ID, &#39;search_src_text&#39;)sbox.send_keys(&#39;白月黑羽&#39;)# 输入回车键，确定搜索driver.press_keycode(AndroidKey.ENTER)# 选择（定位）所有视频标题eles = driver.find_elements(By.ID, &#39;title&#39;)for ele in eles:    # 打印标题    print(ele.text)input(&#39;**** Press to quit..&#39;)driver.quit()</code></pre><ol start="7"><li>报错解决办法<br>（1）WebDriverException</li></ol><pre><code>selenium.common.exceptions.WebDriverException: Message: An unknown server-side error occurred while processing the command. Original error: Neither ANDROID_HOME nor ANDROID_SDK_ROOT environment variable was exported. Read https://developer.android.com/studio/command-line/variables for more details</code></pre><p>报错原因：未添加ANDROID_HOME<br>解决办法：在环境变量中添加ANDROID_HOME，值为androidsdk的解压目录/安装目录<br>（2）</p><pre><code>Error: Activity used to start app doesn’t exist or cannot ve launched!</code></pre><p>报错原因：desired_caps中的appPackage,appActivtity设置不正确<br>解决办法：手机端打开app –&gt; win+r –&gt; cmd –&gt; 输入adb shell dumpsys activity activities | findstr mResume获取app包名和活动名称<br>例如，打开微信，输入命令后显示如下信息：</p><pre><code>mResumedActivity: ActivityRecord&#123;66ff017 u0 com.tencent.mm/.ui.LauncherUI t6167&#125;</code></pre><p>将appPackage设置为com.tencent.mm,将appActivity设置为.ui.LauncherUI</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;appium手机App自动化测试&quot;&gt;&lt;a href=&quot;#appium手机App自动化测试&quot; class=&quot;headerlink&quot; title=&quot;appium手机App自动化测试&quot;&gt;&lt;/a&gt;appium手机App自动化测试&lt;/h1&gt;&lt;h2 id=&quot;手机App自动化测试环境搭建&quot;&gt;&lt;a href=&quot;#手机App自动化测试环境搭建&quot; class=&quot;headerlink&quot; title=&quot;手机App自动化测试环境搭建&quot;&gt;&lt;/a&gt;手机App自动化测试环境搭建&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;安装appium client编程库&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;pip install appium-python-client
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;安装Appium Server&lt;br&gt;下载链接链接：&lt;a href=&quot;https://pan.baidu.com/s/19C9fGmoXne8DgfXhrTB2TQ&quot;&gt;https://pan.baidu.com/s/19C9fGmoXne8DgfXhrTB2TQ&lt;/a&gt;&lt;br&gt;提取码：kgwb&lt;/li&gt;
&lt;li&gt;安装JDK&lt;br&gt;下载链接同上。&lt;br&gt;安装好之后，需要添加环境变量JAVA_HOME，例如：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;JAVA_HOME   d:\tools\java\jdk1.8.0_211(jdk安装目录)
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;&lt;p&gt;安装Android SDK&lt;br&gt;下载链接同上。&lt;br&gt;下载Android SDK文件包：androidsdk.zip，并解压。&lt;br&gt;解压完成后添加环境变量ANDROID_HOME，例如：&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="自动化测试" scheme="http://example.com/categories/python/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    <category term="appium" scheme="http://example.com/categories/python/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/appium/"/>
    
    <category term="appium手机App自动化测试" scheme="http://example.com/categories/python/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/appium/appium%E6%89%8B%E6%9C%BAApp%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="appium" scheme="http://example.com/tags/appium/"/>
    
    <category term="手机App自动化测试" scheme="http://example.com/tags/%E6%89%8B%E6%9C%BAApp%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>selenium | pyhon+selenium测试WebTours网站登录注册功能</title>
    <link href="http://example.com/2022/07/14/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    <id>http://example.com/2022/07/14/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</id>
    <published>2022-07-15T03:30:30.000Z</published>
    <updated>2022-07-15T12:54:54.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pyhon-selenium测试WebTours网站登录注册功能"><a href="#pyhon-selenium测试WebTours网站登录注册功能" class="headerlink" title="pyhon+selenium测试WebTours网站登录注册功能"></a>pyhon+selenium测试WebTours网站登录注册功能</h1><h2 id="Web-Tours下载、安装"><a href="#Web-Tours下载、安装" class="headerlink" title="Web Tours下载、安装"></a>Web Tours下载、安装</h2><p><a href="https://blog.csdn.net/weixin_45129277/article/details/114013243">WebTours下载、安装</a></p><h2 id="安装selenium"><a href="#安装selenium" class="headerlink" title="安装selenium"></a>安装selenium</h2><p>在终端输入以下命令安装selenium:</p><pre><code>pip install selenium</code></pre><h2 id="测试注册功能"><a href="#测试注册功能" class="headerlink" title="测试注册功能"></a>测试注册功能</h2><p><strong>user.txt</strong></p><pre><code>name1 1name2 2name3 3</code></pre><p>注：本示例使用Firfox浏览器进行测试<br><strong>代码：</strong></p><pre><code>from selenium import webdriverfrom time import sleepfile = open(&quot;user.txt&quot;, &quot;r&quot;)for line in file:    username = line.split()[0]    password = line.split()[1]    # 注册    driver = webdriver.Firefox()    driver.get(&quot;http://localhost:1080/webtours&quot;)    driver.switch_to_default_content()    driver.switch_to_frame(&quot;body&quot;)    driver.switch_to_frame(&quot;info&quot;)    # driver.find_element_by_link_text(&quot;sign up now&quot;).click()    driver.find_element_by_partial_link_text(&quot;sign up&quot;).click()    sleep(3)    driver.switch_to_default_content()    driver.switch_to_frame(&quot;body&quot;)    driver.switch_to_frame(&quot;info&quot;)    driver.find_element_by_name(&quot;username&quot;).send_keys(username)    driver.find_element_by_name(&quot;password&quot;).send_keys(password)    driver.find_element_by_name(&quot;passwordConfirm&quot;).send_keys(password)    driver.find_element_by_name(&quot;register&quot;).click()    sleep(3)    driver.switch_to_default_content()    driver.switch_to_frame(&quot;body&quot;)    driver.switch_to_frame(&quot;info&quot;)    expect = &quot;Thank you, &quot; + username    actual = driver.find_element_by_tag_name(&quot;body&quot;).text    if expect in actual:        print(&quot;测试通过&quot;)    else:        print(&quot;测试失败&quot;)driver.quit()</code></pre><h2 id="测试登录、订票功能"><a href="#测试登录、订票功能" class="headerlink" title="测试登录、订票功能"></a>测试登录、订票功能</h2><pre><code>from selenium import webdriverfrom time import sleepfrom selenium.webdriver.support.select import Selectdriver = webdriver.Firefox()driver.get(&quot;http://localhost:1080/webtours&quot;)sleep(3)driver.switch_to_default_content()driver.switch_to_frame(&quot;body&quot;)driver.switch_to_frame(&quot;info&quot;)actual = driver.find_element_by_tag_name(&quot;body&quot;).textif &quot;Welcome to the Web Tours site&quot; in actual:    print(&quot;打开网站成功&quot;)else:    print(&quot;打开网站失败&quot;)driver.switch_to_default_content()driver.switch_to_frame(&quot;body&quot;)driver.switch_to_frame(&quot;navbar&quot;)driver.find_element_by_name(&quot;username&quot;).send_keys(&quot;jojo&quot;)driver.find_element_by_name(&quot;password&quot;).send_keys(&quot;bean&quot;)driver.find_element_by_name(&quot;login&quot;).click()sleep(3)driver.switch_to_default_content()driver.switch_to_frame(&quot;body&quot;)driver.switch_to_frame(&quot;info&quot;)actual = driver.find_element_by_tag_name(&quot;body&quot;).textif &quot;Welcome, jojo&quot; in actual:    print(&quot;登录成功&quot;)else:    print(&quot;登录失败&quot;)sleep(3)driver.switch_to_default_content()driver.switch_to_frame(&quot;body&quot;)driver.switch_to_frame(&quot;navbar&quot;)driver.find_element_by_xpath(&quot;//img[@alt=&#39;Search Flights Button&#39;]&quot;).click()sleep(3)driver.switch_to_default_content()driver.switch_to_frame(&quot;body&quot;)driver.switch_to_frame(&quot;info&quot;)Select(driver.find_element_by_name(&quot;depart&quot;)).select_by_visible_text(&quot;Denver&quot;)Select(driver.find_element_by_name(&quot;arrive&quot;)).select_by_visible_text(&quot;London&quot;)driver.find_element_by_name(&quot;findFlights&quot;).click()sleep(3)driver.switch_to_default_content()driver.switch_to_frame(&quot;body&quot;)driver.switch_to_frame(&quot;info&quot;)driver.find_elements_by_name(&quot;outboundFlight&quot;)[1].click()driver.find_element_by_name(&quot;reserveFlights&quot;).click()sleep(1)driver.switch_to_default_content()driver.switch_to_frame(&quot;body&quot;)driver.switch_to_frame(&quot;info&quot;)driver.find_element_by_name(&quot;buyFlights&quot;).click()sleep(1)driver.switch_to_default_content()driver.switch_to_frame(&quot;body&quot;)driver.switch_to_frame(&quot;info&quot;)actual = driver.find_element_by_tag_name(&quot;body&quot;).textif &quot;Thank you for booking through Web Tours.&quot; in actual:    print(&quot;订票成功&quot;)else:    print(&quot;订票失败&quot;)sleep(3)driver.switch_to_default_content()driver.switch_to_frame(&quot;body&quot;)driver.switch_to_frame(&quot;info&quot;)driver.find_element_by_name(&quot;Book Another&quot;).click()sleep(1)driver.switch_to_default_content()driver.switch_to_frame(&quot;body&quot;)driver.switch_to_frame(&quot;navbar&quot;)driver.find_element_by_xpath(&quot;//img[@alt=&#39;SignOff Button&#39;]&quot;).click()driver.switch_to_default_content()driver.switch_to_frame(&quot;body&quot;)driver.switch_to_frame(&quot;info&quot;)actual = driver.find_element_by_tag_name(&quot;body&quot;).textif &quot;Welcome to the Web Tours site&quot; in actual:    print(&quot;注销成功&quot;)else:    print(&quot;注销失败&quot;)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;pyhon-selenium测试WebTours网站登录注册功能&quot;&gt;&lt;a href=&quot;#pyhon-selenium测试WebTours网站登录注册功能&quot; class=&quot;headerlink&quot; title=&quot;pyhon+selenium测试WebTours网站登录</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="自动化测试" scheme="http://example.com/categories/python/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    <category term="selenium" scheme="http://example.com/categories/python/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/selenium/"/>
    
    <category term="pyhon+selenium测试webtours网站登录注册功能" scheme="http://example.com/categories/python/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/selenium/pyhon-selenium%E6%B5%8B%E8%AF%95webtours%E7%BD%91%E7%AB%99%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="自动化测试" scheme="http://example.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    <category term="selenium" scheme="http://example.com/tags/selenium/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 104.二叉树的最大深度</title>
    <link href="http://example.com/2022/07/12/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
    <id>http://example.com/2022/07/12/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</id>
    <published>2022-07-12T10:07:30.000Z</published>
    <updated>2022-07-12T10:11:33.961Z</updated>
    
    <content type="html"><![CDATA[<h1 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104.二叉树的最大深度"></a>104.二叉树的最大深度</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，找出其最大深度。<br>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>说明: 叶子节点是指没有子节点的节点。<br>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>方法一：深度优先搜索<br>首先可以想到使用深度优先搜索的方法，遍历整棵树，记录最小深度。<br>对于每一个非叶子节点，我们只需要分别计算其左右子树的最大叶子节点深度。这样就将一个大问题转化为了小问题，可以递归地解决该问题。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># class TreeNode(object):  # Definition for a binary tree node.#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution(object):    def maxDepth(self, root):        &quot;&quot;&quot;        :type root: TreeNode        :rtype: int        &quot;&quot;&quot;        def get_depth(root):            if not root:                return 0            left_depth = get_depth(root.left)            right_depth = get_depth(root.right)            return max(right_depth, left_depth) + 1        return get_depth(root)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;104-二叉树的最大深度&quot;&gt;&lt;a href=&quot;#104-二叉树的最大深度&quot; class=&quot;headerlink&quot; title=&quot;104.二叉树的最大深度&quot;&gt;&lt;/a&gt;104.二叉树的最大深度&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; cla</summary>
      
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%A0%91/"/>
    
    <category term="104.二叉树的最大深度" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%A0%91/104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 102.二叉树的层序遍历</title>
    <link href="http://example.com/2022/07/11/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://example.com/2022/07/11/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2022-07-12T07:58:32.000Z</published>
    <updated>2022-07-12T08:33:33.294Z</updated>
    
    <content type="html"><![CDATA[<h1 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102.二叉树的层序遍历"></a>102.二叉树的层序遍历</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。<br><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">题目链接</a></p><span id="more"></span><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li><p>递归法<br>根据题目要求，我们需要遍历二叉树，并将相同层次的节点归入同一个数组；</p><pre><code> 可以通过传入辅助的level参数决定层次，就可以将同一level的放入同一数组。</code></pre></li><li><p>迭代法（使用队列）<br>使用队列进行实现，弹出当前层节点的同时，依次加入下一层节点；由于队列先进先出的特性，当前层的节点会被先访问。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h1 id="Definition-for-a-binary-tree-node"><a href="#Definition-for-a-binary-tree-node" class="headerlink" title="Definition for a binary tree node."></a>Definition for a binary tree node.</h1><p> class TreeNode(object):</p><pre><code> def __init__(self, val=0, left=None, right=None):     self.val = val     self.left = left     self.right = right</code></pre><p> class Queue(object):</p><pre><code> &quot;&quot;&quot;实现一个队列&quot;&quot;&quot;  def __init__(self):     self.__list = []  def enqueue(self, elem):     &quot;&quot;&quot;入队&quot;&quot;&quot;     self.__list.append(elem)  def dequeue(self):     &quot;&quot;&quot;出队&quot;&quot;&quot;     return self.__list.pop(0)  def is_empty(self):     return not self.__list  def size(self):     &quot;&quot;&quot;队列的大小&quot;&quot;&quot;     return len(self.__list)</code></pre><p> class Solution(object):</p><pre><code> def levelOrder(self, root):     &quot;&quot;&quot;使用队列对树进行层序遍历，无返回值&quot;&quot;&quot;     if not root:         return     queue = Queue()     queue.enqueue(root)     while queue.size() != 0:         node = queue.dequeue()         print(node.val)         if node.left is not None:             queue.enqueue(node.left)         if node.right is not None:             queue.enqueue(node.right)  def levelOrder1(self, root):     &quot;&quot;&quot;     递归法          根据题目要求，我们需要遍历二叉树，并将相同层次的节点归入同一个数组；     可以通过传入辅助的level参数决定层次，就可以将同一level的放入同一数组。     &quot;&quot;&quot;     def helper(node, level):         if len(levels) == level:  # 每一层都需要创建一个数组             levels.append([])                  levels[level].append(node.val)  # 向对应层的数组中加入节点                  # 递归，层次+1         if node.left is not None:             helper(node.left, level + 1)         if node.right is not None:             helper(node.right, level + 1)          levels = []     if root is None:         return levels     helper(root, 0)     return levels  def levelOrder2(self, root):     &quot;&quot;&quot;     迭代法          使用队列进行实现，弹出当前层节点的同时，依次加入下一层节点；由于队列先进先出的特性，当前层的节点会被先访问。     &quot;&quot;&quot;     answer = []     level = []     dummy = TreeNode(1001)     queue = Queue()          if not root:         return answer          queue.enqueue(root)     queue.enqueue(dummy)          while not queue.is_empty():         current = queue.dequeue()         if current == dummy:             answer.append(level)             level = list()             if not queue.is_empty():                 queue.enqueue(dummy)         else:             level.append(current.val)             if current.left is not None:                 queue.enqueue(current.left)             if current.right is not None:                 queue.enqueue(current.right)          return answer</code></pre><p> if <strong>name</strong> == “<strong>main</strong>“:</p><pre><code> # create the binary tree root = TreeNode(3) node2 = TreeNode(9) node3 = TreeNode(20) node4 = TreeNode(15) node5 = TreeNode(7) root.left = node2 root.right = node3 node3.left = node4 node3.right = node5  slt = Solution() # slt.levelOrder(root) # res = slt.levelOrder1(root) res = slt.levelOrder2(root) print(res)</code></pre></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;102-二叉树的层序遍历&quot;&gt;&lt;a href=&quot;#102-二叉树的层序遍历&quot; class=&quot;headerlink&quot; title=&quot;102.二叉树的层序遍历&quot;&gt;&lt;/a&gt;102.二叉树的层序遍历&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。&lt;br&gt;&lt;a href=&quot;https://leetcode.cn/problems/binary-tree-level-order-traversal/&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%A0%91/"/>
    
    <category term="102.二叉树的层序遍历" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%A0%91/102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="层序遍历" scheme="http://example.com/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>pyqrcode | 生成二维码</title>
    <link href="http://example.com/2022/07/09/%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    <id>http://example.com/2022/07/09/%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81/</id>
    <published>2022-07-10T03:12:23.000Z</published>
    <updated>2022-07-10T08:02:50.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生成二维码"><a href="#生成二维码" class="headerlink" title="生成二维码"></a>生成二维码</h1><p><strong>代码：</strong></p><pre><code>import pyqrcode  # pip install pyqrcodeimport png  # pip install pypnglink = &quot;https://victory-liao.github.io/&quot;qrCode = pyqrcode.create(link)qrCode.png(&quot;my blog.png&quot;, scale=10)</code></pre><p><strong>结果：</strong><br><img src="/2022/07/09/%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81/1.png"><br><strong>注：如果要生成其他链接的二维码，只需要替换link变量中的值！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;生成二维码&quot;&gt;&lt;a href=&quot;#生成二维码&quot; class=&quot;headerlink&quot; title=&quot;生成二维码&quot;&gt;&lt;/a&gt;生成二维码&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import pyqrcode  # pip</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="pyqrcode" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pyqrcode/"/>
    
    
    <category term="二维码" scheme="http://example.com/tags/%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    
    <category term="pyqrcode" scheme="http://example.com/tags/pyqrcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 9.回文数</title>
    <link href="http://example.com/2022/07/09/%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <id>http://example.com/2022/07/09/%E5%9B%9E%E6%96%87%E6%95%B0/</id>
    <published>2022-07-10T02:38:18.000Z</published>
    <updated>2022-07-10T02:50:10.240Z</updated>
    
    <content type="html"><![CDATA[<h1 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9.回文数"></a>9.回文数</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。<br>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。<br>例如，121 是回文，而 123 不是。<br><a href="https://leetcode.cn/problems/palindrome-number">题目链接</a></p><span id="more"></span><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.使用栈判断是否回文<br>先将每位数字依次入栈，再将栈中的所有数字依次出栈，如果入栈的数字序列与出战的数字序列相同，则该数为回文数。<br>2.将整数x转化为字符串<br>将整数x转化为字符串，将字符串反转，如果原字符串与反转字符串相等，则该数为回文数。<br>3.反转一半数字<br>反转后一半数字，并将其与前半部分数字进行比较，如果二者相同，则该数为回文数。<br>如何知道反转数字的位数已经达到原始数字位数的一半？当原始数字小于或等于反转后的数字时，就意味着我们已经处理了<br>一半位数的数字了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):    def isPalindrome2(self, x):        &quot;&quot;&quot;        使用栈实现回文                先将每位数字依次入栈，再将栈中的所有数字依次出栈，如果入栈的数字序列与出战的数字序列相同，则该数为回文数。        &quot;&quot;&quot;        if x &lt; 0:  # 负数肯定不是回文数            return False        xCopy = x        stack = list()        while x != 0:            stack.append(x % 10)            x = x // 10                    stack = stack[::-1]  # 从个位数开始取每位数字比较方便，但是入栈的数字序列与原数字序列相反，故反转栈                revertedNumber = 0        while stack:            revertedNumber = revertedNumber * 10 + stack.pop()                if xCopy == revertedNumber:            return True        else:            return False        def isPalindrome1(self, x):        x = str(x)        return x == x[::-1]        def isPalindrome(self, x):        &quot;&quot;&quot;        特殊情况：        1.当x&lt;0时，x不是回文数        2.如果数字的最后一位是0，为了使该数字为回文，则          其第一位数字也应该是0，只有0满足        &quot;&quot;&quot;        if x &lt; 0 or (x % 10 == 0 and x != 0):            return False                revertedNumber = 0        while x &gt; revertedNumber:            revertedNumber = (revertedNumber * 10) + (x % 10)            x //= 10                    # 当数字长度为奇数时，我们可以通过revertedNumber/10去除位于中位的数字。        # 例如，当输入为12321时，在while循环末尾我们可以得到x=12，revertedNumber=123,        # 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。        return x == revertedNumber or x == revertedNumber // 10    if __name__ == &quot;__main__&quot;:    slt = Solution()    # res = slt.isPalindrome(12321)    # res = slt.isPalindrome1(12321)    res = slt.isPalindrome2(12321)    print(&quot;是回文数&quot; if res else &quot;不是回文数&quot;)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;9-回文数&quot;&gt;&lt;a href=&quot;#9-回文数&quot; class=&quot;headerlink&quot; title=&quot;9.回文数&quot;&gt;&lt;/a&gt;9.回文数&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。&lt;br&gt;回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。&lt;br&gt;例如，121 是回文，而 123 不是。&lt;br&gt;&lt;a href=&quot;https://leetcode.cn/problems/palindrome-number&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="回文" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E5%9B%9E%E6%96%87/"/>
    
    <category term="9.回文数" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E5%9B%9E%E6%96%87/9-%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="回文数" scheme="http://example.com/tags/%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 70.爬楼梯</title>
    <link href="http://example.com/2022/07/09/%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <id>http://example.com/2022/07/09/%E7%88%AC%E6%A5%BC%E6%A2%AF/</id>
    <published>2022-07-09T13:40:07.000Z</published>
    <updated>2022-07-09T13:59:59.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br><a href="https://leetcode.cn/problems/climbing-stairs/">题目链接</a></p><span id="more"></span><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>f(n) = f(n-1) + f(n-2)</strong></p><ol><li><p>递归法<br>由f(1)=1,f(2)=2,f(3)=3,…,以此类推,f(n)=f(n-1)+f(n-2),使用递归法实现该问题，递归方程为f(n)=f(n-1)+f(n-2),<br>递归出口为f(1)=1,f(2)=2。</p></li><li><p>记忆化递归法<br>使用数组记录了每次计算的结果，避免递归法中的重复计算。</p></li><li><p>动态规划<br>动态规划转移方程：f(n)=f(n-1)+f(n-2)<br>边界条件：f(1)=1,f(2)=2</p></li><li><p>滚动数组<br>使用长度为3的数组实现爬楼梯问题，问题中涉及三个状态:状态1、状态2、状态3，每次更新状态时，先将状态2移动到状态1<br>的位置，再把状态3移动到状态2的位置，即将状态数组整体向前滚动一位。<br>例：<br>|1|2|3|—&gt;|2|3|5|</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p> class Solution(object):</p><pre><code> def climbStairs(self, n):     &quot;&quot;&quot;     递归法     :type n: int     :rtype: int     &quot;&quot;&quot;     if n == 1:         return 1     if n == 2:         return 2     return self.climbStairs(n - 1) + self.climbStairs(n - 2)  def climbStairs2(self, n):     &quot;&quot;&quot;     记忆化递归法     :type n: int     :rtype: int     &quot;&quot;&quot;     memo = []     return self.climbStairsMemo(n, memo)  def climbStairsMemo(self, n, memo):     if memo[n] &gt; 0:         return memo[n]     if n == 1:         memo[n] = 1     elif n == 2:         memo[n] = 2     else:         memo[n] = self.climbStairsMemo(n - 1, memo) + self.climbStairsMemo(n - 2, memo)     return memo[n]  def climbStairs3(self, n):     &quot;&quot;&quot;     动态规划     :type n: int     :rtype: int     &quot;&quot;&quot;     if n == 1:         return 1     dp = [1, 2]     for i in range(2, n):         dp.append(dp[i-1]+dp[i-2])  # dp[i] = dp[i-1] + dp[i-2]     return dp[n-1]  def climbStairs4(self, n):     &quot;&quot;&quot;     滚动数组（斐波那契数列）     :type n: int     :rtype: int     &quot;&quot;&quot;     if n == 1:         return 1     first = 1     second = 2     for i in range(2, n):         third = first + second         first = second         second = third     return second     </code></pre><p> if <strong>name</strong> == “<strong>main</strong>“:</p><pre><code> slt = Solution() # numberOfSolutions = slt.climbStairs(2) # numberOfSolutions = slt.climbStairs2(2) # numberOfSolutions = slt.climbStairs3(2) numberOfSolutions = slt.climbStairs4(4) print(numberOfSolutions)</code></pre></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;70-爬楼梯&quot;&gt;&lt;a href=&quot;#70-爬楼梯&quot; class=&quot;headerlink&quot; title=&quot;70.爬楼梯&quot;&gt;&lt;/a&gt;70.爬楼梯&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;假设你正在爬楼梯。需要 n 阶你才能到达楼顶。&lt;br&gt;每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;br&gt;&lt;a href=&quot;https://leetcode.cn/problems/climbing-stairs/&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="动态规划" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="70.爬楼梯" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/70-%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 19.删除链表中的倒数第N个节点</title>
    <link href="http://example.com/2022/07/09/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>http://example.com/2022/07/09/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</id>
    <published>2022-07-09T12:32:37.000Z</published>
    <updated>2022-07-17T03:35:05.144Z</updated>
    
    <content type="html"><![CDATA[<h1 id="19-删除链表中的倒数第N个节点"><a href="#19-删除链表中的倒数第N个节点" class="headerlink" title="19. 删除链表中的倒数第N个节点"></a>19. 删除链表中的倒数第N个节点</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li><p>计算链表长度<br>删除链表的倒数第 n 个结点操作就等价于删除正数第L-n+1个节点，L为链表的长度</p></li><li><p>栈<br>遍历链表的同时将所有节点依次入栈，根据栈 先进后出 的原则，弹出栈的第n个节点就是需要删除的节点，并且弹出<br>第n个节点后的栈顶节点为待删除节点的前驱节点。</p><span id="more"></span><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p> class ListNode(object):</p><pre><code> def __init__(self, val=0, next=None):     self.val = val     self.next = next</code></pre><p> class Solution(object):</p><pre><code> def removeNthFromEnd(self, linkedList, n):     &quot;&quot;&quot;     计算链表长度     :type head: ListNode     :type n: int     :rtype: ListNode     &quot;&quot;&quot;     dummy = ListNode(0, linkedList)     length = self.lenOfLinkedList(dummy)     print(length)     cur = dummy     for i in range(1, length - n):         cur = cur.next     cur.next = cur.next.next     return dummy.next  def removeNthFromEnd2(self, head, n):     &quot;&quot;&quot;栈&quot;&quot;&quot;     stack = list()     cur = head     while cur:         stack.append(cur)         cur = cur.next     for i in range(n):         stack.pop()              prev = stack[-1]     prev.next = prev.next.next     return head  def removeNthFromEnd3(self, head, n):     &quot;&quot;&quot;双指针&quot;&quot;&quot;     dummy = ListNode(0, head)     first = head     second = dummy     for i in range(n):         first = first.next          while first:         first = first.next         second = second.next          second.next = second.next.next     return dummy.next  def lenOfLinkedList(self, head):     if not head:         return 0     p = head     count = 0     while p is not None:         count += 1         p = p.next     return count  def createLinkedList(self, list):     head = r = ListNode(list[0])     for num in list[1:]:         node = ListNode(num)         r.next = node         r = node          return head  def traverseLinkedList(self, head):     if not head:         return     p = head     while p is not None:         print(p.val, end=&quot; &quot;)         p = p.next     print(&quot;&quot;)</code></pre><p> if <strong>name</strong> == “<strong>main</strong>“:</p><pre><code> slt = Solution() linkedList = slt.createLinkedList([1, 2, 3, 4, 5]) print(&quot;linked list:&quot;, end=&quot;&quot;) slt.traverseLinkedList(linkedList) length = slt.lenOfLinkedList(linkedList) print(&quot;length of linked list:&quot;, length) # newLinkedList = slt.removeNthFromEnd(linkedList, 2) # newLinkedList = slt.removeNthFromEnd2(linkedList, 2) newLinkedList = slt.removeNthFromEnd3(linkedList, 2) print(&quot;linked list after deleting the reversed n-th node:&quot;, end=&quot;&quot;) slt.traverseLinkedList(newLinkedList)</code></pre></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;19-删除链表中的倒数第N个节点&quot;&gt;&lt;a href=&quot;#19-删除链表中的倒数第N个节点&quot; class=&quot;headerlink&quot; title=&quot;19. 删除链表中的倒数第N个节点&quot;&gt;&lt;/a&gt;19. 删除链表中的倒数第N个节点&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/remove-nth-node-from-end-of-list/&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;计算链表长度&lt;br&gt;删除链表的倒数第 n 个结点操作就等价于删除正数第L-n+1个节点，L为链表的长度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;栈&lt;br&gt;遍历链表的同时将所有节点依次入栈，根据栈 先进后出 的原则，弹出栈的第n个节点就是需要删除的节点，并且弹出&lt;br&gt;第n个节点后的栈顶节点为待删除节点的前驱节点。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="链表" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="19.删除链表中的倒数第N个节点" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E9%93%BE%E8%A1%A8/19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
</feed>
