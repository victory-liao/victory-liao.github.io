<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Victory&#39;s Blog</title>
  
  <subtitle>非淡泊无以明志，非宁静无以致远</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-06-23T03:52:48.796Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>victory-liao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM | JDK监控和故障处理常用工具总结</title>
    <link href="http://example.com/2022/06/22/JDK%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2022/06/22/JDK%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/</id>
    <published>2022-06-23T03:03:09.000Z</published>
    <updated>2022-06-23T03:52:48.796Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK监控和故障处理常用工具总结"><a href="#JDK监控和故障处理常用工具总结" class="headerlink" title="JDK监控和故障处理常用工具总结"></a>JDK监控和故障处理常用工具总结</h1><ol><li>jps<br>JVM Process Status Tool,用于查看所有Java进程的启动类、传入参数和Java虚拟机参数等信息。</li><li>jstat<br>JVM Statistics Monitoring Tool,用于收集HotSpot虚拟机各方面的运行数据。</li><li>jinfo<br>Configuration Info for Java,显示虚拟机配置信息。</li><li>jmap<br>Memory Map for Java,生成虚拟机的内存转储快照（heapdump文件）、</li><li>jhat<br>JVM Heap Analysis Tool,用于分析堆转储快照，它会建立一个HTTP/Web服务器，让用户可以在浏览器上查看分析结果。</li><li>jstack<br>Stack Trace for Java,生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。<br><a href="https://javaguide.cn/java/jvm/jdk-monitoring-and-troubleshooting-tools.html#jdk-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7">参考链接</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JDK监控和故障处理常用工具总结&quot;&gt;&lt;a href=&quot;#JDK监控和故障处理常用工具总结&quot; class=&quot;headerlink&quot; title=&quot;JDK监控和故障处理常用工具总结&quot;&gt;&lt;/a&gt;JDK监控和故障处理常用工具总结&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;jps&lt;br&gt;J</summary>
      
    
    
    
    <category term="JVM" scheme="http://example.com/categories/JVM/"/>
    
    <category term="JDK监控和故障处理常用工具总结" scheme="http://example.com/categories/JVM/JDK%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 多数元素</title>
    <link href="http://example.com/2022/06/19/%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/"/>
    <id>http://example.com/2022/06/19/%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</id>
    <published>2022-06-20T03:48:45.000Z</published>
    <updated>2022-06-20T03:59:19.933Z</updated>
    
    <content type="html"><![CDATA[<h1 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169.多数元素"></a>169.多数元素</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊n/2⌋ 的元素。<br>你可以假设数组是非空的，并且给定的数组总是存在多数元素。<br><a href="https://leetcode.cn/problems/majority-element">题目链接</a></p><span id="more"></span><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li><p>HashMap<br>使用哈希表统计每个元素出现的次数，返回哈希表中值最大的键。</p></li><li><p>排序<br>如果将数组 nums 中的所有元素按照单调递增或单调递减的顺序排序，那么下标为 ⌊n/2⌋ 的元素（下标从 0 开始）一定是众数。<br>因此，对数组进行排序并返回下标为⌊n/2⌋的数组元素。</p></li><li><p>随机化<br>因为超过 ⌊n/2⌋ 的数组下标被众数占据了，这样我们随机挑选一个下标对应的元素并验证，有很大的概率能找到众数。</p></li><li><p>分治<br>如果数 a 是数组 nums 的众数，如果我们将 nums 分成两部分，那么 a 必定是至少一部分的众数。<br>我们使用经典的分治算法递归求解，直到所有的子问题都是长度为 1 的数组。长度为 1 的子数组中唯一的数显然是众数，直接返回即可。如果回溯后某区间的长度大于 1，我们必须将左右子区间的值合并。如果它们的众数相同，那么显然这一段区间的众数是它们相同的值。否则，我们需要比较两个众数在整个区间内出现的次数来决定该区间的众数。</p></li><li><p>Boyer-Moore投票算法<br>如果我们把众数记为 +1+1+1，把其他数记为 −1-1−1，将它们全部加起来，显然和大于 0，从结果本身我们可以看出众数比其他数多。</p><h2 id="代码-java版本"><a href="#代码-java版本" class="headerlink" title="代码(java版本)"></a>代码(java版本)</h2><p> import java.util.Arrays;<br> import java.util.HashMap;<br> import java.util.Iterator;<br> import java.util.Map;<br> import java.util.Map.Entry;<br> import java.util.Random;</p><p> public class MajorityElement {</p><pre><code> private int randRange(Random rand, int min, int max)&#123;     return rand.nextInt(max - min) + min; &#125;  private int countOccurences(int[] nums, int num)&#123;     int count = 0;          for(int num1 : nums)&#123;         if(num == num1)&#123;             count++;         &#125;     &#125;          return count; &#125;  public int majorityElement(int[] nums)&#123;     Random rand = new Random();          int majorityCount = nums.length / 2;          while(true)&#123;         int candidate = nums[randRange(rand, 0, nums.length)];         if(countOccurences(nums, candidate) &gt; majorityCount)&#123;             return candidate;         &#125;     &#125; &#125;  private int countInRange(int[] nums, int num, int lo, int hi)&#123;     int count = 0;     for(int i = lo; i &lt;= hi; i++)&#123;         if(nums[i] == num)&#123;             count++;         &#125;     &#125;     return count; &#125;  private int majorityElementRec(int[] nums, int lo, int hi)&#123;     if(lo == hi)&#123;         return nums[lo];     &#125;          int mid = (hi - lo) / 2 + lo;     int left = majorityElementRec(nums, lo, mid);     int right = majorityElementRec(nums, mid + 1, hi);          if(left == right)&#123;         return left;     &#125;          int leftCount = countInRange(nums, left, lo, hi);     int rightCount = countInRange(nums, right, lo, hi);          return leftCount &gt; rightCount ? left : right; &#125;  //方法4：分治 public int majorityElement1(int[] nums)&#123;     return majorityElementRec(nums, 0, nums.length - 1); &#125;  //方法5：Boyer-Moore public int majorityElement2(int[] nums)&#123;     int count = 0;     Integer candidate = null;          for (int num : nums)&#123;         if(count == 0)&#123;             candidate = num;         &#125;         count += (num == candidate) ? 1 : -1;     &#125;          return candidate; &#125;  public static void main(String[] args) &#123;     int[] nums = new int[]&#123;2,2,1,1,1,2,2&#125;;          //方法1：HashMap</code></pre><p> //        Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;();<br> //        for(Integer num : nums){<br> //            String tempNum = num.toString();<br> //            if(!map.keySet().contains(tempNum)){<br> //                map.put(tempNum, 1);<br> //<br> //            }else{<br> //                map.put(tempNum, map.get(tempNum) + 1);<br> //            }<br> //        }<br> //<br> //        Iterator&lt;Entry&lt;String, Integer&gt;&gt; iterator = map.entrySet().iterator();<br> //        for(;iterator.hasNext();){<br> //            Entry&lt;String, Integer&gt; next = iterator.next();<br> //            String key = next.getKey();<br> //            Integer value = next.getValue();<br> //            if(value &gt; (int)(nums.length / 2)){<br> //                System.out.println(key);<br> //            }<br> //        }</p><pre><code>     //方法2：排序</code></pre><p> //        Arrays.sort(nums);<br> //        System.out.println(nums[nums.length / 2]);</p><pre><code>     //方法3：随机化     MajorityElement majorityElement = new MajorityElement();     int majority1 = majorityElement.majorityElement(nums);     System.out.println(majority1);          //方法4：分治     int majority2 = majorityElement.majorityElement1(nums);     System.out.println(majority2);          //方法5：Boyer-Moore投票算法     int majority3 = majorityElement.majorityElement2(nums);     System.out.println(majority3); &#125;</code></pre><p> }</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;169-多数元素&quot;&gt;&lt;a href=&quot;#169-多数元素&quot; class=&quot;headerlink&quot; title=&quot;169.多数元素&quot;&gt;&lt;/a&gt;169.多数元素&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊n/2⌋ 的元素。&lt;br&gt;你可以假设数组是非空的，并且给定的数组总是存在多数元素。&lt;br&gt;&lt;a href=&quot;https://leetcode.cn/problems/majority-element&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="数组" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>JVM | 垃圾收集器</title>
    <link href="http://example.com/2022/06/13/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>http://example.com/2022/06/13/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</id>
    <published>2022-06-14T03:33:16.000Z</published>
    <updated>2022-06-19T14:04:54.890Z</updated>
    
    <content type="html"><![CDATA[<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><table><thead><tr><th align="center">垃圾收集器</th><th align="center">串行/并行/并发</th><th align="center">新生代/老年代</th><th align="center">算法</th><th align="center">目标</th><th align="center">适用场景</th></tr></thead><tbody><tr><td align="center">Serial</td><td align="center">串行</td><td align="center">新生代</td><td align="center">复制算法</td><td align="center">响应速度优先</td><td align="center">单CPU环境下的Client模式</td></tr><tr><td align="center">Serial Old</td><td align="center">串行</td><td align="center">老年代</td><td align="center">标记-整理</td><td align="center">响应速度优先</td><td align="center">单CPU环境下的Client模式、CMS的后备预案</td></tr><tr><td align="center">ParNew</td><td align="center">并行</td><td align="center">新生代</td><td align="center">复制算法</td><td align="center">响应速度优先</td><td align="center">多CPU环境下在Server模式下与CMS配合</td></tr><tr><td align="center">Parallel Scavenge</td><td align="center">并行</td><td align="center">新生代</td><td align="center">复制算法</td><td align="center">吞吐量优先</td><td align="center">在后台运算而不需要太多交互任务</td></tr><tr><td align="center">Parallel Old</td><td align="center">并行</td><td align="center">老年代</td><td align="center">标记整理</td><td align="center">吞吐量优先</td><td align="center">在后台运算而不需要太多交互任务</td></tr><tr><td align="center">CMS</td><td align="center">并发</td><td align="center">老年代</td><td align="center">标记-清除</td><td align="center">响应速度优先</td><td align="center">集中在互联网网站或者基于浏览器的B/S系统的服务端上的Java应用</td></tr><tr><td align="center">G1</td><td align="center">并发</td><td align="center">Both</td><td align="center">标记-整理+复制算法</td><td align="center">响应速度优先</td><td align="center">面向服务端应用，将来替换CMS</td></tr><tr><td align="center">Shenandoah</td><td align="center">并发</td><td align="center">Both</td><td align="center">标记-整理+复制算法</td><td align="center">低延迟</td><td align="center"></td></tr><tr><td align="center">ZGC</td><td align="center">并发</td><td align="center">Both</td><td align="center">标记-整理+复制算法</td><td align="center">低延迟</td><td align="center"></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;垃圾收集器&quot;&gt;&lt;a href=&quot;#垃圾收集器&quot; class=&quot;headerlink&quot; title=&quot;垃圾收集器&quot;&gt;&lt;/a&gt;垃圾收集器&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;垃圾收集器&lt;/th&gt;
&lt;th align=</summary>
      
    
    
    
    <category term="JVM" scheme="http://example.com/categories/JVM/"/>
    
    <category term="垃圾收集器" scheme="http://example.com/categories/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
    <category term="GC" scheme="http://example.com/tags/GC/"/>
    
    <category term="垃圾收集器" scheme="http://example.com/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>并发 | 线程池</title>
    <link href="http://example.com/2022/06/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0-1/"/>
    <id>http://example.com/2022/06/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0-1/</id>
    <published>2022-06-08T01:59:41.000Z</published>
    <updated>2022-06-08T09:56:54.956Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p><strong>线程池的实现原理</strong><br><img src="/2022/06/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0-1/1.jpg"><br><strong>线程池的使用</strong><br>（1）线程池的创建</p><pre><code>new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime,unit,workQueue, handler)Parameters:    corePoolSize: the number of threads to keep in the pool, even if they are idle, unless allowCoreThreadTimeOut is set    maximumPoolSize: the maximum number of threads to allow in the pool    keepAliveTime: when the number of threads is greater than the core, this is the maximum time that excess idle threads will wait for new tasks before terminating.    unit the time: unit for the keepAliveTime argument    workQueue：the queue to use for holding tasks before they are executed. This queue will hold only the Runnable tasks submitted by the execute method.    threadFactory: set thread factory    handler: the handler to use when execution is blocked because the thread bounds and queue capacities are reached    workQueue:    ArrayBlockingQueue：基于数组结构的有界阻塞队列    LinkedBlockingQueue：基于链表结果的阻塞队列    SynchronousQueue：不存储元素的阻塞队列    PriorityBlockingQueue:具有优先级的无限阻塞队列handler:    AbortPolicy:直接抛出RejectedExecutionException异常    CallerRunsPolicy:使用调用者所在线程来执行任务    DiscardOldestPolicy：丢弃掉在队列中存在时间最久的任务    DiscardPolicy:默认丢弃任务，不进行任何通知</code></pre><p><a href="https://victory-liao.github.io/2022/04/24/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%847%E4%B8%AD%E6%96%B9%E5%BC%8F/">创建线程池的7种方式</a><br><a href="https://blog.csdn.net/qq_45404693/article/details/121020639">Executor框架</a></p><span id="more"></span><p>（2）向线程池提交任务<br>    execute():用于提交不需要返回值的任务。<br>    submit():用于提交需要返回值的任务。<br>（3）关闭线程池<br>    shutdown()<br>    shutdownNow()<br><strong>线程池的配置</strong><br>（1）<br>CPU密集型任务：配置 CPU数量+1 个线程的线程池；<br>IO密集型任务：配置 2*CPU数量 个线程的线程池；<br>混合型任务：两个事务执行时间相差不大，如果可以拆分，将其分解成一个CPU密集型任务和一个IO密集型任务，如果两个任务的执行时间相差太大，则没有必要拆分。<br>（2）优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理，让优先级高的任务先执行。<br>（3）执行时间不同的任务可以交给不同规模的线程池来处理，或者可以使用优先级队列，让执行时间段的任务先执行。<br>（4）依赖数据库连接池的任务，因为线程提交SQL后选哟等待数据库返回结果，等待的时间越长，则CPU空闲时间越长，应该设置较大的线程数。<br>（5）建议使用有界队列。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;线程池&quot;&gt;&lt;a href=&quot;#线程池&quot; class=&quot;headerlink&quot; title=&quot;线程池&quot;&gt;&lt;/a&gt;线程池&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;线程池的实现原理&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;/2022/06/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0-1/1.jpg&quot;&gt;&lt;br&gt;&lt;strong&gt;线程池的使用&lt;/strong&gt;&lt;br&gt;（1）线程池的创建&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime,unit,workQueue, handler)

Parameters:
    corePoolSize: the number of threads to keep in the pool, even if they are idle, unless allowCoreThreadTimeOut is set
    maximumPoolSize: the maximum number of threads to allow in the pool
    keepAliveTime: when the number of threads is greater than the core, this is the maximum time that excess idle threads will wait for new tasks before terminating.
    unit the time: unit for the keepAliveTime argument
    workQueue：the queue to use for holding tasks before they are executed. This queue will hold only the Runnable tasks submitted by the execute method.
    threadFactory: set thread factory
    handler: the handler to use when execution is blocked because the thread bounds and queue capacities are reached
    
workQueue:
    ArrayBlockingQueue：基于数组结构的有界阻塞队列
    LinkedBlockingQueue：基于链表结果的阻塞队列
    SynchronousQueue：不存储元素的阻塞队列
    PriorityBlockingQueue:具有优先级的无限阻塞队列

handler:
    AbortPolicy:直接抛出RejectedExecutionException异常
    CallerRunsPolicy:使用调用者所在线程来执行任务
    DiscardOldestPolicy：丢弃掉在队列中存在时间最久的任务
    DiscardPolicy:默认丢弃任务，不进行任何通知
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://victory-liao.github.io/2022/04/24/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%847%E4%B8%AD%E6%96%B9%E5%BC%8F/&quot;&gt;创建线程池的7种方式&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/qq_45404693/article/details/121020639&quot;&gt;Executor框架&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="并发" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="线程池" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="线程池" scheme="http://example.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    <category term="Executor" scheme="http://example.com/tags/Executor/"/>
    
    <category term="Executors" scheme="http://example.com/tags/Executors/"/>
    
    <category term="ThreadPoolExecutor" scheme="http://example.com/tags/ThreadPoolExecutor/"/>
    
    <category term="ScheduledThreadPoolExecutor" scheme="http://example.com/tags/ScheduledThreadPoolExecutor/"/>
    
  </entry>
  
  <entry>
    <title>并发 | Exchanger</title>
    <link href="http://example.com/2022/06/07/Exchanger/"/>
    <id>http://example.com/2022/06/07/Exchanger/</id>
    <published>2022-06-07T14:14:03.000Z</published>
    <updated>2022-06-07T14:28:19.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h1><p>Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程<br>通过exchange方法交换数据，如果第一个线程先执行exchange方法，它会一直等待第二个线程也执行exchange方法，当<br>两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。<br><strong>应用场景</strong><br>（1）遗传算法<br>遗传算法里需要选出两个人作为交配对象，这时候会交换两个人的数据，并使用交叉规则得出2个交配结果。<br>（2）校对工作<br>例如，我们需要将纸制银行流水通过人工的方式录入成电子银行流水，为了避免错误，采用AB岗两个人进行录入，录入到<br>Excel后，系统需要加载这两个Excel，并对两个Excel数据进行校对，看看是否录入一致。<br><strong>示例代码：</strong></p><pre><code>package concurrency.exchanger;import java.util.concurrent.Exchanger;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class ExchangerTest &#123;    private static final Exchanger&lt;String&gt; exgr = new Exchanger&lt;String&gt;();        private static ExecutorService threadPool = Executors.newFixedThreadPool(2);        public static void main(String[] args) &#123;        threadPool.execute(new Runnable()&#123;            @Override            public void run() &#123;                try&#123;                    String A = &quot;银行流水A&quot;;//A录入银行流水数据                    exgr.exchange(A);                &#125;catch(InterruptedException e)&#123;                    e.printStackTrace();                &#125;            &#125;                    &#125;);                threadPool.execute(new Runnable()&#123;            @Override            public void run() &#123;                try&#123;                    String B = &quot;银行流水B&quot;;//B录入银行流水数据                    String A = exgr.exchange(B);                    System.out.println(&quot;A和B数据是否一致：&quot;+A.equals(B)+&quot;,A录入的是：&quot;+A+&quot;,B录入的是：&quot;+B);                &#125;catch(InterruptedException e)&#123;                    e.printStackTrace();                &#125;            &#125;                    &#125;);    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Exchanger&quot;&gt;&lt;a href=&quot;#Exchanger&quot; class=&quot;headerlink&quot; title=&quot;Exchanger&quot;&gt;&lt;/a&gt;Exchanger&lt;/h1&gt;&lt;p&gt;Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程</summary>
      
    
    
    
    <category term="并发" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="Exchanger" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/Exchanger/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="Exchanger" scheme="http://example.com/tags/Exchanger/"/>
    
  </entry>
  
  <entry>
    <title>并发 | Semaphore</title>
    <link href="http://example.com/2022/06/07/Semaphore/"/>
    <id>http://example.com/2022/06/07/Semaphore/</id>
    <published>2022-06-07T14:02:35.000Z</published>
    <updated>2022-06-07T14:11:47.673Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><p>Semaphore（信号量）是用来控制同时访问特定资源的数量，它通过协调各个线程，以保证合理的使用公共资源。<br><strong>应用场景：</strong><br>Semaphore可以用于做<strong>流量控制</strong>，特别是公共资源优先的应用场景，比如<strong>数据库连接</strong>。<br><strong>示例代码：</strong></p><pre><code>package concurrency.semaphore;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;public class SemaphoreTest &#123;    private static final int THREAD_COUNT = 30;        private static ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);        private static Semaphore s = new Semaphore(10);        public static void main(String[] args) &#123;        for(int i = 0; i &lt; THREAD_COUNT; i++)&#123;//虽然有30个线程在执行，但是只允许10个并发执行            threadPool.execute(new Runnable()&#123;                @Override                public void run()&#123;                    try&#123;                        s.acquire();                        System.out.println(&quot;save data&quot;);                        s.release();                    &#125;catch(InterruptedException e)&#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;);        &#125;        threadPool.shutdown();    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Semaphore&quot;&gt;&lt;a href=&quot;#Semaphore&quot; class=&quot;headerlink&quot; title=&quot;Semaphore&quot;&gt;&lt;/a&gt;Semaphore&lt;/h1&gt;&lt;p&gt;Semaphore（信号量）是用来控制同时访问特定资源的数量，它通过协调各个线程，以</summary>
      
    
    
    
    <category term="并发" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="Semaphore" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/Semaphore/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="Semaphore" scheme="http://example.com/tags/Semaphore/"/>
    
  </entry>
  
  <entry>
    <title>并发 | Java中的12个原子操作类</title>
    <link href="http://example.com/2022/06/07/Java%E4%B8%AD%E7%9A%8413%E4%B8%AA%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/"/>
    <id>http://example.com/2022/06/07/Java%E4%B8%AD%E7%9A%8413%E4%B8%AA%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/</id>
    <published>2022-06-07T13:29:19.000Z</published>
    <updated>2022-06-07T13:54:03.288Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java中的13个原子操作类"><a href="#Java中的13个原子操作类" class="headerlink" title="Java中的13个原子操作类"></a>Java中的13个原子操作类</h1><p>在java.util.concurrent.atomic包中包含了12个原子类，属于四种类型的原子更新方式，分别是：<br>（1）原子更新基本类型<br>    AtomicInteger:原子更新整型；<br>    AtomicBoolean:原子更新布尔类型；<br>    AtomicLong:源自更新长整型。<br>（2）原子更新数组<br>    AtomicIntegerArray:原子更新整型数组里的元素；<br>    AtomicLongArray:原子更新长整型数组里的元素；<br>    AtomicReferenceArray:原子更新引用类型数组里的元素<br>（3）原子更新引用<br>    AtomicReference:原子更新引用类型；<br>    AtomicReferenceFieldUpdater:原子更新引用类型里的字段；<br>    AtomicMarkableReference:原子更新带有标记位的引用类型（可以原子更新一个布尔类型的标记位和引用类型）。<br>（4）原子更新属性（字段）<br>    AtomicIntegerFieldUpdater:原子更新整型的字段的更新器；<br>    AtomicLongFieldUpdater:原子更新长整型的字段的更新器；<br>    AtomicStampedReference:原子更新带有版本号的引用类型，能够解决使用CAS进行原子更新时可能出现的ABA问题。<br>以下给出每个类型的原子更新的一个示例代码：</p><span id="more"></span><p><strong>示例代码1-原子更新基本类型</strong></p><pre><code>package concurrency.atomic;import java.util.concurrent.atomic.AtomicInteger;public class AtomicIntegerTest1 &#123;    static AtomicInteger ai = new AtomicInteger(1);        public static void main(String[] args)&#123;        int addAndGet = ai.addAndGet(2);        System.out.println(addAndGet);            boolean compareAndSet = ai.compareAndSet(1, 2);        System.out.println(compareAndSet);        System.out.println(ai.get());                System.out.println(ai.getAndIncrement());        System.out.println(ai.get());                ai.lazySet(3);        System.out.println(ai.get());                int andSet = ai.getAndSet(2);        System.out.println(andSet);        System.out.println(ai.get());    &#125;&#125;</code></pre><p><strong>示例代码2-原子更新数组</strong></p><pre><code>package concurrency.atomic;import java.util.concurrent.atomic.AtomicIntegerArray;public class AtomicIntegerArrayTest &#123;    static int[] value = new int[]&#123;1,2&#125;;    static AtomicIntegerArray ai = new AtomicIntegerArray(value);        public static void main(String[] args)&#123;        System.out.println(ai.getAndSet(0, 3));        System.out.println(ai.get(0));        System.out.println(value[0]);        int addAndGet = ai.addAndGet(0, 3);        System.out.println(addAndGet);        System.out.println(ai.get(0));        System.out.println(ai.compareAndSet(0, 3, 33));        System.out.println(ai.compareAndSet(0, 6, 66));    &#125;&#125;</code></pre><p><strong>示例代码3-原子更新引用</strong></p><pre><code>package concurrency.atomic;import java.util.concurrent.atomic.AtomicReference;public class AtomicReferenceTest &#123;    public static AtomicReference&lt;User&gt; atomicUserRef = new AtomicReference&lt;User&gt;();        public static void main(String[] args)&#123;        User user = new User(&quot;conan&quot;, 15);        atomicUserRef.set(user);        User updateUser = new User(&quot;Shinichi&quot;, 17);        atomicUserRef.compareAndSet(user, updateUser);        System.out.println(atomicUserRef.get().getName());        System.out.println(atomicUserRef.get().getOld());    &#125;        static class User&#123;        private String name;        private int old;                public User(String name, int old)&#123;            this.name = name;            this.old = old;        &#125;        public String getName() &#123;            return name;        &#125;        public void setName(String name) &#123;            this.name = name;        &#125;        public int getOld() &#123;            return old;        &#125;        public void setOld(int old) &#123;            this.old = old;        &#125;    &#125;&#125;</code></pre><p><strong>示例代码4-原子更新属性</strong></p><pre><code>package concurrency.atomic;import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;public class AtomicIntegerFieldUpdaterTest &#123;    //创建原子更新器，并设置需要更新的对象和对象的属性    private static AtomicIntegerFieldUpdater&lt;User&gt; a = AtomicIntegerFieldUpdater.newUpdater(User.class, &quot;old&quot;);        public static void main(String[] args)&#123;        //设置柯南的年龄是10岁        User conan = new User(&quot;conan&quot;, 10);        //柯南长了一岁，但是仍然会输出旧的年龄        System.out.println(a.getAndIncrement(conan));        //输出柯南现在的年龄        System.out.println(a.get(conan));    &#125;        public static class User&#123;        private String name;        public volatile int old;                public User(String name, int old)&#123;            this.name = name;            this.old = old;        &#125;        public String getName() &#123;            return name;        &#125;        public int getOld() &#123;            return old;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Java中的13个原子操作类&quot;&gt;&lt;a href=&quot;#Java中的13个原子操作类&quot; class=&quot;headerlink&quot; title=&quot;Java中的13个原子操作类&quot;&gt;&lt;/a&gt;Java中的13个原子操作类&lt;/h1&gt;&lt;p&gt;在java.util.concurrent.atomic包中包含了12个原子类，属于四种类型的原子更新方式，分别是：&lt;br&gt;（1）原子更新基本类型&lt;br&gt;    AtomicInteger:原子更新整型；&lt;br&gt;    AtomicBoolean:原子更新布尔类型；&lt;br&gt;    AtomicLong:源自更新长整型。&lt;br&gt;（2）原子更新数组&lt;br&gt;    AtomicIntegerArray:原子更新整型数组里的元素；&lt;br&gt;    AtomicLongArray:原子更新长整型数组里的元素；&lt;br&gt;    AtomicReferenceArray:原子更新引用类型数组里的元素&lt;br&gt;（3）原子更新引用&lt;br&gt;    AtomicReference:原子更新引用类型；&lt;br&gt;    AtomicReferenceFieldUpdater:原子更新引用类型里的字段；&lt;br&gt;    AtomicMarkableReference:原子更新带有标记位的引用类型（可以原子更新一个布尔类型的标记位和引用类型）。&lt;br&gt;（4）原子更新属性（字段）&lt;br&gt;    AtomicIntegerFieldUpdater:原子更新整型的字段的更新器；&lt;br&gt;    AtomicLongFieldUpdater:原子更新长整型的字段的更新器；&lt;br&gt;    AtomicStampedReference:原子更新带有版本号的引用类型，能够解决使用CAS进行原子更新时可能出现的ABA问题。&lt;br&gt;以下给出每个类型的原子更新的一个示例代码：&lt;/p&gt;</summary>
    
    
    
    <category term="并发" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="Java中的12个原子操作类" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/Java%E4%B8%AD%E7%9A%8412%E4%B8%AA%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="原子类" scheme="http://example.com/tags/%E5%8E%9F%E5%AD%90%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>并发 | CyclicBarrier用于多线程计算数据并合并计算结果</title>
    <link href="http://example.com/2022/06/07/CyclicBarrier%E7%94%A8%E4%BA%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%A1%E7%AE%97%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%90%88%E5%B9%B6%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%9C/"/>
    <id>http://example.com/2022/06/07/CyclicBarrier%E7%94%A8%E4%BA%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%A1%E7%AE%97%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%90%88%E5%B9%B6%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%9C/</id>
    <published>2022-06-07T12:51:58.000Z</published>
    <updated>2022-06-07T13:23:56.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CyclicBarrier用于多线程计算数据并合并计算结果"><a href="#CyclicBarrier用于多线程计算数据并合并计算结果" class="headerlink" title="CyclicBarrier用于多线程计算数据并合并计算结果"></a>CyclicBarrier用于多线程计算数据并合并计算结果</h1><p><strong>CyclicBarrier</strong><br>CyclicBarrier让一组线程到达一个屏障（同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，<br>所有被屏障拦截的线程才会继续执行。<br><strong>注：CyclicBarrier的计数器可以使用reset()方法重置</strong></p><span id="more"></span><p><strong>使用方式1：</strong></p><pre><code>package concurrency.cyclicbarrier;import java.util.concurrent.CyclicBarrier;public class CyclicBarrierTest &#123;    static CyclicBarrier c = new CyclicBarrier(2);    public static void main(String[] args) &#123;        new Thread(new Runnable()&#123;            @Override            public void run()&#123;                try&#123;                    c.await();                &#125;catch(Exception e)&#123;                                    &#125;                System.out.println(1);            &#125;        &#125;).start();                try&#123;            c.await();        &#125;catch(Exception e)&#123;                    &#125;        System.out.println(2);    &#125;&#125;</code></pre><p><strong>使用方式2：</strong></p><pre><code>package concurrency.cyclicbarrier;import java.util.concurrent.CyclicBarrier;public class CyclicBarrierTest2 &#123;    static CyclicBarrier c = new CyclicBarrier(2, new A());        public static void main(String[] args) &#123;        new Thread(new Runnable()&#123;            @Override            public void run()&#123;                try&#123;                    c.await();                &#125;catch(Exception e)&#123;                                    &#125;                System.out.println(1);            &#125;        &#125;).start();                try&#123;            c.await();        &#125;catch(Exception e)&#123;                    &#125;        System.out.println(2);    &#125;        static class A implements Runnable&#123;        @Override        public void run() &#123;            System.out.println(3);        &#125;    &#125;&#125;</code></pre><p><strong>应用场景：</strong> 一个Excel保存了用户所有银行流水，每个Sheet保存一个账户近一年的每笔银行流水，现在<br>需要统计用户的日均银行流水，先用多线程处理每个sheet里的银行流水，都执行完之后，得到每个sheet<br>的日均银行流水，最后，再用barrierAction用这些线程的计算结果，计算出整个Excel的日均银行流水。<br><strong>代码：</strong></p><pre><code>package concurrency.cyclicbarrier;import java.util.Map.Entry;import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.CyclicBarrier;import java.util.concurrent.Executor;import java.util.concurrent.Executors;public class BankWaterService implements Runnable&#123;    //创建4个屏障，处理完之后执行当前类的run方法    private CyclicBarrier c = new CyclicBarrier(4, this);        //假设只有4个sheet，所以只启动4个线程    private Executor executor = Executors.newFixedThreadPool(4);        //保存每个sheet计算出的银流结果    private ConcurrentHashMap&lt;String, Integer&gt; sheetBankWaterCount = new ConcurrentHashMap&lt;String, Integer&gt;();        private void count()&#123;        for(int i = 0; i &lt; 4; i++)&#123;            executor.execute(new Runnable()&#123;                @Override                public void run() &#123;                    //计算当前sheet的银流数据，计算代码省略                    sheetBankWaterCount.put(Thread.currentThread().getName(), 1);                    //银流计算完成，插入一个屏障                    try&#123;                        c.await();                    &#125;catch(InterruptedException | BrokenBarrierException e)&#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;);        &#125;    &#125;        @Override    public void run() &#123;        int result = 0;                //汇总每个sheet计算出的结果        for(Entry&lt;String, Integer&gt; sheet : sheetBankWaterCount.entrySet())&#123;            result += sheet.getValue();        &#125;                //将结果输出        sheetBankWaterCount.put(&quot;result&quot;, result);        System.out.println(result);    &#125;        public static void main(String[] args)&#123;        BankWaterService bankWaterCount = new BankWaterService();        bankWaterCount.count();    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;CyclicBarrier用于多线程计算数据并合并计算结果&quot;&gt;&lt;a href=&quot;#CyclicBarrier用于多线程计算数据并合并计算结果&quot; class=&quot;headerlink&quot; title=&quot;CyclicBarrier用于多线程计算数据并合并计算结果&quot;&gt;&lt;/a&gt;CyclicBarrier用于多线程计算数据并合并计算结果&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;CyclicBarrier&lt;/strong&gt;&lt;br&gt;CyclicBarrier让一组线程到达一个屏障（同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，&lt;br&gt;所有被屏障拦截的线程才会继续执行。&lt;br&gt;&lt;strong&gt;注：CyclicBarrier的计数器可以使用reset()方法重置&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="并发" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="CyclicBarrier" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/CyclicBarrier/"/>
    
    <category term="CyclicBarrier用于多线程计算数据并合并计算结果" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/CyclicBarrier/CyclicBarrier%E7%94%A8%E4%BA%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%A1%E7%AE%97%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%90%88%E5%B9%B6%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%9C/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="CyclicBarrier" scheme="http://example.com/tags/CyclicBarrier/"/>
    
  </entry>
  
  <entry>
    <title>使用ForkJoin框架计算整数相加的结果</title>
    <link href="http://example.com/2022/06/06/%E4%BD%BF%E7%94%A8ForkJoin%E6%A1%86%E6%9E%B6%E8%AE%A1%E7%AE%97%E6%95%B4%E6%95%B0%E7%9B%B8%E5%8A%A0%E7%9A%84%E7%BB%93%E6%9E%9C/"/>
    <id>http://example.com/2022/06/06/%E4%BD%BF%E7%94%A8ForkJoin%E6%A1%86%E6%9E%B6%E8%AE%A1%E7%AE%97%E6%95%B4%E6%95%B0%E7%9B%B8%E5%8A%A0%E7%9A%84%E7%BB%93%E6%9E%9C/</id>
    <published>2022-06-06T13:29:43.000Z</published>
    <updated>2022-06-06T13:34:29.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用ForkJoin框架计算整数相加的结果"><a href="#使用ForkJoin框架计算整数相加的结果" class="headerlink" title="使用ForkJoin框架计算整数相加的结果"></a>使用ForkJoin框架计算整数相加的结果</h1><p><strong>需求：</strong> 使用Fork/Join框架计算1+2+3+4的结果。<br><strong>分析：</strong> 使用Fork/Join框架首先要考虑到的是如何分割任务，如果希望每个子任务最多执行两个数的相加<br>，那么我们设置分割的阈值是2，由于是四个数字相加，所以Fork/Join框架会把这个任务fork成两个子<br>任务，子任务1负责计算1+2，子任务2负责3+4，然后再join两个子任务的结果。因为是有结果的任务，所<br>以必须继承RecursiveTask。<br><strong>实现代码：</strong></p><pre><code>package concurrency.forkjoin;import java.util.concurrent.ExecutionException;import java.util.concurrent.ForkJoinPool;import java.util.concurrent.Future;import java.util.concurrent.RecursiveTask;public class CountTask extends RecursiveTask&lt;Integer&gt;&#123;    private static final int THRESHOLD = 2;//阈值    private int start;    private int end;        public CountTask(int start, int end)&#123;        this.start = start;        this.end = end;    &#125;    @Override    protected Integer compute() &#123;        int sum = 0;                //如果任务足够小就计算任务        boolean canCompute = (end - start) &lt;= THRESHOLD;        if(canCompute)&#123;            for(int i = start; i &lt;= end; i++)&#123;                sum += i;            &#125;        &#125;else&#123;            //如果任务大虚与之，就分裂成两个子任务计算            int middle = (start + end) / 2;            CountTask leftTask = new CountTask(start, middle);            CountTask rightTask = new CountTask(middle + 1, end);            //执行子任务            leftTask.fork();            rightTask.fork();            //等待子任务执行完，并得到其结果            int leftResult = leftTask.join();            int rightResult = rightTask.join();            //合并子任务            sum = leftResult + rightResult;        &#125;        return sum;    &#125;        public static void main(String[] args)&#123;        ForkJoinPool forkJoinPool = new ForkJoinPool();        //生成一个计算任务，负责计算1+2+3+4        CountTask task = new CountTask(1, 4);        //执行一个任务        Future&lt;Integer&gt; result = forkJoinPool.submit(task);        try&#123;            System.out.println(result.get());        &#125;catch(InterruptedException e)&#123;            e.printStackTrace();        &#125;catch(ExecutionException e)&#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用ForkJoin框架计算整数相加的结果&quot;&gt;&lt;a href=&quot;#使用ForkJoin框架计算整数相加的结果&quot; class=&quot;headerlink&quot; title=&quot;使用ForkJoin框架计算整数相加的结果&quot;&gt;&lt;/a&gt;使用ForkJoin框架计算整数相加的结果&lt;/</summary>
      
    
    
    
    <category term="并发" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="ForkJoin" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/ForkJoin/"/>
    
    <category term="使用ForkJoin框架计算整数相加的结果" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/ForkJoin/%E4%BD%BF%E7%94%A8ForkJoin%E6%A1%86%E6%9E%B6%E8%AE%A1%E7%AE%97%E6%95%B4%E6%95%B0%E7%9B%B8%E5%8A%A0%E7%9A%84%E7%BB%93%E6%9E%9C/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="ForkJoin" scheme="http://example.com/tags/ForkJoin/"/>
    
  </entry>
  
  <entry>
    <title>锁 | 读写锁+HashMap实现线程安全的HashMap</title>
    <link href="http://example.com/2022/06/06/%E8%AF%BB%E5%86%99%E9%94%81-HashMap%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84HashMap/"/>
    <id>http://example.com/2022/06/06/%E8%AF%BB%E5%86%99%E9%94%81-HashMap%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84HashMap/</id>
    <published>2022-06-06T08:12:53.000Z</published>
    <updated>2022-06-06T08:31:49.622Z</updated>
    
    <content type="html"><![CDATA[<h1 id="读写锁-HashMap实现线程安全的HashMap"><a href="#读写锁-HashMap实现线程安全的HashMap" class="headerlink" title="读写锁+HashMap实现线程安全的HashMap"></a>读写锁+HashMap实现线程安全的HashMap</h1><p>ReadWriteLockCache组合一个非线程安全的HashMap作为缓存的实现，同时使用读写锁的读锁和写锁来保证ReadWriteLockCaChe是线程安全的。<br><strong>代码：</strong></p><pre><code>package concurrency.AQS; import java.util.HashMap;import java.util.Map;import java.util.Map.Entry;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantReadWriteLock;public class ReadWriteLockCache &#123;    public static void main(String[] args) &#123;        ReadWriteLockCache.put(&quot;user1&quot;, &quot;123&quot;);        ReadWriteLockCache.put(&quot;user2&quot;, &quot;456&quot;);        ReadWriteLockCache.put(&quot;user3&quot;, &quot;789&quot;);        for(Entry entry : ReadWriteLockCache.map.entrySet())&#123;            System.out.println(entry.getKey()+&quot;:&quot;+entry.getValue());        &#125;        System.out.println(&quot;==========================&quot;);        ReadWriteLockCache.put(&quot;user1&quot;, &quot;1233&quot;);        for(Entry entry : ReadWriteLockCache.map.entrySet())&#123;            System.out.println(entry.getKey()+&quot;:&quot;+entry.getValue());        &#125;        System.out.println(&quot;==========================&quot;);        System.out.println(&quot;user1&quot; + ReadWriteLockCache.get(&quot;user1&quot;));        System.out.println(&quot;==========================&quot;);        ReadWriteLockCache.clear();        for(Entry entry : ReadWriteLockCache.map.entrySet())&#123;            System.out.println(entry.getKey()+&quot;:&quot;+entry.getValue());        &#125;            &#125;        static Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();    static ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();    static Lock r = rwl.readLock();    static Lock w = rwl.writeLock();        //获取一个key对应的value    public static final Object get(String key)&#123;        r.lock();        try&#123;            return map.get(key);        &#125;finally&#123;            r.unlock();        &#125;    &#125;        //设置key对应的value，并返回旧的value    public static final Object put(String key, Object value)&#123;        w.lock();        try&#123;            return map.put(key, value);        &#125;finally&#123;            w.unlock();        &#125;    &#125;        //清空所有内容    public static final void clear()&#123;        w.lock();        try&#123;            map.clear();        &#125;finally&#123;            w.unlock();        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;读写锁-HashMap实现线程安全的HashMap&quot;&gt;&lt;a href=&quot;#读写锁-HashMap实现线程安全的HashMap&quot; class=&quot;headerlink&quot; title=&quot;读写锁+HashMap实现线程安全的HashMap&quot;&gt;&lt;/a&gt;读写锁+HashMap</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="锁" scheme="http://example.com/categories/Java/%E5%B9%B6%E5%8F%91/%E9%94%81/"/>
    
    <category term="读写锁+HashMap实现线程安全的HashMap" scheme="http://example.com/categories/Java/%E5%B9%B6%E5%8F%91/%E9%94%81/%E8%AF%BB%E5%86%99%E9%94%81-HashMap%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84HashMap/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="锁" scheme="http://example.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>负载均衡</title>
    <link href="http://example.com/2022/05/31/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>http://example.com/2022/05/31/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</id>
    <published>2022-06-01T02:49:27.000Z</published>
    <updated>2022-06-01T02:51:23.240Z</updated>
    
    <content type="html"><![CDATA[<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p><a href="https://blog.csdn.net/wanghangzhen/article/details/118554304">负载均衡</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;负载均衡&quot;&gt;&lt;a href=&quot;#负载均衡&quot; class=&quot;headerlink&quot; title=&quot;负载均衡&quot;&gt;&lt;/a&gt;负载均衡&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/wanghangzhen/article/details/11</summary>
      
    
    
    
    
    <category term="负载均衡" scheme="http://example.com/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
  <entry>
    <title>并发 | 基于线程池技术的简单Web服务器</title>
    <link href="http://example.com/2022/05/30/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8A%80%E6%9C%AF%E7%9A%84%E7%AE%80%E5%8D%95Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://example.com/2022/05/30/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8A%80%E6%9C%AF%E7%9A%84%E7%AE%80%E5%8D%95Web%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2022-05-31T03:11:39.000Z</published>
    <updated>2022-05-31T03:16:52.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于线程池技术的简单Web服务器"><a href="#基于线程池技术的简单Web服务器" class="headerlink" title="基于线程池技术的简单Web服务器"></a>基于线程池技术的简单Web服务器</h1><p>基于线程池技术的简单Web服务器，这个Web服务器用来处理HTTP请求(目前智能处理简单的文本和JPG图片内容)。这个服务器使用<br>main线程不断地接受可换段Socket的连接，将连接以及请求提交给线程池处理，这样使得Web服务器能够同时处理多个客户端请求。</p><span id="more"></span><p><strong>Web服务器示例代码</strong></p><pre><code>package concurrency.threadPool;import java.io.BufferedReader;import java.io.ByteArrayOutputStream;import java.io.Closeable;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.ServerSocket;import java.net.Socket;public class SimpleHttpServer &#123;    //处理HttpRequest的线程池    static ThreadPool&lt;HttpRequestHandler&gt; threadPool = new DefaultThreadPool&lt;HttpRequestHandler&gt;(1);        //SimpleHttpServer的根路径    static String basePath;        static ServerSocket serverSocket;        //服务器监听端口    static int port = 8080;        public static void setPort(int port)&#123;        if(port &gt; 0)&#123;            SimpleHttpServer.port = port;        &#125;    &#125;        public static void setBasePath(String basePath)&#123;        if(basePath != null &amp;&amp; new File(basePath).exists() &amp;&amp; new File(basePath).isDirectory())&#123;            SimpleHttpServer.basePath = basePath;        &#125;    &#125;        //启动SimpleHttpServer    public static void start() throws IOException&#123;        serverSocket = new ServerSocket(port);        Socket socket = null;        while((socket = serverSocket.accept()) != null)&#123;            //接收一个可换段Socket，生成一个HttpRequestHandler，放入线程池执行            threadPool.execute(new HttpRequestHandler(socket));        &#125;        serverSocket.close();    &#125;        static class HttpRequestHandler implements Runnable&#123;        private Socket socket;        public HttpRequestHandler(Socket socket)&#123;            this.socket = socket;        &#125;                @Override        public void run() &#123;            String line = null;            BufferedReader br = null;            BufferedReader reader = null;            PrintWriter out = null;            InputStream in = null;            try&#123;                reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));                String header = reader.readLine();                //由相对路径计算出绝对路径                String filePath = basePath + header.split(&quot; &quot;)[1];                out = new PrintWriter(socket.getOutputStream());                //如果请求资源为jpg或者ico，则读取资源并输出                if(filePath.endsWith(&quot;jpg&quot;) || filePath.endsWith(&quot;ico&quot;))&#123;                    in = new FileInputStream(filePath);                    ByteArrayOutputStream baos = new ByteArrayOutputStream();                    int i = 0;                    while((i = in.read()) != -1)&#123;                        baos.write(i);                    &#125;                    byte[] array = baos.toByteArray();                    out.println(&quot;HTTP/1.1 200 OK&quot;);                    out.println(&quot;Server: Molly&quot;);                    out.println(&quot;Content-Type: image/jpeg&quot;);                    out.println(&quot;Content-Length: &quot;+array.length);                    out.println(&quot;&quot;);                    socket.getOutputStream().write(array, 0, array.length);                &#125;else&#123;                    br = new BufferedReader(new InputStreamReader(new FileInputStream(filePath)));                    out = new PrintWriter(socket.getOutputStream());                    out.println(&quot;HTTP/1.1 200 OK&quot;);                    out.println(&quot;Server: Molly&quot;);                    out.println(&quot;Content-Type: text/html; charset=UTF-8&quot;);                    out.println(&quot;&quot;);                    while((line = br.readLine()) != null)&#123;                        out.println(line);                    &#125;                &#125;                out.flush();            &#125;catch(Exception ex)&#123;                out.println(&quot;HTTP/1.1 500&quot;);                out.println(&quot;&quot;);                out.flush();            &#125;finally&#123;                close(br, in, reader, out, socket);            &#125;        &#125;            &#125;        //关闭流或者Socket    private static void close(Closeable... closeables)&#123;        if(closeables != null)&#123;            for(Closeable closeable : closeables)&#123;                try &#123;                    closeable.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><p><strong>ThreadPool.java</strong></p><pre><code>package concurrency.threadPool;public interface ThreadPool&lt;Job extends Runnable&gt; &#123;    //执行一个Job，这个Job需要实现Runnable    void execute(Job job);        //关闭线程池    void shutdown();        //增加工作者线程    void addWorkers(int num);        //减少工作者线程    void remvoeWorkers(int num);        //得到正在等待执行的任务数量    int getJobSize();&#125;</code></pre><p><strong>DefaultThreadPool.java</strong></p><pre><code>package concurrency.threadPool;import java.util.ArrayList;import java.util.Collections;import java.util.LinkedList;import java.util.List;import java.util.concurrent.atomic.AtomicLong;public class DefaultThreadPool&lt;Job extends Runnable&gt; implements ThreadPool&lt;Job&gt; &#123;    //线程池最大数量    private static final int MAX_WORKER_NUMBERS = 10;        //线程池默认数量    private static final int DEFAULT_WORKER_NUMBERS = 5;        //线程池最小的数量    private static final int MIN_WORKER_NUMBERS = 1;        //这是一个工作列表，将会向里面插入工作    private final LinkedList&lt;Job&gt; jobs = new LinkedList&lt;Job&gt;();//生产者        //工作者列表    private final List&lt;Worker&gt; workers = Collections.synchronizedList(new ArrayList&lt;Worker&gt;());//消费者        //工作者线程的数量    private int workerNum = DEFAULT_WORKER_NUMBERS;        //线程编号的生成    private AtomicLong threadNum = new AtomicLong();        //工作者，负责消费任务    class Worker implements Runnable&#123;        //是否工作        private volatile boolean running = true;        @Override        public void run()&#123;            while(running)&#123;                Job job = null;                synchronized(jobs)&#123;                    //如果工作者列表是空的，那么就wait                    while(jobs.isEmpty())&#123;                        try&#123;                            jobs.wait();                        &#125;catch(InterruptedException ex)&#123;                            //感知到外部对WorkerThread的中断操作，返回                            Thread.currentThread().interrupt();                            return;                        &#125;                    &#125;                    //取出一个Job                    job = jobs.removeFirst();                &#125;                if(job != null)&#123;                    try&#123;                        job.run();                    &#125;catch(Exception ex)&#123;                        //忽略Job执行中的Exception                    &#125;                &#125;            &#125;        &#125;                public void shutdown()&#123;            running = false;        &#125;    &#125;        //初始化线程工作者    private void initializeWorkers(int num)&#123;        for(int i = 0; i &lt; num; i++)&#123;            Worker worker = new Worker();            workers.add(worker);            Thread thread = new Thread(worker, &quot;ThreadPool-Worker-&quot; + threadNum.incrementAndGet());            thread.start();        &#125;    &#125;        public DefaultThreadPool()&#123;        initializeWorkers(DEFAULT_WORKER_NUMBERS);    &#125;        public DefaultThreadPool(int num)&#123;        workerNum = num &gt; MAX_WORKER_NUMBERS ? MAX_WORKER_NUMBERS : num &lt; MIN_WORKER_NUMBERS ? MIN_WORKER_NUMBERS : num;        initializeWorkers(workerNum);    &#125;        @Override    public void execute(Job job) &#123;        if(job != null)&#123;            //添加一个工作，然后进行通知            synchronized(jobs)&#123;                jobs.addLast(job);                jobs.notify();            &#125;        &#125;    &#125;    @Override    public void shutdown() &#123;        for(Worker worker : workers)&#123;            worker.shutdown();        &#125;    &#125;    @Override    public void addWorkers(int num) &#123;        synchronized(jobs)&#123;            //限制新增的Worker数量不能超过最大值            if(num + this.workerNum &gt; MAX_WORKER_NUMBERS)&#123;                num = MAX_WORKER_NUMBERS - this.workerNum;            &#125;            initializeWorkers(num);            this.workerNum += num;        &#125;    &#125;    @Override    public void remvoeWorkers(int num) &#123;        synchronized(jobs)&#123;            if(num &gt;= this.workerNum)&#123;                throw new IllegalArgumentException(&quot;beyond workNum&quot;);            &#125;            //按照给定的数量停止Worker            int count = 0;            while(count &lt; num)&#123;                Worker worker = workers.get(count);                if(workers.remove(worker))&#123;                    worker.shutdown();                    count++;                &#125;            &#125;            this.workerNum -= count;        &#125;    &#125;    @Override    public int getJobSize() &#123;        return jobs.size();    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;基于线程池技术的简单Web服务器&quot;&gt;&lt;a href=&quot;#基于线程池技术的简单Web服务器&quot; class=&quot;headerlink&quot; title=&quot;基于线程池技术的简单Web服务器&quot;&gt;&lt;/a&gt;基于线程池技术的简单Web服务器&lt;/h1&gt;&lt;p&gt;基于线程池技术的简单Web服务器，这个Web服务器用来处理HTTP请求(目前智能处理简单的文本和JPG图片内容)。这个服务器使用&lt;br&gt;main线程不断地接受可换段Socket的连接，将连接以及请求提交给线程池处理，这样使得Web服务器能够同时处理多个客户端请求。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="基于线程池技术的简单Web服务器" scheme="http://example.com/categories/Java/%E5%B9%B6%E5%8F%91/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8A%80%E6%9C%AF%E7%9A%84%E7%AE%80%E5%8D%95Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="基于线程池技术的简单Web服务器" scheme="http://example.com/tags/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8A%80%E6%9C%AF%E7%9A%84%E7%AE%80%E5%8D%95Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>并发 | CountDownLatch</title>
    <link href="http://example.com/2022/05/30/CountDownLatch/"/>
    <id>http://example.com/2022/05/30/CountDownLatch/</id>
    <published>2022-05-31T02:01:48.000Z</published>
    <updated>2022-06-07T13:17:45.566Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><p>CountDownLatch允许一个或多个线程等待其他线程完成操作。<br>例如：</p><pre><code>CountDownLatch c = new CountDownLatch(2)；</code></pre><p>CountDownLatch的构造函数接收一个int类型的参数作为计数器，如果你想等待N个点完成，这里就传入N.<br>当我们调用CountDownLatch的countDown方法时，N就会减1，CountDownLatch的await方法会阻塞当前<br>线程，直到N变为0。由于countDown方法可以用在任何地方，所以这里说的<strong>N个点，可以是N个线程，也可以<br>是1个线程里的N个步骤</strong>。<br><strong>注：CountDownLatch的计数器智能使用一次</strong></p><span id="more"></span><p><strong>示例代码1</strong></p><pre><code>package concurrency.countdownlatch;import java.util.concurrent.CountDownLatch;public class CountDownLatchTest1 &#123;    static CountDownLatch c = new CountDownLatch(2);        public static void main(String[] args) throws InterruptedException &#123;        new Thread(new Runnable()&#123;            @Override            public void run() &#123;                System.out.println(&quot;parser1 finished&quot;);                c.countDown();            &#125;        &#125;).start();                new Thread(new Runnable()&#123;            @Override            public void run() &#123;                System.out.println(&quot;parser2 finished&quot;);                c.countDown();            &#125;        &#125;).start();        c.await();        System.out.println(&quot;all parsers finished&quot;);    &#125;&#125;</code></pre><p><strong>示例代码2</strong></p><pre><code>package concurrency.countdownlatch;import java.util.concurrent.CountDownLatch;public class CountDownLatchTest2 &#123;    static CountDownLatch c = new CountDownLatch(2);    public static void main(String[] args) throws InterruptedException &#123;        new Thread(new Runnable()&#123;            @Override            public void run() &#123;                System.out.println(&quot;1&quot;);                c.countDown();                System.out.println(&quot;2&quot;);                c.countDown();            &#125;        &#125;).start();        c.await();        System.out.println(&quot;3&quot;);    &#125; &#125;</code></pre><p><a href="https://blog.csdn.net/hbtj_1216/article/details/109655995">CountDownLatch</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;CountDownLatch&quot;&gt;&lt;a href=&quot;#CountDownLatch&quot; class=&quot;headerlink&quot; title=&quot;CountDownLatch&quot;&gt;&lt;/a&gt;CountDownLatch&lt;/h1&gt;&lt;p&gt;CountDownLatch允许一个或多个线程等待其他线程完成操作。&lt;br&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CountDownLatch c = new CountDownLatch(2)；
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CountDownLatch的构造函数接收一个int类型的参数作为计数器，如果你想等待N个点完成，这里就传入N.&lt;br&gt;当我们调用CountDownLatch的countDown方法时，N就会减1，CountDownLatch的await方法会阻塞当前&lt;br&gt;线程，直到N变为0。由于countDown方法可以用在任何地方，所以这里说的&lt;strong&gt;N个点，可以是N个线程，也可以&lt;br&gt;是1个线程里的N个步骤&lt;/strong&gt;。&lt;br&gt;&lt;strong&gt;注：CountDownLatch的计数器智能使用一次&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="CountDownLatch" scheme="http://example.com/categories/Java/%E5%B9%B6%E5%8F%91/CountDownLatch/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="CountDownLatch" scheme="http://example.com/tags/CountDownLatch/"/>
    
  </entry>
  
  <entry>
    <title>并发 | 线程池</title>
    <link href="http://example.com/2022/05/29/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://example.com/2022/05/29/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2022-05-29T08:44:53.000Z</published>
    <updated>2022-05-30T06:51:22.751Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>1.线程池的作用<br>对于服务器端的程序，如果服务端每接收到一个任务，创建一个线程，然后进行执行；这样的做法在面对成千上万的任务递交进服务器时，<br>那么会创建数以万记的线程，这样会时操作系统频繁的进行上下文切换，无故增加系统的负载，而线程的创建和小王都是需要好耗费<br>系统资源的，也无疑浪费了系统资源。线程池技术（通过使用固定或较为固定数目的线程来完成任务的执行）能够很好地解决这个问题，<br>消除频繁创建和消亡线程的系统资源开销。<br>2.线程池的本质<br>使用了一个线程安全的工作队列连接工作者线程和客户端线程，客户端线程将任务放入工作队列后便返回，而工作者线程则不断地从工作<br>队列取出工作并执行。当工作队列为空时，所有的工作者线程均等待在工作队列上，当有客户端提交了一个任务之后会通知任意一个工作者<br>线程，随着大量任务被提交，更多的工作者线程会被唤醒。<br>3.线程池示例<br><strong>ThreadPool.java</strong></p><pre><code>package concurrency.threadPool;public interface ThreadPool&lt;Job extends Runnable&gt; &#123;    //执行一个Job，这个Job需要实现Runnable    void execute(Job job);        //关闭线程池    void shutdown();        //增加工作者线程    void addWorkers(int num);        //减少工作者线程    void remvoeWorkers(int num);        //得到正在等待执行的任务数量    int getJobSize();&#125;</code></pre><p><strong>DefaultThreadPool.java</strong></p><pre><code>package concurrency.threadPool;import java.util.ArrayList;import java.util.Collections;import java.util.LinkedList;import java.util.List;import java.util.concurrent.atomic.AtomicLong;public class DefaultThreadPool&lt;Job extends Runnable&gt; implements ThreadPool&lt;Job&gt; &#123;    //线程池最大数量    private static final int MAX_WORKER_NUMBERS = 10;        //线程池默认数量    private static final int DEFAULT_WORKER_NUMBERS = 5;        //线程池最小的数量    private static final int MIN_WORKER_NUMBERS = 1;        //这是一个工作列表，将会向里面插入工作    private final LinkedList&lt;Job&gt; jobs = new LinkedList&lt;Job&gt;();        //工作者列表    private final List&lt;Worker&gt; workers = Collections.synchronizedList(new ArrayList&lt;Worker&gt;());        //工作者线程的数量    private int workerNum = DEFAULT_WORKER_NUMBERS;        //线程编号的生成    private AtomicLong threadNum = new AtomicLong();        //工作者，负责消费任务    class Worker implements Runnable&#123;        //是否工作        private volatile boolean running = true;        @Override        public void run()&#123;            while(running)&#123;                Job job = null;                synchronized(jobs)&#123;                    //如果工作者列表是空的，那么就wait                    while(jobs.isEmpty())&#123;                        try&#123;                            jobs.wait();                        &#125;catch(InterruptedException ex)&#123;                            //感知到外部对WorkerThread的中断操作，返回                            Thread.currentThread().interrupt();                            return;                        &#125;                    &#125;                    //取出一个Job                    job = jobs.removeFirst();                &#125;                if(job != null)&#123;                    try&#123;                        job.run();                    &#125;catch(Exception ex)&#123;                        //忽略Job执行中的Exception                    &#125;                &#125;            &#125;        &#125;                public void shutdown()&#123;            running = false;        &#125;    &#125;        //初始化线程工作者    private void initializeWorkers(int num)&#123;        for(int i = 0; i &lt; num; i++)&#123;            Worker worker = new Worker();            workers.add(worker);            Thread thread = new Thread(worker, &quot;ThreadPool-Worker-&quot; + threadNum.incrementAndGet());            thread.start();        &#125;    &#125;        public DefaultThreadPool()&#123;        initializeWorkers(DEFAULT_WORKER_NUMBERS);    &#125;        public DefaultThreadPool(int num)&#123;        workerNum = num &gt; MAX_WORKER_NUMBERS ? MAX_WORKER_NUMBERS : num &lt; MIN_WORKER_NUMBERS ? MIN_WORKER_NUMBERS : num;        initializeWorkers(workerNum);    &#125;        @Override    public void execute(Job job) &#123;        if(job != null)&#123;            //添加一个工作，然后进行通知            synchronized(jobs)&#123;                jobs.addLast(job);                jobs.notify();            &#125;        &#125;    &#125;    @Override    public void shutdown() &#123;        for(Worker worker : workers)&#123;            worker.shutdown();        &#125;    &#125;    @Override    public void addWorkers(int num) &#123;        synchronized(jobs)&#123;            //限制新增的Worker数量不能超过最大值            if(num + this.workerNum &gt; MAX_WORKER_NUMBERS)&#123;                num = MAX_WORKER_NUMBERS - this.workerNum;            &#125;            initializeWorkers(num);            this.workerNum += num;        &#125;    &#125;    @Override    public void remvoeWorkers(int num) &#123;        synchronized(jobs)&#123;            if(num &gt;= this.workerNum)&#123;                throw new IllegalArgumentException(&quot;beyond workNum&quot;);            &#125;            //按照给定的数量停止Worker            int count = 0;            while(count &lt; num)&#123;                Worker worker = workers.get(count);                if(workers.remove(worker))&#123;                    worker.shutdown();                    count++;                &#125;            &#125;            this.workerNum -= count;        &#125;    &#125;    @Override    public int getJobSize() &#123;        return jobs.size();    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线程池&quot;&gt;&lt;a href=&quot;#线程池&quot; class=&quot;headerlink&quot; title=&quot;线程池&quot;&gt;&lt;/a&gt;线程池&lt;/h1&gt;&lt;p&gt;1.线程池的作用&lt;br&gt;对于服务器端的程序，如果服务端每接收到一个任务，创建一个线程，然后进行执行；这样的做法在面对成千上万的任务递</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="线程池" scheme="http://example.com/categories/Java/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="线程池" scheme="http://example.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>并发 | 等待/通知机制</title>
    <link href="http://example.com/2022/05/28/%E7%AD%89%E5%BE%85-%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2022/05/28/%E7%AD%89%E5%BE%85-%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/</id>
    <published>2022-05-29T07:37:56.000Z</published>
    <updated>2022-05-30T06:51:06.543Z</updated>
    
    <content type="html"><![CDATA[<h1 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h1><p>等待通知机制，是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或着notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。<br><strong>示例代码</strong></p><pre><code>package concurrency;import java.text.SimpleDateFormat;import java.util.Date;import java.util.concurrent.TimeUnit;public class WaitNotify &#123;    static boolean flag = true;    static Object lock = new Object();        public static void main(String[] args) throws InterruptedException &#123;        Thread waitThread = new Thread(new Wait(), &quot;WaitThread&quot;);        waitThread.start();        TimeUnit.SECONDS.sleep(1);        Thread notifyThread = new Thread(new Notify(), &quot;NotifyThread&quot;);        notifyThread.start();    &#125;        static class Wait implements Runnable&#123;        @Override        public void run()&#123;            //加锁，用于lock的Monitor            synchronized(lock)&#123;                //当条件不满足时，继续wait，同时释放了lock的锁                while(flag)&#123;                    try &#123;                        System.out.println(Thread.currentThread()+&quot; flag is true. wait@ &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));                        lock.wait();                    &#125; catch (InterruptedException e) &#123;                    &#125;                &#125;                //条件满足时，完成工作                System.out.println(Thread.currentThread() + &quot;flag is false. running@ &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            &#125;        &#125;    &#125;        static class Notify implements Runnable&#123;        @Override        public void run() &#123;            synchronized(lock)&#123;                //获取lock的锁，然后进行通知，通知时不会释放lock的锁                //直到当前线程释放了lock后，WaitThread才能从wait方法中返回                System.out.println(Thread.currentThread() + &quot; hold lock. notify @ &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));                lock.notifyAll();                flag = false;                SleepUtils.second(5);            &#125;                        //再次加锁            synchronized(lock)&#123;                System.out.println(Thread.currentThread()+ &quot;hold lock again. sleep@ &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));                SleepUtils.second(5);            &#125;                    &#125;    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;等待-通知机制&quot;&gt;&lt;a href=&quot;#等待-通知机制&quot; class=&quot;headerlink&quot; title=&quot;等待/通知机制&quot;&gt;&lt;/a&gt;等待/通知机制&lt;/h1&gt;&lt;p&gt;等待通知机制，是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="等待/通知机制" scheme="http://example.com/categories/Java/%E5%B9%B6%E5%8F%91/%E7%AD%89%E5%BE%85-%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="等待/通知机制" scheme="http://example.com/tags/%E7%AD%89%E5%BE%85-%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>并发 | 等待超时模式构造简单的数据库连接池</title>
    <link href="http://example.com/2022/05/28/%E7%AD%89%E5%BE%85%E8%B6%85%E6%97%B6%E6%A8%A1%E5%BC%8F%E6%9E%84%E9%80%A0%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    <id>http://example.com/2022/05/28/%E7%AD%89%E5%BE%85%E8%B6%85%E6%97%B6%E6%A8%A1%E5%BC%8F%E6%9E%84%E9%80%A0%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</id>
    <published>2022-05-29T07:33:57.000Z</published>
    <updated>2022-05-30T06:49:15.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="等待超时模式构造简单的数据库连接池"><a href="#等待超时模式构造简单的数据库连接池" class="headerlink" title="等待超时模式构造简单的数据库连接池"></a>等待超时模式构造简单的数据库连接池</h1><p><strong>ConnectionPool.java</strong></p><pre><code>package concurrency.connetionPool;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.sql.Connection;import java.util.LinkedList;import java.util.concurrent.TimeUnit;class ConnectionDriver&#123;    static class ConnectionHandler implements InvocationHandler&#123;        @Override        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;            if(method.getName().equals(&quot;commit&quot;))&#123;                TimeUnit.MILLISECONDS.sleep(100);            &#125;            return null;        &#125;    &#125;        //创建一个Connection的代理，在commit时休眠100毫秒    public static final Connection createConnection()&#123;        return (Connection) Proxy.newProxyInstance(ConnectionDriver.class.getClassLoader(), new Class&lt;?&gt;[] &#123; Connection.class &#125;, new ConnectionHandler());    &#125;&#125;public class ConnectionPool &#123;    private LinkedList&lt;Connection&gt; pool = new LinkedList&lt;Connection&gt;();        public ConnectionPool(int initialSize)&#123;        if(initialSize &gt; 0)&#123;            for(int i = 0; i &lt; initialSize; i++)&#123;                pool.addLast(ConnectionDriver.createConnection());            &#125;        &#125;    &#125;        public void releaseConnection(Connection connection)&#123;        if(connection != null)&#123;            synchronized(pool)&#123;                //连接释放后需要进行通知，这样其他消费者能够感知到连接池中已经归还了一个连接                pool.addLast(connection);                pool.notifyAll();            &#125;        &#125;    &#125;        //在mills内无法获取到连接，将会返回null    public Connection fetchConnection(long mills) throws InterruptedException&#123;        synchronized(pool)&#123;            //完全超时            if(mills &lt; 0)&#123;                while(pool.isEmpty())&#123;                    pool.wait();                &#125;                return pool.removeFirst();//Removes and returns the first element from this list.            &#125;else&#123;                long future = System.currentTimeMillis() + mills;                long remaining = mills;                while(pool.isEmpty() &amp;&amp; remaining &gt; 0)&#123;                    pool.wait(remaining);                    remaining = future - System.currentTimeMillis();                &#125;                Connection result = null;                if(!pool.isEmpty())&#123;                    result = pool.removeFirst();                &#125;                return result;            &#125;        &#125;    &#125;&#125;</code></pre><p><strong>ConnectionPoolTest.java</strong></p><pre><code>package concurrency.connetionPool;import java.sql.Connection;import java.util.concurrent.CountDownLatch;import java.util.concurrent.atomic.AtomicInteger;public class ConnectionPoolTest &#123;    static ConnectionPool pool = new ConnectionPool(10);        //保证所有ConnectionRunner能够同时开始    static CountDownLatch start = new CountDownLatch(1);        //main线程将会等待所有ConnectionRunner结束后才能继续执行    static CountDownLatch end;        public static void main(String[] args) throws InterruptedException&#123;        //线程数量，可以修改线程数量进行观察        int threadCount = 50;        end = new CountDownLatch(threadCount);        int count = 20;        AtomicInteger got = new AtomicInteger();        AtomicInteger notGot = new AtomicInteger();        for(int i = 0; i &lt; threadCount; i++)&#123;            Thread thread = new Thread(new ConnectionRunner(count, got, notGot), &quot;ConnectionRunnerThread&quot;);            thread.start();        &#125;        start.countDown();//使latch的值减1，如果减到了0，则会唤醒所有等待在这个latch上的线程。        end.await();//使当前线程进入同步队列进行等待，直到latch的值被减到0或者当前线程被中断，当前线程就会被唤醒。        System.out.println(&quot;total invoke: &quot; + (threadCount * count));        System.out.println(&quot;got connection: &quot; + got);        System.out.println(&quot;not got connection: &quot; + notGot);    &#125;    static class ConnectionRunner implements Runnable&#123;        int count;        AtomicInteger got;        AtomicInteger notGot;                public ConnectionRunner(int count, AtomicInteger got, AtomicInteger notGot)&#123;            this.count = count;            this.got = got;            this.notGot = notGot;        &#125;                public void run()&#123;            try&#123;                start.await();            &#125;catch(Exception ex)&#123;                            &#125;            while(count &gt; 0)&#123;                try&#123;                    //从线程池中获取连接，如果1000ms内无法获取到，将会返回null                    //分别统计连接获取的数量got和未获取到的数量notGot                    Connection connection = pool.fetchConnection(1000);                    if(connection != null)&#123;                        try&#123;                            connection.createStatement();                            connection.commit();                        &#125;finally&#123;                            pool.releaseConnection(connection);                            got.incrementAndGet();                        &#125;                    &#125;else&#123;                        notGot.incrementAndGet();                    &#125;                &#125;catch(Exception ex)&#123;                                    &#125;finally&#123;                    count--;                &#125;                            &#125;            end.countDown();        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;等待超时模式构造简单的数据库连接池&quot;&gt;&lt;a href=&quot;#等待超时模式构造简单的数据库连接池&quot; class=&quot;headerlink&quot; title=&quot;等待超时模式构造简单的数据库连接池&quot;&gt;&lt;/a&gt;等待超时模式构造简单的数据库连接池&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Co</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="等待超时模式构造简单的数据库连接池" scheme="http://example.com/categories/Java/%E5%B9%B6%E5%8F%91/%E7%AD%89%E5%BE%85%E8%B6%85%E6%97%B6%E6%A8%A1%E5%BC%8F%E6%9E%84%E9%80%A0%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发 | volatile写读的内存语义和锁的释放获取的内存语义</title>
    <link href="http://example.com/2022/05/23/volatile%E5%86%99%E8%AF%BB%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89%E5%92%8C%E9%94%81%E7%9A%84%E9%87%8A%E6%94%BE%E8%8E%B7%E5%8F%96%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89/"/>
    <id>http://example.com/2022/05/23/volatile%E5%86%99%E8%AF%BB%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89%E5%92%8C%E9%94%81%E7%9A%84%E9%87%8A%E6%94%BE%E8%8E%B7%E5%8F%96%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89/</id>
    <published>2022-05-23T14:02:50.000Z</published>
    <updated>2022-05-24T01:02:03.770Z</updated>
    
    <content type="html"><![CDATA[<h1 id="volatile写读的内存语义和锁的释放获取的内存语义"><a href="#volatile写读的内存语义和锁的释放获取的内存语义" class="headerlink" title="volatile写读的内存语义和锁的释放获取的内存语义"></a>volatile写读的内存语义和锁的释放获取的内存语义</h1><h2 id="volatile写、读的内存语义"><a href="#volatile写、读的内存语义" class="headerlink" title="volatile写、读的内存语义"></a>volatile写、读的内存语义</h2><p>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主存。<br><img src="/2022/05/23/volatile%E5%86%99%E8%AF%BB%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89%E5%92%8C%E9%94%81%E7%9A%84%E9%87%8A%E6%94%BE%E8%8E%B7%E5%8F%96%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89/1.PNG"><br>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。<br><img src="/2022/05/23/volatile%E5%86%99%E8%AF%BB%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89%E5%92%8C%E9%94%81%E7%9A%84%E9%87%8A%E6%94%BE%E8%8E%B7%E5%8F%96%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89/2.PNG"></p><h2 id="volatile内存语义的实现"><a href="#volatile内存语义的实现" class="headerlink" title="volatile内存语义的实现"></a>volatile内存语义的实现</h2><p>编译器生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。<br>JMM基于保守策略的JMM内存屏障插入策略如下：<br>（1）在每个volatile写操作的前面插入一个StoreStore屏障。<br>（2）在每个volatile写操作的后面插入一个StoreLoad屏障。<br>（3）在每个volatile读操作的后面插入一个LoadLoad屏障。<br>（4）在每个volatile读操作的后面插入一个LoadStore屏障。</p><h2 id="锁的释放、获取的内存语义"><a href="#锁的释放、获取的内存语义" class="headerlink" title="锁的释放、获取的内存语义"></a>锁的释放、获取的内存语义</h2><p>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。<br>当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。<br>注：锁释放与volatile写有相同的内存语义；锁获取与volatile读具有相同的内存语义。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;volatile写读的内存语义和锁的释放获取的内存语义&quot;&gt;&lt;a href=&quot;#volatile写读的内存语义和锁的释放获取的内存语义&quot; class=&quot;headerlink&quot; title=&quot;volatile写读的内存语义和锁的释放获取的内存语义&quot;&gt;&lt;/a&gt;volat</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="volatile写读的内存语义和锁的释放获取的内存语义" scheme="http://example.com/categories/Java/%E5%B9%B6%E5%8F%91/volatile%E5%86%99%E8%AF%BB%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89%E5%92%8C%E9%94%81%E7%9A%84%E9%87%8A%E6%94%BE%E8%8E%B7%E5%8F%96%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="volatile" scheme="http://example.com/tags/volatile/"/>
    
    <category term="锁" scheme="http://example.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>并发 | volatile、synchronized和原子操作</title>
    <link href="http://example.com/2022/05/22/volatile%E3%80%81synchronized%E5%92%8C%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2022/05/22/volatile%E3%80%81synchronized%E5%92%8C%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</id>
    <published>2022-05-23T03:03:39.000Z</published>
    <updated>2022-05-23T03:57:47.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="volatile、synchronized和原子操作"><a href="#volatile、synchronized和原子操作" class="headerlink" title="volatile、synchronized和原子操作"></a>volatile、synchronized和原子操作</h1><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>volatile是轻量级的synchronized，它在多处理器并发中保证了<strong>共享变量的“可见性”</strong>。可见性是指当一个线程修改一个共享变量时<br>，另外一个线程能读到这个修改的值（Java内存模型确保所有线程看到这个变量的值是一致的）。</p><h3 id="volatile的两条实现原则"><a href="#volatile的两条实现原则" class="headerlink" title="volatile的两条实现原则"></a>volatile的两条实现原则</h3><p>（1）Lock前缀指令会引起处理器缓存回写到内存。<br>（2）一个处理器的缓存回写到内存会导致其他处理器的缓存无效。</p><h3 id="volatile的使用优化"><a href="#volatile的使用优化" class="headerlink" title="volatile的使用优化"></a>volatile的使用优化</h3><p>使用追加到64字节的方式来填满高速缓冲区的缓存行，避免头节点和尾节点加载到同一个缓存行，使头、尾节点在修改时不会互相锁定。</p><h2 id="synchronized实现原理"><a href="#synchronized实现原理" class="headerlink" title="synchronized实现原理"></a>synchronized实现原理</h2><p>JVM基于进入和推出Monitor对象来实现方法同步和代码块同步，但两者实现细节不一样。<br>代码块同步使用monitorenter和monitorexit指令实现的。monitorenter指令在编译后插入到同步代码块的开始位置，而monitorexit是<br>插入到方法结束处和异常处，JVM要博爱正每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，<br>当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象monitor的所有权，即尝试获得对象的锁。</p><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>java如何实现原子操作？<br>通过循环CAS的方式实现原子操作。JVM中CAS操作使用处理器提供的CMPXCHG指令实现。自旋CAS实现的基本思路就是循环及进行CAS操作指导成功为止。</p><h3 id="使用CAS实现线程安全计数器"><a href="#使用CAS实现线程安全计数器" class="headerlink" title="使用CAS实现线程安全计数器"></a>使用CAS实现线程安全计数器</h3><pre><code>package concurrency;import java.util.ArrayList;import java.util.List;import java.util.concurrent.atomic.AtomicInteger;public class Counter &#123;    private AtomicInteger atomicI = new AtomicInteger(0);    private int i = 0;        public static void main(String[] args) &#123;        final Counter cas = new Counter();        List&lt;Thread&gt; ts = new ArrayList&lt;Thread&gt;(600);        long start = System.currentTimeMillis();        for(int j = 0; j &lt; 100; j++)&#123;            Thread t = new Thread(new Runnable()&#123;                @Override                public void run()&#123;                    for(int i = 0; i &lt; 10000; i++)&#123;                        cas.count();                        cas.safeCount();                    &#125;                &#125;            &#125;);            ts.add(t);        &#125;        for(Thread t : ts)&#123;            t.start();        &#125;        //等待所有线程执行完成        for(Thread t : ts)&#123;            try &#123;                t.join();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        System.out.println(cas.i);        System.out.println(cas.atomicI.get());        System.out.println(System.currentTimeMillis() - start);    &#125;        //使用CAS实现线程安全计数器    private void safeCount()&#123;        for(;;)&#123;            int i = atomicI.get();            boolean suc = atomicI.compareAndSet(i, ++i);            if(suc)&#123;                break;            &#125;        &#125;    &#125;        //非线程安全计数器    private void count()&#123;        i++;    &#125;&#125;</code></pre><h2 id="CAS实现原子操作的三大问题"><a href="#CAS实现原子操作的三大问题" class="headerlink" title="CAS实现原子操作的三大问题"></a>CAS实现原子操作的三大问题</h2><p>（1）ABA问题。可以使用版本号解决。JDK Atomic AtomicStampedReference可以解决ABA问题。<br>（2）循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。<br>（3）只能保证一个共享变量的原子操作。对多个共享变量操作可以使用锁/将多个共享变量合并成一个共享变量来操作（两个共享变量i=2,j=a,合并以下ij=2a,然后采用CAS来操作）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;volatile、synchronized和原子操作&quot;&gt;&lt;a href=&quot;#volatile、synchronized和原子操作&quot; class=&quot;headerlink&quot; title=&quot;volatile、synchronized和原子操作&quot;&gt;&lt;/a&gt;volatile</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="volatile" scheme="http://example.com/tags/volatile/"/>
    
    <category term="synchronized" scheme="http://example.com/tags/synchronized/"/>
    
    <category term="原子操作" scheme="http://example.com/tags/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>并发 | 上下文切换和死锁</title>
    <link href="http://example.com/2022/05/22/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/"/>
    <id>http://example.com/2022/05/22/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/</id>
    <published>2022-05-23T02:37:08.000Z</published>
    <updated>2022-05-23T02:59:57.500Z</updated>
    
    <content type="html"><![CDATA[<h1 id="上下文切换和死锁"><a href="#上下文切换和死锁" class="headerlink" title="上下文切换和死锁"></a>上下文切换和死锁</h1><h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，再切换前会保存上一个任务的<br>状态，以便切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。频繁的上下文<br>切换会影响多线程的执行速度。</p><h2 id="如何减少上下文切换"><a href="#如何减少上下文切换" class="headerlink" title="如何减少上下文切换"></a>如何减少上下文切换</h2><p>（1）无锁并发编程。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁（如采用分段锁，不同的线程处理不同段的数据）<br>（2）CAS算法。<br>（3）使用最小线程。避免创建不需要的线程（任务很少，创建了很多线程，造成大量线程阻塞等待）</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁产生的条件"><a href="#死锁产生的条件" class="headerlink" title="死锁产生的条件"></a>死锁产生的条件</h3><p>（1）互斥。一个资源同一时刻只能被一个线程拥有。<br>（2）请求和保持。线程在请求新的资源时，不释放已经拥有的资源。<br>（3）不剥夺条件。进程所获得的资源在未使用完之前，不被其他的线程强行剥夺。<br>（4）循环等待。竞争资源的各个线程形成一个线程等待环路。</p><h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>破坏产生死锁的条件：<br>（2）在进程开始执行时就申请他所需的全部资源<br>（3）一个进程不能获得所需要的全部资源时便处于等待状态，等待期间他占有的资源将被隐式的释放重新加入到系统的资源列表中<br>，可以被其他的进程使用，而等待的进程只有重新获得自己原有的资源以及新申请的资源才可以重新启动、执行。<br>（4）资源有序分配（银行家算法）</p><h3 id="死锁Demo"><a href="#死锁Demo" class="headerlink" title="死锁Demo"></a>死锁Demo</h3><pre><code>package concurrency;public class DeadLockDemo &#123;    private static String A = &quot;A&quot;;    private static String B = &quot;B&quot;;        public static void main(String[] args) &#123;        new DeadLockDemo().deadLock();    &#125;        private void deadLock()&#123;        Thread t1 = new Thread(new Runnable()&#123;            @Override            public void run()&#123;                synchronized(A)&#123;                    try &#123;                        Thread.currentThread().sleep(2000);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    synchronized(B)&#123;                        System.out.println(&quot;1&quot;);                    &#125;                &#125;            &#125;        &#125;);                Thread t2 = new Thread(new Runnable()&#123;            @Override            public void run() &#123;                synchronized(B)&#123;                    synchronized(A)&#123;                        System.out.println(&quot;2&quot;);                    &#125;                &#125;            &#125;        &#125;);                t1.start();        t2.start();    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;上下文切换和死锁&quot;&gt;&lt;a href=&quot;#上下文切换和死锁&quot; class=&quot;headerlink&quot; title=&quot;上下文切换和死锁&quot;&gt;&lt;/a&gt;上下文切换和死锁&lt;/h1&gt;&lt;h2 id=&quot;上下文切换&quot;&gt;&lt;a href=&quot;#上下文切换&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="上下文切换" scheme="http://example.com/categories/Java/%E5%B9%B6%E5%8F%91/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="死锁" scheme="http://example.com/tags/%E6%AD%BB%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Redis | 面试题目</title>
    <link href="http://example.com/2022/05/22/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    <id>http://example.com/2022/05/22/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/</id>
    <published>2022-05-22T09:32:20.000Z</published>
    <updated>2022-05-22T09:33:41.628Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis面试题目"><a href="#Redis面试题目" class="headerlink" title="Redis面试题目"></a>Redis面试题目</h1><p><a href="https://mp.weixin.qq.com/s/3ln9VAB_heYTI7yvxnp2bw">参考资料</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis面试题目&quot;&gt;&lt;a href=&quot;#Redis面试题目&quot; class=&quot;headerlink&quot; title=&quot;Redis面试题目&quot;&gt;&lt;/a&gt;Redis面试题目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/3ln9VA</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    <category term="面试题目" scheme="http://example.com/categories/Redis/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
</feed>
