<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Victory&#39;s Blog</title>
  
  <subtitle>非淡泊无以明志，非宁静无以致远</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-10-27T14:04:43.533Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>victory-liao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>jieba | python词频分析</title>
    <link href="http://example.com/2021/10/27/python%E8%AF%8D%E9%A2%91%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2021/10/27/python%E8%AF%8D%E9%A2%91%E5%88%86%E6%9E%90/</id>
    <published>2021-10-27T13:58:21.000Z</published>
    <updated>2021-10-27T14:04:43.533Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python词频分析"><a href="#python词频分析" class="headerlink" title="python词频分析"></a>python词频分析</h1><p>程序分析了”主要业务”文件夹的所有文件中的文本信息的词频(分别存储在”词频”文件夹中)</p><span id="more"></span><p>实现代码：</p><pre><code>import osimport jiebaimport pandas as pdpath = &#39;主要业务&#39;  # 文件所在文件夹files = [path + &quot;\\&quot; + i for i in os.listdir(path)]  # 获取文件夹下的文件名,并拼接完整路径for file in files:    txt = open(file, &quot;r&quot;, encoding=&quot;utf-8&quot;).read()    words = jieba.lcut(txt)    wordsDict = &#123;&#125;  # 新建字典用于储存词及词频    for word in words:        if len(word) == 1:  # 单个的字符不作为词放入字典            continue        else:            wordsDict.setdefault(word, 0)  # 设置词的初始出现次数为0            wordsDict[word] += 1  # 对于重复出现的词，每出现一次，次数增加1    stopWords = [&quot;2019&quot;, &quot;不断&quot;, &quot;持续&quot;, &quot;主要&quot;, &quot;企业&quot;, &quot;产品&quot;, &quot;业务&quot;, &quot;公司&quot;, &quot;行业&quot;, &quot;000&quot;, &quot;用于&quot;, &quot;情况&quot;, &quot;方面&quot;, &quot;一种&quot;, &quot;要求&quot;, &quot;对于&quot;,                 &quot;进行&quot;, &quot;一般&quot;, &quot;212&quot;, &quot;实现&quot;, &quot;处理&quot;, &quot;通过&quot;, &quot;投入&quot;, &quot;随着&quot;]    for word in stopWords:        if word in wordsDict:            del wordsDict[word]    wordsDict_seq = sorted(wordsDict.items(), key=lambda x: x[1], reverse=True)  # 按字典的值降序排序    df = pd.DataFrame(wordsDict_seq, columns=[&#39;词&#39;, &#39;次数&#39;])    df.to_excel(&quot;词频//&#123;&#125;.xlsx&quot;.format(file.split(&quot;\\&quot;)[1][:-4]), index=False)  # 存为Excel时去掉index索引列  </code></pre><p>“主要业务”文件夹的所有文件:<br><a href="东旭蓝天：2019年年度报告.txt">东旭蓝天：2019年年度报告.txt</a><br><a href="保利地产：2018年年度报告.txt">保利地产：2018年年度报告.txt</a><br><a href="共达电声：2019年年度报告（更新后）.txt">共达电声：2019年年度报告（更新后）.txt</a><br><a href="华特气体：2019年年度报告（修订版）.txt">华特气体：2019年年度报告（修订版）.txt</a><br><a href="吉峰科技：2019年年度报告（更新后）.txt">吉峰科技：2019年年度报告（更新后）.txt</a><br><a href="引力传媒：2019年年度报告（修订版）.txt">引力传媒：2019年年度报告（修订版）.txt</a><br><a href="方正科技：2019年年度报告.txt">方正科技：2019年年度报告.txt</a><br><a href="湖北宜化：2019年年度报告（更新后）.txt">湖北宜化：2019年年度报告（更新后）.txt</a><br><a href="联创股份：2019年年度报告（更新后）.txt">联创股份：2019年年度报告（更新后）.txt</a><br><a href="高乐股份：2019年年度报告.txt">高乐股份：2019年年度报告.txt</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;python词频分析&quot;&gt;&lt;a href=&quot;#python词频分析&quot; class=&quot;headerlink&quot; title=&quot;python词频分析&quot;&gt;&lt;/a&gt;python词频分析&lt;/h1&gt;&lt;p&gt;程序分析了”主要业务”文件夹的所有文件中的文本信息的词频(分别存储在”词频”文件夹中)&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="jieba" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/jieba/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="os" scheme="http://example.com/tags/os/"/>
    
    <category term="jieba" scheme="http://example.com/tags/jieba/"/>
    
    <category term="pandas" scheme="http://example.com/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | sqrt</title>
    <link href="http://example.com/2021/10/27/sqrt/"/>
    <id>http://example.com/2021/10/27/sqrt/</id>
    <published>2021-10-27T13:25:35.000Z</published>
    <updated>2021-10-27T13:37:33.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="69-sqrt-x"><a href="#69-sqrt-x" class="headerlink" title="69.sqrt(x)"></a>69.sqrt(x)</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个非负整数 x ，计算并返回 x 的 算术平方根 。<br>由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。<br>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</p><p><a href="https://leetcode-cn.com/problems/sqrtx/">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.二分法</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):    @staticmethod    def my_sqrt1(a):        &quot;&quot;&quot;二分法开根号&quot;&quot;&quot;        # 初始化左右边界        left, right = 0, a        while left &lt;= right:            mid = (left + right) // 2            if mid ** 2 == a:                return mid            elif mid ** 2 &gt; a:                right = mid - 1            else:                left = mid + 1        return rightif __name__ == &quot;__main__&quot;:    a = 3    s = Solution()    sqrt_a = s.my_sqrt1(a)    print(sqrt_a)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;69-sqrt-x&quot;&gt;&lt;a href=&quot;#69-sqrt-x&quot; class=&quot;headerlink&quot; title=&quot;69.sqrt(x)&quot;&gt;&lt;/a&gt;69.sqrt(x)&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;header</summary>
      
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>pypiwin32 | 批量发送不同内容的邮件给不同的收件人</title>
    <link href="http://example.com/2021/10/27/%E6%89%B9%E9%87%8F%E5%8F%91%E9%80%81%E4%B8%8D%E5%90%8C%E5%86%85%E5%AE%B9%E7%9A%84%E9%82%AE%E4%BB%B6%E7%BB%99%E4%B8%8D%E5%90%8C%E7%9A%84%E6%94%B6%E4%BB%B6%E4%BA%BA/"/>
    <id>http://example.com/2021/10/27/%E6%89%B9%E9%87%8F%E5%8F%91%E9%80%81%E4%B8%8D%E5%90%8C%E5%86%85%E5%AE%B9%E7%9A%84%E9%82%AE%E4%BB%B6%E7%BB%99%E4%B8%8D%E5%90%8C%E7%9A%84%E6%94%B6%E4%BB%B6%E4%BA%BA/</id>
    <published>2021-10-27T12:54:32.000Z</published>
    <updated>2021-10-27T13:22:09.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="批量发送不同内容的邮件给不同的收件人"><a href="#批量发送不同内容的邮件给不同的收件人" class="headerlink" title="批量发送不同内容的邮件给不同的收件人"></a>批量发送不同内容的邮件给不同的收件人</h1><p>程序实现自动将’年假_按部门’下各个部门的年假情况Excel表格发送给’邮件地址.xlsx’中各个部门的负责人。</p><span id="more"></span><p>实现代码：</p><pre><code>import osfrom openpyxl import load_workbookwb = load_workbook(&quot;邮件地址.xlsx&quot;)ws = wb.activeaddress = &#123;&#125;for i in range(2, ws.max_row + 1):    dept = ws[&quot;A&quot; + str(i)].value    to_add = ws[&quot;B&quot; + str(i)].value    cc_add = ws[&quot;C&quot; + str(i)].value    address[dept] = [to_add, cc_add]import win32com.client as win32def Send_mail(to_add, cc_add, file_path, dept):    &#39;&#39;&#39;    传入参数说明：    to_add,收件人地址    cc_add,抄送地址    file_path,附件路径    dept,部门名称    &#39;&#39;&#39;    outlook = win32.Dispatch(&#39;Outlook.Application&#39;)  # 调用windows outlook应用    mail = outlook.CreateItem(0)  # 创建邮件    mail.to = to_add  # 收件人    mail.cc = cc_add  # 抄送人    mail.Subject = &quot;&#123;&#125;年假情况&quot;.format(dept)  # 主题    mail.Attachments.Add(file_path)  # 添加附件。若有多个附件，则多调用几次即可    mail.Body = &#39;&#39;&#39;Dear All,\n这是&#123;&#125;的年假情况，请查收！谢谢。\n\nBest regards!\n人事部 小李&#39;&#39;&#39;.format(dept)  # 正文内容    mail.Send()  # 发送邮件# 发送邮件到各部门for dept in address.keys():    to_add = address[dept][0]    cc_add = address[dept][1]    file_path = os.getcwd() + &#39;\\年假_按部门\\年假情况_&#123;&#125;.xlsx&#39;.format(dept)    Send_mail(to_add, cc_add, file_path, dept)print(&quot;邮件发送完成。&quot;)</code></pre><p>‘年假_按部门’文件夹包括以下内容：<br><a href="年假情况_人事部.xlsx">年假情况_人事部.xlsx</a><br><a href="年假情况_关务部.xlsx">年假情况_关务部.xlsx</a><br><a href="年假情况_品质部.xlsx">年假情况_品质部.xlsx</a><br><a href="年假情况_工程部.xlsx">年假情况_工程部.xlsx</a><br><a href="年假情况_总务部.xlsx">年假情况_总务部.xlsx</a><br><a href="年假情况_物料部.xlsx">年假情况_物料部.xlsx</a><br><a href="年假情况_生产部.xlsx">年假情况_生产部.xlsx</a><br><a href="年假情况_研发部.xlsx">年假情况_研发部.xlsx</a><br><a href="年假情况_船务部.xlsx">年假情况_船务部.xlsx</a><br><a href="年假情况_采购部.xlsx">年假情况_采购部.xlsx</a></p><p><a href="邮件地址.xlsx">邮件地址.xlsx</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;批量发送不同内容的邮件给不同的收件人&quot;&gt;&lt;a href=&quot;#批量发送不同内容的邮件给不同的收件人&quot; class=&quot;headerlink&quot; title=&quot;批量发送不同内容的邮件给不同的收件人&quot;&gt;&lt;/a&gt;批量发送不同内容的邮件给不同的收件人&lt;/h1&gt;&lt;p&gt;程序实现自动将’年假_按部门’下各个部门的年假情况Excel表格发送给’邮件地址.xlsx’中各个部门的负责人。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="pypiwin32" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pypiwin32/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="openpyxl" scheme="http://example.com/tags/openpyxl/"/>
    
    <category term="pypiwin32" scheme="http://example.com/tags/pypiwin32/"/>
    
  </entry>
  
  <entry>
    <title>os | python批量重命名文件</title>
    <link href="http://example.com/2021/10/27/python%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6/"/>
    <id>http://example.com/2021/10/27/python%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6/</id>
    <published>2021-10-27T12:37:41.000Z</published>
    <updated>2021-10-27T13:19:21.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python批量重命名文件"><a href="#python批量重命名文件" class="headerlink" title="python批量重命名文件"></a>python批量重命名文件</h1><p>程序将’文件’文件夹下的所有文件重命名。</p><span id="more"></span><p>实现代码：</p><pre><code>import osdef Get_modify_time(file):    return os.path.getmtime(file)  # 获取文件修改时间path = &#39;文件&#39;  # 文件所在文件夹files = [path + &quot;\\&quot; + i for i in os.listdir(path)]  # 获取文件夹下的文件名,并拼接完整路径files.sort(key=Get_modify_time)  # 以文件修改时间为依据升序排序seq = 1  # 计数器，从1开始for file in files:    os.rename(file, os.path.join(path, str(seq) + &quot;. &quot; + file.split(&quot;\\&quot;)[-1]))  # 重命名文件    seq += 1</code></pre><p>‘文件’文件夹包括以下文件：<br><a href="说明.docx">说明.docx</a><br><a href="文档.txt">文档.txt</a><br><a href="演示文稿 - v1.pptx">演示文稿 - v1.pptx</a><br><a href="演示文稿.pptx">演示文稿.pptx</a><br><a href="资料.xlsx">资料.xlsx</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;python批量重命名文件&quot;&gt;&lt;a href=&quot;#python批量重命名文件&quot; class=&quot;headerlink&quot; title=&quot;python批量重命名文件&quot;&gt;&lt;/a&gt;python批量重命名文件&lt;/h1&gt;&lt;p&gt;程序将’文件’文件夹下的所有文件重命名。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="内置模块" scheme="http://example.com/categories/python/%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/"/>
    
    <category term="os" scheme="http://example.com/categories/python/%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/os/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="os" scheme="http://example.com/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>baidu-aip | python调用人工智能识别表格</title>
    <link href="http://example.com/2021/10/27/python%E8%B0%83%E7%94%A8%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%AF%86%E5%88%AB%E8%A1%A8%E6%A0%BC/"/>
    <id>http://example.com/2021/10/27/python%E8%B0%83%E7%94%A8%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%AF%86%E5%88%AB%E8%A1%A8%E6%A0%BC/</id>
    <published>2021-10-27T12:19:47.000Z</published>
    <updated>2021-10-27T12:25:43.009Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python调用人工智能识别表格"><a href="#python调用人工智能识别表格" class="headerlink" title="python调用人工智能识别表格"></a>python调用人工智能识别表格</h1><p>使用百度的OCR API识别表格中的文字。<br><a href="https://blog.csdn.net/weixin_39932611/article/details/112354147">参考资料1</a><br><a href="https://blog.csdn.net/weixin_44298740/article/details/117560495">参考资料2</a></p><span id="more"></span><pre><code># coding:utf-8# 获取路径下所有图片文件，并存入列表import oswork_path = &quot;图片\\&quot;pictures = []  # 存储文件夹内所有文件的路径（包括子目录内的文件）for root, dirs, files in os.walk(work_path):    path = [os.path.join(root, name) for name in files]    pictures.extend(path)from aip import AipOcr  # 导入AipOcr模块，用于做文字识别import time  # 时间模块import requests  # 用于HTTP请求APP_ID = &#39;25067363&#39;API_KEY = &#39;0PRCHim4nzLcDNEYR1hcSGGG&#39;SECRET_KEY = &#39;DFGtcTbhpD829q9GOUbjPYameEty7C6i&#39;client = AipOcr(APP_ID, API_KEY, SECRET_KEY)# 提交识别请求，并储存所有请求IDfor picture in pictures:    pic = open(picture, &#39;rb&#39;)  # 以二进制方式打开图片    img = pic.read()  # 读取    table = client.tableRecognitionAsync(img)  # 调用表格识别模块    print(table)    # request_id = table[&#39;result&#39;][0][&#39;request_id&#39;]    #    # # 判断识别是否完成，直到完成才根据请求ID获取Excel下载路径    # result = client.getTableRecognitionResult(request_id)  # 通过ID获取识别结果    # while result[&#39;result&#39;][&#39;ret_msg&#39;] != &#39;已完成&#39;:  # 如果状态是“已完成”，才能获取下载地址    #     time.sleep(2)  # 暂停2秒再刷新    #     result = client.getTableRecognitionResult(request_id)  # 持续刷新，直到满足条件    #    # download_path = result[&#39;result&#39;][&#39;result_data&#39;]    #    # # 下载并将Excel文件名设为图片名    # excel_name = picture.split(&quot;.&quot;)[0] + &quot;.xls&quot;  # 让excel文件的名字与图片相同    # excel = requests.get(download_path)  # 抓取下载链接    # file = open(excel_name, &#39;wb&#39;)  # 新建excel文件    # file.write(excel.content)  # 写入excel文件并保存    </code></pre><p><a href="论文.jpg">论文.jpg</a><br><a href="收货表.jpg">收货表.jpg</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;python调用人工智能识别表格&quot;&gt;&lt;a href=&quot;#python调用人工智能识别表格&quot; class=&quot;headerlink&quot; title=&quot;python调用人工智能识别表格&quot;&gt;&lt;/a&gt;python调用人工智能识别表格&lt;/h1&gt;&lt;p&gt;使用百度的OCR API识别表格中的文字。&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_39932611/article/details/112354147&quot;&gt;参考资料1&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_44298740/article/details/117560495&quot;&gt;参考资料2&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="baidu-aip" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/baidu-aip/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="os" scheme="http://example.com/tags/os/"/>
    
    <category term="time" scheme="http://example.com/tags/time/"/>
    
    <category term="requests" scheme="http://example.com/tags/requests/"/>
    
    <category term="baidu-aip" scheme="http://example.com/tags/baidu-aip/"/>
    
  </entry>
  
  <entry>
    <title>CNN | 卷积神经网络如何处理一维时间序列数据</title>
    <link href="http://example.com/2021/10/26/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%B8%80%E7%BB%B4%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE/"/>
    <id>http://example.com/2021/10/26/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%B8%80%E7%BB%B4%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE/</id>
    <published>2021-10-27T03:28:20.000Z</published>
    <updated>2021-10-27T03:31:42.930Z</updated>
    
    <content type="html"><![CDATA[<h1 id="卷积神经网络如何处理一维时间序列数据"><a href="#卷积神经网络如何处理一维时间序列数据" class="headerlink" title="卷积神经网络如何处理一维时间序列数据?"></a>卷积神经网络如何处理一维时间序列数据?</h1><p><a href="https://zhuanlan.zhihu.com/p/67496559">卷积神经网络如何处理一维时间序列数据?</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;卷积神经网络如何处理一维时间序列数据&quot;&gt;&lt;a href=&quot;#卷积神经网络如何处理一维时间序列数据&quot; class=&quot;headerlink&quot; title=&quot;卷积神经网络如何处理一维时间序列数据?&quot;&gt;&lt;/a&gt;卷积神经网络如何处理一维时间序列数据?&lt;/h1&gt;&lt;p&gt;&lt;a h</summary>
      
    
    
    
    <category term="深度学习" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="深度学习基础" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
    <category term="CNN" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/CNN/"/>
    
    
    <category term="深度学习" scheme="http://example.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="CNN" scheme="http://example.com/tags/CNN/"/>
    
  </entry>
  
  <entry>
    <title>CNN | 卷积神经网络(一维卷积、二维卷积、三维卷积)</title>
    <link href="http://example.com/2021/10/26/%E4%B8%80%E7%BB%B4%E5%8D%B7%E7%A7%AF%E4%BA%8C%E7%BB%B4%E5%8D%B7%E7%A7%AF%E4%B8%89%E7%BB%B4%E5%8D%B7%E7%A7%AF/"/>
    <id>http://example.com/2021/10/26/%E4%B8%80%E7%BB%B4%E5%8D%B7%E7%A7%AF%E4%BA%8C%E7%BB%B4%E5%8D%B7%E7%A7%AF%E4%B8%89%E7%BB%B4%E5%8D%B7%E7%A7%AF/</id>
    <published>2021-10-27T02:10:04.000Z</published>
    <updated>2021-10-27T03:30:46.457Z</updated>
    
    <content type="html"><![CDATA[<h1 id="卷积神经网络-一维卷积、二维卷积、三维卷积"><a href="#卷积神经网络-一维卷积、二维卷积、三维卷积" class="headerlink" title="卷积神经网络(一维卷积、二维卷积、三维卷积)"></a>卷积神经网络(一维卷积、二维卷积、三维卷积)</h1><p><a href="https://www.cnblogs.com/szxspark/p/8445406.html">一维卷积、二维卷积、三维卷积</a><br><a href="https://blog.csdn.net/weixin_44378513/article/details/112307989?spm=1001.2101.3001.6650.17&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-17.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-17.no_search_link">1D CNN+2D CNN+3D CNN</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;卷积神经网络-一维卷积、二维卷积、三维卷积&quot;&gt;&lt;a href=&quot;#卷积神经网络-一维卷积、二维卷积、三维卷积&quot; class=&quot;headerlink&quot; title=&quot;卷积神经网络(一维卷积、二维卷积、三维卷积)&quot;&gt;&lt;/a&gt;卷积神经网络(一维卷积、二维卷积、三维卷积)</summary>
      
    
    
    
    <category term="深度学习" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="深度学习基础" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
    <category term="CNN" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/CNN/"/>
    
    
    <category term="深度学习" scheme="http://example.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="一维卷积" scheme="http://example.com/tags/%E4%B8%80%E7%BB%B4%E5%8D%B7%E7%A7%AF/"/>
    
    <category term="二维卷积" scheme="http://example.com/tags/%E4%BA%8C%E7%BB%B4%E5%8D%B7%E7%A7%AF/"/>
    
    <category term="三维卷积" scheme="http://example.com/tags/%E4%B8%89%E7%BB%B4%E5%8D%B7%E7%A7%AF/"/>
    
  </entry>
  
  <entry>
    <title>pygame | 植物大战僵尸</title>
    <link href="http://example.com/2021/10/25/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8/"/>
    <id>http://example.com/2021/10/25/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8/</id>
    <published>2021-10-25T13:54:30.000Z</published>
    <updated>2021-10-27T01:53:06.110Z</updated>
    
    <content type="html"><![CDATA[<h1 id="植物大战僵尸"><a href="#植物大战僵尸" class="headerlink" title="植物大战僵尸"></a>植物大战僵尸</h1><p>python pygame 实现植物大战僵尸.<br><a href="https://blog.csdn.net/Gtieguo/article/details/112093640">植物大战僵尸</a></p><span id="more"></span><p>实现代码：</p><pre><code># 引入需要的模块import pygameimport random# 配置图片地址IMAGE_PATH = &#39;imgs/&#39;# 设置页面宽高scrrr_width = 800scrrr_height = 560# 创建控制游戏结束的状态GAMEOVER = False# 图片加载报错处理LOG = &#39;文件:&#123;&#125;中的方法:&#123;&#125;出错&#39;.format(__file__, __name__)# 创建地图类class Map():    map_names_list = [IMAGE_PATH + &#39;map1.png&#39;, IMAGE_PATH + &#39;map2.png&#39;]    # 初始化地图    def __init__(self, x, y, img_index):        self.image = pygame.image.load(Map.map_names_list[img_index])        self.position = (x, y)        # 是否能够种植        self.can_grow = True    # 加载地图    def load_map(self):        MainGame.window.blit(self.image, self.position)# 植物类class Plant(pygame.sprite.Sprite):    def __init__(self):        super(Plant, self).__init__()        self.live = True    def load_image(self):        if hasattr(self, &#39;image&#39;) and hasattr(self, &#39;rect&#39;):            MainGame.window.blit(self.image, self.rect)        else:            print(LOG)# 向日葵类class Sunflower(Plant):    def __init__(self, x, y):        super(Sunflower, self).__init__()        self.image = pygame.image.load(&#39;imgs/sunflower.png&#39;)        self.rect = self.image.get_rect()        self.rect.x = x        self.rect.y = y        self.price = 50        self.hp = 100        # 5 时间计数器        self.time_count = 0    # 新增功能：生成阳光    def produce_money(self):        self.time_count += 1        if self.time_count == 25:            MainGame.money += 5            self.time_count = 0    # 向日葵加入到窗口中    def display_sunflower(self):        MainGame.window.blit(self.image, self.rect)# 豌豆射手类class PeaShooter(Plant):    def __init__(self, x, y):        super(PeaShooter, self).__init__()        # self.image 为一个 surface        self.image = pygame.image.load(&#39;imgs/peashooter.png&#39;)        self.rect = self.image.get_rect()        self.rect.x = x        self.rect.y = y        self.price = 50        self.hp = 200        # 6 发射计数器        self.shot_count = 0    # 增加射击方法    def shot(self):        # 6 记录是否应该射击        should_fire = False        for zombie in MainGame.zombie_list:            if zombie.rect.y == self.rect.y and zombie.rect.x &lt; 800 and zombie.rect.x &gt; self.rect.x:                should_fire = True        # 6 如果活着        if self.live and should_fire:            self.shot_count += 1            # 6 计数器到25发射一次            if self.shot_count == 25:                # 6 基于当前豌豆射手的位置，创建子弹                peabullet = PeaBullet(self)                # 6 将子弹存储到子弹列表中                MainGame.peabullet_list.append(peabullet)                self.shot_count = 0    # 将豌豆射手加入到窗口中的方法    def display_peashooter(self):        MainGame.window.blit(self.image, self.rect)# 豌豆子弹类class PeaBullet(pygame.sprite.Sprite):    def __init__(self, peashooter):        self.live = True        self.image = pygame.image.load(&#39;imgs/peabullet.png&#39;)        self.damage = 50        self.speed = 10        self.rect = self.image.get_rect()        self.rect.x = peashooter.rect.x + 60        self.rect.y = peashooter.rect.y + 15    def move_bullet(self):        # 7 在屏幕范围内，实现往右移动        if self.rect.x &lt; scrrr_width:            self.rect.x += self.speed        else:            self.live = False    # 7 新增，子弹与僵尸的碰撞    def hit_zombie(self):        for zombie in MainGame.zombie_list:            if pygame.sprite.collide_rect(self, zombie):                # 打中僵尸之后，修改子弹的状态，                self.live = False                # 僵尸掉血                zombie.hp -= self.damage                if zombie.hp &lt;= 0:                    zombie.live = False                    self.nextLevel()    # 7闯关方法    def nextLevel(self):        MainGame.score += 20        MainGame.remnant_score -= 20        for i in range(1, 100):            if MainGame.score == 100 * i and MainGame.remnant_score == 0:                MainGame.remnant_score = 100 * i                MainGame.shaoguan += 1                MainGame.produce_zombie += 50    def display_peabullet(self):        MainGame.window.blit(self.image, self.rect)# 僵尸类class Zombie(pygame.sprite.Sprite):    def __init__(self, x, y):        super(Zombie, self).__init__()        self.image = pygame.image.load(&#39;imgs/zombie.png&#39;)        self.rect = self.image.get_rect()        self.rect.x = x        self.rect.y = y        self.hp = 1000        self.damage = 2        self.speed = 1        self.live = True        self.stop = False    # 9 僵尸的移动    def move_zombie(self):        if self.live and not self.stop:            self.rect.x -= self.speed            if self.rect.x &lt; -80:                # 8 调用游戏结束方法                MainGame().gameOver()    # 9 判断僵尸是否碰撞到植物，如果碰撞，调用攻击植物的方法    def hit_plant(self):        for plant in MainGame.plants_list:            if pygame.sprite.collide_rect(self, plant):                # 8  僵尸移动状态的修改                self.stop = True                self.eat_plant(plant)    # 9 僵尸攻击植物    def eat_plant(self, plant):        # 9 植物生命值减少        plant.hp -= self.damage        # 9 植物死亡后的状态修改，以及地图状态的修改        if plant.hp &lt;= 0:            a = plant.rect.y // 80 - 1            b = plant.rect.x // 80            map = MainGame.map_list[a][b]            map.can_grow = True            plant.live = False            # 8 修改僵尸的移动状态            self.stop = False    # 9 将僵尸加载到地图中    def display_zombie(self):        MainGame.window.blit(self.image, self.rect)# 主程序class MainGame():    # 2 创建关数，得分，剩余分数，钱数    shaoguan = 1    score = 0    remnant_score = 100    money = 200    # 3 存储所有地图坐标点    map_points_list = []    # 3 存储所有的地图块    map_list = []    # 4 存储所有植物的列表    plants_list = []    # 7 存储所有豌豆子弹的列表    peabullet_list = []    # 9 新增存储所有僵尸的列表    zombie_list = []    count_zombie = 0    produce_zombie = 100    # 1 加载游戏窗口    def init_window(self):        # 1 调用显示模块的初始化        pygame.display.init()        # 1 创建窗口        MainGame.window = pygame.display.set_mode([scrrr_width, scrrr_height])    # 2 文本绘制    def draw_text(self, content, size, color):        pygame.font.init()        font = pygame.font.SysFont(&#39;kaiti&#39;, size)        text = font.render(content, True, color)        return text    # 2 加载帮助提示    def load_help_text(self):        text1 = self.draw_text(&#39;1.按左键创建向日葵 2.按右键创建豌豆射手&#39;, 26, (255, 0, 0))        MainGame.window.blit(text1, (5, 5))    # 3 初始化坐标点    def init_plant_points(self):        for y in range(1, 7):            points = []            for x in range(10):                point = (x, y)                points.append(point)            MainGame.map_points_list.append(points)            print(&quot;MainGame.map_points_list&quot;, MainGame.map_points_list)    # 3 初始化地图    def init_map(self):        for points in MainGame.map_points_list:            temp_map_list = list()            for point in points:                # map = None                if (point[0] + point[1]) % 2 == 0:                    map = Map(point[0] * 80, point[1] * 80, 0)                else:                    map = Map(point[0] * 80, point[1] * 80, 1)                # 将地图块加入到窗口中                temp_map_list.append(map)                print(&quot;temp_map_list&quot;, temp_map_list)            MainGame.map_list.append(temp_map_list)        print(&quot;MainGame.map_list&quot;, MainGame.map_list)    # 3 将地图加载到窗口中    def load_map(self):        for temp_map_list in MainGame.map_list:            for map in temp_map_list:                map.load_map()    # 6 增加豌豆射手发射处理    def load_plants(self):        for plant in MainGame.plants_list:            # 6 优化加载植物的处理逻辑            if plant.live:                if isinstance(plant, Sunflower):                    plant.display_sunflower()                    plant.produce_money()                elif isinstance(plant, PeaShooter):                    plant.display_peashooter()                    plant.shot()            else:                MainGame.plants_list.remove(plant)    # 7 加载所有子弹的方法    def load_peabullets(self):        for b in MainGame.peabullet_list:            if b.live:                b.display_peabullet()                b.move_bullet()                # v1.9 调用子弹是否打中僵尸的方法                b.hit_zombie()            else:                MainGame.peabullet_list.remove(b)    # 8事件处理    def deal_events(self):        # 8 获取所有事件        eventList = pygame.event.get()        # 8 遍历事件列表，判断        for e in eventList:            if e.type == pygame.QUIT:                self.gameOver()            elif e.type == pygame.MOUSEBUTTONDOWN:                # print(&#39;按下鼠标按键&#39;)                print(e.pos)                # print(e.button)#左键1  按下滚轮2 上转滚轮为4 下转滚轮为5  右键 3                x = e.pos[0] // 80                y = e.pos[1] // 80                print(x, y)                map = MainGame.map_list[y - 1][x]                print(map.position)                # 8 增加创建时候的地图装填判断以及金钱判断                if e.button == 1:                    if map.can_grow and MainGame.money &gt;= 50:                        sunflower = Sunflower(map.position[0], map.position[1])                        MainGame.plants_list.append(sunflower)                        print(&#39;当前植物列表长度:&#123;&#125;&#39;.format(len(MainGame.plants_list)))                        map.can_grow = False                        MainGame.money -= 50                elif e.button == 3:                    if map.can_grow and MainGame.money &gt;= 50:                        peashooter = PeaShooter(                            map.position[0], map.position[1])                        MainGame.plants_list.append(peashooter)                        print(&#39;当前植物列表长度:&#123;&#125;&#39;.format(len(MainGame.plants_list)))                        map.can_grow = False                        MainGame.money -= 50    # 9 新增初始化僵尸的方法    def init_zombies(self):        for i in range(1, 7):            dis = random.randint(1, 5) * 200            zombie = Zombie(800 + dis, i * 80)            MainGame.zombie_list.append(zombie)    # 9将所有僵尸加载到地图中    def load_zombies(self):        for zombie in MainGame.zombie_list:            if zombie.live:                zombie.display_zombie()                zombie.move_zombie()                # v2.0 调用是否碰撞到植物的方法                zombie.hit_plant()            else:                MainGame.zombie_list.remove(zombie)    # 1 开始游戏    def start_game(self):        # 1 初始化窗口        self.init_window()        # 3 初始化坐标和地图        self.init_plant_points()        self.init_map()        # 9 调用初始化僵尸的方法        self.init_zombies()        # 1 只要游戏没结束，就一直循环        while not GAMEOVER:            # 1 渲染白色背景            MainGame.window.fill((255, 255, 255))            # 2 渲染的文字和坐标位置            MainGame.window.blit(                self.draw_text(                    &#39;当前钱数$: &#123;&#125;&#39;.format(                        MainGame.money), 26, (255, 0, 0)), (500, 40))            MainGame.window.blit(                self.draw_text(                    &#39;当前关数&#123;&#125;，得分&#123;&#125;,距离下关还差&#123;&#125;分&#39;.format(                        MainGame.shaoguan,                        MainGame.score,                        MainGame.remnant_score),                    26,                    (255,                     0,                     0)),                (5,                 40))            self.load_help_text()            # 3 需要反复加载地图            self.load_map()            # 6 调用加载植物的方法            self.load_plants()            # 7  调用加载所有子弹的方法            self.load_peabullets()            # 8 调用事件处理的方法            self.deal_events()            # 9 调用展示僵尸的方法            self.load_zombies()            # 9 计数器增长，每数到100，调用初始化僵尸的方法            MainGame.count_zombie += 1            if MainGame.count_zombie == MainGame.produce_zombie:                self.init_zombies()                MainGame.count_zombie = 0            pygame.time.wait(10)            pygame.display.update()    def gameOver(self):        MainGame.window.blit(            self.draw_text(                &#39;游戏结束&#39;, 50, (255, 0, 0)), (300, 200))        print(&#39;游戏结束&#39;)        pygame.time.wait(400)        global GAMEOVER        GAMEOVER = Trueif __name__ == &#39;__main__&#39;:    game = MainGame()    game.start_game()</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;植物大战僵尸&quot;&gt;&lt;a href=&quot;#植物大战僵尸&quot; class=&quot;headerlink&quot; title=&quot;植物大战僵尸&quot;&gt;&lt;/a&gt;植物大战僵尸&lt;/h1&gt;&lt;p&gt;python pygame 实现植物大战僵尸.&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/Gtieguo/article/details/112093640&quot;&gt;植物大战僵尸&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="pygame" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pygame/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="pygame" scheme="http://example.com/tags/pygame/"/>
    
    <category term="植物大战僵尸" scheme="http://example.com/tags/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8/"/>
    
  </entry>
  
  <entry>
    <title>openpyxl | 在Excel中按条件筛选数据并存入新的表</title>
    <link href="http://example.com/2021/10/25/%E5%9C%A8Excel%E4%B8%AD%E6%8C%89%E6%9D%A1%E4%BB%B6%E7%AD%9B%E9%80%89%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%AD%98%E5%85%A5%E6%96%B0%E7%9A%84%E8%A1%A8/"/>
    <id>http://example.com/2021/10/25/%E5%9C%A8Excel%E4%B8%AD%E6%8C%89%E6%9D%A1%E4%BB%B6%E7%AD%9B%E9%80%89%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%AD%98%E5%85%A5%E6%96%B0%E7%9A%84%E8%A1%A8/</id>
    <published>2021-10-25T09:20:44.000Z</published>
    <updated>2021-10-25T09:23:19.682Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在Excel中按条件筛选数据并存入新的表"><a href="#在Excel中按条件筛选数据并存入新的表" class="headerlink" title="在Excel中按条件筛选数据并存入新的表"></a>在Excel中按条件筛选数据并存入新的表</h1><p>实现代码：</p><pre><code># 1.获取满足条件的数据from openpyxl import load_workbookwb = load_workbook(&quot;每月物料表.xlsx&quot;)data = &#123;&#125;  # 储存所有工作表中满足条件的数据，以工作表名称为键sheet_names = wb.sheetnamesfor sheet_name in sheet_names:    ws = wb[sheet_name]    qty_list = []    # 获取G列的数据，并用enumrate给其对应的元素编号    for row in range(2, ws.max_row + 1):        qty = ws[&#39;G&#39; + str(row)].value        qty_list.append(qty)    # print(qty_list)    qty_idx = list(enumerate(qty_list))  # 用于编号    # 判断数据是否大于1000，然后返回大于1000的数据所对应的行数    row_idx = []  # 用于储存数量大于1000所对应的的行号    for i in range(len(qty_idx)):        if qty_idx[i][1] &gt; 1000:            row_idx.append(qty_idx[i][0] + 2)    # print(row_idx)    # 获取满足条件的数据    data_morethan1K = []    for i in row_idx:        data_morethan1K.append(ws[&#39;A&#39; + str(i) + &quot;:&quot; + &#39;I&#39; + str(i)])    # print(data_morethan1K)    data[sheet_name] = data_morethan1K# 2.写入获取的数据from openpyxl.styles import Border, Side, PatternFill, Font, GradientFill, Alignmentthin = Side(border_style=&quot;thin&quot;, color=&quot;000000&quot;)  # 定义边框粗细及颜色wb = load_workbook(&quot;模板.xlsx&quot;)ws = wb.activefor month in data.keys():    ws_new = wb.copy_worksheet(ws)  # 复制模板中的工作表    ws_new.title = month    print(ws_new.title)    # 将每个月的数据条数逐个取出并写入新的工作表    for i in range(len(data[month])):  # 按数据行数计数，每行数据对应9列，所以每行需分别写入9个单元格        ws_new.cell(row=i + 2, column=1).value = data[month][i][0][0].value        ws_new.cell(row=i + 2, column=2).value = data[month][i][0][1].value        ws_new.cell(row=i + 2, column=3).value = data[month][i][0][2].value        ws_new.cell(row=i + 2, column=4).value = data[month][i][0][3].value.date()        ws_new.cell(row=i + 2, column=5).value = data[month][i][0][4].value        ws_new.cell(row=i + 2, column=6).value = data[month][i][0][5].value        ws_new.cell(row=i + 2, column=7).value = data[month][i][0][6].value        ws_new.cell(row=i + 2, column=8).value = data[month][i][0][7].value        ws_new.cell(row=i + 2, column=9).value = data[month][i][0][8].value    # 设置字号，对齐，缩小字体填充，加边框    # Font(bold=True)可加粗字体    for row_number in range(2, ws_new.max_row + 1):        for col_number in range(1, 10):            c = ws_new.cell(row=row_number, column=col_number)            c.font = Font(size=10)            c.border = Border(top=thin, left=thin, right=thin, bottom=thin)            c.alignment = Alignment(horizontal=&quot;left&quot;, vertical=&quot;center&quot;, shrink_to_fit=True)wb.save(&quot;每月(大于1K).xlsx&quot;)</code></pre><p><a href="模板.xlsx">模板.xlsx</a><br><a href="每月物料表.xlsx">每月物料表.xlsx</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;在Excel中按条件筛选数据并存入新的表&quot;&gt;&lt;a href=&quot;#在Excel中按条件筛选数据并存入新的表&quot; class=&quot;headerlink&quot; title=&quot;在Excel中按条件筛选数据并存入新的表&quot;&gt;&lt;/a&gt;在Excel中按条件筛选数据并存入新的表&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="openpyxl" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/openpyxl/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="openpyxl" scheme="http://example.com/tags/openpyxl/"/>
    
  </entry>
  
  <entry>
    <title>openpyxl | 用Python在Excel中查找并替换数据</title>
    <link href="http://example.com/2021/10/25/%E7%94%A8Python%E5%9C%A8Excel%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%B9%B6%E6%9B%BF%E6%8D%A2%E6%95%B0%E6%8D%AE/"/>
    <id>http://example.com/2021/10/25/%E7%94%A8Python%E5%9C%A8Excel%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%B9%B6%E6%9B%BF%E6%8D%A2%E6%95%B0%E6%8D%AE/</id>
    <published>2021-10-25T08:10:48.000Z</published>
    <updated>2021-10-27T13:17:02.223Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用Python在Excel中查找并替换数据"><a href="#用Python在Excel中查找并替换数据" class="headerlink" title="用Python在Excel中查找并替换数据"></a>用Python在Excel中查找并替换数据</h1><p>实现代码：</p><pre><code>from openpyxl import load_workbook  # 用于读取Excel中的信息# 获取Excel表格中的数据wb = load_workbook(&#39;查找替换.xlsx&#39;)  # 读取工作簿ws = wb.active  # 读取活动工作表data = &#123;&#125;  # 新建字典，用于储存数据for row in range(2, ws.max_row + 1):    chazhao = str(ws[&#39;A&#39; + str(row)].value)  # 转换成字符串，以免后续比对时出现数据类型冲突    tihuan = str(ws[&#39;B&#39; + str(row)].value)  # 转换成字符串，以免后续比对时出现数据类型冲突    data[chazhao] = tihuan  # 键值对应存入字典wb = load_workbook(&#39;原表.xlsx&#39;)  # 读取目标工作簿ws = wb.activeID_list = []  # 新建一个列表，用于储存原表D列的信息for row in range(2, ws.max_row + 1):    ID = ws[&#39;D&#39; + str(row)].value  # 遍历整个工作表，将D列的数据逐个存入ID变量    ID_list.append(ID)  # 将读取到的结果存入列表code = []for i in ID_list:    if i is None:  # 如果是None，则放入None占位，以保持列表的值的顺序与原表一致        code.append(None)    else:        code.append(i.split(&quot;：&quot;)[-1])  # 不是None,则按&quot;：&quot;符号分割，并放分割后的最后一个值进入新列表codefor i in range(len(code)):    if code[i] in data:        ws.cell(row=i + 2, column=4).value = ID_list[i].split(&quot;：&quot;)[0] + &quot;：&quot; + data[code[i]]wb.save(&#39;原表-替换.xlsx&#39;)</code></pre><p><a href="查找替换.xlsx">查找替换.xlsx</a><br><a href="原表.xlsx">原表.xlsx</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;用Python在Excel中查找并替换数据&quot;&gt;&lt;a href=&quot;#用Python在Excel中查找并替换数据&quot; class=&quot;headerlink&quot; title=&quot;用Python在Excel中查找并替换数据&quot;&gt;&lt;/a&gt;用Python在Excel中查找并替换数据&lt;/</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="openpyxl" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/openpyxl/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="openpyxl" scheme="http://example.com/tags/openpyxl/"/>
    
  </entry>
  
  <entry>
    <title>PIL | 批量压缩图片</title>
    <link href="http://example.com/2021/10/24/%E6%89%B9%E9%87%8F%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87/"/>
    <id>http://example.com/2021/10/24/%E6%89%B9%E9%87%8F%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87/</id>
    <published>2021-10-25T07:53:51.000Z</published>
    <updated>2021-10-27T13:15:46.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="批量压缩图片"><a href="#批量压缩图片" class="headerlink" title="批量压缩图片"></a>批量压缩图片</h1><p>实现代码：</p><pre><code># 将图片按修改时间排序(这样才能与图片的描述一致)，将路径存入列表，以便后面逐个插入图片时调用import osfrom PIL import Imagefrom docx import Documentpath = &quot;6s_pictures&quot;list_p = [path + &quot;\\&quot; + i for i in os.listdir(path)]  # 获取图片的文件名,并拼接完整路径list_p.sort(key=lambda path: os.path.getmtime(path))  # 将列表中的文件按其修改时间排序，os.path.getmtime() 函数是获取文件最后修改时间print(list_p)# 按比例缩小图片尺寸for infile in list_p:    im = Image.open(infile)    (x, y) = im.size  # 读取图片尺寸（像素）    x_s = 165  # 定义缩小后的标准宽度    y_s = int(y * x_s / x)  # 基于标准宽度计算缩小后的高度    out = im.resize((x_s, y_s), Image.ANTIALIAS)  # 改变尺寸，保持图片高品质    out.save(r&quot;6s_pictures_new\&#123;&#125;&quot;.format(infile.split(&quot;\\&quot;)[-1]))path = &quot;6s_pictures_new&quot;list_p = [path + &quot;\\&quot; + i for i in os.listdir(path)]  # 获取图片的文件名,并拼接完整路径list_p.sort(key=lambda path: os.path.getmtime(path))  # 将列表中的文件按其修改时间排序，os.path.getmtime() 函数是获取文件最后修改时间doc = Document(&quot;6S稽查问题模板.docx&quot;)table = doc.tables[0]  # 已确定是第一个表格，其索引是0# 增加需要的行，以便足够填入数据for i in range(len(list_p) - 1):    table.add_row()# 写入数据及图片for row in range(1, len(list_p) + 1):    # 插入图片    run = table.cell(row, 2).paragraphs[0].add_run()  # 新增一个文字块    picture = run.add_picture(list_p[row - 1])  # 插入图片doc.save(&quot;6S稽查问题.docx&quot;)</code></pre><p><a href="https://github.com/victory-liao/victory-liao.github.io/tree/master/source/images/6s_pictures">6s_pictures</a><br><a href="6S稽查问题模板.docx">6S稽查问题模板.docx</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;批量压缩图片&quot;&gt;&lt;a href=&quot;#批量压缩图片&quot; class=&quot;headerlink&quot; title=&quot;批量压缩图片&quot;&gt;&lt;/a&gt;批量压缩图片&lt;/h1&gt;&lt;p&gt;实现代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 将图片按修改时间排序(这样才能与图片的描述一致)，将路径存入列</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="PIL" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/PIL/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="python-docx" scheme="http://example.com/tags/python-docx/"/>
    
    <category term="PIL" scheme="http://example.com/tags/PIL/"/>
    
  </entry>
  
  <entry>
    <title>matplotlib | 绘制双柱状图</title>
    <link href="http://example.com/2021/10/24/matplotlib%E7%BB%98%E5%88%B6%E5%8F%8C%E6%9F%B1%E7%8A%B6%E5%9B%BE/"/>
    <id>http://example.com/2021/10/24/matplotlib%E7%BB%98%E5%88%B6%E5%8F%8C%E6%9F%B1%E7%8A%B6%E5%9B%BE/</id>
    <published>2021-10-25T07:36:09.000Z</published>
    <updated>2021-10-25T07:38:09.997Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用matplotlib绘制双柱状图"><a href="#使用matplotlib绘制双柱状图" class="headerlink" title="使用matplotlib绘制双柱状图"></a>使用matplotlib绘制双柱状图</h1><p>实现代码：</p><pre><code>import matplotlib.pyplot as plt# 定义函数来显示柱状上的数值def autolabel(rects):    for rect in rects:        height = rect.get_height()        plt.text(rect.get_x() + rect.get_width() / 2. - 0.2, 1.03 * height, &#39;%s&#39; % float(height))if __name__ == &#39;__main__&#39;:    l1 = [75, 57, 59, 60, 60]    l2 = [68.39, 58, 54, 58, 55]    # l1 = [68.50, 53.13, 53.04, 52.64, 56.32]    # l2 = [66.31, 53.57, 50.54, 55.54, 47.72]    name = [&#39;CNN-LSTM&#39;, &#39;CNN3Conv&#39;, &#39;CNN5Conv&#39;, &#39;LeNet&#39;, &#39;EEGNet&#39;]    total_width, n = 0.8, 2    width = total_width / n    x = [0, 1, 2, 3, 4]    plt.rc(&#39;font&#39;, family=&#39;SimHei&#39;, size=12)  # 设置中文显示，否则出现乱码！    a = plt.bar(x, l1, width=width, label=&#39;Valence&#39;, fc=&#39;y&#39;)    for i in range(len(x)):        x[i] = x[i] + width    b = plt.bar(x, l2, width=width, label=&#39;Arousal&#39;, tick_label=name, fc=&#39;r&#39;)    autolabel(a)    autolabel(b)    plt.xlabel(&#39;Models&#39;)    plt.ylabel(&#39;Accuracy&#39;)    plt.title(&#39;Valence Accuracy and Arousal Accuracy&#39;)    plt.legend()    plt.show()    plt.savefig(&#39;accuracy.png&#39;)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用matplotlib绘制双柱状图&quot;&gt;&lt;a href=&quot;#使用matplotlib绘制双柱状图&quot; class=&quot;headerlink&quot; title=&quot;使用matplotlib绘制双柱状图&quot;&gt;&lt;/a&gt;使用matplotlib绘制双柱状图&lt;/h1&gt;&lt;p&gt;实现代码：&lt;</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="matplotlib" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/matplotlib/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="matplotlib" scheme="http://example.com/tags/matplotlib/"/>
    
    <category term="双柱状图" scheme="http://example.com/tags/%E5%8F%8C%E6%9F%B1%E7%8A%B6%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>python-docx | 向Word文档中添加图片</title>
    <link href="http://example.com/2021/10/24/%E5%90%91Word%E6%96%87%E6%A1%A3%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87/"/>
    <id>http://example.com/2021/10/24/%E5%90%91Word%E6%96%87%E6%A1%A3%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87/</id>
    <published>2021-10-24T12:59:45.000Z</published>
    <updated>2021-10-24T13:29:34.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="向Word文档中添加图片"><a href="#向Word文档中添加图片" class="headerlink" title="向Word文档中添加图片"></a>向Word文档中添加图片</h1><p>以下代码使用python-docx向Word文档中的指定位置添加图片</p><span id="more"></span><pre><code># 提取Excel表中的数据from openpyxl import load_workbook  # 用于读取Excel中的信息wb = load_workbook(&#39;数据.xlsx&#39;)ws = wb.activedata = []for row in range(2, ws.max_row + 1):    number = ws[&#39;A&#39; + str(row)].value    problem = ws[&#39;B&#39; + str(row)].value    owner = ws[&#39;C&#39; + str(row)].value    info_list = [number, problem, owner]    data.append(info_list)# print(data)from docx import Documentfrom docx.shared import Cmimport osdoc = Document(&quot;6S稽查问题模板.docx&quot;)# 将图片按修改时间排序(这样才能与图片的描述一致)，将路径存入列表，以便后面逐个插入图片时调用path = &quot;6s_pictures&quot;list_p = [path + &quot;\\&quot; + i for i in os.listdir(path)]  # 获取图片的文件名,并拼接完整路径list_p.sort(key=lambda path: os.path.getmtime(path))  # 将列表中的文件按其修改时间排序，os.path.getmtime() 函数是获取文件最后修改时间table = doc.tables[0]  # 已确定是第一个表格，其索引是0# 增加需要的行，以便足够填入数据for i in range(len(data) - 1):    table.add_row()# 写入数据及图片for row in range(1, len(data) + 1):    table.cell(row, 0).text = str(data[row - 1][0])  # 往第1列写入序号    table.cell(row, 1).text = data[row - 1][1]  # 往第2列写入问题描述    table.cell(row, 3).text = data[row - 1][2]  # 往第4列写入责任部门    # 插入图片并调整图片的高度和宽度，以适合模板中的单元格尺寸    run = table.cell(row, 2).paragraphs[0].add_run()  # 新增一个文字块    picture = run.add_picture(list_p[row - 1])  # 插入图片    picture.height = Cm(4.4)  # 设置图片高度    picture.width = Cm(6.2)  # 设置图片宽度doc.save(&quot;6S稽查问题.docx&quot;)</code></pre><p><a href="6S稽查问题模板.docx">6S稽查问题模板.docx</a><br><a href="数据.xlsx">数据.xlsx</a><br><a href="https://github.com/victory-liao/victory-liao.github.io/tree/master/source/images/6s_pictures">6s_pictures</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;向Word文档中添加图片&quot;&gt;&lt;a href=&quot;#向Word文档中添加图片&quot; class=&quot;headerlink&quot; title=&quot;向Word文档中添加图片&quot;&gt;&lt;/a&gt;向Word文档中添加图片&lt;/h1&gt;&lt;p&gt;以下代码使用python-docx向Word文档中的指定位置添加图片&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="python-docx" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/python-docx/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="openpyxl" scheme="http://example.com/tags/openpyxl/"/>
    
    <category term="python-docx" scheme="http://example.com/tags/python-docx/"/>
    
  </entry>
  
  <entry>
    <title>python-docx | 设置word文档里表格的格式</title>
    <link href="http://example.com/2021/10/24/%E8%AE%BE%E7%BD%AEword%E6%96%87%E6%A1%A3%E9%87%8C%E8%A1%A8%E6%A0%BC%E7%9A%84%E6%A0%BC%E5%BC%8F/"/>
    <id>http://example.com/2021/10/24/%E8%AE%BE%E7%BD%AEword%E6%96%87%E6%A1%A3%E9%87%8C%E8%A1%A8%E6%A0%BC%E7%9A%84%E6%A0%BC%E5%BC%8F/</id>
    <published>2021-10-24T09:51:06.000Z</published>
    <updated>2021-10-24T09:53:55.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设置word文档里表格的格式"><a href="#设置word文档里表格的格式" class="headerlink" title="设置word文档里表格的格式"></a>设置word文档里表格的格式</h1><p>以下代码实现使用python-docx对word文档里表格的格式进行设置。</p><span id="more"></span><pre><code># 单元格边框设置函数from docx.table import _Cellfrom docx.oxml import OxmlElementfrom docx.oxml.ns import qndef Set_cell_border(cell: _Cell, **kwargs):    &quot;&quot;&quot;    设置单元格边框函数    使用方法:    Set_cell_border(        cell,        top=&#123;&quot;sz&quot;: 12, &quot;val&quot;: &quot;single&quot;, &quot;color&quot;: &quot;#FF0000&quot;, &quot;space&quot;: &quot;0&quot;&#125;,        bottom=&#123;&quot;sz&quot;: 12, &quot;color&quot;: &quot;#00FF00&quot;, &quot;val&quot;: &quot;single&quot;&#125;,        start=&#123;&quot;sz&quot;: 24, &quot;val&quot;: &quot;dashed&quot;, &quot;shadow&quot;: &quot;true&quot;&#125;,        end=&#123;&quot;sz&quot;: 12, &quot;val&quot;: &quot;dashed&quot;&#125;,    )    传入参数有cell, 即单元格；top指上边框；bottom指下边框；start指左边框；end指右边框。    &quot;sz&quot;指线的粗细程度；&quot;val&quot;指线型，比如单线，虚线等；&quot;color&quot;指颜色，颜色编码可百度；    &quot;space&quot;指间隔，一般不设置，设置的值大于0会导致线错开；&quot;shadow&quot;指边框阴影    &quot;&quot;&quot;    tc = cell._tc    tcPr = tc.get_or_add_tcPr()    tcBorders = tcPr.first_child_found_in(&quot;w:tcBorders&quot;)    if tcBorders is None:        tcBorders = OxmlElement(&#39;w:tcBorders&#39;)        tcPr.append(tcBorders)    for edge in (&#39;start&#39;, &#39;top&#39;, &#39;end&#39;, &#39;bottom&#39;, &#39;insideH&#39;, &#39;insideV&#39;):        edge_data = kwargs.get(edge)        if edge_data:            tag = &#39;w:&#123;&#125;&#39;.format(edge)            element = tcBorders.find(qn(tag))            if element is None:                element = OxmlElement(tag)                tcBorders.append(element)            for key in [&quot;sz&quot;, &quot;val&quot;, &quot;color&quot;, &quot;space&quot;, &quot;shadow&quot;]:                if key in edge_data:                    element.set(qn(&#39;w:&#123;&#125;&#39;.format(key)), str(edge_data[key]))# 定义单元格填充颜色函数from docx.oxml.ns import nsdeclsfrom docx.oxml import parse_xmldef Set_Background_Color(cell, rgbColor):    shading_elm = parse_xml(        r&#39;&lt;w:shd &#123;&#125; w:fill=&quot;&#123;color_value&#125;&quot;/&gt;&#39;.format(nsdecls(&#39;w&#39;), color_value=rgbColor))  # 固定写法，照抄即可    cell._tc.get_or_add_tcPr().append(shading_elm)from docx.enum.text import WD_ALIGN_PARAGRAPH  # 设置水平居中对齐需要用到的库from docx.enum.table import WD_ALIGN_VERTICAL  # 设置垂直居中对齐需要用到的库from docx.shared import Cm  # 长度单位（厘米cm用到的库)from docx import Documentdoc = Document(&quot;收货记录.docx&quot;)  # 打开word文件table = doc.tables[0]max_row = len(table.rows)  # 获取表格总行数# 1.最后一行中，“总数”两个字要加粗run = table.cell(max_row - 1, 4).paragraphs[0].runs[0]  # 获取最后一行第五列对应单元格中的文字块，即“总数”字样所在单元格run.font.bold = True  # 将文字块设置为粗体# 2.最后一行的行高要调大一点，现在这样扁扁的，难看table.rows[max_row - 1].height = Cm(1)  # 将最后一行的行高设置为1厘米# 3.最后一行那几个空单元格有框线，太碍眼，得去掉，将总数及左边两个cell左边框和下边框设成白色for i in range(3):    cell = table.cell(max_row - 1, i)    Set_cell_border(        cell,        bottom=&#123;&quot;color&quot;: &quot;#FFFFFF&quot;&#125;,        start=&#123;&quot;color&quot;: &quot;#FFFFFF&quot;&#125;,        end=&#123;&quot;color&quot;: &quot;#FFFFFF&quot;&#125;    )cell_1 = table.cell(max_row - 1, 3)Set_cell_border(cell_1, start=&#123;&quot;color&quot;: &quot;#FFFFFF&quot;&#125;, bottom=&#123;&quot;color&quot;: &quot;#FFFFFF&quot;&#125;)cell_2 = table.cell(max_row - 1, 6)Set_cell_border(cell_2, end=&#123;&quot;color&quot;: &quot;#FFFFFF&quot;&#125;, bottom=&#123;&quot;color&quot;: &quot;#FFFFFF&quot;&#125;)# 4.各单元格水平和垂直方向都要居中对齐for row in range(1, max_row):    for col in range(len(table.columns)):        table.cell(row, col).paragraphs[0].alignment = WD_ALIGN_PARAGRAPH.CENTER        table.cell(row, col).vertical_alignment = WD_ALIGN_VERTICAL.CENTER# 5.数量列≥85的，底色设置为橙色qty = []  # 存储数量信息# 读取第二行到29行，第2，3列中的数据for i in range(1, max_row - 1):    qty_info = table.rows[i].cells[5].text  # cells[5]指表格第6列    qty.append(int(qty_info))# 将数量≥85的单元格填色row = 1  # 行计数器for i in qty:    if i &gt;= 85:        cell = table.cell(row, 5)  # 第6列数据为数量，列索引是5        Set_Background_Color(cell, &quot;98F5FF&quot;)  # 填充颜色，&quot;98F5FF&quot;是蓝色的编码    row += 1  # 跳转到下一行doc.save(&quot;收货记录-整理.docx&quot;)</code></pre><p><a href="收货记录.docx">收货记录.docx</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;设置word文档里表格的格式&quot;&gt;&lt;a href=&quot;#设置word文档里表格的格式&quot; class=&quot;headerlink&quot; title=&quot;设置word文档里表格的格式&quot;&gt;&lt;/a&gt;设置word文档里表格的格式&lt;/h1&gt;&lt;p&gt;以下代码实现使用python-docx对word文档里表格的格式进行设置。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="python-docx" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/python-docx/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="python-docx" scheme="http://example.com/tags/python-docx/"/>
    
  </entry>
  
  <entry>
    <title>python-docx | 向word中的表格写入数据</title>
    <link href="http://example.com/2021/10/24/%E5%90%91word%E4%B8%AD%E7%9A%84%E8%A1%A8%E6%A0%BC%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE/"/>
    <id>http://example.com/2021/10/24/%E5%90%91word%E4%B8%AD%E7%9A%84%E8%A1%A8%E6%A0%BC%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE/</id>
    <published>2021-10-24T09:32:31.000Z</published>
    <updated>2021-10-24T09:36:06.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="向word中的表格写入数据"><a href="#向word中的表格写入数据" class="headerlink" title="向word中的表格写入数据"></a>向word中的表格写入数据</h1><p>以下代码实现一键往word文档的表格中填写数据。</p><span id="more"></span><pre><code># 从Excel表中提取数据from openpyxl import load_workbookwb = load_workbook(&quot;收货数据.xlsx&quot;)ws = wb.activedata = []for row in range(2, ws.max_row + 1):    seq = ws[&quot;A&quot; + str(row)].value    supplier = ws[&quot;B&quot; + str(row)].value    material_pn = ws[&quot;C&quot; + str(row)].value    material_model = ws[&quot;D&quot; + str(row)].value    desp = ws[&quot;E&quot; + str(row)].value    qty = ws[&quot;F&quot; + str(row)].value    date = ws[&quot;G&quot; + str(row)].value.date()    info = [seq, supplier, material_pn, material_model, desp, qty, date]    data.append(info)# 定义数量加总函数def Sum_list(list):    s = 0    for i in list:  # 累加列表中的所有数        s += i    return s# 加总数量列的所有数字qty_list = []for i in data:    qty_list.append(i[5])  # 数量在内层列表的第6个位置，索引是5sum_qty = Sum_list(qty_list)  # 调用加总函数加总# 定义合并单元格的函数def Merge_cells(table, target_list, start_row, col):    &#39;&#39;&#39;    table: 是需要操作的表格    target_list: 是目标列表，即含有重复数据的列表    start_row: 是开始行，即表格中开始比对数据的行（需要将标题除开）    col: 是需要处理数据的列    &#39;&#39;&#39;    start = 0  # 开始行计数    end = 0  # 结束行计数    reference = target_list[0]  # 设定基准，以列表中的第一个字符串开始    for i in range(len(target_list)):  # 遍历列表        if target_list[i] != reference:  # 开始比对，如果内容不同执行如下            reference = target_list[i]  # 基准变成列表中下一个字符串            end = i - 1            table.cell(start + start_row, col).merge(table.cell(end + start_row, col))            start = end + 1        if i == len(target_list) - 1:  # 遍历到最后一行，按如下操作            end = i            table.cell(start + start_row, col).merge(table.cell(end + start_row, col))# 数据提取即处理完毕后，就可以往Word的表格中写入数据了from docx import Documentdoc = Document(&quot;收货记录模板.docx&quot;)# 读取word文档中的第一个表格的第二和第三列除标题和尾部总数行的数据table = doc.tables[0]  # 已确定是第一个表格，其索引是0supplier = []  # 存储供应商名称pn = []  # 存储物料编码for i in data:    supplier.append(i[1])    pn.append(i[2])# 按需增加行，以便填写数据for i in range(len(supplier)):  # 模板中已经有一行了，所以总共只需增加len(supplier)行    table.add_row()# 增加好行后先做合并单元格操作Merge_cells(table, supplier, 1, 1)  # 开始合并行为2，索引为1；供应商名称是在2列，索引为1Merge_cells(table, pn, 1, 2)  # 开始合并行为2，索引为1；物料编码是在3列，索引为2# 写入数据到表格for row in range(1, len(supplier) + 1):    for col in range(7):        table.cell(row, col).text = str(data[row - 1][col])max_row = len(table.rows)  # 获取最大一行qty_row = max_row - 1  # 确定需要写入加总数据的一行table.cell(qty_row, 5).merge(table.cell(qty_row, 6))  # 合并右下角用于填写数量的两个单元格table.cell(qty_row, 4).text = &#39;总数：&#39;table.cell(qty_row, 5).text = str(sum_qty)doc.save(&quot;收货记录3.docx&quot;)</code></pre><p><a href="收货数据.xlsx">收货数据.xlsx</a><br><a href="收货记录模板.docx">收货记录模板.docx</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;向word中的表格写入数据&quot;&gt;&lt;a href=&quot;#向word中的表格写入数据&quot; class=&quot;headerlink&quot; title=&quot;向word中的表格写入数据&quot;&gt;&lt;/a&gt;向word中的表格写入数据&lt;/h1&gt;&lt;p&gt;以下代码实现一键往word文档的表格中填写数据。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="python-docx" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/python-docx/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="openpyxl" scheme="http://example.com/tags/openpyxl/"/>
    
    <category term="python-docx" scheme="http://example.com/tags/python-docx/"/>
    
  </entry>
  
  <entry>
    <title>python-docx | 合并word表格中上下行那内容相同的单元格</title>
    <link href="http://example.com/2021/10/21/%E5%90%88%E5%B9%B6word%E8%A1%A8%E6%A0%BC%E4%B8%AD%E4%B8%8A%E4%B8%8B%E8%A1%8C%E9%82%A3%E5%86%85%E5%AE%B9%E7%9B%B8%E5%90%8C%E7%9A%84%E5%8D%95%E5%85%83%E6%A0%BC/"/>
    <id>http://example.com/2021/10/21/%E5%90%88%E5%B9%B6word%E8%A1%A8%E6%A0%BC%E4%B8%AD%E4%B8%8A%E4%B8%8B%E8%A1%8C%E9%82%A3%E5%86%85%E5%AE%B9%E7%9B%B8%E5%90%8C%E7%9A%84%E5%8D%95%E5%85%83%E6%A0%BC/</id>
    <published>2021-10-21T09:53:10.000Z</published>
    <updated>2021-10-21T09:55:56.693Z</updated>
    
    <content type="html"><![CDATA[<h1 id="合并word表格中上下行那内容相同的单元格"><a href="#合并word表格中上下行那内容相同的单元格" class="headerlink" title="合并word表格中上下行那内容相同的单元格"></a>合并word表格中上下行那内容相同的单元格</h1><p>以下代码实现自动合并excel表格中上下行内容相同的单元格</p><span id="more"></span><pre><code>from docx import Document# 定义合并单元格的函数def Merge_cells(table, target_list, start_row, col):    &quot;&quot;&quot;    table: 是需要操作的表格    target_list: 是目标列表，即含有重复数据的列表    start_row: 是开始行，即表格中开始比对数据的行（需要将标题除开）    col: 是需要处理数据的列    &quot;&quot;&quot;    start = 0  # 开始行计数    end = 0  # 结束行计数    reference = target_list[0]  # 设定基准，以列表中的第一个字符串开始    for i in range(len(target_list)):  # 遍历列表        if target_list[i] != reference:  # 开始比对，如果内容不同执行如下            reference = target_list[i]  # 基准变成列表中下一个字符串            end = i - 1            table.cell(start + start_row, col).merge(table.cell(end + start_row, col))            start = end + 1        if i == len(target_list) - 1:  # 遍历到最后一行，按如下操作            end = i            table.cell(start + start_row, col).merge(table.cell(end + start_row, col))doc = Document(&quot;收货记录.docx&quot;)# 读取word文档中的第一个表格的第二和第三列除标题和尾部总数行的数据table = doc.tables[0]  # 已确定是第一个表格，其索引是0supplier = []  # 存储供应商名称pn = []  # 存储物料编码max_row = len(table.rows)  # 获取第最大一行# 读取第二行到29行，第2，3列中的数据for i in range(1, max_row - 1):    supplier_name = table.rows[i].cells[1].text  # cells[1]指表格第二列    supplier.append(supplier_name)for i in range(1, max_row - 1):    material_pn = table.rows[i].cells[2].text  # cells[2]指表格第三列    pn.append(material_pn)Merge_cells(table, supplier, 1, 1)  # 开始合并行为2，索引为1；供应商名称是在2列，索引为1Merge_cells(table, pn, 1, 2)  # 开始合并行为2，索引为1；物料编码是在3列，索引为2# 重新往第2和第3列写入数据，以覆盖之前重复的数据for row in range(1, len(supplier) + 1):    table.cell(row, 1).text = supplier[row - 2]    table.cell(row, 2).text = pn[row - 2]doc.save(&quot;收货记录-合并单元格.docx&quot;)</code></pre><p><a href="收货记录.docx">收货记录.docx</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;合并word表格中上下行那内容相同的单元格&quot;&gt;&lt;a href=&quot;#合并word表格中上下行那内容相同的单元格&quot; class=&quot;headerlink&quot; title=&quot;合并word表格中上下行那内容相同的单元格&quot;&gt;&lt;/a&gt;合并word表格中上下行那内容相同的单元格&lt;/h1&gt;&lt;p&gt;以下代码实现自动合并excel表格中上下行内容相同的单元格&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="python-docx" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/python-docx/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="python-docx" scheme="http://example.com/tags/python-docx/"/>
    
  </entry>
  
  <entry>
    <title>openpyxl | 合并excel表格中上下行内容相同的单元格</title>
    <link href="http://example.com/2021/10/21/%E5%90%88%E5%B9%B6excel%E8%A1%A8%E6%A0%BC%E4%B8%AD%E4%B8%8A%E4%B8%8B%E8%A1%8C%E5%86%85%E5%AE%B9%E7%9B%B8%E5%90%8C%E7%9A%84%E5%8D%95%E5%85%83%E6%A0%BC/"/>
    <id>http://example.com/2021/10/21/%E5%90%88%E5%B9%B6excel%E8%A1%A8%E6%A0%BC%E4%B8%AD%E4%B8%8A%E4%B8%8B%E8%A1%8C%E5%86%85%E5%AE%B9%E7%9B%B8%E5%90%8C%E7%9A%84%E5%8D%95%E5%85%83%E6%A0%BC/</id>
    <published>2021-10-21T09:35:15.000Z</published>
    <updated>2021-10-21T09:37:48.441Z</updated>
    
    <content type="html"><![CDATA[<h1 id="合并excel表格中上下行内容相同的单元格"><a href="#合并excel表格中上下行内容相同的单元格" class="headerlink" title="合并excel表格中上下行内容相同的单元格"></a>合并excel表格中上下行内容相同的单元格</h1><p>以下代码实现自动合并excel表格中上下行内容相同的单元格</p><span id="more"></span><pre><code># 获取Excel表格中的数据from openpyxl import load_workbook  # 用于读取Excel中的信息def merge_cells(ws, target_list, start_row, col):    &quot;&quot;&quot;    ws: 是需要操作的工作表    target_list: 是目标列表，即含有重复数据的列表    start_row: 是开始行，即工作表中开始比对数据的行（需要将标题除开）    col: 是需要处理数据的列    &quot;&quot;&quot;    start = 0  # 开始行计数，初试值为0，对应列表中的第1个元素的位置0    end = 0  # 结束行计数，初试值为0，对应列表中的第1个元素的位置0    reference = target_list[0]  # 设定基准，以列表中的第一个字符串开始    for i in range(len(target_list)):  # 遍历列表        if target_list[i] != reference:  # 开始比对，如果内容不同执行如下            reference = target_list[i]  # 基准变成列表中下一个字符串            end = i - 1  # 列计数器            ws.merge_cells(col + str(start + start_row) + &quot;:&quot; + col + str(end + start_row))            start = end + 1        if i == len(target_list) - 1:  # 遍历到最后一行，按如下操作            end = i            ws.merge_cells(col + str(start + start_row) + &quot;:&quot; + col + str(end + start_row))wb = load_workbook(&#39;产品清单.xlsx&#39;)sheet_names = wb.get_sheet_names()for sheet_name in sheet_names:  # 遍历每个工作表，抓取数据，并根据要求合并单元格    ws = wb[sheet_name]    customer_list = []  # 客户名称    pn_list = []  # 产品编码    for row in range(6, ws.max_row - 2):        customer = ws[&#39;B&#39; + str(row)].value        pn = ws[&#39;C&#39; + str(row)].value        customer_list.append(customer)        pn_list.append(pn)    # 调用以上定义的合并单元格函数`Merge_cells`做单元格合并操作    start_row = 6  # 开始行是第六行    merge_cells(ws, customer_list, start_row, &quot;B&quot;)  # &quot;B&quot; - 客户名称是在B列    merge_cells(ws, pn_list, start_row, &quot;C&quot;)  # &quot;C&quot; - 产品编码是在C列wb.save(&quot;产品清单-合并单元.xlsx&quot;)</code></pre><p><a href="产品清单.xlsx">产品清单.xlsx</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;合并excel表格中上下行内容相同的单元格&quot;&gt;&lt;a href=&quot;#合并excel表格中上下行内容相同的单元格&quot; class=&quot;headerlink&quot; title=&quot;合并excel表格中上下行内容相同的单元格&quot;&gt;&lt;/a&gt;合并excel表格中上下行内容相同的单元格&lt;/h1&gt;&lt;p&gt;以下代码实现自动合并excel表格中上下行内容相同的单元格&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="openpyxl" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/openpyxl/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="openpyxl" scheme="http://example.com/tags/openpyxl/"/>
    
  </entry>
  
  <entry>
    <title>openpyxl | 快速提取一串字符中的中文</title>
    <link href="http://example.com/2021/10/21/%E5%BF%AB%E9%80%9F%E6%8F%90%E5%8F%96%E4%B8%80%E4%B8%B2%E5%AD%97%E7%AC%A6%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%87/"/>
    <id>http://example.com/2021/10/21/%E5%BF%AB%E9%80%9F%E6%8F%90%E5%8F%96%E4%B8%80%E4%B8%B2%E5%AD%97%E7%AC%A6%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%87/</id>
    <published>2021-10-21T09:11:03.000Z</published>
    <updated>2021-10-21T09:14:24.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速提取一串字符中的中文"><a href="#快速提取一串字符中的中文" class="headerlink" title="快速提取一串字符中的中文"></a>快速提取一串字符中的中文</h1><p>以下代码实现了快速提取（正则表达式）一串字符串中的中文。</p><span id="more"></span><pre><code>import refrom openpyxl import load_workbookdata = []wb = load_workbook(&#39;data/data.xlsx&#39;)ws = wb.activefor row in range(2, ws.max_row + 1):  # 从第二行开始遍历excel文件所有行    info = ws[&#39;A&#39; + str(row)].value    data.append(info)chinese_list = []for i in data:    chinese = re.findall(&#39;[\u4e00-\u9fa5]&#39;, i)    chinese_list.append(&#39;&#39;.join(chinese))for row in range(2, ws.max_row + 1):    ws[&#39;B&#39; + str(row)].value = chinese_list[row - 2]wb.save(&quot;./data/data_chinese.xlsx&quot;)</code></pre><p><a href="data.xlsx">下载data.xlsx</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;快速提取一串字符中的中文&quot;&gt;&lt;a href=&quot;#快速提取一串字符中的中文&quot; class=&quot;headerlink&quot; title=&quot;快速提取一串字符中的中文&quot;&gt;&lt;/a&gt;快速提取一串字符中的中文&lt;/h1&gt;&lt;p&gt;以下代码实现了快速提取（正则表达式）一串字符串中的中文。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="openpyxl" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/openpyxl/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="re" scheme="http://example.com/tags/re/"/>
    
    <category term="openpyxl" scheme="http://example.com/tags/openpyxl/"/>
    
    <category term="正则表达式" scheme="http://example.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>python-pptx | 提取ppt中的文字到word中</title>
    <link href="http://example.com/2021/10/21/%E6%8F%90%E5%8F%96ppt%E4%B8%AD%E7%9A%84%E6%96%87%E5%AD%97%E5%88%B0word%E4%B8%AD/"/>
    <id>http://example.com/2021/10/21/%E6%8F%90%E5%8F%96ppt%E4%B8%AD%E7%9A%84%E6%96%87%E5%AD%97%E5%88%B0word%E4%B8%AD/</id>
    <published>2021-10-21T08:37:48.000Z</published>
    <updated>2021-10-21T08:41:37.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="提取ppt中的文字到word中"><a href="#提取ppt中的文字到word中" class="headerlink" title="提取ppt中的文字到word中"></a>提取ppt中的文字到word中</h1><p>以下代码实现了将ppt中的所有文字提取到word中。</p><span id="more"></span><pre><code>from pptx import Presentationdata = []prs = Presentation(&#39;data\制造业必修课.pptx&#39;)for slide in prs.slides:  # 遍历每页ppt    for shape in slide.shapes:  # 遍历ppt中的每个形状        if shape.has_text_frame:  # 判断该形状是否包含文本，保证有文本才提取            for paragraph in shape.text_frame.paragraphs:  # 按文本框中的段落提取                data.append(paragraph.text)  # 提取一个段落的文本，就存到列表data中# 写入文本文件TxtFile = open(&#39;data\制造业必修课.txt&#39;, &#39;w&#39;, encoding=&#39;utf-8&#39;)for i in data:    TxtFile.write(i + &#39;\n&#39;)  # 写入并换行，以保证正确分段TxtFile.close()  # 保存# 写入word文件import docxdoc = docx.Document()  # 创建一个word文件对象for i in data:    doc.add_paragraph(i)  # 增加一个段落，并将列表中的一个字符串写入word文件doc.save(&#39;data\制造业必修课.docx&#39;)</code></pre><p><a href="制造业必修课.pptx">制造业必修课.pptx</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;提取ppt中的文字到word中&quot;&gt;&lt;a href=&quot;#提取ppt中的文字到word中&quot; class=&quot;headerlink&quot; title=&quot;提取ppt中的文字到word中&quot;&gt;&lt;/a&gt;提取ppt中的文字到word中&lt;/h1&gt;&lt;p&gt;以下代码实现了将ppt中的所有文字提取到word中。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="python-pptx" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/python-pptx/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="python-docx" scheme="http://example.com/tags/python-docx/"/>
    
    <category term="python-pptx" scheme="http://example.com/tags/python-pptx/"/>
    
  </entry>
  
  <entry>
    <title>sviewgui | 对数据文件中的数据进行可视化</title>
    <link href="http://example.com/2021/10/19/%E5%AF%B9%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    <id>http://example.com/2021/10/19/%E5%AF%B9%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E5%8F%AF%E8%A7%86%E5%8C%96/</id>
    <published>2021-10-20T07:38:43.000Z</published>
    <updated>2021-10-20T09:34:53.001Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用sviewgui对csv文件或Pandas的DataFrame的数据可视化"><a href="#使用sviewgui对csv文件或Pandas的DataFrame的数据可视化" class="headerlink" title="使用sviewgui对csv文件或Pandas的DataFrame的数据可视化"></a>使用sviewgui对csv文件或Pandas的DataFrame的数据可视化</h1><p><a href="https://mp.weixin.qq.com/s/6ftmwDzlyuCgN5YsX81pKQ">参考资料</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用sviewgui对csv文件或Pandas的DataFrame的数据可视化&quot;&gt;&lt;a href=&quot;#使用sviewgui对csv文件或Pandas的DataFrame的数据可视化&quot; class=&quot;headerlink&quot; title=&quot;使用sviewgui对csv</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="sviewgui" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/sviewgui/"/>
    
    
    <category term="sviewgui" scheme="http://example.com/tags/sviewgui/"/>
    
  </entry>
  
</feed>
