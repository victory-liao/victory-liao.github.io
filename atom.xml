<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Victory&#39;s Blog</title>
  
  <subtitle>非宁静无以致远</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-03-14T14:31:26.799Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>victory-liao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何制定短期、长期目标？</title>
    <link href="http://example.com/2024/03/14/%E5%A6%82%E4%BD%95%E5%88%B6%E5%AE%9A%E7%9F%AD%E6%9C%9F%E3%80%81%E9%95%BF%E6%9C%9F%E7%9B%AE%E6%A0%87%EF%BC%9F/"/>
    <id>http://example.com/2024/03/14/%E5%A6%82%E4%BD%95%E5%88%B6%E5%AE%9A%E7%9F%AD%E6%9C%9F%E3%80%81%E9%95%BF%E6%9C%9F%E7%9B%AE%E6%A0%87%EF%BC%9F/</id>
    <published>2024-03-14T14:07:36.000Z</published>
    <updated>2024-03-14T14:31:26.799Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何制定短、长期目标？"><a href="#如何制定短、长期目标？" class="headerlink" title="如何制定短、长期目标？"></a>如何制定短、长期目标？</h3><p>首先，这是一个问句。其次，问题下面的文字不是答案，是在寻找答案。</p><span id="more"></span><p>先说说不制定短期目标会造成哪些现象吧。就自己来说，如果没有短期目标会直接的造成当下执行力的直线减弱，会陷入“无所事事”的焦虑与内耗之中，会喜欢在“短且快”的事物中结束当下的焦虑，比如:刷抖音，或者说会选择“躺平”，没有心情去干其他的事。</p><p>如果有一个短期目标，那么自己就会有来自完成这个目标的微小的压力，而这微小压力会增强执行力，这是自我分析的结果，希望后面能够验证(结果是对的)或调整(结果错了)这个结果。比如，我计划三天看一本不那么厚的书，那么我的手脚这三天就有地方去了，脚应该放在阅读桌的正下方，手应该放在这本书的右下角去翻页，在这个短的周期里，这本书会对我的行为有指导作用，或许这就是我的结论的含义吧。短期的目标会增加执行力，那么如何正确的制定短期目标是我需要去探索、去实践的。</p><p>进一步分析，不制定或者说没有一个长期目标的话，对我个人而言会在焦虑与内耗下造成迷茫，缺少动力的情况。若说短期目标是当下手和脚应该放在哪里的问题，那么长期目标就是“心所往”，也就是说，你想要去到哪里。一个长的周期内，我们有可能会精力充沛，信心满满的做一些事，也有可能会无所事事，迷茫焦虑，不知道该干什么，不知道我要去哪，不知道人生该如何度过。</p><p>再像上一段那样出个结论的话那就是，长期目标是一块磁铁，会在一个长的周期内在你迷茫的时候，将你的心拉回来，让你幡然醒悟，哦，我是要去到哪里，从里结束迷茫，继续前行。比如，在大三到大四考研的哪一年中，上岸就是一个相对长期的目标，在这主线任务中，当然大部分的时间是复习，但免不了放纵，迷茫的时刻，但是有了上岸的目标，在放纵一日，迷茫一日，焦虑一日之后，这个目标就会把我拉回来，如上所说，那是心去的地方，也许这是我的结论的当前解释吧。这个结论也是自我分析的结果，需要与制定长期目标这个问题一起去探索，去实践。</p><p>2024.3.13<br>victory</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;如何制定短、长期目标？&quot;&gt;&lt;a href=&quot;#如何制定短、长期目标？&quot; class=&quot;headerlink&quot; title=&quot;如何制定短、长期目标？&quot;&gt;&lt;/a&gt;如何制定短、长期目标？&lt;/h3&gt;&lt;p&gt;首先，这是一个问句。其次，问题下面的文字不是答案，是在寻找答案。&lt;/p&gt;</summary>
    
    
    
    <category term="多一点思考" scheme="http://example.com/categories/%E5%A4%9A%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/"/>
    
    <category term="如何制定短、长期目标？" scheme="http://example.com/categories/%E5%A4%9A%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/%E5%A6%82%E4%BD%95%E5%88%B6%E5%AE%9A%E7%9F%AD%E3%80%81%E9%95%BF%E6%9C%9F%E7%9B%AE%E6%A0%87%EF%BC%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>CUDA | CUDA源程序结构</title>
    <link href="http://example.com/2024/03/14/CUDA%E6%BA%90%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2024/03/14/CUDA%E6%BA%90%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/</id>
    <published>2024-03-14T13:55:46.000Z</published>
    <updated>2024-03-14T14:04:58.177Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CUDA源程序的结构"><a href="#CUDA源程序的结构" class="headerlink" title="CUDA源程序的结构"></a>CUDA源程序的结构</h3><p>采用CUDA并行计算编程模型进行编程一般分为以下几个步骤：</p><ol><li><p>分配GPU内存（使用cudaMalloc()函数进行分配）。</p></li><li><p>从CPU内存中拷贝数据到GPU内存（cudaMemcpy()）。</p></li><li><p>调用CUDA内核函数来完成程序指定的运算（xxxKernel&lt;&lt;&lt;block, grid&gt;&gt;&gt;()）。</p><p>在此过程中注意线程的组织方式，通过设置不同block、grid来进行组织。</p></li><li><p>将数据从GPU拷回CPU内存（cudaMemcpy()）。</p></li><li><p>释放GPU内存空间（cudaFree）。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;CUDA源程序的结构&quot;&gt;&lt;a href=&quot;#CUDA源程序的结构&quot; class=&quot;headerlink&quot; title=&quot;CUDA源程序的结构&quot;&gt;&lt;/a&gt;CUDA源程序的结构&lt;/h3&gt;&lt;p&gt;采用CUDA并行计算编程模型进行编程一般分为以下几个步骤：&lt;/p&gt;
&lt;ol&gt;</summary>
      
    
    
    
    <category term="并行计算" scheme="http://example.com/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
    <category term="CUDA" scheme="http://example.com/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/CUDA/"/>
    
    <category term="CUDA源程序结构" scheme="http://example.com/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/CUDA/CUDA%E6%BA%90%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="CUDA" scheme="http://example.com/tags/CUDA/"/>
    
  </entry>
  
  <entry>
    <title>CUDA | 数据划分形式</title>
    <link href="http://example.com/2024/03/14/%E6%95%B0%E6%8D%AE%E5%88%92%E5%88%86%E5%BD%A2%E5%BC%8F/"/>
    <id>http://example.com/2024/03/14/%E6%95%B0%E6%8D%AE%E5%88%92%E5%88%86%E5%BD%A2%E5%BC%8F/</id>
    <published>2024-03-14T13:55:25.000Z</published>
    <updated>2024-03-14T13:57:37.667Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据划分形式"><a href="#数据划分形式" class="headerlink" title="数据划分形式"></a>数据划分形式</h3><p>块划分和周期划分是数据分配给线程的两种不同策略，它们在一些方面存在差异。以下是具体分析：</p><ul><li><strong>块划分</strong>：在块划分中，<strong>一组连续的数据被分到一个块内</strong>。<strong>每个数据块通常具有相同的大小</strong>，并以任意次序被安排给一个线程进行处理。线程在同一时间只处理一个数据块，这种方式简化了同步和调度的问题，因为每个线程独立工作在自己的数据块上。</li><li><strong>周期划分</strong>：周期划分将更少的数据分到一个块内。在这种策略下，每个线程负责处理多个数据块，且这些<strong>数据块之间通常是不连续的</strong>。相邻的线程会处理相邻的数据块，当一个线程需要选择一个新的数据块时，它必须跳过与当前线程数一样多的数据块。这种划分方式可以提高缓存的利用率，并可能减少内存访问延迟。</li></ul><p>总的来说，<strong>块划分适合每个线程处理大块连续数据的任务</strong>，而<strong>周期划分更适合于需要细粒度并行和数据局部性</strong>优化的场景。实际选择哪种划分方式取决于具体的应用场景和目标架构的特点。 </p><p>以下是块划分和周期划分的代码示例：</p><p>块划分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义数据大小和线程数</span></span><br><span class="line">data_size = <span class="number">20</span></span><br><span class="line">num_threads = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算每个线程处理的数据量</span></span><br><span class="line">chunk_size = data_size // num_threads</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据分成块，并分配给线程</span></span><br><span class="line">data = np.random.rand(data_size)</span><br><span class="line">chunks = [data[i*chunk_size:(i+<span class="number">1</span>)*chunk_size] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_threads)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在每个线程中处理数据块</span></span><br><span class="line"><span class="keyword">for</span> chunk <span class="keyword">in</span> chunks:</span><br><span class="line">    <span class="comment"># 在这里进行数据处理</span></span><br><span class="line">    <span class="built_in">print</span>(chunk)</span><br></pre></td></tr></table></figure><p>周期划分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义数据大小和线程数</span></span><br><span class="line">data_size = <span class="number">20</span></span><br><span class="line">num_threads = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算每个线程处理的数据量</span></span><br><span class="line">chunk_size = data_size // num_threads</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据分成块，并分配给线程</span></span><br><span class="line">data = np.random.rand(data_size)</span><br><span class="line">chunks = [data[i::num_threads] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_threads)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在每个线程中处理数据块</span></span><br><span class="line"><span class="keyword">for</span> chunk <span class="keyword">in</span> chunks:</span><br><span class="line">    <span class="comment"># 在这里进行数据处理</span></span><br><span class="line">    <span class="built_in">print</span>(chunk)</span><br></pre></td></tr></table></figure><p>以上代码示例展示了如何将数据划分为块，并将这些块分配给不同的线程进行处理。在块划分中，每个线程处理一个连续的数据块；而在周期划分中，每个线程处理多个不连续的数据块。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;数据划分形式&quot;&gt;&lt;a href=&quot;#数据划分形式&quot; class=&quot;headerlink&quot; title=&quot;数据划分形式&quot;&gt;&lt;/a&gt;数据划分形式&lt;/h3&gt;&lt;p&gt;块划分和周期划分是数据分配给线程的两种不同策略，它们在一些方面存在差异。以下是具体分析：&lt;/p&gt;
&lt;ul&gt;
</summary>
      
    
    
    
    <category term="并行计算" scheme="http://example.com/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
    <category term="CUDA" scheme="http://example.com/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/CUDA/"/>
    
    <category term="数据划分形式" scheme="http://example.com/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/CUDA/%E6%95%B0%E6%8D%AE%E5%88%92%E5%88%86%E5%BD%A2%E5%BC%8F/"/>
    
    
    <category term="CUDA" scheme="http://example.com/tags/CUDA/"/>
    
    <category term="数据划分" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%88%92%E5%88%86/"/>
    
    <category term="块划分" scheme="http://example.com/tags/%E5%9D%97%E5%88%92%E5%88%86/"/>
    
    <category term="周期划分" scheme="http://example.com/tags/%E5%91%A8%E6%9C%9F%E5%88%92%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>pytest | fixtures执行顺序及清理顺序</title>
    <link href="http://example.com/2024/03/07/fixtures%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E5%8F%8A%E6%B8%85%E7%90%86%E9%A1%BA%E5%BA%8F/"/>
    <id>http://example.com/2024/03/07/fixtures%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E5%8F%8A%E6%B8%85%E7%90%86%E9%A1%BA%E5%BA%8F/</id>
    <published>2024-03-07T13:56:45.000Z</published>
    <updated>2024-03-07T13:59:46.185Z</updated>
    
    <content type="html"><![CDATA[<h3 id="pytest-fixtures执行顺序和清理顺序"><a href="#pytest-fixtures执行顺序和清理顺序" class="headerlink" title="pytest fixtures执行顺序和清理顺序"></a>pytest fixtures执行顺序和清理顺序</h3><ol><li>fixtures执行顺序</li></ol><p>pytest一个test请求多个fixture时，fixtures的执行顺序是什么？</p><span id="more"></span><p>以下面的demo为例，在这段代码中test_string_only请求了append_first，order，fisrt_entry三个fixtures，从代码中可以看出append_first fixture依赖于order和first_entry fixtures。</p><p>pytest会对多个fixtures进行<strong>依赖解析</strong>，<strong>如果一个fixture依赖于其他fixture(s)，那么被依赖的fixtures会先于依赖它们的fixture执行</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># contents of test_append.py</span></span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Arrange</span></span><br><span class="line"><span class="meta">@pytest.fixture</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first_entry</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;3 - first_entry fixture has been executed.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;a&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Arrange</span></span><br><span class="line"><span class="meta">@pytest.fixture</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">order</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;2 - order fixture has been executed.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Act</span></span><br><span class="line"><span class="meta">@pytest.fixture</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">append_first</span>(<span class="params">order, first_entry</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;1 - append_first fixture has been executed.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> order.append(first_entry)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_string_only</span>(<span class="params">append_first, order, first_entry</span>):</span></span><br><span class="line">    <span class="comment"># Assert</span></span><br><span class="line">    <span class="keyword">assert</span> order == [first_entry]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行以上代码的结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">============================= test session starts =============================</span><br><span class="line">collecting ... collected 1 item</span><br><span class="line"></span><br><span class="line">test_append.py::test_string_only </span><br><span class="line">2 - order fixture has been executed.</span><br><span class="line">3 - first_entry fixture has been executed.</span><br><span class="line">1 - append_first fixture has been executed.</span><br><span class="line">PASSED                                  [100%]</span><br><span class="line"></span><br><span class="line">============================== 1 passed in 0.04s ==============================</span><br></pre></td></tr></table></figure><p>从运行结果可以看出，order fixture和first_entry fixture先于append_firt fixture执行。</p><p><strong>fixtures之间不存在依赖关系的，按照它们被声明的顺序执行</strong>，以下面的demo为例，假设有两个 fixtures，fixture A 和 fixture B，其中 fixture A 依赖于 fixture B。下面是一个示例来说明它们按照声明顺序执行的情况：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fixture_b</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Executing fixture B&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Cleaning up fixture B&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fixture_a</span>(<span class="params">fixture_b</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Executing fixture A&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Cleaning up fixture A&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_example</span>(<span class="params">fixture_a, fixture_b</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Executing test example&quot;</span>)</span><br><span class="line">    <span class="keyword">assert</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>fixture_b</code> 和 <code>fixture_a</code> 都使用了 <code>@pytest.fixture</code> 装饰器进行声明。在测试函数 <code>test_example</code> 的参数列表中，<code>fixture_b</code> 在 <code>fixture_a</code> 之前声明。</p><p>当运行这个测试时，pytest 会首先执行 <code>fixture_b</code>，然后执行 <code>fixture_a</code>。这是因为 <code>fixture_a</code> 依赖于 <code>fixture_b</code>，所以需要先执行它。最后，测试函数 <code>test_example</code> 会被执行。</p><p>输出结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Executing fixture B</span><br><span class="line">Executing fixture A</span><br><span class="line">Executing test example</span><br><span class="line">Cleaning up fixture A</span><br><span class="line">Cleaning up fixture B</span><br></pre></td></tr></table></figure><p>可以看到，fixtures 是按照它们被声明的顺序执行的，首先是 <code>fixture_b</code>，然后是 <code>fixture_a</code>。 </p><ol><li>fixtures清理顺序</li></ol><p>每个fixture在它自己的代码块执行完毕后立即进行清理。有依赖关系的fixtures的清理工作先从清理被依赖fixture开始，例如fixture A依赖于fixture B，那么执行顺序将会是：首先执行fixture B，然后执行fixture A，最后清理工作会先从fixture A开始，然后是fixture B。这种设计确保了每个fixture能及时清理自己使用的资源，避免了潜在的资源冲突或泄露问题。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;pytest-fixtures执行顺序和清理顺序&quot;&gt;&lt;a href=&quot;#pytest-fixtures执行顺序和清理顺序&quot; class=&quot;headerlink&quot; title=&quot;pytest fixtures执行顺序和清理顺序&quot;&gt;&lt;/a&gt;pytest fixtures执行顺序和清理顺序&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;fixtures执行顺序&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;pytest一个test请求多个fixture时，fixtures的执行顺序是什么？&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="python测试框架" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="pytest" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/pytest/"/>
    
    <category term="fixtures执行顺序及清理顺序" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/pytest/fixtures%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E5%8F%8A%E6%B8%85%E7%90%86%E9%A1%BA%E5%BA%8F/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="pytest" scheme="http://example.com/tags/pytest/"/>
    
    <category term="fixtures" scheme="http://example.com/tags/fixtures/"/>
    
  </entry>
  
  <entry>
    <title>pytest | 自定义失败断言解释</title>
    <link href="http://example.com/2024/03/07/%E6%96%AD%E8%A8%80%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E9%87%8D%E5%86%99/"/>
    <id>http://example.com/2024/03/07/%E6%96%AD%E8%A8%80%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E9%87%8D%E5%86%99/</id>
    <published>2024-03-07T13:52:36.000Z</published>
    <updated>2024-03-07T13:55:32.432Z</updated>
    
    <content type="html"><![CDATA[<h3 id="自定义失败断言解释"><a href="#自定义失败断言解释" class="headerlink" title="自定义失败断言解释"></a>自定义失败断言解释</h3><p>使用pytest测试代码块（Code Block）或函数（Functions）时，通常使用assert语句对代码块或函数的执行结果与预期结果进行比较，从而判断代码块或函数的正确性。如果在测试过程中某测试用例中的断言失败，即代码块或函数的实际执行结果与预期结果不一致，pytest将会报告错误信息。</p><span id="more"></span><p>在pytest中我们可以通过实现pytest_assertrepr_coompare钩子函数（Hook Function）来自定义失败断言的错误信息。</p><p>pytest_assertrepr_coompare钩子函数的语法如下：</p><p><strong>pytest_assertrepr_compare</strong>(<em>config</em>, <em>op</em>, <em>left</em>, <em>right</em>)[<a href="https://docs.pytest.org/en/8.0.x/_modules/_pytest/hookspec.html#pytest_assertrepr_compare">source]</a></p><p>​    Return explanation for comparisons in failing assert expressions.（返回失败断言表达式的解释信息）</p><p>​    Parameters:</p><p>​        <strong>config</strong> (<a href="https://docs.pytest.org/en/8.0.x/reference/reference.html#pytest.Config"><em>Config</em></a>) – The pytest config object.（pytest配置对象）</p><p>​        <strong>op</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#str"><em>str</em></a>) – The operator, e.g. <code>&quot;==&quot;</code>, <code>&quot;!=&quot;</code>, <code>&quot;not in&quot;</code>.（操作符）</p><p>​        <strong>left</strong> (<a href="https://docs.python.org/3/library/functions.html#object"><em>object</em></a>) – The left operand.（操作数1）</p><p>​        <strong>right</strong> (<a href="https://docs.python.org/3/library/functions.html#object"><em>object</em></a>) – The right operand.（操作数2）</p><p>通过钩子函数自定义错误断言信息的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># content of conftest.py</span></span><br><span class="line"><span class="keyword">from</span> test_foocompare <span class="keyword">import</span> Foo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 钩子函数，自定义断言信息</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pytest_assertrepr_compare</span>(<span class="params">op, left, right</span>):</span></span><br><span class="line">    <span class="comment"># 若Foo对象作相等断言（==）时失败，则输入自定义信息</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(left, Foo) <span class="keyword">and</span> <span class="built_in">isinstance</span>(right, Foo) <span class="keyword">and</span> op == <span class="string">&quot;==&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            <span class="string">&quot;Comparing Foo instances:&quot;</span>,</span><br><span class="line">            <span class="string">f&quot;   vals: <span class="subst">&#123;left.val&#125;</span> != <span class="subst">&#123;right.val&#125;</span>&quot;</span>,</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># content of test_foocompare.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.val == other.val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_compare</span>():</span></span><br><span class="line">    f1 = Foo(<span class="number">1</span>)</span><br><span class="line">    f2 = Foo(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">assert</span> f1 == f2</span><br></pre></td></tr></table></figure><p>运行test_foocompare.py模块，控制台会输出一下信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E       assert Comparing Foo instances:</span><br><span class="line">E            vals: 1 != 2</span><br></pre></td></tr></table></figure><p>自定义失败断言信息时通过重写断言表达式实现的，我们可以通过在代码中关闭”断言重写“功能：</p><ul><li><p>关闭特定模块的断言重写：在docstring中增加PYTEST_DONT_REWRITE字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    PYTEST_DONT_REWRITE</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">......</span><br><span class="line">python test code</span><br><span class="line">......</span><br></pre></td></tr></table></figure></li><li><p>关闭所有模块的断言重写：使用–assert=plain</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest --assert=plain</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;自定义失败断言解释&quot;&gt;&lt;a href=&quot;#自定义失败断言解释&quot; class=&quot;headerlink&quot; title=&quot;自定义失败断言解释&quot;&gt;&lt;/a&gt;自定义失败断言解释&lt;/h3&gt;&lt;p&gt;使用pytest测试代码块（Code Block）或函数（Functions）时，通常使用assert语句对代码块或函数的执行结果与预期结果进行比较，从而判断代码块或函数的正确性。如果在测试过程中某测试用例中的断言失败，即代码块或函数的实际执行结果与预期结果不一致，pytest将会报告错误信息。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="python测试框架" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="pytest" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/pytest/"/>
    
    <category term="自定义失败断言解释" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/pytest/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%B1%E8%B4%A5%E6%96%AD%E8%A8%80%E8%A7%A3%E9%87%8A/"/>
    
    
    <category term="pytest" scheme="http://example.com/tags/pytest/"/>
    
    <category term="断言" scheme="http://example.com/tags/%E6%96%AD%E8%A8%80/"/>
    
    <category term="钩子函数" scheme="http://example.com/tags/%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>python | 钩子函数、python中定义钩子函数</title>
    <link href="http://example.com/2024/03/06/%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E3%80%81python%E4%B8%AD%E5%AE%9A%E4%B9%89%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2024/03/06/%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E3%80%81python%E4%B8%AD%E5%AE%9A%E4%B9%89%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/</id>
    <published>2024-03-07T03:45:38.000Z</published>
    <updated>2024-03-07T03:50:24.308Z</updated>
    
    <content type="html"><![CDATA[<h3 id="钩子函数、python中定义钩子函数"><a href="#钩子函数、python中定义钩子函数" class="headerlink" title="钩子函数、python中定义钩子函数"></a>钩子函数、python中定义钩子函数</h3><p>钩子函数的概念来源于其工作原理，即<strong>在系统或框架的特定阶段“钩住”某一刻以执行自定义代码</strong>。</p><p>钩子函数是一种在特定事件发生时由系统自动调用的自定义函数。这个术语“钩子”（hook）形象地描述了这种机制：它允许开发者“钩住”程序执行过程中的某些点，以便在这些点上插入自己的代码。这些函数通常用于响应系统事件、修改程序行为或执行特定任务。以下是钩子函数由来的几个方面：</p><ul><li><strong>系统级钩子函数</strong>：在操作系统层面，钩子函数可以监视和处理系统消息，如键盘按键、鼠标动作或窗口消息等。这些函数在消息传递到目标之前截获它们，允许开发者执行自定义操作。</li><li><strong>编程框架中的钩子函数</strong>：在应用程序框架中，钩子函数用于扩展框架的功能而无需修改框架本身的代码。</li><li><strong>函数式编程中的钩子函数</strong>：在函数式编程中，钩子函数可以用来实现纯函数，确保函数的输出仅依赖于输入并且不产生副作用。</li></ul><p>总的来说，钩子函数提供了一种灵活的方式来处理程序流程中的特定事件，使得开发者能够在不改变原有程序结构的情况下，添加或修改功能。 </p><p>在Python中，可以使用<strong>装饰器</strong>来实现钩子函数。以下是一个简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hook_decorator</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;在函数执行前执行的钩子函数&quot;</span>)</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;在函数执行后执行的钩子函数&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@hook_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">example_function</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;这是一个示例函数&quot;</span>)</span><br><span class="line"></span><br><span class="line">example_function()</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输出结果：</span></span><br><span class="line"><span class="string">在函数执行前执行的钩子函数</span></span><br><span class="line"><span class="string">这是一个示例函数</span></span><br><span class="line"><span class="string">在函数执行后执行的钩子函数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;钩子函数、python中定义钩子函数&quot;&gt;&lt;a href=&quot;#钩子函数、python中定义钩子函数&quot; class=&quot;headerlink&quot; title=&quot;钩子函数、python中定义钩子函数&quot;&gt;&lt;/a&gt;钩子函数、python中定义钩子函数&lt;/h3&gt;&lt;p&gt;钩子函数的概</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="基础" scheme="http://example.com/categories/python/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="钩子函数" scheme="http://example.com/categories/python/%E5%9F%BA%E7%A1%80/%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="钩子函数" scheme="http://example.com/tags/%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/"/>
    
    <category term="装饰器" scheme="http://example.com/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    
    <category term="hook" scheme="http://example.com/tags/hook/"/>
    
  </entry>
  
  <entry>
    <title>纯函数</title>
    <link href="http://example.com/2024/03/06/%E7%BA%AF%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2024/03/06/%E7%BA%AF%E5%87%BD%E6%95%B0/</id>
    <published>2024-03-07T03:45:08.000Z</published>
    <updated>2024-03-07T03:49:11.775Z</updated>
    
    <content type="html"><![CDATA[<h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><p><strong>纯函数（Pure Function）是一种在函数式编程中非常重要的概念，它指的是那些给定相同的输入，总是返回相同输出，并且在执行过程中不会产生副作用的函数</strong>。</p><p>纯函数的核心特征包括：</p><ul><li><strong>相同的输入产生相同的输出</strong>：这意味着如果两次调用函数时的参数完全相同，那么这两次调用的结果也应该是相同的。</li><li><strong>无副作用</strong>：纯函数在执行过程中不会改变任何状态，也不会与系统外部有任何可观察的交互，例如修改全局变量、进行I/O操作等。</li><li><strong>结果只依赖于输入参数</strong>：函数的返回值只能由它的参数决定，不依赖于任何外部状态或额外的输入。</li></ul><p>纯函数的优势在于它们具有可预测性，易于测试和重用。由于它们的输出完全由输入决定，因此可以在不产生副作用的情况下自由地替换和使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;纯函数&quot;&gt;&lt;a href=&quot;#纯函数&quot; class=&quot;headerlink&quot; title=&quot;纯函数&quot;&gt;&lt;/a&gt;纯函数&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;纯函数（Pure Function）是一种在函数式编程中非常重要的概念，它指的是那些给定相同的输入，总是返回相同输出</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="基础" scheme="http://example.com/categories/python/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="纯函数" scheme="http://example.com/categories/python/%E5%9F%BA%E7%A1%80/%E7%BA%AF%E5%87%BD%E6%95%B0/"/>
    
    
    <category term="纯函数" scheme="http://example.com/tags/%E7%BA%AF%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>pytest | 异常断言</title>
    <link href="http://example.com/2024/03/06/pytest%E5%BC%82%E5%B8%B8%E6%96%AD%E8%A8%80/"/>
    <id>http://example.com/2024/03/06/pytest%E5%BC%82%E5%B8%B8%E6%96%AD%E8%A8%80/</id>
    <published>2024-03-07T03:44:37.000Z</published>
    <updated>2024-03-07T03:48:08.198Z</updated>
    
    <content type="html"><![CDATA[<h3 id="pytest异常断言"><a href="#pytest异常断言" class="headerlink" title="pytest异常断言"></a>pytest异常断言</h3><p><strong>异常断言</strong>即测试待测代码段是否会抛出特定的异常。异常断言最常用的两种方式如下：</p><ol><li>pytest.raises()</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_zero_division</span>():</span></span><br><span class="line">    <span class="comment"># pytest.raises(ZeroDivisionError)作为一个上下文管理器（context manageer）断言with后的代码块是否会抛出“ZeroDivisionError”除零异常</span></span><br><span class="line">    <span class="keyword">with</span> pytest.raises(ZeroDivisionError) <span class="keyword">as</span> excpinfo:</span><br><span class="line">        <span class="number">1</span> / <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 异常信息excpinfo中匹配除零异常信息“division by zero”</span></span><br><span class="line">    <span class="keyword">assert</span> excpinfo.match(<span class="string">&quot;division by zero&quot;</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li>@pytest.mark.xfail</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>():</span></span><br><span class="line">    <span class="keyword">raise</span> IndexError()</span><br><span class="line"></span><br><span class="line"><span class="comment"># @pytest.mark.xfail(raises=IndexError)是一个python装饰器，用于标记（mark）一个测试用例为预期失败，该例子中若f()函数抛出IndexError异常，则标记该测试为预期失败，测试报告（report）中会报告一个1 xfail，若f()函数未抛出IndexError异常，则测试报告中会报告一个1 xpass</span></span><br><span class="line"><span class="meta">@pytest.mark.xfail(<span class="params">raises=IndexError</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_f</span>():</span></span><br><span class="line">    f()</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>将<code>pytest.mark.xfail</code>与<code>raises</code>参数一起使用可能更适合于记录未修复的bug，使用<code>pytest.reises()</code>可能更适合于测试自己的代码故意引发的异常的情况。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;pytest异常断言&quot;&gt;&lt;a href=&quot;#pytest异常断言&quot; class=&quot;headerlink&quot; title=&quot;pytest异常断言&quot;&gt;&lt;/a&gt;pytest异常断言&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;异常断言&lt;/strong&gt;即测试待测代码段是否会抛出特定的异</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="python测试框架" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="pytest" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/pytest/"/>
    
    <category term="异常断言" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/pytest/%E5%BC%82%E5%B8%B8%E6%96%AD%E8%A8%80/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="pytest" scheme="http://example.com/tags/pytest/"/>
    
    <category term="python测试框架" scheme="http://example.com/tags/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="异常断言" scheme="http://example.com/tags/%E5%BC%82%E5%B8%B8%E6%96%AD%E8%A8%80/"/>
    
    <category term="pytest.mark.xfail" scheme="http://example.com/tags/pytest-mark-xfail/"/>
    
    <category term="pytest.raises" scheme="http://example.com/tags/pytest-raises/"/>
    
  </entry>
  
  <entry>
    <title>并行计算 | GPU加速原理</title>
    <link href="http://example.com/2024/03/01/GPU%E5%8A%A0%E9%80%9F%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2024/03/01/GPU%E5%8A%A0%E9%80%9F%E5%8E%9F%E7%90%86/</id>
    <published>2024-03-01T13:32:48.000Z</published>
    <updated>2024-03-01T13:35:08.092Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GPU加速原理"><a href="#GPU加速原理" class="headerlink" title="GPU加速原理"></a>GPU加速原理</h3><p>GPU加速的原理是利用多核处理器进行并行运算来实现程序的加速运行**。与CPU不同，GPU拥有数以千计的核心，专门为同时处理多任务而设计，可以高效地处理并行任务。</p><p>CPU几倍很强的通用性，可以处理不同类型的数据，同时擅长处理逻辑判断导致的大量分支跳转和中断处理，CPU相当于一个博学多闻的博士在完成一项工作。而GPU处理的数据类型高度统一，且GPU有数以千计的核心，可以并行计算任务，相当于1000个小学生在完成一个任务，呈现“人多力量大”的优势。</p><p>实际使用中，GPU需要CPU的配合来完成任务的计算，并行计算部分会运行在GPU上，串行计算部分运行在CPU上，CPU负责总体的程序流程。</p><p><a href="https://blog.csdn.net/qq_41632117/article/details/118737557">参考资料：GPU加速原理，博主写的非常详细！</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;GPU加速原理&quot;&gt;&lt;a href=&quot;#GPU加速原理&quot; class=&quot;headerlink&quot; title=&quot;GPU加速原理&quot;&gt;&lt;/a&gt;GPU加速原理&lt;/h3&gt;&lt;p&gt;GPU加速的原理是利用多核处理器进行并行运算来实现程序的加速运行**。与CPU不同，GPU拥有数以千</summary>
      
    
    
    
    <category term="并行计算" scheme="http://example.com/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
    <category term="GPU" scheme="http://example.com/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/GPU/"/>
    
    <category term="GPU加速原理" scheme="http://example.com/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/GPU/GPU%E5%8A%A0%E9%80%9F%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="GPU" scheme="http://example.com/tags/GPU/"/>
    
    <category term="CPU" scheme="http://example.com/tags/CPU/"/>
    
    <category term="并行计算" scheme="http://example.com/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
    <category term="串行计算" scheme="http://example.com/tags/%E4%B8%B2%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
    <category term="GPU加速原理" scheme="http://example.com/tags/GPU%E5%8A%A0%E9%80%9F%E5%8E%9F%E7%90%86/"/>
    
    <category term="多核处理器" scheme="http://example.com/tags/%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>pytest | 如何调用pytest</title>
    <link href="http://example.com/2024/02/29/%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8pytest/"/>
    <id>http://example.com/2024/02/29/%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8pytest/</id>
    <published>2024-02-29T11:38:53.000Z</published>
    <updated>2024-02-29T11:42:48.245Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何调用pytest"><a href="#如何调用pytest" class="headerlink" title="如何调用pytest"></a>如何调用pytest</h3><p>pytest支持命令行参数选择特定的tests去执行，以下是常见的一些选择方法。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> run tests <span class="keyword">in</span> a module</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行测试文件中的所有符合pytest测试发现规则的测试用例(测试文件中符合test_*()的函数、TestXxx类中的测试用例)</span></span><br><span class="line">pytest test_mod.py</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> run tests <span class="keyword">in</span> a directory</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行testing目录下的所有文件名符合test_*.py或*_test.py的测试文件中的测试用例</span></span><br><span class="line">pytest testing/</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># run tests by keyword expressions</span></span><br><span class="line">pytest -k <span class="string">&quot;MyClass and not method&quot;</span></span><br><span class="line"><span class="comment"># 通过关键词表达式指定pytest运行的测试用例，pytest会在testpaths或者当前目录下找到类名为TestMyClass的类中的方法名不带method的方法去执行。如下示例，运行pytest -k &quot;MyClass and not method&quot;会执行test_a方法而不会运行test_method_add()方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编写测试文件test_keyword_exp.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestMyClass</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_a</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="string">&quot;a&quot;</span> == <span class="string">&quot;a&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_method_add</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> add(<span class="number">1</span>, <span class="number">2</span>) == <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> run tests by collection arguments</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> To run a specific <span class="built_in">test</span> within a module</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行test_mod.py测试文件中的test_func测试用例</span></span><br><span class="line">pytest tests/test_mod.py::test_func</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> To run all tests <span class="keyword">in</span> a class:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行test_mod.py测试文件中的TestClass类中的测试用例</span></span><br><span class="line">pytest tests/test_mod.py::TestClass</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Specifying a specific <span class="built_in">test</span> method:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行test_mod.py测试文件中的TestClass类中的test_method测试用例</span></span><br><span class="line">pytest tests/test_mod.py::TestClass::test_method</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Specifying a specific parametrization of a <span class="built_in">test</span>:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行test_mod.py测试文件中的带参数的test_func测试用例</span></span><br><span class="line">pytest tests/test_mod.py::test_func[x1,y2]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Run tests by marker expressions</span></span><br><span class="line"><span class="comment"># 运行带有@pytest.mark.slow装饰器的测试</span></span><br><span class="line">pytest -m slow</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下示例中，pytest将运行test_a测试用例，而不会运行test_b测试用例</span></span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestMarkDecoration</span>:</span></span><br><span class="line"><span class="meta">    @pytest.mark.slow</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_a</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="number">1</span> == <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @pytest.mark.quick</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_b</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="number">2</span> == <span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> run tests from packages</span></span><br><span class="line">pytest --pyargs pkg.testing</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这将导入pkg.testing，并使用其文件系统位置从中查找和运行测试</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;如何调用pytest&quot;&gt;&lt;a href=&quot;#如何调用pytest&quot; class=&quot;headerlink&quot; title=&quot;如何调用pytest&quot;&gt;&lt;/a&gt;如何调用pytest&lt;/h3&gt;&lt;p&gt;pytest支持命令行参数选择特定的tests去执行，以下是常见的一些选择方</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="python测试框架" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="pytest" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/pytest/"/>
    
    <category term="如何调用pytest" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/pytest/%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8pytest/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="pytest" scheme="http://example.com/tags/pytest/"/>
    
    <category term="测试框架" scheme="http://example.com/tags/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>pytest | pytest使用规则及示例</title>
    <link href="http://example.com/2024/02/29/pytest%E6%B5%8B%E8%AF%95%E7%A4%BA%E4%BE%8B/"/>
    <id>http://example.com/2024/02/29/pytest%E6%B5%8B%E8%AF%95%E7%A4%BA%E4%BE%8B/</id>
    <published>2024-02-29T11:10:36.000Z</published>
    <updated>2024-02-29T11:36:05.332Z</updated>
    
    <content type="html"><![CDATA[<h3 id="pytest使用规则及示例"><a href="#pytest使用规则及示例" class="headerlink" title="pytest使用规则及示例"></a>pytest使用规则及示例</h3><p>Pytest是一个功能强大且易于使用的<code>python测试框架</code>，支持编写<code>单元测试</code>、<code>集成测试</code>和<code>功能测试</code>。</p><p>Pytest使用规则：</p><ol><li>测试文件命名应符合<code>test_*.py</code>或<code>*_test.py</code></li><li>若使用class对测试用例进行分组，测试类名应符合<code>TestXxx</code></li><li>测试用例函数/方法名称应符合<code>test_*()</code></li></ol><p>另外，值得注意的是，pytest支持在测试类中定义<code>setup</code>和<code>teardown</code>方法，这写方法会<strong>在每个测试方法运行前后分别调用</strong>，用于设置测试环境和清理资源。<code>setup_class</code>和<code>teardown_class</code>方法在测试类中的<strong>所有测试方法之前和之后分别只运行一次</strong>。</p><p>下面编写一个计算器类Calculator，并使用pytest进行测试。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test_calculator.py 测试文件名称符合test_*.py</span></span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义计算器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sub</span>(<span class="params">a, b</span>):</span></span><br><span class="line">        <span class="keyword">return</span> a - b</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mul</span>(<span class="params">a, b</span>):</span></span><br><span class="line">        <span class="keyword">return</span> a * b</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">div</span>(<span class="params">a, b</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> a / b</span><br><span class="line">        <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;zero Division Error Exception&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义测试类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCalc</span>:</span>  <span class="comment"># 测试类名符合TestXxx</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_calc_add</span>(<span class="params">self</span>):</span>  <span class="comment"># 测试用例方法名符合test_*()</span></span><br><span class="line">        <span class="keyword">assert</span> Calculator.add(<span class="number">1</span>, <span class="number">2</span>) == <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_calc_sub</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> Calculator.sub(<span class="number">3</span>, <span class="number">1</span>) == <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_calc_mul</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> Calculator.mul(<span class="number">2</span>, <span class="number">4</span>) == <span class="number">8</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_calc_div</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> Calculator.div(<span class="number">8</span>, <span class="number">4</span>) == <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_calc_div_zero_div_exp</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">with</span> pytest.raises(ZeroDivisionError):</span><br><span class="line">            Calculator.div(<span class="number">3</span>, <span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;pytest使用规则及示例&quot;&gt;&lt;a href=&quot;#pytest使用规则及示例&quot; class=&quot;headerlink&quot; title=&quot;pytest使用规则及示例&quot;&gt;&lt;/a&gt;pytest使用规则及示例&lt;/h3&gt;&lt;p&gt;Pytest是一个功能强大且易于使用的&lt;code&gt;p</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="python测试框架" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="pytest" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/pytest/"/>
    
    <category term="pytest使用规则及示例" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/pytest/pytest%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99%E5%8F%8A%E7%A4%BA%E4%BE%8B/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="pytest" scheme="http://example.com/tags/pytest/"/>
    
    <category term="单元测试" scheme="http://example.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
    <category term="集成测试" scheme="http://example.com/tags/%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95/"/>
    
    <category term="功能测试" scheme="http://example.com/tags/%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
    <category term="测试框架" scheme="http://example.com/tags/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>DevOps | CI/CD</title>
    <link href="http://example.com/2024/02/28/CI-CD/"/>
    <id>http://example.com/2024/02/28/CI-CD/</id>
    <published>2024-02-28T11:41:24.000Z</published>
    <updated>2024-02-28T11:55:43.510Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI/CD"></a>CI/CD</h3><p><strong>CI/CD</strong>:持续集成和持续交付/持续部署，是DevOps实践中的关键组成部分，包括<strong>代码的自动构建、测试和部署</strong>，以确保软件的快速和健壮开发。</p><p><code>DevOps</code>是软件开发中的一种文化和实践，强调开发（Development），测试，运维（Operations）三个领域的合并，通过自动化软件交付和架构变更的流程，实现构建、测试、发布软件的快捷、频繁和可靠。</p><p><a href="https://www.redhat.com/zh/topics/devops/what-is-ci-cd">参考资料1：什么是 CI/CD？</a></p><p><a href="https://zhuanlan.zhihu.com/p/136843588">参考资料2：使用gitlab实现CI/CD</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;CI-CD&quot;&gt;&lt;a href=&quot;#CI-CD&quot; class=&quot;headerlink&quot; title=&quot;CI/CD&quot;&gt;&lt;/a&gt;CI/CD&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;CI/CD&lt;/strong&gt;:持续集成和持续交付/持续部署，是DevOps实践中的关键组成部分，包括</summary>
      
    
    
    
    <category term="DevOps" scheme="http://example.com/categories/DevOps/"/>
    
    <category term="CI/CD" scheme="http://example.com/categories/DevOps/CI-CD/"/>
    
    
    <category term="DevOps" scheme="http://example.com/tags/DevOps/"/>
    
    <category term="CI" scheme="http://example.com/tags/CI/"/>
    
    <category term="CD" scheme="http://example.com/tags/CD/"/>
    
    <category term="持续集成" scheme="http://example.com/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
    <category term="持续交付" scheme="http://example.com/tags/%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98/"/>
    
    <category term="持续部署" scheme="http://example.com/tags/%E6%8C%81%E7%BB%AD%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>python | 迭代器与生成器的区别</title>
    <link href="http://example.com/2024/02/28/python%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2024/02/28/python%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2024-02-28T11:30:00.000Z</published>
    <updated>2024-02-28T11:32:59.296Z</updated>
    
    <content type="html"><![CDATA[<h3 id="迭代器与生成器的区别"><a href="#迭代器与生成器的区别" class="headerlink" title="迭代器与生成器的区别"></a>迭代器与生成器的区别</h3><ol><li><p>python迭代器</p><p>Python中的迭代器是一个可以记住遍历位置的对象，用于访问集合元素的一种方式。迭代器是Python中处理数据集合的一种高效机制，它们<strong>允许开发者逐个访问集合中的元素，而不需要一次性将所有数据加载到内存中</strong>。</p><p>迭代器通过实现<code>__iter__()</code>和<code>__next__()</code>方法来定义其行为。<code>__iter__()</code>方法返回迭代器对象本身，而<code>__next__()</code>方法负责返回容器中的下一个值。当没有更多元素可以返回时，<code>__next__()</code>方法会抛出<code>StopIteration</code>异常，通知调用者所有元素已经被遍历完毕。</p><span id="more"></span><p>​    在Python中，可以使用<code>iter()</code>函数获取一个对象的迭代器，然后使用<code>next()</code>函数来访问迭代器中的下一个元素。此外，Python的for循环本质上就是在使用迭代器，它可以自动处理<code>StopIteration</code>异常，使得代码更加简洁易读。以下是使用for循环遍历可迭代对象中元素的示例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用for循环遍历list、tuple、dict、str、set等可迭代对象</span></span><br><span class="line"><span class="comment"># 遍历列表list</span></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line">    <span class="built_in">print</span>(element)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 编译元组tuple</span></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(element)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 遍历字典dict</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> &#123;<span class="string">&#x27;one&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>: <span class="number">2</span>&#125;:</span><br><span class="line">    <span class="built_in">print</span>(key)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 遍历字符串str</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> <span class="string">&quot;123&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(char)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 遍历集合</span></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> &#123;<span class="string">&#x27;1&#x27;</span>, <span class="number">2</span>, <span class="number">3.0</span>&#125;:</span><br><span class="line">    <span class="built_in">print</span>(element)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 使用python内置方法iter()获取对象的迭代器iterator</span></span><br><span class="line"><span class="comment"># 获取字符串迭代器</span></span><br><span class="line">s = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">it_s = <span class="built_in">iter</span>(s)</span><br><span class="line"><span class="built_in">print</span>(it_s)  <span class="comment"># &lt;str_iterator object at 0x10c90e650&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_s))  <span class="comment"># &#x27;a&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_s))  <span class="comment"># &#x27;b&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_s))  <span class="comment"># &#x27;c&#x27;</span></span><br><span class="line"><span class="comment"># print(next(it)) # StopIteration</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取列表迭代器</span></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">it_list1 = <span class="built_in">iter</span>(list1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_list1))  <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_list1))  <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_list1))  <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取集合迭代器</span></span><br><span class="line">set1 = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line">it_set1 = <span class="built_in">iter</span>(set1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_set1))  <span class="comment"># &#x27;a&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_set1))  <span class="comment"># &#x27;b&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_set1))  <span class="comment"># &#x27;c&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取字典迭代器</span></span><br><span class="line">dict1 = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line">it_dict1 = <span class="built_in">iter</span>(dict1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_dict1))  <span class="comment"># ’a‘</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_dict1))  <span class="comment"># ’b‘</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_dict1))  <span class="comment"># ’c‘</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取元组迭代器</span></span><br><span class="line">tuple1 = (<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>)</span><br><span class="line">it_tuple1 = <span class="built_in">iter</span>(tuple1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_tuple1))  <span class="comment"># 1.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_tuple1))  <span class="comment"># 2.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_tuple1))  <span class="comment"># 3.0</span></span><br></pre></td></tr></table></figure></li><li><p>python生成器</p><p>Python中的生成器是一种<strong>特殊类型的迭代器</strong>，它使用<code>yield</code>关键字来返回数据。</p><p>生成器是一种特殊的函数，它可以在执行过程中暂停并保存其状态，以便稍后从上次停止的位置继续执行。当生成器被调用时，它不会立即执行，而是返回一个生成器对象。只有当开始迭代该对象时，生成器才会逐步执行，并在每次遇到<code>yield</code>语句时返回一个值。</p><p><strong>生成器的主要优点是它们可以按需生成数据，而不是一次性生成所有数据</strong>。这在<strong>处理大量数据</strong>或需要<strong>延迟计算结果</strong>的情况下非常有用。生成器还可以用于实现协程（coroutines），这是一种允许多个任务协作执行的编程模式。</p><p>以下是一个简单的生成器示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_up_to</span>(<span class="params"><span class="built_in">max</span></span>):</span></span><br><span class="line">    count = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> count &lt;= <span class="built_in">max</span>:</span><br><span class="line">        <span class="keyword">yield</span> count</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个生成器对象</span></span><br><span class="line">counter = count_up_to(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代生成器对象</span></span><br><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> counter:</span><br><span class="line">    <span class="built_in">print</span>(number)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 使用生成器表达式定义生成器，采用()</span></span><br><span class="line">num_iterator = (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(num_iterator)</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> num_iterator:</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line"></span><br><span class="line">num_iterator2 = (i*i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(num_iterator2))  <span class="comment"># 求平方和</span></span><br><span class="line"></span><br><span class="line">xvec = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line">yvec = [<span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(x*y <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(xvec, yvec)))  <span class="comment"># 点积</span></span><br><span class="line"></span><br><span class="line">data = <span class="string">&#x27;golf&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(data[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>)))  <span class="comment"># 反转输出字符串</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;迭代器与生成器的区别&quot;&gt;&lt;a href=&quot;#迭代器与生成器的区别&quot; class=&quot;headerlink&quot; title=&quot;迭代器与生成器的区别&quot;&gt;&lt;/a&gt;迭代器与生成器的区别&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;python迭代器&lt;/p&gt;
&lt;p&gt;Python中的迭代器是一个可以记住遍历位置的对象，用于访问集合元素的一种方式。迭代器是Python中处理数据集合的一种高效机制，它们&lt;strong&gt;允许开发者逐个访问集合中的元素，而不需要一次性将所有数据加载到内存中&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;迭代器通过实现&lt;code&gt;__iter__()&lt;/code&gt;和&lt;code&gt;__next__()&lt;/code&gt;方法来定义其行为。&lt;code&gt;__iter__()&lt;/code&gt;方法返回迭代器对象本身，而&lt;code&gt;__next__()&lt;/code&gt;方法负责返回容器中的下一个值。当没有更多元素可以返回时，&lt;code&gt;__next__()&lt;/code&gt;方法会抛出&lt;code&gt;StopIteration&lt;/code&gt;异常，通知调用者所有元素已经被遍历完毕。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="基础" scheme="http://example.com/categories/python/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="迭代器与生成器的区别" scheme="http://example.com/categories/python/%E5%9F%BA%E7%A1%80/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="迭代器" scheme="http://example.com/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    
    <category term="生成器" scheme="http://example.com/tags/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
    <category term="yield" scheme="http://example.com/tags/yield/"/>
    
    <category term="iter()" scheme="http://example.com/tags/iter/"/>
    
    <category term="next()" scheme="http://example.com/tags/next/"/>
    
  </entry>
  
  <entry>
    <title>C++ | GCC或Clang头文件搜索路径</title>
    <link href="http://example.com/2024/02/26/GCC%E6%88%96Clang%E5%A4%B4%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84/"/>
    <id>http://example.com/2024/02/26/GCC%E6%88%96Clang%E5%A4%B4%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84/</id>
    <published>2024-02-26T12:45:07.000Z</published>
    <updated>2024-02-26T12:56:19.195Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GCC-Clang的头文件搜索路径"><a href="#GCC-Clang的头文件搜索路径" class="headerlink" title="GCC/Clang的头文件搜索路径"></a>GCC/Clang的头文件搜索路径</h3><ul><li><p>GCC/Clang编译器在对C++源代码文件进行预处理时，会对C++源代码头部包含的头文件进行搜索，搜索时根据环境变量CPLUS_INCLUDE_PATH中的路径进行搜索，如果搜索不到某头文件会报错。若CPLUS_INCLUDE_PATH中没有包含所使用头文件所在路径，也可以通过-I参数制定使用到的头文件的路径，例如，gcc -I /your/header/file/ test.cpp。</p></li><li><p>添加GCC头文件搜索路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export CPLUS_INCLUDE_PATH=$CPLUS_INCLUDE_PATH:/xxx/include</span><br></pre></td></tr></table></figure></li><li><p>查看C++编译器（GCC）的头文件搜索路径命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gcc -x c++ -v -E -</span><br><span class="line"><span class="meta">#</span><span class="bash"> gcc：表示使用GCC编译器进行编译。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -x c++：表示指定编译的语言为C++。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -v：表示显示详细的编译过程信息。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -E：表示仅执行预处理阶段，不进行编译和链接。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -：表示从标准输入读取源代码。</span></span><br></pre></td></tr></table></figure></li><li><p>查看C++编译器（Clang）的头文件搜索路径命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">clang -x c++ -v -E -</span><br><span class="line"><span class="meta">#</span><span class="bash"> clang：表示使用GCC编译器进行编译。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -x c++：表示指定编译的语言为C++。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -v：表示显示详细的编译过程信息。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -E：表示仅执行预处理阶段，不进行编译和链接。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -：表示从标准输入读取源代码。</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;GCC-Clang的头文件搜索路径&quot;&gt;&lt;a href=&quot;#GCC-Clang的头文件搜索路径&quot; class=&quot;headerlink&quot; title=&quot;GCC/Clang的头文件搜索路径&quot;&gt;&lt;/a&gt;GCC/Clang的头文件搜索路径&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;G</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    <category term="头文件搜索路径" scheme="http://example.com/categories/C/%E5%A4%B4%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="GCC" scheme="http://example.com/tags/GCC/"/>
    
    <category term="Clang" scheme="http://example.com/tags/Clang/"/>
    
    <category term="头文件搜索路径" scheme="http://example.com/tags/%E5%A4%B4%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>python | 将python程序打包成exe</title>
    <link href="http://example.com/2024/02/22/%E5%B0%86python%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85%E6%88%90exe/"/>
    <id>http://example.com/2024/02/22/%E5%B0%86python%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85%E6%88%90exe/</id>
    <published>2024-02-22T13:03:22.000Z</published>
    <updated>2024-02-22T13:36:23.779Z</updated>
    
    <content type="html"><![CDATA[<h3 id="将python程序打包成exe"><a href="#将python程序打包成exe" class="headerlink" title="将python程序打包成exe"></a>将python程序打包成exe</h3><ol><li><p>编写python程序（例如test.py）</p></li><li><p>安装pyinstaller</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U pyinstaller</span><br></pre></td></tr></table></figure></li><li><p>打包python程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller test.py</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;将python程序打包成exe&quot;&gt;&lt;a href=&quot;#将python程序打包成exe&quot; class=&quot;headerlink&quot; title=&quot;将python程序打包成exe&quot;&gt;&lt;/a&gt;将python程序打包成exe&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;编写python程</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="pyinstaller" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pyinstaller/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="打包" scheme="http://example.com/tags/%E6%89%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>python | python是否支持多线程</title>
    <link href="http://example.com/2024/01/24/python%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://example.com/2024/01/24/python%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2024-01-24T12:41:30.000Z</published>
    <updated>2024-01-24T12:44:17.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python是否支持多线程"><a href="#Python是否支持多线程" class="headerlink" title="Python是否支持多线程"></a>Python是否支持多线程</h1><ol><li><p>多线程</p><p><strong>线程在CPU上运行，是操作系统进行调度和执行的基本单位</strong>。</p></li></ol><p>​    首先，要明确进程与线程的关系。一个进程可以包含多个线程，而每个线程都是进程中的一个执行流。可以把进程比作一个工厂，而线程就像是工厂里的工人，它们共同协作完成工作。</p><p>​    其次，线程的创建和运行是在一个进程中进行的。当启动一个线程时（例如，通过调用<code>Thread.start()</code>方法），操作系统会为这个线程分配必要的资源，包括寄存器、栈等，并在CPU上执行该线程的代码。</p><p>​    再者，在<strong>多核CPU</strong>系统中，<strong>不同的线程可以被分配到不同的核心上并行运行</strong>。而在<strong>单核CPU</strong>中，<strong>线程的运行会通过时间片轮转或优先级调度等方式进行切换</strong>，从而实现并发执行。</p><p>​    最后，<strong>线程之间共享所属进程的内存空间</strong>，包括代码段、数据段、堆和栈。这意味着线程可以访问相同的变量和数据结构，但同时需要注意<strong>同步机制</strong>来避免数据竞争和不一致的问题。</p><p>综上所述，线程是在CPU上运行的，它们利用进程中的资源和内存空间，按照操作系统的调度策略执行任务。</p><ol><li>python是否支持多线程？</li></ol><p>Python支持<strong>多线程</strong>，但由于全局解释器锁（GIL）的存在，在任意时刻只能有一个线程执行Python字节码。Python中的多线程是通过<strong>在一个进程中创建多个线程来实现的</strong>，每个线程可以执行不同的任务。然而，由于Python解释器（cpython，由c语言编写的python解释器库）的GIL限制，这些线程并不是真正意义上的并行执行。GIL确保了同一时间只有一个线程能够访问Python的对象和内存空间，这意味着即使在多核处理器上，Python的多线程也无法实现真正的并行计算。</p><p>​    尽管如此，Python的多线程对于<strong>I/O密集型任务</strong>仍然非常有用，因为它们可以在等待I/O操作完成时释放GIL，从而允许其他线程执行。在这种情况下，多线程可以提高程序的效率，因为它们可以减少因等待I/O而浪费的时间。</p><p>​    此外，如果需要执行<strong>CPU密集型任务</strong>，或者希望充分利用多核处理器的能力，可以考虑使用Python的<strong>多进程</strong>模块<code>multiprocessing</code>。多进程可以绕过GIL的限制，因为<strong>每个进程都有自己的Python解释器和内存空间</strong>，从而实现真正的并行执行。</p><p>​    multiprocessing实现多进程并行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_cube</span>(<span class="params">num</span>):</span> </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Cube: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(num * num * num)) </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_square</span>(<span class="params">num</span>):</span> </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Square: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(num * num)) </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>: </span><br><span class="line">    <span class="comment"># 创建进程</span></span><br><span class="line">    p1 = multiprocessing.Process(target=print_square, args=(<span class="number">10</span>, )) </span><br><span class="line">    p2 = multiprocessing.Process(target=print_cube, args=(<span class="number">10</span>, )) </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开启进程</span></span><br><span class="line">    p1.start() </span><br><span class="line">    p2.start() </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待p1、p2线程都执行完</span></span><br><span class="line">    p1.join() </span><br><span class="line">    p2.join() </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Done!&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Python是否支持多线程&quot;&gt;&lt;a href=&quot;#Python是否支持多线程&quot; class=&quot;headerlink&quot; title=&quot;Python是否支持多线程&quot;&gt;&lt;/a&gt;Python是否支持多线程&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;多线程&lt;/p&gt;
&lt;p&gt;&lt;stron</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="基础" scheme="http://example.com/categories/python/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="python是否支持多线程" scheme="http://example.com/categories/python/%E5%9F%BA%E7%A1%80/python%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="multiprocessing" scheme="http://example.com/tags/multiprocessing/"/>
    
    <category term="多线程" scheme="http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="python解释器" scheme="http://example.com/tags/python%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
    
    <category term="cpython" scheme="http://example.com/tags/cpython/"/>
    
  </entry>
  
  <entry>
    <title>记录生活 | 回顾过去七年</title>
    <link href="http://example.com/2024/01/14/%E5%9B%9E%E9%A1%BE%E8%BF%87%E5%8E%BB%E4%B8%83%E5%B9%B4/"/>
    <id>http://example.com/2024/01/14/%E5%9B%9E%E9%A1%BE%E8%BF%87%E5%8E%BB%E4%B8%83%E5%B9%B4/</id>
    <published>2024-01-14T13:05:29.000Z</published>
    <updated>2024-01-14T14:16:50.094Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="27e6817d642bc8140dc16eef201868f96f2609ba8b663023ea9e9147c3c5e7f5">b780b0a90ab26cc39689a6bfa1e86daac6442d6de9743a9acd3f0a2af43b85bdb715df0ebdb51ad32f6a5c32379787da49754b6d64ef0f02bc11fe93600aa0ba3a7a0eb9b2c3860f78bf73f5530e7151d69ecab0d672f1a03902e66963d3d7d3e46b7274546f6ffe6a543802835573f898159d5c126b8ab13f510e6cc7c9654b7db00e9e42999592df4d41b9dff36a8b5d671aef5ee92548d0a71772dcffc87d88e21224f1c60a24627c5aae61e6ec1064ae7e99d3c3dfa21422752fe488128e283b4d751aa97f95603c65485cdc8ccb8e7521e1907de08874e611ce3774e9b11bf928767ecb99b4243b2034b317cdfca49ea7e8e33ad7e549dad741371251e9a574e00eb0236a5412c9646d60bd09680d2ddab49d398ca6d38f41c9d779956edc2f850b251dc91a6156932c055053c082208f6ab34fe04daa3591916d86e270466f0deb70ccf75177083639925460e22a9d3c547b3105295a4f8bc7300aa64b4bc037923b2e822fdabb68b77e3e76599076709e4fa4659d55bff65db3662140243cf18ad27d609579c991d39e429d41d34824b9e76e7c5b390545522cda880964fd356bc654e6fd4f9b4fc4e5d663672983f2fa85564e0f0e5360af66838a80e7becf77a5f38a929225536db201b29fc1f03be52a305cba271bd50ef401aae717d2073559aca3f3574655630e5a2d57ea3ee83307ad452339012334d327da40c73b4e925f8f2232810d5d256aa74cc85464321b6bd23c67cf3d0e2576696c52aadd9e232b8e1f3d32af4f8d271a634b290c5402a28998ac5acce2e311fbb8c80d5fbd5f4b33473af210f9393a509103acea363659de510e040ddc5a6dad19efa0e5d0b3dd95c483946db7c8adb5cd6b7cb57f5d169e7f67d442e7a7b25a11049fd30f5dba604f0ecac2a36a487bae69e547dd1beb43b3077147bba95d600eefd55e3d54e6a579678f6013d4ba9e1d731030a5b17fdae327100bc00280038d0d3f9c027ec603c759fd87b1026174c936b18d8872b8b3c28bc4a9fdfd5d536a72b60fe73f7d49fd67b29389451e17a24205362bf0d62cad7076bd5d47a1a06b2caee77dfd337318e68f40a7d151360b67bae8a0cc874217e2c676f3a62f9bf07b9f657e26d04a210f54ed84c7d82c036dbb22a20757808ccc4370406e2ee060d8ad8a10ff8cc969db95ea68c2c3dfebb01943d77c067956072f3f587bc0994c860ebfe89b6f19433b042ef14d234d41842e3b4761cea9567a7f9d0f23f699582be2ff7f44f1d08dafc360259d107b5091f365c29ad3b7403e63e7f5730c5ce58ad524c5931e6d92ff78c5ce4284889cae4f2f1e68d5f6c8fe2161a7086df744cdbe2e5b7099ef9fa267d78bad60be2148a1f864a8f7c7b8e5d122e7a3525dc506813c4cf708266db032f636030fcc14063d318355b4321912f78bb8dc0a14d5528fc989ddee5e809cd1fb71dcadfc52cc47d8265c762f6bfe2012b38d79524fcaa1012fd737cde7d26ffc87845452e1cd56777b08b59af38083ff3c9c13e9601d8f50220cf74fec358637cb1e9021075d82f0fc2b9a172b27eb83979591c17cd8f6f96a3a65fb7cb97041f800109b70befeabba168fe05b52027b0a74e1c1016621cf725a975ac4da24e728a9413622fdaae45061d5073786788e3188c0a982594b0cc71d38581383f75d87accfd584252e6d29f9e3ebcfbbe3e38e7b45d082613cb3571bdefb3bf0b351e9e896fc226b8918f2c852028ba23702a8a6a5c27bd2cf045c6c4c48082efff5ed4811b199f248330dd95b83ede847a1fb309a6fc849fcf319d398f7c7e3e390a50a7d5c3fe3d6510bd1efcc69ef1d258dcf346309723b1da6a5622367a7e279b4aecbc0a8fd3bb12a51424dea3447321d6d2f449ebd1b0025f9fa778c5e0176302a7450787f7130a2ce010317e47f56ebf7f93cb36094654c81e10ab2dab2bed01269284637f6c4c22ba21d0135e08e6c7cefd8f7f8f612cf4a831898b71db92b35c5db1f11652738723388006f5ca3827a4d8cb7edce64860d2cc91e4032ae025397605b181d8a5c6c8ae55b0c6d1bf55053cca5b14ea45e2caed66d22a97bd5f353d410d792bb409d751ea0818608e2ac320238bfb936e6e4c978e1657fe5f9515e1fcfc9e09341633737c6b2c544f0f2b45459ac23784c4606afa42f84bfa32f760ee811e41e9be4ccf7cf38b7bac66edbff9ce1b3e1a5a741d832271147a46ebe3a97003d5751350dbc8dc4328336bc7047112b812beb5b699035d585c86eb884cb1aebf08be2dad1e0a676f67dd471c4bb2a41b2abacd794e1c9f846f2837a19946c0ea9679d60c770482164269167b8f4863816458d5bc153cbbc1adeb0fff88ee44cbb4f3c4af6fe7b9e4e7c77154d71d8ece4de67765abe0ade375d2e0d1ba0c45e065bc26523a3fa1c67ad6bde7636394a18f617bef78d4adb027a4f734f5ee57ea4b80f2b7598965bdb92f198e3218e1651ac87f8ee66cdab49d46379c0dc67976483c5a1d74d4b3e5e2e4f2358cccaa06b0fcae6d32ac16ad0748cc1c3b31724fd9d77cff876c9006da4f78bc0bdacac7ec57ade50cf0915854cd97ca7421635d5bbd84ab125145d9cf1c60b8073955235b007c83fda33479686f1e528f5366de8915a3608d12b51c028ed3644c6ff474a7be3c775372d2ec5048dcabcfbd3a5ba1de45078819af9f2e8787892ebba6771be39b4224818a194629d2e69e740a6a2c7e973bd666562f02c676e02f2bd547af3fd426e329f369dcb284ecc55630fbbee7a1335b04458366b19e9b45542da2fe31ed568329cde6fd41867974dd0e1034ba6ebdbfe28e26ae1d28aca4c5410a366b91d3caacdbd536f67e0bc82e948fffc80bf61e7f25014df02dc835a49ce682c87a9362fd270f84b8187fa24f204c991597b9dad86d0e31adb958209b2241d2f3bff0aac3b99d3251d5be04f3087bdeca114257961e201de55a66fa07c72dacfbabb9d8722b2a8eefec54fc146c1866fbef2d91f59a6a3d9d64577366d41bf2d6e83a96bd44073d3383c2d10f8179271e6cb2b5c3166bf86c93da1fe586843f05fce0af82151e54a552a1d8a49a52c4cb2c006fafdd43f8fda62be68a412582656eb72d55eb22f9d925d0fc0cc2ad0e143e7247871a58f2e3fb87e19aa51640d2631969dc3a7a5c3f23dd4b7de7b92760495de12ff143a54591e37becf42a915ac3459f5597a4060f4e9139514ee37405d4e49b47c3b8357271e439b682efd77b45ef7e21046722bc964a4370ce571e825b4ad109df4325b152480c2a0e2b92d3a682313de09c5a9816a48d4951a42f0e5015b5c5cfe1ddf16bc14cc39245c47d4bb16863ae322cc4df453a7ab522044ebb5c8451fc1478cc63237bf24fbb75f464b7532b2bee4c892b8179dc86a714b49bcdb9e7b5ce651c7dd9fd0ae35f7c881f4d0550b86a345d0e41e5ea66c9ee1f1648ecda62b3003f10dff48d5416de75df08b503a0c41d94602ead624db85c378519c6c5b9b87c99b0e049aa6c8a72ec3ae750443075f66e00536741c0b240bfdfd4fe055cac97acaf9b4581a8bfdc9e25ddb0880777f4f62fa1935faeff788041859783b34a137273d58256b64d04fe1f1550dacbf56bb6cbe2bf845a4d01c12827cc481924e9ef7048600d98784b7393e0d4744fce15fc1fedbc775e77e7c9132177759243fdf5274b014016d9f17e4391c97048487b75517707bcb66e2fc08accc5ad14a4e7f56d27b82bd606c751b5fcf3c5db974358d8c64d71d3928e4ac3c3ae7da637de7f8cb5e0c4f239793f33256ec40568ec99810762eda17364f847e88c0208db67decd42c2d100eaf5545f4b5c599609b651303d268b3032443775b18f448158ff880936c6afc6a4c7eaf1205c50adce1756d8b7dbf57b308e3f7804466b8b5f89dfd800bec8daadb19b14e2224a15b5201c070ff6fa49e9004b02b40a879eabe54baba9a3fbd8290568e2ee12710183fd842ec0d0b7fb26c617ad0c25653f3c4145dd4e898bbe10e717de2b35c26346fbfb65fcdd15c37080c12f83d12e2d945e0730cc34f081cfc12a9a3b7105b268ba6620f65c3ea82d5a73e9655be3a7242521fdd367da0eafc12efc791e02b0403f2deede7e1429bf28b1e56ed2651c30ebafe7b307fedc201c73178bf5d06e748f986d2f74c218ba05997bb4deb08e1029b242f73f207d0d8cf127d9fda0eea9c7593b80204b26743dae55848b296aa4cac31fffc301466bcb453f35bb65a26a7de13063befd6a3279687cf1038bc4e335ea6bca3155de2fcc231114e99f605b9e6528dfeb410b848023d0486f7cd870f6778298cfc0123644d4ab2dd20fd7ae3914dfe99403edd765bb91a043d47c540f8c1a62e4c47f663a765c08e1e058e75e484c4afbf9c2548c6c70542a5d8fd1491a3cef9f69f6b4421b40f4f49165c7907c96c942fd518d0a2597a149f83837bd52b6205306fc4e9948ebb3d803e3cf8841338de3cb0ab809ee5e13f8432f302f8b7b248e0b042300b75bb77b2b14df7be763be09eac4e30d86917deaa61faccd96ba4275d27d73185da55962deb5a0177d31dfb38a41ff8b16f291ac57ce3130390b3c990ac9c050fb5378b19f69010870af28cf2cd1933c3c212114c6acf37b6c3bb2e43db3bc45dd088ecb33694211244ae8b6a302b15241c357571749b0001f5286c2b8e461ffb78c1dbf54c200acfdeec51af399e7839151d66924d1d8d87537b43ba4c500b28d0da57ccda0df0b9b5a292514a504e54cf1191eb9946ea2dbde9d9b17837e8debbb9bdab86f0affacc950451718a2dc4a0060b8fd2a84afda90101d08b50306853cf01ab41e186868d909569d2fef8c6b4f32de75375810f8607d09120121db8fe978623c34a35d8b4df309ac8952e6748fe0720fdfeb6e4c824a5b548cc2fcb19ce152509b37acd2240c7a5531d564f63ec7843d0d65c56532548a62773a9d9041be4eba4b013ffbd733088a72dc2afb4b2ffea5f7bb9b727499fbfa78376c3e9d455e2f6f07d6565bd31432a5a4110dfa1009c8c1aea5233d7bcb406f9e81e84c2c7ea0e5c27ee790c9da705c4f693637cdb435fb7fdec116d60e8048ede165fcafc035561e16d874c54707a971634ecf5431a913f6d54719c6e4195ed272f3a792d7328cdb334228f43f0c69f28185c41520f4266430efb89ee9d47b4122fb2b0121c24ac458d2b3b0fd0c886819939672f4110d22fe1f243f5d2f72235dedb5a5b400b68f54a9b7da405b9b7b7791ab05f34d736aaef74f47864b42d76c67cc4961b391d8ec674d1511c58230d1b43829a7d8121b278fb0c18c00597e4eba297e9b313c158f32102548aa1fd8356e99e1191a95b9fc035562e914c464440f7ba84ab8f0a6dac5dc97324cd0c20599fefb245705ca0a283c542662e91b3ebc501644f8faea7371be3b75af751f0279871f542f19c4432c46975d624d3625791ade85caa4d2409c36ffcbe555adbf20b8b6d5f893e749c124f73509aa43109c1f1a7b06f4b4c80e474fbff99b5a3a2f70e6f01b358e010a29c3bfbdcdc0f18bd7b772921ff64fe32d355be227b92c88d077feb20bae6fe78c63dd2637914daa27940445e6402470e1be1b32e7254339eefa8f4e789f529a88eaa20a4da651c589e5268927d8215c7e1465e251d20a6bd9485ca0d76ceee5621e3c28cfb6191d178d6a9db0574ba1dc53157a5024b1b904eece92c6e0ccd7fe5f573c61c9b7bfe3ecc12b56611a8a8498e5a2c6626be4640a1ab01a99b6cf960d0798f624ed22b7a3135534e523eba4e71a1e4d4c4bfd887248d8c0482d2f4eea9cf874c3c094d2e81e18223628250f22f5071faaf0ec9e4823426ff0f8685b346870017bd3205577c1b90fdd7540921ee0a2de3d8fe044073a8690ac6d532cb7a398b045cd98c3f735bb57f0a71e3eee88ba03de174bad4a10418873e03f4bac141db0e523df2e1711de58bb7bb54ccf2721c318addc5d7cd5b6a1d04ef20a5e2d151abda8e5b78fde6391c6fe589532669e0124d8ebc4b7b47c68eaa3d68b21fd2efe3951c9763dac6bb0282c23e692c2aaafa0e90f13087bc1aea4f2eec9b1a1f46ee3f1774bc98754ec25cf4af35346b97fb56ad03634c4b1c56ec50bfbfebc50f5b069592a1f608add5f202af5e3bb21b56a89ad9f61ed907248ec5c699e12e537480adda31bcce61f9647e94139bf9ca56a7fb79ef08e94317bdd56dfcb4944953035c0529e004fed3b5e535dc2b8c013c01f23233e52e3a6a8c0817e159321bdb6314f82c206132250746944573ac65533c6dd6317d659fb2287750f1a5c347a7e3e1891a23f057a50e62739dc3b28a8922d22af8ce33a4f19c95b788a304a849f89fe06c86e3872c29c283f2bcf90f9051025d81352f2ab2f586f6caf75fc95c062b8648dcf7aa9148310b624e83d826842195bae0e4f420e6be43d1f00c5519b40247659788937b4964f44971e12ffbf4cdd54b521635febbcb79fdaeb211371f26e7fe129d3e7c8283e1af00c8798e069193da50b2f4850aa550940c9de284f26431e5191d4e7ac2170c37da7c5e608e1e500aa344b2e43bff12412a0dcfcfd92ed77150adbd321d7deed06d965cfb93cf74a93a90d103c66fd721b076cb05eb60cbc821003e90a859af67a2541841bb1d74db1dd7582834bc9e389b9827af81af48d10637b828cfd4ce4d58fa21125000c4396a9a7d3cd41961d0151752081ca67776bb892e8648cce8169a492a1fc1b379abfe61a57aef80f974f0516b9e12166d372a338c651ace40fd28fbe79680e5d92ac0cc92fcb951de3d7594daac82e4c838d8e761f75a8415bdff7d0db3b71f4c039d81bca202b919f686a2df9cbbb0a7f7e700a2f44887886eeab0e1023abd0cb22599b04041983a1d9569ce6ac96fe48b0561221c9b8ec44411bfa1533a87ca61d8ac1f2f7cc2dfc54cf48c5b67895788a89a79e370717a863508fb3d45a81f19f6aa69acb01cc3fc267d953d459726da3dc098b3e314b2e35ec8a4db0a77b55bf7e464c6b7585f8453fd233062c75536e66fd9a3563436bfb41827646f292335a963d81ef6861ca3d56a61120ec734b198936288b2922e8e8d51f8122b66251a30d3bbaf158bf1647e8c21dc35204f41df9dc383eb01f8bcb3613ff1</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">此文涉及个人经历，暂不公开！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="记录生活" scheme="http://example.com/categories/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/"/>
    
    <category term="回顾过去七年" scheme="http://example.com/categories/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E5%9B%9E%E9%A1%BE%E8%BF%87%E5%8E%BB%E4%B8%83%E5%B9%B4/"/>
    
    
    <category term="记录生活" scheme="http://example.com/tags/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>C++ | 字符串分割</title>
    <link href="http://example.com/2023/10/12/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2/"/>
    <id>http://example.com/2023/10/12/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2/</id>
    <published>2023-10-12T15:54:27.000Z</published>
    <updated>2023-10-12T15:56:10.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-字符串分割"><a href="#C-字符串分割" class="headerlink" title="C++字符串分割"></a>C++字符串分割</h1><p>字符串分割是编程中经常遇到的一个问题，采用C++语言实现字符串分割与其他语言有所不同，下面将采用C++语言实现字符串分割并对用到的字符串操作函数进行详细的描述。</p><ul><li><p>字符串分割Java实现</p><p>Java通过调用String.split(String delimiter)方法可直接完成对字符串的分割。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    String str = <span class="string">&quot;I am a good programmer!&quot;</span>;</span><br><span class="line">    String[] splited_string = str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(String s : splited_string)&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>字符串分割Python实现</p><p>python实现字符串分割代码更为间接，很多功能使用python实现仅用一行代码，江湖上称之为“一行流”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;I am a good programmer!&quot;</span>.split(<span class="string">&quot; &quot;</span>))</span><br></pre></td></tr></table></figure></li><li><p>字符串分割C++实现</p><p>比起Java和python实现，采用C++实现字符串分割的过程则略为繁琐。需要用到c_str()、strcpy()、strtok()等方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splitString</span><span class="params">(<span class="keyword">const</span> string &amp;str, <span class="keyword">const</span> string &amp;split, vector&lt;string&gt; &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// str:要处理的字符串</span></span><br><span class="line">    <span class="comment">// split:分隔符</span></span><br><span class="line">    <span class="comment">// res:存放分割后的结果</span></span><br><span class="line">    <span class="keyword">char</span> *strc = <span class="keyword">new</span> <span class="keyword">char</span>[str.<span class="built_in">size</span>() + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(strc, str.<span class="built_in">c_str</span>()); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *temp = <span class="built_in">strtok</span>(strc, split.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="comment">//strtok()的源码为char *__cdecl strtok(char * __restrict__ _Str,const char * __restrict__ _Delim)</span></span><br><span class="line">    <span class="comment">//strtok接收的参数时char*类型，因此进行字符串分割前需要将string类型的字符串转为char*类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(<span class="built_in">string</span>(temp));</span><br><span class="line">        temp = <span class="built_in">strtok</span>(<span class="literal">NULL</span>, split.<span class="built_in">c_str</span>()); <span class="comment">//strtok第一个参数传入NULL，使用之前保存的SAVE_PTR定位下一个待处理的字符的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] strc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="built_in">splitString</span>(<span class="string">&quot;I am a good programmer!&quot;</span>, <span class="string">&quot; &quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;分割的子字符串的数量为：&quot;</span> &lt;&lt; result.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;分割后的字符串为：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; result[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>字符串分割所使用方法详解</p><ul><li><p>string.c_str()</p><p>c_str()方法的原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> _CharT* <span class="title">c_str</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>该方法返回一个指向常量的指针，指针所指向的内容不能被修改，在字符串分割中主要使用该方法将string类型转为char*类型，与字符串分割函数strtok()方法的接收参数类型保持一致。注意：一定要使用strcpy()函数等来操作方法c_str()返回的指针。</p></li><li><p>string.strcpy()</p><p>strcpy()方法的原型如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char * __cdecl strcpy(char * __restrict__ _Dest,const char * __restrict__ _Source);</span><br></pre></td></tr></table></figure><p>该方法将字符串Source复制到Dest。该方法线程不安全，c++提供了线程安全的字符串拷贝方法strcpy_s()。</p></li><li><p>string.strtok()</p><p>strtok()方法的原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *__cdecl <span class="title">strtok</span><span class="params">(<span class="keyword">char</span> * __restrict__ _Str,<span class="keyword">const</span> <span class="keyword">char</span> * __restrict__ _Delim)</span></span></span><br></pre></td></tr></table></figure><p>其中，Str表示要进行分割的字符串，Delim为字符串分隔符，该方法将Delim中的字符作为分隔符对字符串Str进行分割。如果Str为空，则函数内部的SAVE_PTR指针在下一次调用中将作为下一个分割字符串的起始位置。其实这就说明在函数strtok()内部使用了一个<strong>静态变量SAVE_PTR指针</strong>，用以<strong>记录分割一次之后_String中下一个字符串的位置</strong>。这种方法导致了一个问题，就是<strong>strtok()函数</strong>是<strong>线程不安全</strong>的（因为其<strong>函数内部使用到了静态存储区</strong>）。</p><p>除此之外，从函数的定义，第一个传入参数<strong>_String</strong>定义为<strong>char*而不是const char*</strong>，就说明<strong>strtok()函数不保证不修改传入数据的内容</strong>。实际上，<strong>第一个参数_String传进来的字符串，是会被strtok()函数所修改的</strong>，因此调用strtok()函数的时候应当注意。</p><p>c++中也提供了线程安全的字符串分割方法strtok_s，其原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *__cdecl <span class="title">strtok_s</span><span class="params">(<span class="keyword">char</span> *_Str,<span class="keyword">const</span> <span class="keyword">char</span> *_Delim,<span class="keyword">char</span> **_Context)</span></span>;</span><br></pre></td></tr></table></figure><p>strtok_s()函数增加了一个参数<strong>_Context</strong>，这个参数就是<strong>相当于strtok()函数中内部定义的静态SAVE_PTR指针</strong>，用来传递对字符串_String的处理进行到了哪里。</p></li></ul></li></ul><p><a href="https://blog.csdn.net/jay_zzs/article/details/106883832">参考文章：C/C++——字符串分割（strtok, strtok_s）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-字符串分割&quot;&gt;&lt;a href=&quot;#C-字符串分割&quot; class=&quot;headerlink&quot; title=&quot;C++字符串分割&quot;&gt;&lt;/a&gt;C++字符串分割&lt;/h1&gt;&lt;p&gt;字符串分割是编程中经常遇到的一个问题，采用C++语言实现字符串分割与其他语言有所不同，下面将采用</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    <category term="字符串分割" scheme="http://example.com/categories/C/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>C++ | OOP方法实现链式队列</title>
    <link href="http://example.com/2023/10/12/OOP%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97/"/>
    <id>http://example.com/2023/10/12/OOP%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97/</id>
    <published>2023-10-12T15:30:22.000Z</published>
    <updated>2023-10-12T15:31:24.215Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-OOP方法实现链式队列"><a href="#C-OOP方法实现链式队列" class="headerlink" title="C++ OOP方法实现链式队列"></a>C++ OOP方法实现链式队列</h1><ul><li><p>队列</p><p>队列（Queue）是一个<strong>先进先出（First In First Out, FIFO）</strong>的数据结构，即先入队的元素先出队。队列有<strong>两种存储形式：顺序存储和链式存储</strong>，采用顺序存储方式的队列称为顺序队列，采用链式存储的队列称为链式队列。顺序队列采用数组存储队列中的元素，由队头指针head和队尾指针tail表示队列的头尾。<strong>链式队列采用链表实现，由头结点和若干个队列元素节点组成，头结点包括队头指针head、队尾指针和队列大小size三个域，head指针指向队头，tail指针指向队尾，队列元素节点由值域val和指针域next组成，val代表队列元素的值，next代表指向下一个队列结点的指针。</strong>其中，较为常用的是链式队列，下面将详细介绍链式队列的属性、方法以及C++代码实现。</p></li><li><p>队列属性和方法介绍</p><p>对队列进行抽象，可将其表示为包括队头指针、队尾指针和队列大小三个属性的数据结构。队列的基本操作包括入队、出队、队列判空、队列销毁、队列元素输出等，其伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列定义</span></span><br><span class="line">queue：</span><br><span class="line">    head, tail, size<span class="comment">//head:队头指针、tail：队尾指针、size：队列大小</span></span><br><span class="line">    <span class="built_in">enqueue</span>(elem)<span class="comment">//入队</span></span><br><span class="line">    <span class="built_in">dequeue</span>()<span class="comment">//出队</span></span><br><span class="line">    <span class="built_in">is_empty</span>()<span class="comment">//队列判空</span></span><br><span class="line">    <span class="built_in">destory</span>()<span class="comment">//队列销毁</span></span><br><span class="line">    <span class="built_in">traverse</span>()<span class="comment">//队列元素输出</span></span><br></pre></td></tr></table></figure></li><li><p>链式队列C++实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列中的元素结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> val;<span class="comment">//值域</span></span><br><span class="line">        QueueNode *next;<span class="comment">//指针域，指向下一个队列元素</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> size;<span class="comment">//队列大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        QueueNode *head;<span class="comment">//队头指针</span></span><br><span class="line">        QueueNode *tail;<span class="comment">//队尾指针</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">Queue</span>();<span class="comment">//构造函数，完成对象初始化工作</span></span><br><span class="line">        ~<span class="built_in">Queue</span>();<span class="comment">//析构函数</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">int</span> val)</span></span>;<span class="comment">//入队</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">dequeue</span><span class="params">()</span></span>;<span class="comment">//出队</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">is_empty</span><span class="params">()</span></span>;<span class="comment">//队列判空</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span></span>;<span class="comment">//销毁队列</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">()</span></span>;<span class="comment">//输出队列中的所有元素</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">get_size</span><span class="params">()</span></span>;<span class="comment">//获取队列大小</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取队列大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Queue::get_size</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">Queue::<span class="built_in">Queue</span>()&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;head = <span class="keyword">this</span>-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">Queue::~<span class="built_in">Queue</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Queue::enqueue</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    QueueNode *node = (QueueNode *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(QueueNode));</span><br><span class="line"></span><br><span class="line">    node-&gt;val = val;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;head = node;</span><br><span class="line">        <span class="keyword">this</span>-&gt;tail = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;tail-&gt;next = node;</span><br><span class="line">        <span class="keyword">this</span>-&gt;tail = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;size += <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Queue::dequeue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;<span class="built_in">is_empty</span>() == <span class="number">1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;队列为空，没有元素可以出队，请先向队列中添加元素！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> val = <span class="keyword">this</span>-&gt;head-&gt;val;</span><br><span class="line">    <span class="keyword">this</span>-&gt;head = <span class="keyword">this</span>-&gt;head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;size -= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列判空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Queue::is_empty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;size == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出所有队列元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Queue::traverse</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;<span class="built_in">is_empty</span>() == <span class="number">1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;队列为空！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;队列所有元素如下：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    QueueNode *p_node = <span class="keyword">this</span>-&gt;head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p_node != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; p_node-&gt;val &lt;&lt; endl;</span><br><span class="line">        p_node = p_node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Queue::destory</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;<span class="built_in">is_empty</span>() == <span class="number">1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;队列中没有元素！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="keyword">this</span>-&gt;<span class="built_in">dequeue</span>();</span><br><span class="line">    <span class="keyword">while</span>(val != <span class="number">-1</span>)&#123;</span><br><span class="line">        val = <span class="keyword">this</span>-&gt;<span class="built_in">dequeue</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;queue is destroyed!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//队列定义</span></span><br><span class="line">    Queue queue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作队列</span></span><br><span class="line">    queue.<span class="built_in">enqueue</span>(<span class="number">1</span>);<span class="comment">//元素入队列</span></span><br><span class="line">    queue.<span class="built_in">enqueue</span>(<span class="number">2</span>);</span><br><span class="line">    queue.<span class="built_in">enqueue</span>(<span class="number">3</span>);</span><br><span class="line">    queue.<span class="built_in">enqueue</span>(<span class="number">4</span>);</span><br><span class="line">    queue.<span class="built_in">enqueue</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">int</span> val = queue.<span class="built_in">dequeue</span>();<span class="comment">//元素出队列</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;出队元素为：&quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">    queue.<span class="built_in">traverse</span>();<span class="comment">//输出所有队列元素</span></span><br><span class="line">    queue.<span class="built_in">destory</span>();<span class="comment">//销毁队列</span></span><br><span class="line">    queue.<span class="built_in">traverse</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;queue.size:&quot;</span> &lt;&lt; queue.<span class="built_in">get_size</span>() &lt;&lt; endl;<span class="comment">//输出队列大小</span></span><br><span class="line">    cout &lt;&lt; queue.<span class="built_in">is_empty</span>() &lt;&lt; endl;<span class="comment">//队列判空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><a href="https://blog.csdn.net/LiuBo_01/article/details/80412290">参考资料：队列的基本操作（顺序队列、循环队列、链式队列）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-OOP方法实现链式队列&quot;&gt;&lt;a href=&quot;#C-OOP方法实现链式队列&quot; class=&quot;headerlink&quot; title=&quot;C++ OOP方法实现链式队列&quot;&gt;&lt;/a&gt;C++ OOP方法实现链式队列&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;队列&lt;/p&gt;
&lt;p&gt;队列（</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    <category term="OOP方法实现链式队列" scheme="http://example.com/categories/C/OOP%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="OOP" scheme="http://example.com/tags/OOP/"/>
    
    <category term="链式队列" scheme="http://example.com/tags/%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>C++ | lambda表达式</title>
    <link href="http://example.com/2023/10/10/cpluspluslambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://example.com/2023/10/10/cpluspluslambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2023-10-11T03:46:38.000Z</published>
    <updated>2023-10-11T03:48:09.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><ol><li><p>lambda表达式是什么？</p><p>Lambda 表达式（通常称为 Lambda）是一种在被调用的位置或作为参数传递给函数的位置定义匿名函数对象（闭包）的简便方法。</p></li><li><p>lambda表达式的语法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture list] (parameters) <span class="function"><span class="keyword">mutable</span> <span class="title">throw</span><span class="params">()</span> -&gt; <span class="keyword">return</span>-type </span>&#123;statement&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p><strong>capture list</strong>: 在C ++规范中也称为<strong>Lambda导入器</strong>， 捕获列表总是出现在Lambda函数的开始处。实际上，[]是Lambda引出符。编译器根据该引出符判断接下来的代码是否是Lambda函数，<strong>捕获列表能够捕捉上下文中的变量以供Lambda函数使用</strong>。</p><p><strong>parameters</strong>: 与普通函数参数列表一致。不需要参数传递时，可以省略“（）”。</p><p><strong>mutable</strong>: mutable修饰符修饰的函数为可变函数， 默认情况下Lambda函数总是一个const函数，mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）。</p><p><strong>throw()</strong>:  用于Lamdba表达式内部函数抛出异常。</p><p><strong>return-type</strong>: 函数的返回值类型，不需要返回值时可以连“-&gt;”一起省略。若在返回值类型明确的情况下省略该部分，编译器会对返回值类型进行自动推导。</p><p><strong>{statement}</strong>: 函数体，可以使用函数参数和所有capture list捕获的变量。</p></li><li><p>capture list详解</p><p>Lambda 可在其主体中引入新的变量（用 C++14），它还可以访问（或“捕获”）周边范围内的变量。 Lambda 以 capture 子句开头。 它指定捕获哪些变量，以及捕获是通过值还是通过引用进行的。 有与号 (<code>&amp;</code>) 前缀的变量通过引用进行访问，没有该前缀的变量通过值进行访问。</p><p><strong>空 capture 子句 <code>[ ]</code> 指示 lambda 表达式的主体不访问封闭范围中的变量。</strong></p><p><strong><code>[&amp;]</code> 表示通过引用捕获引用的所有变量，而 <code>[=]</code> 表示通过值捕获它们。</strong></p></li></ol><p>​        注意：捕获列表不允许变量重复传递。例如[=, a]或[&amp;,&amp;a]，=已经通过值捕获方式捕获了所有变量，&amp;已经通        过引用捕获方式捕获了所有变量。</p><ol><li><p>lambda表达式示例</p><ul><li><p>[]不捕获任何变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> func = [](string words) -&gt; <span class="keyword">void</span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        []:捕获列表为空，表示不捕获任何变量</span></span><br><span class="line"><span class="comment">        words:函数参数</span></span><br><span class="line"><span class="comment">        -&gt;void：函数返回值为void</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;hello,&quot;</span> &lt;&lt; words &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">func</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>[&amp;]以引用传递方式捕获所有变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">auto</span> func = [&amp;]() -&gt; <span class="keyword">void</span>&#123;</span><br><span class="line">        <span class="comment">// [&amp;]:以引用传递方式捕获变量</span></span><br><span class="line">        <span class="comment">// -&gt;void：函数返回值为void</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;i:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; j:&quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>[=]以值传递方式捕获所有变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">int num1 = 1;</span><br><span class="line">int num2 = 2;</span><br><span class="line">    auto add = [=]() -&gt; int&#123;</span><br><span class="line">        /*</span><br><span class="line">        [=]:以值传递方式捕获变量</span><br><span class="line">        -&gt;int：函数返回值为int</span><br><span class="line">        */</span><br><span class="line">        return num1 + num2;</span><br><span class="line">    &#125;;</span><br><span class="line">    int sum = add();</span><br><span class="line">    cout &lt;&lt; &quot;num1+num2=&quot; &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;lambda表达式&quot;&gt;&lt;a href=&quot;#lambda表达式&quot; class=&quot;headerlink&quot; title=&quot;lambda表达式&quot;&gt;&lt;/a&gt;lambda表达式&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;lambda表达式是什么？&lt;/p&gt;
&lt;p&gt;Lambda 表达式（通常称为 Lambda）是一种在被调用的位置或作为参数传递给函数的位置定义匿名函数对象（闭包）的简便方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;lambda表达式的语法&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[capture list] (parameters) &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;mutable&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;throw&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; -&amp;gt; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;-type &lt;/span&gt;&amp;#123;statement&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    <category term="lambda表达式" scheme="http://example.com/categories/C/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="lambda表达式" scheme="http://example.com/tags/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
</feed>
