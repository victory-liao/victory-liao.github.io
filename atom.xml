<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Victory&#39;s Blog</title>
  
  <subtitle>非淡泊无以明志，非宁静无以致远</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-05-30T06:31:45.866Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>victory-liao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>并发 | 线程池</title>
    <link href="http://example.com/2022/05/29/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://example.com/2022/05/29/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2022-05-29T08:44:53.000Z</published>
    <updated>2022-05-30T06:31:45.866Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>1.线程池的作用<br>对于服务器端的程序，如果服务端每接收到一个任务，创建一个线程，然后进行执行；这样的做法在面对成千上万的任务递交进服务器时，<br>那么会创建数以万记的线程，这样会时操作系统频繁的进行上下文切换，无故增加系统的负载，而线程的创建和小王都是需要好耗费<br>系统资源的，也无疑浪费了系统资源。线程池技术（通过使用固定或较为固定数目的线程来完成任务的执行）能够很好地解决这个问题，<br>消除频繁创建和消亡线程的系统资源开销。<br>2.线程池的本质<br>使用了一个线程安全的工作队列连接工作者线程和客户端线程，客户端线程将任务放入工作队列后便返回，而工作者线程则不断地从工作<br>队列取出工作并执行。当工作队列为空时，所有的工作者线程均等待在工作队列上，当有客户端提交了一个任务之后会通知任意一个工作者<br>线程，随着大量任务被提交，更多的工作者线程会被唤醒。<br>3.线程池示例<br><strong>ThreadPool.java</strong></p><pre><code>package concurrency.threadPool;public interface ThreadPool&lt;Job extends Runnable&gt; &#123;    //执行一个Job，这个Job需要实现Runnable    void execute(Job job);        //关闭线程池    void shutdown();        //增加工作者线程    void addWorkers(int num);        //减少工作者线程    void remvoeWorkers(int num);        //得到正在等待执行的任务数量    int getJobSize();&#125;</code></pre><p><strong>DefaultThreadPool.java</strong></p><pre><code>package concurrency.threadPool;import java.util.ArrayList;import java.util.Collections;import java.util.LinkedList;import java.util.List;import java.util.concurrent.atomic.AtomicLong;public class DefaultThreadPool&lt;Job extends Runnable&gt; implements ThreadPool&lt;Job&gt; &#123;    //线程池最大数量    private static final int MAX_WORKER_NUMBERS = 10;        //线程池默认数量    private static final int DEFAULT_WORKER_NUMBERS = 5;        //线程池最小的数量    private static final int MIN_WORKER_NUMBERS = 1;        //这是一个工作列表，将会向里面插入工作    private final LinkedList&lt;Job&gt; jobs = new LinkedList&lt;Job&gt;();        //工作者列表    private final List&lt;Worker&gt; workers = Collections.synchronizedList(new ArrayList&lt;Worker&gt;());        //工作者线程的数量    private int workerNum = DEFAULT_WORKER_NUMBERS;        //线程编号的生成    private AtomicLong threadNum = new AtomicLong();        //工作者，负责消费任务    class Worker implements Runnable&#123;        //是否工作        private volatile boolean running = true;        @Override        public void run()&#123;            while(running)&#123;                Job job = null;                synchronized(jobs)&#123;                    //如果工作者列表是空的，那么就wait                    while(jobs.isEmpty())&#123;                        try&#123;                            jobs.wait();                        &#125;catch(InterruptedException ex)&#123;                            //感知到外部对WorkerThread的中断操作，返回                            Thread.currentThread().interrupt();                            return;                        &#125;                    &#125;                    //取出一个Job                    job = jobs.removeFirst();                &#125;                if(job != null)&#123;                    try&#123;                        job.run();                    &#125;catch(Exception ex)&#123;                        //忽略Job执行中的Exception                    &#125;                &#125;            &#125;        &#125;                public void shutdown()&#123;            running = false;        &#125;    &#125;        //初始化线程工作者    private void initializeWorkers(int num)&#123;        for(int i = 0; i &lt; num; i++)&#123;            Worker worker = new Worker();            workers.add(worker);            Thread thread = new Thread(worker, &quot;ThreadPool-Worker-&quot; + threadNum.incrementAndGet());            thread.start();        &#125;    &#125;        public DefaultThreadPool()&#123;        initializeWorkers(DEFAULT_WORKER_NUMBERS);    &#125;        public DefaultThreadPool(int num)&#123;        workerNum = num &gt; MAX_WORKER_NUMBERS ? MAX_WORKER_NUMBERS : num &lt; MIN_WORKER_NUMBERS ? MIN_WORKER_NUMBERS : num;        initializeWorkers(workerNum);    &#125;        @Override    public void execute(Job job) &#123;        if(job != null)&#123;            //添加一个工作，然后进行通知            synchronized(jobs)&#123;                jobs.addLast(job);                jobs.notify();            &#125;        &#125;    &#125;    @Override    public void shutdown() &#123;        for(Worker worker : workers)&#123;            worker.shutdown();        &#125;    &#125;    @Override    public void addWorkers(int num) &#123;        synchronized(jobs)&#123;            //限制新增的Worker数量不能超过最大值            if(num + this.workerNum &gt; MAX_WORKER_NUMBERS)&#123;                num = MAX_WORKER_NUMBERS - this.workerNum;            &#125;            initializeWorkers(num);            this.workerNum += num;        &#125;    &#125;    @Override    public void remvoeWorkers(int num) &#123;        synchronized(jobs)&#123;            if(num &gt;= this.workerNum)&#123;                throw new IllegalArgumentException(&quot;beyond workNum&quot;);            &#125;            //按照给定的数量停止Worker            int count = 0;            while(count &lt; num)&#123;                Worker worker = workers.get(count);                if(workers.remove(worker))&#123;                    worker.shutdown();                    count++;                &#125;            &#125;            this.workerNum -= count;        &#125;    &#125;    @Override    public int getJobSize() &#123;        return jobs.size();    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线程池&quot;&gt;&lt;a href=&quot;#线程池&quot; class=&quot;headerlink&quot; title=&quot;线程池&quot;&gt;&lt;/a&gt;线程池&lt;/h1&gt;&lt;p&gt;1.线程池的作用&lt;br&gt;对于服务器端的程序，如果服务端每接收到一个任务，创建一个线程，然后进行执行；这样的做法在面对成千上万的任务递</summary>
      
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="线程池" scheme="http://example.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>并发 | 等待/通知机制</title>
    <link href="http://example.com/2022/05/28/%E7%AD%89%E5%BE%85-%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2022/05/28/%E7%AD%89%E5%BE%85-%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/</id>
    <published>2022-05-29T07:37:56.000Z</published>
    <updated>2022-05-29T07:41:50.912Z</updated>
    
    <content type="html"><![CDATA[<h1 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h1><p>等待通知机制，是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或着notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。<br><strong>示例代码</strong></p><pre><code>package concurrency;import java.text.SimpleDateFormat;import java.util.Date;import java.util.concurrent.TimeUnit;public class WaitNotify &#123;    static boolean flag = true;    static Object lock = new Object();        public static void main(String[] args) throws InterruptedException &#123;        Thread waitThread = new Thread(new Wait(), &quot;WaitThread&quot;);        waitThread.start();        TimeUnit.SECONDS.sleep(1);        Thread notifyThread = new Thread(new Notify(), &quot;NotifyThread&quot;);        notifyThread.start();    &#125;        static class Wait implements Runnable&#123;        @Override        public void run()&#123;            //加锁，用于lock的Monitor            synchronized(lock)&#123;                //当条件不满足时，继续wait，同时释放了lock的锁                while(flag)&#123;                    try &#123;                        System.out.println(Thread.currentThread()+&quot; flag is true. wait@ &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));                        lock.wait();                    &#125; catch (InterruptedException e) &#123;                    &#125;                &#125;                //条件满足时，完成工作                System.out.println(Thread.currentThread() + &quot;flag is false. running@ &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            &#125;        &#125;    &#125;        static class Notify implements Runnable&#123;        @Override        public void run() &#123;            synchronized(lock)&#123;                //获取lock的锁，然后进行通知，通知时不会释放lock的锁                //直到当前线程释放了lock后，WaitThread才能从wait方法中返回                System.out.println(Thread.currentThread() + &quot; hold lock. notify @ &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));                lock.notifyAll();                flag = false;                SleepUtils.second(5);            &#125;                        //再次加锁            synchronized(lock)&#123;                System.out.println(Thread.currentThread()+ &quot;hold lock again. sleep@ &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));                SleepUtils.second(5);            &#125;                    &#125;    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;等待-通知机制&quot;&gt;&lt;a href=&quot;#等待-通知机制&quot; class=&quot;headerlink&quot; title=&quot;等待/通知机制&quot;&gt;&lt;/a&gt;等待/通知机制&lt;/h1&gt;&lt;p&gt;等待通知机制，是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的</summary>
      
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="等待/通知机制" scheme="http://example.com/tags/%E7%AD%89%E5%BE%85-%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>并发 | volatile写读的内存语义和锁的释放获取的内存语义</title>
    <link href="http://example.com/2022/05/23/volatile%E5%86%99%E8%AF%BB%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89%E5%92%8C%E9%94%81%E7%9A%84%E9%87%8A%E6%94%BE%E8%8E%B7%E5%8F%96%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89/"/>
    <id>http://example.com/2022/05/23/volatile%E5%86%99%E8%AF%BB%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89%E5%92%8C%E9%94%81%E7%9A%84%E9%87%8A%E6%94%BE%E8%8E%B7%E5%8F%96%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89/</id>
    <published>2022-05-23T14:02:50.000Z</published>
    <updated>2022-05-24T01:02:03.770Z</updated>
    
    <content type="html"><![CDATA[<h1 id="volatile写读的内存语义和锁的释放获取的内存语义"><a href="#volatile写读的内存语义和锁的释放获取的内存语义" class="headerlink" title="volatile写读的内存语义和锁的释放获取的内存语义"></a>volatile写读的内存语义和锁的释放获取的内存语义</h1><h2 id="volatile写、读的内存语义"><a href="#volatile写、读的内存语义" class="headerlink" title="volatile写、读的内存语义"></a>volatile写、读的内存语义</h2><p>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主存。<br><img src="/2022/05/23/volatile%E5%86%99%E8%AF%BB%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89%E5%92%8C%E9%94%81%E7%9A%84%E9%87%8A%E6%94%BE%E8%8E%B7%E5%8F%96%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89/1.PNG"><br>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。<br><img src="/2022/05/23/volatile%E5%86%99%E8%AF%BB%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89%E5%92%8C%E9%94%81%E7%9A%84%E9%87%8A%E6%94%BE%E8%8E%B7%E5%8F%96%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89/2.PNG"></p><h2 id="volatile内存语义的实现"><a href="#volatile内存语义的实现" class="headerlink" title="volatile内存语义的实现"></a>volatile内存语义的实现</h2><p>编译器生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。<br>JMM基于保守策略的JMM内存屏障插入策略如下：<br>（1）在每个volatile写操作的前面插入一个StoreStore屏障。<br>（2）在每个volatile写操作的后面插入一个StoreLoad屏障。<br>（3）在每个volatile读操作的后面插入一个LoadLoad屏障。<br>（4）在每个volatile读操作的后面插入一个LoadStore屏障。</p><h2 id="锁的释放、获取的内存语义"><a href="#锁的释放、获取的内存语义" class="headerlink" title="锁的释放、获取的内存语义"></a>锁的释放、获取的内存语义</h2><p>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。<br>当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。<br>注：锁释放与volatile写有相同的内存语义；锁获取与volatile读具有相同的内存语义。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;volatile写读的内存语义和锁的释放获取的内存语义&quot;&gt;&lt;a href=&quot;#volatile写读的内存语义和锁的释放获取的内存语义&quot; class=&quot;headerlink&quot; title=&quot;volatile写读的内存语义和锁的释放获取的内存语义&quot;&gt;&lt;/a&gt;volat</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="volatile写读的内存语义和锁的释放获取的内存语义" scheme="http://example.com/categories/Java/%E5%B9%B6%E5%8F%91/volatile%E5%86%99%E8%AF%BB%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89%E5%92%8C%E9%94%81%E7%9A%84%E9%87%8A%E6%94%BE%E8%8E%B7%E5%8F%96%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="volatile" scheme="http://example.com/tags/volatile/"/>
    
    <category term="锁" scheme="http://example.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>并发 | volatile、synchronized和原子操作</title>
    <link href="http://example.com/2022/05/22/volatile%E3%80%81synchronized%E5%92%8C%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2022/05/22/volatile%E3%80%81synchronized%E5%92%8C%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</id>
    <published>2022-05-23T03:03:39.000Z</published>
    <updated>2022-05-23T03:57:47.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="volatile、synchronized和原子操作"><a href="#volatile、synchronized和原子操作" class="headerlink" title="volatile、synchronized和原子操作"></a>volatile、synchronized和原子操作</h1><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>volatile是轻量级的synchronized，它在多处理器并发中保证了<strong>共享变量的“可见性”</strong>。可见性是指当一个线程修改一个共享变量时<br>，另外一个线程能读到这个修改的值（Java内存模型确保所有线程看到这个变量的值是一致的）。</p><h3 id="volatile的两条实现原则"><a href="#volatile的两条实现原则" class="headerlink" title="volatile的两条实现原则"></a>volatile的两条实现原则</h3><p>（1）Lock前缀指令会引起处理器缓存回写到内存。<br>（2）一个处理器的缓存回写到内存会导致其他处理器的缓存无效。</p><h3 id="volatile的使用优化"><a href="#volatile的使用优化" class="headerlink" title="volatile的使用优化"></a>volatile的使用优化</h3><p>使用追加到64字节的方式来填满高速缓冲区的缓存行，避免头节点和尾节点加载到同一个缓存行，使头、尾节点在修改时不会互相锁定。</p><h2 id="synchronized实现原理"><a href="#synchronized实现原理" class="headerlink" title="synchronized实现原理"></a>synchronized实现原理</h2><p>JVM基于进入和推出Monitor对象来实现方法同步和代码块同步，但两者实现细节不一样。<br>代码块同步使用monitorenter和monitorexit指令实现的。monitorenter指令在编译后插入到同步代码块的开始位置，而monitorexit是<br>插入到方法结束处和异常处，JVM要博爱正每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，<br>当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象monitor的所有权，即尝试获得对象的锁。</p><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>java如何实现原子操作？<br>通过循环CAS的方式实现原子操作。JVM中CAS操作使用处理器提供的CMPXCHG指令实现。自旋CAS实现的基本思路就是循环及进行CAS操作指导成功为止。</p><h3 id="使用CAS实现线程安全计数器"><a href="#使用CAS实现线程安全计数器" class="headerlink" title="使用CAS实现线程安全计数器"></a>使用CAS实现线程安全计数器</h3><pre><code>package concurrency;import java.util.ArrayList;import java.util.List;import java.util.concurrent.atomic.AtomicInteger;public class Counter &#123;    private AtomicInteger atomicI = new AtomicInteger(0);    private int i = 0;        public static void main(String[] args) &#123;        final Counter cas = new Counter();        List&lt;Thread&gt; ts = new ArrayList&lt;Thread&gt;(600);        long start = System.currentTimeMillis();        for(int j = 0; j &lt; 100; j++)&#123;            Thread t = new Thread(new Runnable()&#123;                @Override                public void run()&#123;                    for(int i = 0; i &lt; 10000; i++)&#123;                        cas.count();                        cas.safeCount();                    &#125;                &#125;            &#125;);            ts.add(t);        &#125;        for(Thread t : ts)&#123;            t.start();        &#125;        //等待所有线程执行完成        for(Thread t : ts)&#123;            try &#123;                t.join();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        System.out.println(cas.i);        System.out.println(cas.atomicI.get());        System.out.println(System.currentTimeMillis() - start);    &#125;        //使用CAS实现线程安全计数器    private void safeCount()&#123;        for(;;)&#123;            int i = atomicI.get();            boolean suc = atomicI.compareAndSet(i, ++i);            if(suc)&#123;                break;            &#125;        &#125;    &#125;        //非线程安全计数器    private void count()&#123;        i++;    &#125;&#125;</code></pre><h2 id="CAS实现原子操作的三大问题"><a href="#CAS实现原子操作的三大问题" class="headerlink" title="CAS实现原子操作的三大问题"></a>CAS实现原子操作的三大问题</h2><p>（1）ABA问题。可以使用版本号解决。JDK Atomic AtomicStampedReference可以解决ABA问题。<br>（2）循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。<br>（3）只能保证一个共享变量的原子操作。对多个共享变量操作可以使用锁/将多个共享变量合并成一个共享变量来操作（两个共享变量i=2,j=a,合并以下ij=2a,然后采用CAS来操作）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;volatile、synchronized和原子操作&quot;&gt;&lt;a href=&quot;#volatile、synchronized和原子操作&quot; class=&quot;headerlink&quot; title=&quot;volatile、synchronized和原子操作&quot;&gt;&lt;/a&gt;volatile</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="volatile" scheme="http://example.com/tags/volatile/"/>
    
    <category term="synchronized" scheme="http://example.com/tags/synchronized/"/>
    
    <category term="原子操作" scheme="http://example.com/tags/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>并发 | 上下文切换和死锁</title>
    <link href="http://example.com/2022/05/22/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/"/>
    <id>http://example.com/2022/05/22/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/</id>
    <published>2022-05-23T02:37:08.000Z</published>
    <updated>2022-05-23T02:59:57.500Z</updated>
    
    <content type="html"><![CDATA[<h1 id="上下文切换和死锁"><a href="#上下文切换和死锁" class="headerlink" title="上下文切换和死锁"></a>上下文切换和死锁</h1><h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，再切换前会保存上一个任务的<br>状态，以便切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。频繁的上下文<br>切换会影响多线程的执行速度。</p><h2 id="如何减少上下文切换"><a href="#如何减少上下文切换" class="headerlink" title="如何减少上下文切换"></a>如何减少上下文切换</h2><p>（1）无锁并发编程。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁（如采用分段锁，不同的线程处理不同段的数据）<br>（2）CAS算法。<br>（3）使用最小线程。避免创建不需要的线程（任务很少，创建了很多线程，造成大量线程阻塞等待）</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁产生的条件"><a href="#死锁产生的条件" class="headerlink" title="死锁产生的条件"></a>死锁产生的条件</h3><p>（1）互斥。一个资源同一时刻只能被一个线程拥有。<br>（2）请求和保持。线程在请求新的资源时，不释放已经拥有的资源。<br>（3）不剥夺条件。进程所获得的资源在未使用完之前，不被其他的线程强行剥夺。<br>（4）循环等待。竞争资源的各个线程形成一个线程等待环路。</p><h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>破坏产生死锁的条件：<br>（2）在进程开始执行时就申请他所需的全部资源<br>（3）一个进程不能获得所需要的全部资源时便处于等待状态，等待期间他占有的资源将被隐式的释放重新加入到系统的资源列表中<br>，可以被其他的进程使用，而等待的进程只有重新获得自己原有的资源以及新申请的资源才可以重新启动、执行。<br>（4）资源有序分配（银行家算法）</p><h3 id="死锁Demo"><a href="#死锁Demo" class="headerlink" title="死锁Demo"></a>死锁Demo</h3><pre><code>package concurrency;public class DeadLockDemo &#123;    private static String A = &quot;A&quot;;    private static String B = &quot;B&quot;;        public static void main(String[] args) &#123;        new DeadLockDemo().deadLock();    &#125;        private void deadLock()&#123;        Thread t1 = new Thread(new Runnable()&#123;            @Override            public void run()&#123;                synchronized(A)&#123;                    try &#123;                        Thread.currentThread().sleep(2000);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    synchronized(B)&#123;                        System.out.println(&quot;1&quot;);                    &#125;                &#125;            &#125;        &#125;);                Thread t2 = new Thread(new Runnable()&#123;            @Override            public void run() &#123;                synchronized(B)&#123;                    synchronized(A)&#123;                        System.out.println(&quot;2&quot;);                    &#125;                &#125;            &#125;        &#125;);                t1.start();        t2.start();    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;上下文切换和死锁&quot;&gt;&lt;a href=&quot;#上下文切换和死锁&quot; class=&quot;headerlink&quot; title=&quot;上下文切换和死锁&quot;&gt;&lt;/a&gt;上下文切换和死锁&lt;/h1&gt;&lt;h2 id=&quot;上下文切换&quot;&gt;&lt;a href=&quot;#上下文切换&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="上下文切换" scheme="http://example.com/categories/Java/%E5%B9%B6%E5%8F%91/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="死锁" scheme="http://example.com/tags/%E6%AD%BB%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Redis | 面试题目</title>
    <link href="http://example.com/2022/05/22/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    <id>http://example.com/2022/05/22/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/</id>
    <published>2022-05-22T09:32:20.000Z</published>
    <updated>2022-05-22T09:33:41.628Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis面试题目"><a href="#Redis面试题目" class="headerlink" title="Redis面试题目"></a>Redis面试题目</h1><p><a href="https://mp.weixin.qq.com/s/3ln9VAB_heYTI7yvxnp2bw">参考资料</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis面试题目&quot;&gt;&lt;a href=&quot;#Redis面试题目&quot; class=&quot;headerlink&quot; title=&quot;Redis面试题目&quot;&gt;&lt;/a&gt;Redis面试题目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/3ln9VA</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    <category term="面试题目" scheme="http://example.com/categories/Redis/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis | 缓存和数据库的一致性问题</title>
    <link href="http://example.com/2022/05/21/%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2022/05/21/%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/</id>
    <published>2022-05-22T04:15:47.000Z</published>
    <updated>2022-05-22T04:19:41.080Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缓存和数据库的一致性问题"><a href="#缓存和数据库的一致性问题" class="headerlink" title="缓存和数据库的一致性问题"></a>缓存和数据库的一致性问题</h1><p>1、想要提高应用的性能，可以引入「缓存」来解决<br>2、引入缓存后，需要考虑缓存和数据库一致性问题，可选的方案有：「更新数据库 + 更新缓存」、「更新数据库 + 删除缓存」<br>3、更新数据库 + 更新缓存方案，在「并发」场景下无法保证缓存和数据一致性，且存在「缓存资源浪费」和「机器性能浪费」的情况发生<br>4、在更新数据库 + 删除缓存的方案中，「先删除缓存，再更新数据库」在「并发」场景下依旧有数据不一致问题，解决方案是「延迟双删」，但这个延迟时间很难评估，所以推荐用「先更新数据库，再删除缓存」的方案<br>5、在「先更新数据库，再删除缓存」方案下，为了保证两步都成功执行，需配合「消息队列」或「订阅变更日志」的方案来做，本质是通过「重试」的方式保证数据一致性<br>6、在「先更新数据库，再删除缓存」方案下，「读写分离 + 主从库延迟」也会导致缓存和数据库不一致，缓解此问题的方案是「延迟双删」，凭借经验发送「延迟消息」到队列中，延迟删除缓存，同时也要控制主从库延迟，尽可能降低不一致发生的概率<br><a href="https://mp.weixin.qq.com/s?__biz=MzIyOTYxNDI5OA==&mid=2247487312&idx=1&sn=fa19566f5729d6598155b5c676eee62d&chksm=e8beb8e5dfc931f3e35655da9da0b61c79f2843101c130cf38996446975014f958a6481aacf1&scene=178&cur_album_id=1699766580538032128#rd">参考资料</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;缓存和数据库的一致性问题&quot;&gt;&lt;a href=&quot;#缓存和数据库的一致性问题&quot; class=&quot;headerlink&quot; title=&quot;缓存和数据库的一致性问题&quot;&gt;&lt;/a&gt;缓存和数据库的一致性问题&lt;/h1&gt;&lt;p&gt;1、想要提高应用的性能，可以引入「缓存」来解决&lt;br&gt;2、引</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    <category term="缓存和数据库的一致性问题" scheme="http://example.com/categories/Redis/%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis | 集群搭建</title>
    <link href="http://example.com/2022/05/20/Redis%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <id>http://example.com/2022/05/20/Redis%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</id>
    <published>2022-05-21T04:19:56.000Z</published>
    <updated>2022-05-21T04:50:47.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis集群搭建"><a href="#Redis集群搭建" class="headerlink" title="Redis集群搭建"></a>Redis集群搭建</h1><p>1.下载Redis并将redis放到linux目录/opt下<br>2.在opt下创建myRedis文件夹,并备份redis.conf到此处<br>3.安装ruby环境<br>（1）yum install ruby<br>（2）yum install rubygems<br>4.创建6个实例（此处使用相同主机的不同端口来模拟多个节点）<br>通过include引入备份文件redis.conf（redis.conf中需要修改配置：protected-mode no   daemonize yes   appendonly no）的内容并修改每个节点不同的信息<br>(1)redis6379.conf</p><pre><code>include /opt/myRedis/redis.confpidfile &quot;/var/run/redis6379.pid&quot;port 6379dbfilename &quot;dump6379.rdb&quot;cluster-enabled yescluster-config-file nodes-6379.confcluster-node-timeout 15000</code></pre><p>(2)redis6380.conf</p><pre><code>include /opt/myRedis/redis.confpidfile &quot;/var/run/redis6380.pid&quot;port 6380dbfilename &quot;dump6380.rdb&quot;cluster-enabled yescluster-config-file nodes-6380.confcluster-node-timeout 15000</code></pre><p>(3)redis6381.conf</p><pre><code>include /opt/myRedis/redis.confpidfile &quot;/var/run/redis6381.pid&quot;port 6381dbfilename &quot;dump6381.rdb&quot;cluster-enabled yescluster-config-file nodes-6381.confcluster-node-timeout 15000</code></pre><p>(4)redis6389.conf</p><pre><code>include /opt/myRedis/redis.confpidfile &quot;/var/run/redis6389.pid&quot;port 6389dbfilename &quot;dump6389.rdb&quot;cluster-enabled yescluster-config-file nodes-6389.confcluster-node-timeout 15000</code></pre><p>(5)redis6390.conf</p><pre><code>include /opt/myRedis/redis.confpidfile &quot;/var/run/redis6390.pid&quot;port 6390dbfilename &quot;dump6390.rdb&quot;cluster-enabled yescluster-config-file nodes-6390.confcluster-node-timeout 15000</code></pre><p>(6)redis6391.conf</p><pre><code>include /opt/myRedis/redis.confpidfile &quot;/var/run/redis6391.pid&quot;port 6391dbfilename &quot;dump6391.rdb&quot;cluster-enabled yescluster-config-file nodes-6391.confcluster-node-timeout 15000</code></pre><p>5.启动所有redis实例，nodes-xxxx.conf文件都生成正常。<br><img src="/2022/05/20/Redis%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/1.PNG"><br>6.将六个实例组合到一个集群当中</p><pre><code>redis-cli --cluster create 192.168.1.108:6379 192.168.1.108:6380 192.168.1.108:6381 192.168.1.108:6389 192.168.1.108:6390 192.168.1.108:6391 --cluster-replicas 1</code></pre><p>7.启动客户端并查看集群<br><img src="/2022/05/20/Redis%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/2.PNG"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis集群搭建&quot;&gt;&lt;a href=&quot;#Redis集群搭建&quot; class=&quot;headerlink&quot; title=&quot;Redis集群搭建&quot;&gt;&lt;/a&gt;Redis集群搭建&lt;/h1&gt;&lt;p&gt;1.下载Redis并将redis放到linux目录/opt下&lt;br&gt;2.在opt下创</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    <category term="集群搭建" scheme="http://example.com/categories/Redis/%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
    <category term="集群" scheme="http://example.com/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>Redis | 关闭服务报错</title>
    <link href="http://example.com/2022/05/15/Redis%E5%85%B3%E9%97%AD%E6%9C%8D%E5%8A%A1%E6%8A%A5%E9%94%99/"/>
    <id>http://example.com/2022/05/15/Redis%E5%85%B3%E9%97%AD%E6%9C%8D%E5%8A%A1%E6%8A%A5%E9%94%99/</id>
    <published>2022-05-16T06:20:38.000Z</published>
    <updated>2022-05-16T06:28:15.976Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis关闭服务报错"><a href="#Redis关闭服务报错" class="headerlink" title="Redis关闭服务报错"></a>Redis关闭服务报错</h1><p>在linux中执行redis-cli shutdown命令来关闭redis服务时报错：</p><pre><code>(error) ERR Errors trying to SHUTDOWN. Check logs.</code></pre><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>1)执行vim命令打开redis.conf文件</p><pre><code>vim redis.conf</code></pre><p>2)在配置文件中找到logfile “”，并修改为 logfile “/opt/myRedis/redis_log.log”<br>3)修改日志文件redis_log.log的文件权限</p><pre><code>sudo chmod 777 /opt/myRedis/redis_log.log</code></pre><p>4)强制关闭redis服务</p><pre><code>kill -9 当前redis服务的进程号</code></pre><p>5)重启redis服务(案例将redis的配置文件做了备份，放在/opt/myRedis/目录下)</p><pre><code>redis-server redis.conf</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis关闭服务报错&quot;&gt;&lt;a href=&quot;#Redis关闭服务报错&quot; class=&quot;headerlink&quot; title=&quot;Redis关闭服务报错&quot;&gt;&lt;/a&gt;Redis关闭服务报错&lt;/h1&gt;&lt;p&gt;在linux中执行redis-cli shutdown命令来关闭re</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    <category term="关闭服务报错" scheme="http://example.com/categories/Redis/%E5%85%B3%E9%97%AD%E6%9C%8D%E5%8A%A1%E6%8A%A5%E9%94%99/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
    <category term="关闭服务报错" scheme="http://example.com/tags/%E5%85%B3%E9%97%AD%E6%9C%8D%E5%8A%A1%E6%8A%A5%E9%94%99/"/>
    
  </entry>
  
  <entry>
    <title>Redis | 集群</title>
    <link href="http://example.com/2022/05/13/Redis%E9%9B%86%E7%BE%A4/"/>
    <id>http://example.com/2022/05/13/Redis%E9%9B%86%E7%BE%A4/</id>
    <published>2022-05-13T10:06:31.000Z</published>
    <updated>2022-05-13T10:17:50.079Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h1><ol><li>问题<br>1）服务器内存容量不够，redis如何进行扩容？<br>2）大量并发写操作， redis如何分摊？</li><li>集群<br>Redis 集群实现了对Redis的水平扩容，即<strong>启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1/N</strong>。<br>注：Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</li><li>slots<br>一个 Redis 集群包含 16384 个插槽（hash slot）， 数据库中的每个键都属于这 16384 个插槽的其中一个， 集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。<br>集群中的每个节点负责处理一部分插槽。举个例子， 如果一个集群可以有主节点，其中：节点A负责处理0号至5500号插槽，节点B负责处理5501号至11000号插槽，节点C负责处理11001号至16383号插槽。</li><li>集群的优点<br>1）实现扩容<br>2）分摊压力<br>3）无中心配置相对简单</li><li>集群的缺点<br>1）多键操作是不被支持的（这些键有可能存在不同的服务器上，可以通过{}来定义组的概念，从而使key中{}内相同内容的键值对放到一个slot中去。）<br>2）多键的Redis事务是不被支持的。lua脚本不被支持。<br>3）由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis集群&quot;&gt;&lt;a href=&quot;#Redis集群&quot; class=&quot;headerlink&quot; title=&quot;Redis集群&quot;&gt;&lt;/a&gt;Redis集群&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;问题&lt;br&gt;1）服务器内存容量不够，redis如何进行扩容？&lt;br&gt;2）大量并发写操作，</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    <category term="集群" scheme="http://example.com/categories/Redis/%E9%9B%86%E7%BE%A4/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
    <category term="集群" scheme="http://example.com/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>Redis | 主从复制</title>
    <link href="http://example.com/2022/05/13/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>http://example.com/2022/05/13/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</id>
    <published>2022-05-13T08:26:24.000Z</published>
    <updated>2022-05-13T10:05:21.190Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><ol><li>主从复制<br>主机数据更新后根据配置和策略，自动同步到备机的master/slaver机制，master以写为主，slave以读为主<br><img src="/2022/05/13/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/1.PNG"></li><li>复制原理<br>（1）每次从机联通后，都会给主机发送sync指令<br>（2）主机立刻进行存盘操作并发送RDB文给从机<br>（3）从机收到RDB文件后，进行全盘加载<br>（4）之后每次主机的写操作，都会立刻发送给从机，从机执行相同的命令<br><img src="/2022/05/13/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/2.PNG"></li><li>哨兵模式<br>能够后台监控主机是否故障，如果故障了根据投票数自动将从机转换为主机<br><img src="/2022/05/13/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/3.PNG"></li><li>故障恢复<br>（1）如果发生故障，从下线的主服务的所有从服务里挑选一个从服务，将其转成主服务<br>选择条件：<br>1）选择优先级靠前的（优先级可以在redis.conf中设置slave-priority）<br>2）选择偏移量最大的(偏移量最大指获得原主服务数据最多的服务)<br>3）选择runid最小的从服务（每个Redis实例启动后都会随机生成一个40为的runid）</li><li>优点<br>（1）读写分离<br>（2）容灾快速恢复</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis主从复制&quot;&gt;&lt;a href=&quot;#Redis主从复制&quot; class=&quot;headerlink&quot; title=&quot;Redis主从复制&quot;&gt;&lt;/a&gt;Redis主从复制&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;主从复制&lt;br&gt;主机数据更新后根据配置和策略，自动同步到备机的maste</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    <category term="主从复制" scheme="http://example.com/categories/Redis/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
    <category term="主从复制" scheme="http://example.com/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Redis | 持久化方式</title>
    <link href="http://example.com/2022/05/09/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F/"/>
    <id>http://example.com/2022/05/09/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F/</id>
    <published>2022-05-09T13:45:48.000Z</published>
    <updated>2022-05-12T07:03:25.131Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis持久化方式"><a href="#Redis持久化方式" class="headerlink" title="Redis持久化方式"></a>Redis持久化方式</h1><ol><li>两个不同形式得持久化方式<br>RDB(Redis DataBase)<br>AOF(Append Of File)</li><li>RDB</li><li>1 RDB<br>在指定的时间间隔内将内存中的数据集快照(Snapshot)写入磁盘,恢复时将快照文件直接读到内存中。</li><li>2 备份<br>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能；</li><li>3 适用<br>大规模数据的恢复且对于数据恢复的完整性不是非常敏感</li><li>4 优点<br>1）节省磁盘空间<br>2）恢复速度快</li><li>5 缺点<br>1）虽然Redis在fork时使用了写时拷贝技术,但是如果数据庞大时还是比较消耗性能。<br>2）在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。</li><li>AOF</li><li>1 AOF<br>以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)，只许追加文件但不可以改写文件，Redis启动之初会读取该文件重新构建数据，换言之，Redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</li><li>2 AOF同步频率设置：<br>1）始终同步<br>2）每秒同步<br>3）不主动进行同步</li><li>3 Rewrite:<br>AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制,当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof。</li></ol><p><strong>如何实现重写？</strong><br>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，遍历新进程的内存中数据，每条记录有一条的Set语句。重写aof文件的操作，并没有读取旧的aof文件，而是<strong>将整个内存中的数据库内容用命令的方式重写了一个新的aof文件</strong>，这点和快照有点类似。<br><strong>何时重写</strong><br>系统载入时或者上次重写完毕时，Redis会记录此时AOF大小，设为base_size,如果Redis的AOF当前大小&gt;= base_size +base_size*100% (默认)或当前大小&gt;=64mb(默认)的情况下，Redis会对AOF进行重写。<br>3.4 AOF的优点：<br>1）备份机制更稳健，丢失数据概率更低。<br>2）可读的日志文本，通过操作AOF文件，可以处理误操作。<br>3.5 AOF的缺点：<br>1）比起RDB占用更多的磁盘空间。<br>2）恢复备份速度要慢。<br>3）每次读写都同步的话，有一定的性能压力。<br>4）存在个别Bug，造成不能恢复。<br><strong>注意：</strong><br>1）AOF和RDB同时开启，系统默认取AOF的数据<br>2）推荐AOF和RDB都使用<br>3）如果对数据不敏感，可以选单独用RDB<br>4）不建议单独用 AOF，因为可能会出现Bug<br>5）如果只是做纯内存缓存，可以都不用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis持久化方式&quot;&gt;&lt;a href=&quot;#Redis持久化方式&quot; class=&quot;headerlink&quot; title=&quot;Redis持久化方式&quot;&gt;&lt;/a&gt;Redis持久化方式&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;两个不同形式得持久化方式&lt;br&gt;RDB(Redis DataBa</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    <category term="持久化方式" scheme="http://example.com/categories/Redis/%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
    <category term="持久化方式" scheme="http://example.com/tags/%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis | 秒杀</title>
    <link href="http://example.com/2022/05/07/%E7%A7%92%E6%9D%80/"/>
    <id>http://example.com/2022/05/07/%E7%A7%92%E6%9D%80/</id>
    <published>2022-05-07T12:14:29.000Z</published>
    <updated>2022-05-09T12:00:11.595Z</updated>
    
    <content type="html"><![CDATA[<h1 id="秒杀"><a href="#秒杀" class="headerlink" title="秒杀"></a>秒杀</h1><h2 id="秒杀需要解决的问题"><a href="#秒杀需要解决的问题" class="headerlink" title="秒杀需要解决的问题"></a>秒杀需要解决的问题</h2><p>解决商品库存计数器和秒杀成功的用户记录的事务操作</p><h2 id="秒杀遇到的三个问题"><a href="#秒杀遇到的三个问题" class="headerlink" title="秒杀遇到的三个问题"></a>秒杀遇到的三个问题</h2><p>1.连接超时问题 —&gt; 使用Redis连接池<br>2.超卖（卖出的商品数量超过商品库存数量） —&gt; 使用事务<br>3.库存遗留问题（并发的请求中只有一个请求能够秒杀成功造成库存遗留） —&gt; 使用lua脚本</p><span id="more"></span><p>1.index.jsp</p><pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;iPhoneXsMAX !!!  1元秒杀！！！&lt;/h1&gt;&lt;form id=&quot;msform&quot; action=&quot;$&#123;pageContext.request.contextPath&#125;/doseckill&quot; enctype=&quot;application/x-www-form-urlencoded&quot;&gt;    &lt;input type=&quot;hidden&quot; id=&quot;prodid&quot; name=&quot;prodid&quot; value=&quot;0101&quot;&gt;    &lt;input type=&quot;button&quot;  id=&quot;miaosha_btn&quot; name=&quot;seckill_btn&quot; value=&quot;秒杀点我&quot;/&gt;&lt;/form&gt;&lt;/body&gt;&lt;script  type=&quot;text/javascript&quot; src=&quot;$&#123;pageContext.request.contextPath&#125;/script/jquery/jquery-3.1.0.js&quot;&gt;&lt;/script&gt;&lt;script  type=&quot;text/javascript&quot;&gt;$(function()&#123;    $(&quot;#miaosha_btn&quot;).click(function()&#123;             var url=$(&quot;#msform&quot;).attr(&quot;action&quot;);         $.post(url,$(&quot;#msform&quot;).serialize(),function(data)&#123;            if(data==&quot;false&quot;)&#123;                alert(&quot;抢光了&quot; );                $(&quot;#miaosha_btn&quot;).attr(&quot;disabled&quot;,true);            &#125;        &#125; );        &#125;)&#125;)&lt;/script&gt;&lt;/html&gt;</code></pre><p>2.SeckillServlet.java</p><pre><code>public class SecKillServlet extends HttpServlet &#123;    private static final long serialVersionUID = 1L;           /**     * @see HttpServlet#HttpServlet()     */    public SecKillServlet() &#123;        super();        // TODO Auto-generated constructor stub    &#125;    /**     * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)     */    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        // TODO Auto-generated method stub         String userid = new Random().nextInt(50000) +&quot;&quot; ;         String prodid =request.getParameter(&quot;prodid&quot;);                boolean if_success=SecKill_redisByScript.doSecKill(userid,prodid);         response.getWriter().print(if_success);    &#125;&#125;</code></pre><p>3.JedisPoolUtil.java</p><pre><code>package com.atguigu;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;public class JedisPoolUtil &#123;    private static volatile JedisPool jedisPool = null;     private JedisPoolUtil() &#123;    &#125;    public static JedisPool getJedisPoolInstance() &#123;        if (null == jedisPool) &#123;            synchronized (JedisPoolUtil.class) &#123;                if (null == jedisPool) &#123;                    JedisPoolConfig poolConfig = new JedisPoolConfig();                    poolConfig.setMaxTotal(200);                    poolConfig.setMaxIdle(32);                    poolConfig.setMaxWaitMillis(100*1000);                    poolConfig.setBlockWhenExhausted(true);                    poolConfig.setTestOnBorrow(true);  // ping  PONG                                     jedisPool = new JedisPool(poolConfig, &quot;192.168.223.132&quot;, 6379, 60000 );                             &#125;            &#125;        &#125;        return jedisPool;    &#125;    public static void release(JedisPool jedisPool, Jedis jedis) &#123;        if (null != jedis) &#123;            jedisPool.returnResource(jedis);        &#125;    &#125;&#125;</code></pre><p>4.Seckill_redisByScript.java</p><pre><code>public class SecKill_redisByScript &#123;        private static final  org.slf4j.Logger logger =LoggerFactory.getLogger(SecKill_redisByScript.class) ;    public static void main(String[] args) &#123;          JedisPool jedispool =  JedisPoolUtil.getJedisPoolInstance();         Jedis jedis=jedispool.getResource();        System.out.println(jedis.ping());                Set&lt;HostAndPort&gt; set=new HashSet&lt;HostAndPort&gt;();            //    doSecKill(&quot;201&quot;,&quot;sk:0101&quot;);    &#125;        static String secKillScript =&quot;local userid=KEYS[1];\r\n&quot; +             &quot;local prodid=KEYS[2];\r\n&quot; +             &quot;local qtkey=&#39;Seckill:&#39;..prodid..\&quot;:kc\&quot;;\r\n&quot; +             &quot;local usersKey=&#39;Seckill:&#39;..prodid..\&quot;:user\&quot;;\r\n&quot; +             &quot;local userExists=redis.call(\&quot;sismember\&quot;,usersKey,userid);\r\n&quot; +             &quot;if tonumber(userExists)==1 then \r\n&quot; +             &quot;   return 2;\r\n&quot; +             &quot;end\r\n&quot; +             &quot;local num= redis.call(\&quot;get\&quot; ,qtkey);\r\n&quot; +             &quot;if tonumber(num)&lt;=0 then \r\n&quot; +             &quot;   return 0;\r\n&quot; +             &quot;else \r\n&quot; +             &quot;   redis.call(\&quot;decr\&quot;,qtkey);\r\n&quot; +             &quot;   redis.call(\&quot;sadd\&quot;,usersKey,userid);\r\n&quot; +             &quot;end\r\n&quot; +             &quot;return 1&quot; ;                 static String secKillScript2 =             &quot;local userExists=redis.call(\&quot;sismember\&quot;,\&quot;&#123;sk&#125;:0101:usr\&quot;,userid);\r\n&quot; +            &quot; return 1&quot;;         public static boolean doSecKill(String uid,String prodid) throws IOException &#123;                JedisPool jedisPool = JedisPoolUtil.getJedisPoolInstance();                                Jedis jedis = jedisPool.getResource();                                String sha1=  jedis.scriptLoad(secKillScript);                                 Object result= jedis.evalsha(sha1, 2, uid,prodid);                    String reString=String.valueOf(result);                if (&quot;0&quot;.equals( reString )  ) &#123;                    System.err.println(&quot;已抢空！！&quot;);                &#125;else if(&quot;1&quot;.equals( reString )  )  &#123;                    System.out.println(&quot;抢购成功！！！！&quot;);                &#125;else if(&quot;2&quot;.equals( reString )  )  &#123;                    System.err.println(&quot;该用户已抢过！！&quot;);                &#125;else&#123;                    System.err.println(&quot;抢购异常！！&quot;);                &#125;                jedis.close();        return true;             &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;秒杀&quot;&gt;&lt;a href=&quot;#秒杀&quot; class=&quot;headerlink&quot; title=&quot;秒杀&quot;&gt;&lt;/a&gt;秒杀&lt;/h1&gt;&lt;h2 id=&quot;秒杀需要解决的问题&quot;&gt;&lt;a href=&quot;#秒杀需要解决的问题&quot; class=&quot;headerlink&quot; title=&quot;秒杀需要解决的问题&quot;&gt;&lt;/a&gt;秒杀需要解决的问题&lt;/h2&gt;&lt;p&gt;解决商品库存计数器和秒杀成功的用户记录的事务操作&lt;/p&gt;
&lt;h2 id=&quot;秒杀遇到的三个问题&quot;&gt;&lt;a href=&quot;#秒杀遇到的三个问题&quot; class=&quot;headerlink&quot; title=&quot;秒杀遇到的三个问题&quot;&gt;&lt;/a&gt;秒杀遇到的三个问题&lt;/h2&gt;&lt;p&gt;1.连接超时问题 —&amp;gt; 使用Redis连接池&lt;br&gt;2.超卖（卖出的商品数量超过商品库存数量） —&amp;gt; 使用事务&lt;br&gt;3.库存遗留问题（并发的请求中只有一个请求能够秒杀成功造成库存遗留） —&amp;gt; 使用lua脚本&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    <category term="秒杀" scheme="http://example.com/categories/Redis/%E7%A7%92%E6%9D%80/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
    <category term="秒杀" scheme="http://example.com/tags/%E7%A7%92%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>Redis | 事务</title>
    <link href="http://example.com/2022/05/07/%E4%BA%8B%E5%8A%A1-2/"/>
    <id>http://example.com/2022/05/07/%E4%BA%8B%E5%8A%A1-2/</id>
    <published>2022-05-07T12:03:15.000Z</published>
    <updated>2022-05-07T12:11:56.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="Redis中事务的定义"><a href="#Redis中事务的定义" class="headerlink" title="Redis中事务的定义"></a>Redis中事务的定义</h2><p>Redis事务是一个单独的隔离操作：<strong>事务中的所有命令都会序列化、按顺序地执行</strong>。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断<br>Redis事务的主要作用就是<strong>串联多个命令防止别的命令插队</strong>。</p><h2 id="事务相关的命令-multi、exec、discard"><a href="#事务相关的命令-multi、exec、discard" class="headerlink" title="事务相关的命令(multi、exec、discard)"></a>事务相关的命令(multi、exec、discard)</h2><p>1.从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，至到输入Exec后，Redis会将之前的命令队列中的命令依次执行。<br>2.组队的过程中可以通过discard来放弃组队。 </p><span id="more"></span><h2 id="事务中的错误处理"><a href="#事务中的错误处理" class="headerlink" title="事务中的错误处理"></a>事务中的错误处理</h2><p>1.组队中某个命令出现了报告错误，执行时整个的所有队列会都会被取消。<br>2.如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。</p><h2 id="Redis事务的使用"><a href="#Redis事务的使用" class="headerlink" title="Redis事务的使用"></a>Redis事务的使用</h2><p>1.WATCH key[key….]<br>在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。<br>2.unwatch<br>取消 WATCH 命令对所有 key 的监视。<br>如果在执行 WATCH 命令之后， EXEC 命令或 DISCARD 命令先被执行了的话，那么就不需要再执行 UNWATCH 了。<br>3.三特性<br>3.1单独的隔离操作<br>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。<br>3.2没有隔离级别的概念<br>队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，也就不存在“事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头痛的问题 <br>3.3不保证原子性<br>Redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚 </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; title=&quot;事务&quot;&gt;&lt;/a&gt;事务&lt;/h1&gt;&lt;h2 id=&quot;Redis中事务的定义&quot;&gt;&lt;a href=&quot;#Redis中事务的定义&quot; class=&quot;headerlink&quot; title=&quot;Redis中事务的定义&quot;&gt;&lt;/a&gt;Redis中事务的定义&lt;/h2&gt;&lt;p&gt;Redis事务是一个单独的隔离操作：&lt;strong&gt;事务中的所有命令都会序列化、按顺序地执行&lt;/strong&gt;。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断&lt;br&gt;Redis事务的主要作用就是&lt;strong&gt;串联多个命令防止别的命令插队&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;事务相关的命令-multi、exec、discard&quot;&gt;&lt;a href=&quot;#事务相关的命令-multi、exec、discard&quot; class=&quot;headerlink&quot; title=&quot;事务相关的命令(multi、exec、discard)&quot;&gt;&lt;/a&gt;事务相关的命令(multi、exec、discard)&lt;/h2&gt;&lt;p&gt;1.从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，至到输入Exec后，Redis会将之前的命令队列中的命令依次执行。&lt;br&gt;2.组队的过程中可以通过discard来放弃组队。 &lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    <category term="事务" scheme="http://example.com/categories/Redis/%E4%BA%8B%E5%8A%A1/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
    <category term="事务" scheme="http://example.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Redis | Jedis实现手机号验证码</title>
    <link href="http://example.com/2022/05/06/Jedis%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%9C%BA%E5%8F%B7%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    <id>http://example.com/2022/05/06/Jedis%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%9C%BA%E5%8F%B7%E9%AA%8C%E8%AF%81%E7%A0%81/</id>
    <published>2022-05-07T02:19:55.000Z</published>
    <updated>2022-05-07T02:28:05.158Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Jedis实现手机号验证码"><a href="#Jedis实现手机号验证码" class="headerlink" title="Jedis实现手机号验证码"></a>Jedis实现手机号验证码</h1><p><img src="/2022/05/06/Jedis%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%9C%BA%E5%8F%B7%E9%AA%8C%E8%AF%81%E7%A0%81/1.PNG"><br><strong>要求</strong><br>1.输入手机号，点击发送后随机生成6位数字码，2分钟有效<br>2.输入验证码，点击验证，返回成功或失败<br>3.每个手机号每天只能输入3次</p><span id="more"></span><p>1.index.jsp</p><pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=ISO-8859-1&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;script  src=&quot;/Verify_code/static/jquery/jquery-3.1.0.js&quot; &gt;&lt;/script&gt;&lt;link href=&quot;/Verify_code/static/bs/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot; /&gt;&lt;script  src=&quot;/Verify_code/static/bs/js/bootstrap.min.js&quot;   &gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;   &lt;div class=&quot;container&quot;&gt;        &lt;div class=&quot;row&quot;&gt;            &lt;div id=&quot;alertdiv&quot; class=&quot;col-md-12&quot;&gt;                  &lt;form class=&quot;navbar-form navbar-left&quot; role=&quot;search&quot; id=&quot;codeform&quot;&gt;                  &lt;div class=&quot;form-group&quot;&gt;                    &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;填写手机号&quot; name=&quot;phone_no&quot;&gt;                    &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; id=&quot;sendCode&quot;&gt;发送验证码&lt;/button&gt;&lt;br&gt;                    &lt;font id=&quot;countdown&quot; color=&quot;red&quot; &gt;&lt;/font&gt;                    &lt;br&gt;                    &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;填写验证码&quot; name=&quot;verify_code&quot;&gt;                    &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; id=&quot;verifyCode&quot;&gt;确定&lt;/button&gt;                    &lt;font id=&quot;result&quot; color=&quot;green&quot; &gt;&lt;/font&gt;&lt;font id=&quot;error&quot; color=&quot;red&quot; &gt;&lt;/font&gt;                    &lt;/div&gt;                    &lt;/form&gt;    &lt;/div&gt;   &lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; var t=120;//设定倒计时的时间 var interval;function refer()&#123;      $(&quot;#countdown&quot;).text(&quot;请于&quot;+t+&quot;秒内填写验证码 &quot;); // 显示倒计时     t--; // 计数器递减     if(t&lt;=0)&#123;        clearInterval(interval);        $(&quot;#countdown&quot;).text(&quot;验证码已失效，请重新发送！ &quot;);    &#125;&#125; $(function()&#123;    $(&quot;#sendCode&quot;).click( function () &#123;                      $.post(&quot;/Verify_code/CodeSenderServlet&quot;,$(&quot;#codeform&quot;).serialize(),function(data)&#123;             if(data==&quot;true&quot;)&#123;                 t=120;                 clearInterval(interval);                 interval= setInterval(&quot;refer()&quot;,1000);//启动1秒定时               &#125;else if (data==&quot;limit&quot;)&#123;                clearInterval(interval);                $(&quot;#countdown&quot;).text(&quot;单日发送超过次数！ &quot;)             &#125;          &#125;);       &#125;);        $(&quot;#verifyCode&quot;).click( function () &#123;                   $.post(&quot;/Verify_code/CodeVerifyServlet&quot;,$(&quot;#codeform&quot;).serialize(),function(data)&#123;             if(data==&quot;true&quot;)&#123;                 $(&quot;#result&quot;).attr(&quot;color&quot;,&quot;green&quot;);                 $(&quot;#result&quot;).text(&quot;验证成功&quot;);                 clearInterval(interval);                 $(&quot;#countdown&quot;).text(&quot;&quot;);             &#125;else&#123;                 $(&quot;#result&quot;).attr(&quot;color&quot;,&quot;red&quot;);                 $(&quot;#result&quot;).text(&quot;验证失败&quot;);             &#125;          &#125;);       &#125;);        &#125;);&lt;/script&gt;&lt;/html&gt;</code></pre><p>2.CodeSenderServlet.java(发送验证码)</p><pre><code>@WebServlet(&quot;/CodeSenderServlet&quot;)public class CodeSenderServlet extends HttpServlet &#123;    private static final long serialVersionUID = 1L;           /**     * @see HttpServlet#HttpServlet()     */    public CodeSenderServlet() &#123;        super();        // TODO Auto-generated constructor stub    &#125;    /**     * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)     */    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;                //获取手机号        String phone_no = request.getParameter(&quot;phone_no&quot;);        //获取验证码        String code = getCode(6);        //拼接key        String codeKey = &quot;Verify_code:&quot; + phone_no + &quot;:code&quot;;//Verify_code:12345:code        String countKey = &quot;Verify_code:&quot; + phone_no + &quot;:count&quot;;                Jedis jedis = new Jedis(&quot;192.168.44.132&quot;, 6379);        //判断发送验证码的次数        String count = jedis.get(countKey);        if(count == null) &#123;            //代表第一次            jedis.setex(countKey, 24*60*60, &quot;1&quot;);        &#125;else if(Integer.parseInt(count) &lt;= 2) &#123;            jedis.incr(countKey);        &#125;else if(Integer.parseInt(count) &gt; 2) &#123;            response.getWriter().print(&quot;limit&quot;);            jedis.close();            return ;        &#125;                //向redis中进行存储，以手机号为键，以验证码为值        jedis.setex(codeKey, 120, code);        jedis.close();        response.getWriter().print(true);            &#125;            private String getCode(int length) &#123;        String code = &quot;&quot;;        Random random = new Random();        for(int i = 0; i &lt; length; i++) &#123;            int rand = random.nextInt(10);            code += rand;        &#125;        return code;    &#125;&#125;</code></pre><p>3.验证</p><pre><code>@WebServlet(&quot;/CodeVerifyServlet&quot;)public class CodeVerifyServlet extends HttpServlet &#123;    private static final long serialVersionUID = 1L;           /**     * @see HttpServlet#HttpServlet()     */    public CodeVerifyServlet() &#123;        super();        // TODO Auto-generated constructor stub    &#125;    /**     * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)     */    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;            //获取验证码和手机号        String phone_no = request.getParameter(&quot;phone_no&quot;);        String verify_code = request.getParameter(&quot;verify_code&quot;);        //拼接key        String codeKey = &quot;Verify_code:&quot; + phone_no + &quot;:code&quot;;        //从redis中获取手机号所对应的验证码        Jedis jedis = new Jedis(&quot;192.168.44.132&quot;, 6379);        String code = jedis.get(codeKey);        if(code.equals(verify_code)) &#123;            response.getWriter().print(true);        &#125;        jedis.close();            &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Jedis实现手机号验证码&quot;&gt;&lt;a href=&quot;#Jedis实现手机号验证码&quot; class=&quot;headerlink&quot; title=&quot;Jedis实现手机号验证码&quot;&gt;&lt;/a&gt;Jedis实现手机号验证码&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2022/05/06/Jedis%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%9C%BA%E5%8F%B7%E9%AA%8C%E8%AF%81%E7%A0%81/1.PNG&quot;&gt;&lt;br&gt;&lt;strong&gt;要求&lt;/strong&gt;&lt;br&gt;1.输入手机号，点击发送后随机生成6位数字码，2分钟有效&lt;br&gt;2.输入验证码，点击验证，返回成功或失败&lt;br&gt;3.每个手机号每天只能输入3次&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    <category term="Jedis实现手机号验证码" scheme="http://example.com/categories/Redis/Jedis%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%9C%BA%E5%8F%B7%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
    <category term="Jedis" scheme="http://example.com/tags/Jedis/"/>
    
    <category term="手机号验证码" scheme="http://example.com/tags/%E6%89%8B%E6%9C%BA%E5%8F%B7%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Java | 创建线程的三种方式</title>
    <link href="http://example.com/2022/04/24/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://example.com/2022/04/24/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</id>
    <published>2022-04-25T01:05:43.000Z</published>
    <updated>2022-04-25T01:08:26.053Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建线程的三种方式"><a href="#创建线程的三种方式" class="headerlink" title="创建线程的三种方式"></a>创建线程的三种方式</h1><p>创建线程有三种方式，分别是继承Thread类、实现Runnable接口、实现Callable接口。</p><p>1.通过继承Thread类来创建并启动线程的步骤如下：<br>1.1定义Thread类的子类，并重写该类的run()方法，该run()方法将作为线程执行体。<br>1.2创建Thread子类的实例，即创建了线程对象。<br>1.3调用线程对象的start()方法来启动该线程。<br>2.通过实现Runnable接口来创建并启动线程的步骤如下：<br>2.1定义Runnable接口的实现类，并实现该接口的run()方法，该run()方法将作为线程执行体。<br>2.2创建Runnable实现类的实例，并将其作为Thread的target来创建Thread对象，Thread对象为线程对象。<br>2.3调用线程对象的start()方法来启动该线程。<br>3.通过实现Callable接口来创建并启动线程的步骤如下：<br>3.1创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，且该call()方法有返回值。然后再创建Callable实现类的实例。<br>3.2使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。<br>3.3使用FutureTask对象作为Thread对象的target创建并启动新线程。<br>3.4调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。</p><span id="more"></span><p><strong>代码</strong></p><pre><code>import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;class MyThread extends Thread&#123;    @Override    public void run()&#123;        System.out.println(Thread.currentThread().getName());    &#125;&#125;class MyThread1 implements Runnable&#123;    @Override    public void run() &#123;        System.out.println(Thread.currentThread().getName());    &#125;&#125;class MyThread2 implements Callable&#123;    @Override    public Object call() throws Exception &#123;        return &quot;success&quot;;    &#125;&#125;public class ThreadTest &#123;    public static void main(String[] args) throws ExecutionException &#123;        for(int i=0;i&lt;10;i++)&#123;            //继承Thread类            //new MyThread().start();                        //实现Runnable接口            //new Thread(new MyThread1()).start();                        //实现Callable接口            FutureTask&lt;String&gt; task = new FutureTask&lt;&gt;(new MyThread2());            new Thread(task).start();                    try &#123;                System.out.println(task.get());            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;创建线程的三种方式&quot;&gt;&lt;a href=&quot;#创建线程的三种方式&quot; class=&quot;headerlink&quot; title=&quot;创建线程的三种方式&quot;&gt;&lt;/a&gt;创建线程的三种方式&lt;/h1&gt;&lt;p&gt;创建线程有三种方式，分别是继承Thread类、实现Runnable接口、实现Callable接口。&lt;/p&gt;
&lt;p&gt;1.通过继承Thread类来创建并启动线程的步骤如下：&lt;br&gt;1.1定义Thread类的子类，并重写该类的run()方法，该run()方法将作为线程执行体。&lt;br&gt;1.2创建Thread子类的实例，即创建了线程对象。&lt;br&gt;1.3调用线程对象的start()方法来启动该线程。&lt;br&gt;2.通过实现Runnable接口来创建并启动线程的步骤如下：&lt;br&gt;2.1定义Runnable接口的实现类，并实现该接口的run()方法，该run()方法将作为线程执行体。&lt;br&gt;2.2创建Runnable实现类的实例，并将其作为Thread的target来创建Thread对象，Thread对象为线程对象。&lt;br&gt;2.3调用线程对象的start()方法来启动该线程。&lt;br&gt;3.通过实现Callable接口来创建并启动线程的步骤如下：&lt;br&gt;3.1创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，且该call()方法有返回值。然后再创建Callable实现类的实例。&lt;br&gt;3.2使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。&lt;br&gt;3.3使用FutureTask对象作为Thread对象的target创建并启动新线程。&lt;br&gt;3.4调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="基础" scheme="http://example.com/categories/Java/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="创建线程的三种方式" scheme="http://example.com/categories/Java/%E5%9F%BA%E7%A1%80/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="多线程" scheme="http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="线程" scheme="http://example.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java | 创建线程池的7种方式</title>
    <link href="http://example.com/2022/04/24/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%847%E4%B8%AD%E6%96%B9%E5%BC%8F/"/>
    <id>http://example.com/2022/04/24/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%847%E4%B8%AD%E6%96%B9%E5%BC%8F/</id>
    <published>2022-04-24T09:57:42.000Z</published>
    <updated>2022-04-24T09:58:52.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建线程池的7种方式"><a href="#创建线程池的7种方式" class="headerlink" title="创建线程池的7种方式"></a>创建线程池的7种方式</h1><pre><code>import java.util.Date;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class ThreadPoolCreationTest &#123;    public static void fixedThreadPool()&#123;//        ExecutorService threadPool = Executors.newFixedThreadPool(2);//        //        Runnable runnable = new Runnable()&#123;//            @Override//            public void run()&#123;//                System.out.println(&quot;任务被执行，线程：&quot; + Thread.currentThread().getName());//            &#125;//        &#125;;//        //        Future&lt;?&gt; submit = threadPool.submit(runnable);////        System.out.println(submit);////        System.out.println(submit.isDone());//        threadPool.execute(runnable);//        threadPool.execute(runnable);//        threadPool.execute(runnable);                ExecutorService threadPool = Executors.newFixedThreadPool(2);        for(int i = 0; i &lt; 4; i++)&#123;            threadPool.execute(() -&gt; &#123;                System.out.println(&quot;任务被执行，线程：&quot; + Thread.currentThread().getName());            &#125;);        &#125;    &#125;        public static void cachedThreadPool()&#123;        ExecutorService threadPool = Executors.newCachedThreadPool();        for(int i=0;i&lt;10;i++)&#123;            threadPool.execute(() -&gt; &#123;                System.out.println(&quot;任务被执行，线程：&quot; + Thread.currentThread().getName());            &#125;);        &#125;    &#125;        public static void singleThreadPool()&#123;        ExecutorService threadPool = Executors.newSingleThreadExecutor();        for(int i = 0; i &lt; 10; i++)&#123;            threadPool.execute(() -&gt; &#123;                System.out.println(&quot;任务被执行，线程：&quot; + Thread.currentThread().getName());            &#125;);        &#125;    &#125;        public static void scheduledThreadPool()&#123;        ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(5);        System.out.println(&quot;添加任务，时间：&quot;+new Date());        threadPool.schedule(()-&gt;&#123;            System.out.println(&quot;任务被执行，时间：&quot;+new Date());            try &#123;                TimeUnit.SECONDS.sleep(1);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;, 1, TimeUnit.SECONDS);    &#125;        public static void singleThreadScheduledPool()&#123;        ScheduledExecutorService threadPool = Executors.newSingleThreadScheduledExecutor();        System.out.println(&quot;添加任务，时间：&quot;+new Date());        threadPool.schedule(()-&gt;&#123;            System.out.println(&quot;任务被执行，时间：&quot;+new Date());            try &#123;                TimeUnit.SECONDS.sleep(1);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;, 2, TimeUnit.SECONDS);    &#125;        public static void workStealingPool()&#123;        ExecutorService threadPool = Executors.newWorkStealingPool();        for(int i = 0; i &lt; 10; i++)&#123;            final int index = i;            threadPool.execute(() -&gt;&#123;                System.out.println(index + &quot;被执行，线程名&quot;+Thread.currentThread().getName());            &#125;);        &#125;        while(!threadPool.isTerminated())&#123;                    &#125;    &#125;        //推荐使用    //阿里巴巴开发手册：线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。    public static void myThreadPoolExecutor()&#123;        final int CORE_POOL_SIZE = 5;          final int MAX_POOL_SIZE = 10;        final int QUEUE_CAPACITY = 100;        final Long KEEP_ALIVE_TIME = 1L;        ThreadPoolExecutor threadPool = new ThreadPoolExecutor(                CORE_POOL_SIZE,                MAX_POOL_SIZE,                KEEP_ALIVE_TIME,                TimeUnit.SECONDS,                new ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY),                new ThreadPoolExecutor.CallerRunsPolicy()                );        for(int i = 0; i &lt; 10; i++)&#123;            final int index = i;            threadPool.execute(() -&gt; &#123;                System.out.println(index+&quot;被执行，线程名：&quot;+Thread.currentThread().getName());                try &#123;                    Thread.sleep(1000);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;);        &#125;            &#125;            public static void main(String[] args) &#123;        //fixedThreadPool();        //cachedThreadPool();        //singleThreadPool();        //scheduledThreadPool();        //singleThreadScheduledPool();        //workStealingPool();        myThreadPoolExecutor();    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;创建线程池的7种方式&quot;&gt;&lt;a href=&quot;#创建线程池的7种方式&quot; class=&quot;headerlink&quot; title=&quot;创建线程池的7种方式&quot;&gt;&lt;/a&gt;创建线程池的7种方式&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;import java.util.Date;
import </summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="基础" scheme="http://example.com/categories/Java/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="创建线程池的7种方式" scheme="http://example.com/categories/Java/%E5%9F%BA%E7%A1%80/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%847%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="线程池" scheme="http://example.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>Java | ThreadLocal</title>
    <link href="http://example.com/2022/04/23/ThreadLocal/"/>
    <id>http://example.com/2022/04/23/ThreadLocal/</id>
    <published>2022-04-24T04:07:49.000Z</published>
    <updated>2022-04-24T04:10:42.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ThreadLocal示例"><a href="#ThreadLocal示例" class="headerlink" title="ThreadLocal示例"></a>ThreadLocal示例</h1><p>ThreadLocal:<br>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。如果想实现每一个线程都有自己的专属本地变量该如何解决呢？ JDK 中提供的ThreadLocal类正是为了解决这样的问题。<br>ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。<br>如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是ThreadLocal变量名的由来。他们可以使用 get（） 和 set（） 方法来获取默认值或将修改其值，从而避免了线程安全问题。</p><p><strong>代码：</strong></p><pre><code>import java.text.SimpleDateFormat;import java.util.Random;public class ThreadLocalTest implements Runnable&#123;    //private static final ThreadLocal&lt;SimpleDateFormat&gt; formatter = ThreadLocal.withInitial(()-&gt;new SimpleDateFormat(&quot;yyyyMMdd HHmm&quot;));    private static final ThreadLocal&lt;SimpleDateFormat&gt; formatter = new ThreadLocal&lt;SimpleDateFormat&gt;()&#123;        @Override        protected SimpleDateFormat initialValue()&#123;            return new SimpleDateFormat(&quot;yyyyMMdd HHmm&quot;);        &#125;    &#125;;        @Override    public void run() &#123;        System.out.println(&quot;Thread Name=&quot;+Thread.currentThread().getName()+&quot; default formatter=&quot;+formatter.get().toPattern());        try &#123;            Thread.sleep(new Random().nextInt(1000));        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        formatter.set(new SimpleDateFormat());        System.out.println(&quot;Thread Name=&quot;+Thread.currentThread().getName()+&quot; current formatter=&quot;+formatter.get().toPattern());            &#125;        public static void main(String[] args) throws InterruptedException&#123;        ThreadLocalTest obj = new ThreadLocalTest();        for(int i=0;i&lt;10;i++)&#123;            Thread t = new Thread(obj, &quot;&quot;+i);            Thread.sleep(new Random().nextInt(1000));            t.start();        &#125;    &#125;    &#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ThreadLocal示例&quot;&gt;&lt;a href=&quot;#ThreadLocal示例&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal示例&quot;&gt;&lt;/a&gt;ThreadLocal示例&lt;/h1&gt;&lt;p&gt;ThreadLocal:&lt;br&gt;通常情况下，我们创建</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="基础" scheme="http://example.com/categories/Java/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="ThreadLocal" scheme="http://example.com/categories/Java/%E5%9F%BA%E7%A1%80/ThreadLocal/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="ThreadLocal" scheme="http://example.com/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>单例模式 | 双重检验锁方式实现单例模式</title>
    <link href="http://example.com/2022/04/23/%E5%8F%8C%E9%87%8D%E6%A3%80%E9%AA%8C%E9%94%81%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/04/23/%E5%8F%8C%E9%87%8D%E6%A3%80%E9%AA%8C%E9%94%81%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-04-24T02:43:26.000Z</published>
    <updated>2022-04-24T02:56:03.079Z</updated>
    
    <content type="html"><![CDATA[<p><a href>参考资料</a></p><pre><code>package SingletonTest;class Singleton&#123;    private volatile static Singleton instance;        private Singleton()&#123;            &#125;        public static Singleton getInstance()&#123;        if(instance == null)&#123;            synchronized (Singleton.class) &#123;                if(instance == null)&#123;                    instance = new Singleton();                &#125;                //instance = new Singleton();            &#125;        &#125;        return instance;    &#125;&#125;public class MyThread extends Thread&#123;    @Override    public void run()&#123;        System.out.println(Singleton.getInstance().hashCode());    &#125;        public static void main(String[] args)&#123;        MyThread[] myThread = new MyThread[10];        for(int i=0;i&lt;myThread.length;i++)&#123;            myThread[i] = new MyThread();        &#125;                for(int i=0;i&lt;myThread.length;i++)&#123;            myThread[i].start();        &#125;    &#125;&#125;</code></pre><p><strong>双重锁的运行结果：</strong></p><pre><code>1156205522115620552211562055221156205522115620552211562055221156205522115620552211562055221156205522</code></pre><p><strong>去掉第二重锁的运行结果（产生了多例）：</strong></p><pre><code>1700548907148620290814862029081700548907148620290814862029081700548907148620290814862029081700548907</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href&gt;参考资料&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package SingletonTest;

class Singleton&amp;#123;
    private volatile static Singleton instance;
    
    pr</summary>
      
    
    
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="单例模式" scheme="http://example.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="双重检验锁方式实现单例模式" scheme="http://example.com/tags/%E5%8F%8C%E9%87%8D%E6%A3%80%E9%AA%8C%E9%94%81%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java | HashMap的七种遍历方式</title>
    <link href="http://example.com/2022/04/23/HashMap%E7%9A%84%E4%B8%83%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/"/>
    <id>http://example.com/2022/04/23/HashMap%E7%9A%84%E4%B8%83%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/</id>
    <published>2022-04-23T13:00:26.000Z</published>
    <updated>2022-04-23T13:20:32.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HashMap的七种遍历方式"><a href="#HashMap的七种遍历方式" class="headerlink" title="HashMap的七种遍历方式"></a>HashMap的七种遍历方式</h1><p><a href="https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw">参考资料</a></p><pre><code>import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Map.Entry;public class HashMapTraversalMethodsTest &#123;    public static void main(String[] args) &#123;                Map&lt;Integer, String&gt; map = new HashMap();        map.put(1, &quot;Java&quot;);        map.put(2, &quot;Python&quot;);        map.put(3, &quot;C&quot;);        map.put(4, &quot;C++&quot;);        map.put(5, &quot;JavaScript&quot;);                //迭代器EntrySet（推荐使用）//        Iterator&lt;Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();//        while(iterator.hasNext())&#123;//            Entry&lt;Integer, String&gt; entry = iterator.next();//            System.out.println(entry.getKey());//            System.out.println(entry.getValue());//        &#125;                //迭代器KeySet//        Iterator&lt;Integer&gt; iterator = map.keySet().iterator();//        while(iterator.hasNext())&#123;//            Integer key = iterator.next();//            System.out.println(key);//            System.out.println(map.get(key));//        &#125;                //ForEach EntrySet//        for(Entry&lt;Integer, String&gt; entry:map.entrySet())&#123;//            System.out.println(entry.getKey());//            System.out.println(entry.getValue());//        &#125;                //ForEach KeySet//        for(Integer key:map.keySet())&#123;//            System.out.println(key);//            System.out.println(map.get(key));//        &#125;                //Lambda//        map.forEach((key, value) -&gt; &#123;//            System.out.println(key);//            System.out.println(value);//        &#125;);                //Streams API单线程//        map.entrySet().stream().forEach((entry) -&gt; &#123;//            System.out.println(entry.getKey());//            System.out.println(entry.getValue());//        &#125;);                //Streams API多线程        map.entrySet().parallelStream().forEach((entry) -&gt;&#123;            System.out.println(entry.getKey());            System.out.println(entry.getValue());        &#125;);    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HashMap的七种遍历方式&quot;&gt;&lt;a href=&quot;#HashMap的七种遍历方式&quot; class=&quot;headerlink&quot; title=&quot;HashMap的七种遍历方式&quot;&gt;&lt;/a&gt;HashMap的七种遍历方式&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://mp.we</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="基础" scheme="http://example.com/categories/Java/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="HashMap的七种遍历方式" scheme="http://example.com/categories/Java/%E5%9F%BA%E7%A1%80/HashMap%E7%9A%84%E4%B8%83%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/"/>
    
    
    <category term="HashMap" scheme="http://example.com/tags/HashMap/"/>
    
    <category term="遍历" scheme="http://example.com/tags/%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
</feed>
