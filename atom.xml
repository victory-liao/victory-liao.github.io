<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Victory&#39;s Blog</title>
  
  <subtitle>非淡泊无以明志，非宁静无以致远</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-07-10T02:50:10.240Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>victory-liao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode | 9.回文数</title>
    <link href="http://example.com/2022/07/09/%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <id>http://example.com/2022/07/09/%E5%9B%9E%E6%96%87%E6%95%B0/</id>
    <published>2022-07-10T02:38:18.000Z</published>
    <updated>2022-07-10T02:50:10.240Z</updated>
    
    <content type="html"><![CDATA[<h1 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9.回文数"></a>9.回文数</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。<br>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。<br>例如，121 是回文，而 123 不是。<br><a href="https://leetcode.cn/problems/palindrome-number">题目链接</a></p><span id="more"></span><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.使用栈判断是否回文<br>先将每位数字依次入栈，再将栈中的所有数字依次出栈，如果入栈的数字序列与出战的数字序列相同，则该数为回文数。<br>2.将整数x转化为字符串<br>将整数x转化为字符串，将字符串反转，如果原字符串与反转字符串相等，则该数为回文数。<br>3.反转一半数字<br>反转后一半数字，并将其与前半部分数字进行比较，如果二者相同，则该数为回文数。<br>如何知道反转数字的位数已经达到原始数字位数的一半？当原始数字小于或等于反转后的数字时，就意味着我们已经处理了<br>一半位数的数字了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):    def isPalindrome2(self, x):        &quot;&quot;&quot;        使用栈实现回文                先将每位数字依次入栈，再将栈中的所有数字依次出栈，如果入栈的数字序列与出战的数字序列相同，则该数为回文数。        &quot;&quot;&quot;        if x &lt; 0:  # 负数肯定不是回文数            return False        xCopy = x        stack = list()        while x != 0:            stack.append(x % 10)            x = x // 10                    stack = stack[::-1]  # 从个位数开始取每位数字比较方便，但是入栈的数字序列与原数字序列相反，故反转栈                revertedNumber = 0        while stack:            revertedNumber = revertedNumber * 10 + stack.pop()                if xCopy == revertedNumber:            return True        else:            return False        def isPalindrome1(self, x):        x = str(x)        return x == x[::-1]        def isPalindrome(self, x):        &quot;&quot;&quot;        特殊情况：        1.当x&lt;0时，x不是回文数        2.如果数字的最后一位是0，为了使该数字为回文，则          其第一位数字也应该是0，只有0满足        &quot;&quot;&quot;        if x &lt; 0 or (x % 10 == 0 and x != 0):            return False                revertedNumber = 0        while x &gt; revertedNumber:            revertedNumber = (revertedNumber * 10) + (x % 10)            x //= 10                    # 当数字长度为奇数时，我们可以通过revertedNumber/10去除位于中位的数字。        # 例如，当输入为12321时，在while循环末尾我们可以得到x=12，revertedNumber=123,        # 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。        return x == revertedNumber or x == revertedNumber // 10    if __name__ == &quot;__main__&quot;:    slt = Solution()    # res = slt.isPalindrome(12321)    # res = slt.isPalindrome1(12321)    res = slt.isPalindrome2(12321)    print(&quot;是回文数&quot; if res else &quot;不是回文数&quot;)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;9-回文数&quot;&gt;&lt;a href=&quot;#9-回文数&quot; class=&quot;headerlink&quot; title=&quot;9.回文数&quot;&gt;&lt;/a&gt;9.回文数&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。&lt;br&gt;回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。&lt;br&gt;例如，121 是回文，而 123 不是。&lt;br&gt;&lt;a href=&quot;https://leetcode.cn/problems/palindrome-number&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="回文" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E5%9B%9E%E6%96%87/"/>
    
    <category term="9.回文数" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E5%9B%9E%E6%96%87/9-%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="回文数" scheme="http://example.com/tags/%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 70.爬楼梯</title>
    <link href="http://example.com/2022/07/09/%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <id>http://example.com/2022/07/09/%E7%88%AC%E6%A5%BC%E6%A2%AF/</id>
    <published>2022-07-09T13:40:07.000Z</published>
    <updated>2022-07-09T13:59:59.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br><a href="https://leetcode.cn/problems/climbing-stairs/">题目链接</a></p><span id="more"></span><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>f(n) = f(n-1) + f(n-2)</strong></p><ol><li><p>递归法<br>由f(1)=1,f(2)=2,f(3)=3,…,以此类推,f(n)=f(n-1)+f(n-2),使用递归法实现该问题，递归方程为f(n)=f(n-1)+f(n-2),<br>递归出口为f(1)=1,f(2)=2。</p></li><li><p>记忆化递归法<br>使用数组记录了每次计算的结果，避免递归法中的重复计算。</p></li><li><p>动态规划<br>动态规划转移方程：f(n)=f(n-1)+f(n-2)<br>边界条件：f(1)=1,f(2)=2</p></li><li><p>滚动数组<br>使用长度为3的数组实现爬楼梯问题，问题中涉及三个状态:状态1、状态2、状态3，每次更新状态时，先将状态2移动到状态1<br>的位置，再把状态3移动到状态2的位置，即将状态数组整体向前滚动一位。<br>例：<br>|1|2|3|—&gt;|2|3|5|</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p> class Solution(object):</p><pre><code> def climbStairs(self, n):     &quot;&quot;&quot;     递归法     :type n: int     :rtype: int     &quot;&quot;&quot;     if n == 1:         return 1     if n == 2:         return 2     return self.climbStairs(n - 1) + self.climbStairs(n - 2)  def climbStairs2(self, n):     &quot;&quot;&quot;     记忆化递归法     :type n: int     :rtype: int     &quot;&quot;&quot;     memo = []     return self.climbStairsMemo(n, memo)  def climbStairsMemo(self, n, memo):     if memo[n] &gt; 0:         return memo[n]     if n == 1:         memo[n] = 1     elif n == 2:         memo[n] = 2     else:         memo[n] = self.climbStairsMemo(n - 1, memo) + self.climbStairsMemo(n - 2, memo)     return memo[n]  def climbStairs3(self, n):     &quot;&quot;&quot;     动态规划     :type n: int     :rtype: int     &quot;&quot;&quot;     if n == 1:         return 1     dp = [1, 2]     for i in range(2, n):         dp.append(dp[i-1]+dp[i-2])  # dp[i] = dp[i-1] + dp[i-2]     return dp[n-1]  def climbStairs4(self, n):     &quot;&quot;&quot;     滚动数组（斐波那契数列）     :type n: int     :rtype: int     &quot;&quot;&quot;     if n == 1:         return 1     first = 1     second = 2     for i in range(2, n):         third = first + second         first = second         second = third     return second     </code></pre><p> if <strong>name</strong> == “<strong>main</strong>“:</p><pre><code> slt = Solution() # numberOfSolutions = slt.climbStairs(2) # numberOfSolutions = slt.climbStairs2(2) # numberOfSolutions = slt.climbStairs3(2) numberOfSolutions = slt.climbStairs4(4) print(numberOfSolutions)</code></pre></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;70-爬楼梯&quot;&gt;&lt;a href=&quot;#70-爬楼梯&quot; class=&quot;headerlink&quot; title=&quot;70.爬楼梯&quot;&gt;&lt;/a&gt;70.爬楼梯&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;假设你正在爬楼梯。需要 n 阶你才能到达楼顶。&lt;br&gt;每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;br&gt;&lt;a href=&quot;https://leetcode.cn/problems/climbing-stairs/&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="动态规划" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="70.爬楼梯" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/70-%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>19. 删除链表中的倒数第N个节点</title>
    <link href="http://example.com/2022/07/09/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>http://example.com/2022/07/09/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</id>
    <published>2022-07-09T12:32:37.000Z</published>
    <updated>2022-07-09T12:39:48.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="19-删除链表中的倒数第N个节点"><a href="#19-删除链表中的倒数第N个节点" class="headerlink" title="19. 删除链表中的倒数第N个节点"></a>19. 删除链表中的倒数第N个节点</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。<br><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">题目链接</a></p><span id="more"></span><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li><p>计算链表长度<br>删除链表的倒数第 n 个结点操作就等价于删除正数第L-n+1个节点，L为链表的长度</p></li><li><p>栈<br>遍历链表的同时将所有节点依次入栈，根据栈 先进后出 的原则，弹出栈的第n个节点就是需要删除的节点，并且弹出<br>第n个节点后的栈顶节点为待删除节点的前驱节点。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p> class ListNode(object):</p><pre><code> def __init__(self, val=0, next=None):     self.val = val     self.next = next</code></pre><p> class Solution(object):</p><pre><code> def removeNthFromEnd(self, linkedList, n):     &quot;&quot;&quot;     计算链表长度     :type head: ListNode     :type n: int     :rtype: ListNode     &quot;&quot;&quot;     dummy = ListNode(0, linkedList)     length = self.lenOfLinkedList(dummy)     print(length)     cur = dummy     for i in range(1, length - n):         cur = cur.next     cur.next = cur.next.next     return dummy.next  def removeNthFromEnd2(self, head, n):     &quot;&quot;&quot;栈&quot;&quot;&quot;     stack = list()     cur = head     while cur:         stack.append(cur)         cur = cur.next     for i in range(n):         stack.pop()              prev = stack[-1]     prev.next = prev.next.next     return head  def removeNthFromEnd3(self, head, n):     &quot;&quot;&quot;双指针&quot;&quot;&quot;     dummy = ListNode(0, head)     first = head     second = dummy     for i in range(n):         first = first.next          while first:         first = first.next         second = second.next          second.next = second.next.next     return dummy.next  def lenOfLinkedList(self, head):     if not head:         return 0     p = head     count = 0     while p is not None:         count += 1         p = p.next     return count  def createLinkedList(self, list):     head = r = ListNode(list[0])     for num in list[1:]:         node = ListNode(num)         r.next = node         r = node          return head  def traverseLinkedList(self, head):     if not head:         return     p = head     while p is not None:         print(p.val, end=&quot; &quot;)         p = p.next     print(&quot;&quot;)</code></pre><p> if <strong>name</strong> == “<strong>main</strong>“:</p><pre><code> slt = Solution() linkedList = slt.createLinkedList([1, 2, 3, 4, 5]) print(&quot;linked list:&quot;, end=&quot;&quot;) slt.traverseLinkedList(linkedList) length = slt.lenOfLinkedList(linkedList) print(&quot;length of linked list:&quot;, length) # newLinkedList = slt.removeNthFromEnd(linkedList, 2) # newLinkedList = slt.removeNthFromEnd2(linkedList, 2) newLinkedList = slt.removeNthFromEnd3(linkedList, 2) print(&quot;linked list after deleting the reversed n-th node:&quot;, end=&quot;&quot;) slt.traverseLinkedList(newLinkedList)</code></pre></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;19-删除链表中的倒数第N个节点&quot;&gt;&lt;a href=&quot;#19-删除链表中的倒数第N个节点&quot; class=&quot;headerlink&quot; title=&quot;19. 删除链表中的倒数第N个节点&quot;&gt;&lt;/a&gt;19. 删除链表中的倒数第N个节点&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。&lt;br&gt;&lt;a href=&quot;https://leetcode.cn/problems/remove-nth-node-from-end-of-list/&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="链表" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="19. 删除链表中的倒数第N个节点" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E9%93%BE%E8%A1%A8/19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 15.三数之和</title>
    <link href="http://example.com/2022/06/27/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://example.com/2022/06/27/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2022-06-27T14:07:51.000Z</published>
    <updated>2022-06-27T14:10:34.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h1><p><strong>题目描述：</strong><br>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。<br>注意：答案中不可以包含重复的三元组。<br><a href="https://leetcode.cn/problems/3sum">三数之和</a><br><strong>示例 1：</strong></p><pre><code>输入：nums = [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]</code></pre><p><strong>代码</strong></p><pre><code>class Solution:    # 三重循环    def threeSum1(self, nums):        nums.sort()        n = len(nums)        result = []        for first in range(0, n):            if first == 0 or nums[first] != nums[first - 1]:                for second in range(first + 1, n):                    if second == first + 1 or nums[second] != nums[second - 1]:                        for third in range(second + 1, n):                            if third == second + 1 or nums[third] != nums[third - 1]:                                if nums[first] + nums[second] + nums[third] == 0:                                    result.append([nums[first], nums[second], nums[third]])        return result        # 排序+双指针    def threeSum(self, nums):        n = len(nums)        nums.sort()        ans = list()                # 枚举 a        for first in range(n):            # 需要和上一次枚举的数不相同            if first &gt; 0 and nums[first] == nums[first - 1]:                continue            # c 对应的指针初始指向数组的最右端            third = n - 1            target = -nums[first]            # 枚举 b            for second in range(first + 1, n):                # 需要和上一次枚举的数不相同                if second &gt; first + 1 and nums[second] == nums[second - 1]:                    continue                # 需要保证 b 的指针在 c 的指针的左侧                while second &lt; third and nums[second] + nums[third] &gt; target:                    third -= 1                # 如果指针重合，随着 b 后续的增加                # 就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环                if second == third:                    break                if nums[second] + nums[third] == target:                    ans.append([nums[first], nums[second], nums[third]])                return ansif __name__ == &quot;__main__&quot;:    slt = Solution()    nums = [-1, 0, 1, 2, -1, -4]    # res = slt.threeSum(nums)    res = slt.threeSum1(nums)  # [[-1, -1, 2], [-1, 0, 1]]    print(res)        </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;15-三数之和&quot;&gt;&lt;a href=&quot;#15-三数之和&quot; class=&quot;headerlink&quot; title=&quot;15.三数之和&quot;&gt;&lt;/a&gt;15.三数之和&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;br&gt;给你一个包含 n 个整数的数组 nums，判断 </summary>
      
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="数组" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    <category term="15.三数之和" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>JVM | JDK监控和故障处理常用工具总结</title>
    <link href="http://example.com/2022/06/22/JDK%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2022/06/22/JDK%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/</id>
    <published>2022-06-23T03:03:09.000Z</published>
    <updated>2022-06-23T03:52:48.796Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK监控和故障处理常用工具总结"><a href="#JDK监控和故障处理常用工具总结" class="headerlink" title="JDK监控和故障处理常用工具总结"></a>JDK监控和故障处理常用工具总结</h1><ol><li>jps<br>JVM Process Status Tool,用于查看所有Java进程的启动类、传入参数和Java虚拟机参数等信息。</li><li>jstat<br>JVM Statistics Monitoring Tool,用于收集HotSpot虚拟机各方面的运行数据。</li><li>jinfo<br>Configuration Info for Java,显示虚拟机配置信息。</li><li>jmap<br>Memory Map for Java,生成虚拟机的内存转储快照（heapdump文件）、</li><li>jhat<br>JVM Heap Analysis Tool,用于分析堆转储快照，它会建立一个HTTP/Web服务器，让用户可以在浏览器上查看分析结果。</li><li>jstack<br>Stack Trace for Java,生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。<br><a href="https://javaguide.cn/java/jvm/jdk-monitoring-and-troubleshooting-tools.html#jdk-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7">参考链接</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JDK监控和故障处理常用工具总结&quot;&gt;&lt;a href=&quot;#JDK监控和故障处理常用工具总结&quot; class=&quot;headerlink&quot; title=&quot;JDK监控和故障处理常用工具总结&quot;&gt;&lt;/a&gt;JDK监控和故障处理常用工具总结&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;jps&lt;br&gt;J</summary>
      
    
    
    
    <category term="JVM" scheme="http://example.com/categories/JVM/"/>
    
    <category term="JDK监控和故障处理常用工具总结" scheme="http://example.com/categories/JVM/JDK%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 169.多数元素</title>
    <link href="http://example.com/2022/06/19/%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/"/>
    <id>http://example.com/2022/06/19/%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</id>
    <published>2022-06-20T03:48:45.000Z</published>
    <updated>2022-06-27T14:11:10.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169.多数元素"></a>169.多数元素</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊n/2⌋ 的元素。<br>你可以假设数组是非空的，并且给定的数组总是存在多数元素。<br><a href="https://leetcode.cn/problems/majority-element">题目链接</a></p><span id="more"></span><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li><p>HashMap<br>使用哈希表统计每个元素出现的次数，返回哈希表中值最大的键。</p></li><li><p>排序<br>如果将数组 nums 中的所有元素按照单调递增或单调递减的顺序排序，那么下标为 ⌊n/2⌋ 的元素（下标从 0 开始）一定是众数。<br>因此，对数组进行排序并返回下标为⌊n/2⌋的数组元素。</p></li><li><p>随机化<br>因为超过 ⌊n/2⌋ 的数组下标被众数占据了，这样我们随机挑选一个下标对应的元素并验证，有很大的概率能找到众数。</p></li><li><p>分治<br>如果数 a 是数组 nums 的众数，如果我们将 nums 分成两部分，那么 a 必定是至少一部分的众数。<br>我们使用经典的分治算法递归求解，直到所有的子问题都是长度为 1 的数组。长度为 1 的子数组中唯一的数显然是众数，直接返回即可。如果回溯后某区间的长度大于 1，我们必须将左右子区间的值合并。如果它们的众数相同，那么显然这一段区间的众数是它们相同的值。否则，我们需要比较两个众数在整个区间内出现的次数来决定该区间的众数。</p></li><li><p>Boyer-Moore投票算法<br>如果我们把众数记为 +1+1+1，把其他数记为 −1-1−1，将它们全部加起来，显然和大于 0，从结果本身我们可以看出众数比其他数多。</p><h2 id="代码-java版本"><a href="#代码-java版本" class="headerlink" title="代码(java版本)"></a>代码(java版本)</h2><p> import java.util.Arrays;<br> import java.util.HashMap;<br> import java.util.Iterator;<br> import java.util.Map;<br> import java.util.Map.Entry;<br> import java.util.Random;</p><p> public class MajorityElement {</p><pre><code> private int randRange(Random rand, int min, int max)&#123;     return rand.nextInt(max - min) + min; &#125;  private int countOccurences(int[] nums, int num)&#123;     int count = 0;          for(int num1 : nums)&#123;         if(num == num1)&#123;             count++;         &#125;     &#125;          return count; &#125;  public int majorityElement(int[] nums)&#123;     Random rand = new Random();          int majorityCount = nums.length / 2;          while(true)&#123;         int candidate = nums[randRange(rand, 0, nums.length)];         if(countOccurences(nums, candidate) &gt; majorityCount)&#123;             return candidate;         &#125;     &#125; &#125;  private int countInRange(int[] nums, int num, int lo, int hi)&#123;     int count = 0;     for(int i = lo; i &lt;= hi; i++)&#123;         if(nums[i] == num)&#123;             count++;         &#125;     &#125;     return count; &#125;  private int majorityElementRec(int[] nums, int lo, int hi)&#123;     if(lo == hi)&#123;         return nums[lo];     &#125;          int mid = (hi - lo) / 2 + lo;     int left = majorityElementRec(nums, lo, mid);     int right = majorityElementRec(nums, mid + 1, hi);          if(left == right)&#123;         return left;     &#125;          int leftCount = countInRange(nums, left, lo, hi);     int rightCount = countInRange(nums, right, lo, hi);          return leftCount &gt; rightCount ? left : right; &#125;  //方法4：分治 public int majorityElement1(int[] nums)&#123;     return majorityElementRec(nums, 0, nums.length - 1); &#125;  //方法5：Boyer-Moore public int majorityElement2(int[] nums)&#123;     int count = 0;     Integer candidate = null;          for (int num : nums)&#123;         if(count == 0)&#123;             candidate = num;         &#125;         count += (num == candidate) ? 1 : -1;     &#125;          return candidate; &#125;  public static void main(String[] args) &#123;     int[] nums = new int[]&#123;2,2,1,1,1,2,2&#125;;          //方法1：HashMap</code></pre><p> //        Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;();<br> //        for(Integer num : nums){<br> //            String tempNum = num.toString();<br> //            if(!map.keySet().contains(tempNum)){<br> //                map.put(tempNum, 1);<br> //<br> //            }else{<br> //                map.put(tempNum, map.get(tempNum) + 1);<br> //            }<br> //        }<br> //<br> //        Iterator&lt;Entry&lt;String, Integer&gt;&gt; iterator = map.entrySet().iterator();<br> //        for(;iterator.hasNext();){<br> //            Entry&lt;String, Integer&gt; next = iterator.next();<br> //            String key = next.getKey();<br> //            Integer value = next.getValue();<br> //            if(value &gt; (int)(nums.length / 2)){<br> //                System.out.println(key);<br> //            }<br> //        }</p><pre><code>     //方法2：排序</code></pre><p> //        Arrays.sort(nums);<br> //        System.out.println(nums[nums.length / 2]);</p><pre><code>     //方法3：随机化     MajorityElement majorityElement = new MajorityElement();     int majority1 = majorityElement.majorityElement(nums);     System.out.println(majority1);          //方法4：分治     int majority2 = majorityElement.majorityElement1(nums);     System.out.println(majority2);          //方法5：Boyer-Moore投票算法     int majority3 = majorityElement.majorityElement2(nums);     System.out.println(majority3); &#125;</code></pre><p> }</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;169-多数元素&quot;&gt;&lt;a href=&quot;#169-多数元素&quot; class=&quot;headerlink&quot; title=&quot;169.多数元素&quot;&gt;&lt;/a&gt;169.多数元素&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊n/2⌋ 的元素。&lt;br&gt;你可以假设数组是非空的，并且给定的数组总是存在多数元素。&lt;br&gt;&lt;a href=&quot;https://leetcode.cn/problems/majority-element&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="数组" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    <category term="169.多数元素" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>JVM | 垃圾收集器</title>
    <link href="http://example.com/2022/06/13/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>http://example.com/2022/06/13/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</id>
    <published>2022-06-14T03:33:16.000Z</published>
    <updated>2022-06-19T14:04:54.890Z</updated>
    
    <content type="html"><![CDATA[<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><table><thead><tr><th align="center">垃圾收集器</th><th align="center">串行/并行/并发</th><th align="center">新生代/老年代</th><th align="center">算法</th><th align="center">目标</th><th align="center">适用场景</th></tr></thead><tbody><tr><td align="center">Serial</td><td align="center">串行</td><td align="center">新生代</td><td align="center">复制算法</td><td align="center">响应速度优先</td><td align="center">单CPU环境下的Client模式</td></tr><tr><td align="center">Serial Old</td><td align="center">串行</td><td align="center">老年代</td><td align="center">标记-整理</td><td align="center">响应速度优先</td><td align="center">单CPU环境下的Client模式、CMS的后备预案</td></tr><tr><td align="center">ParNew</td><td align="center">并行</td><td align="center">新生代</td><td align="center">复制算法</td><td align="center">响应速度优先</td><td align="center">多CPU环境下在Server模式下与CMS配合</td></tr><tr><td align="center">Parallel Scavenge</td><td align="center">并行</td><td align="center">新生代</td><td align="center">复制算法</td><td align="center">吞吐量优先</td><td align="center">在后台运算而不需要太多交互任务</td></tr><tr><td align="center">Parallel Old</td><td align="center">并行</td><td align="center">老年代</td><td align="center">标记整理</td><td align="center">吞吐量优先</td><td align="center">在后台运算而不需要太多交互任务</td></tr><tr><td align="center">CMS</td><td align="center">并发</td><td align="center">老年代</td><td align="center">标记-清除</td><td align="center">响应速度优先</td><td align="center">集中在互联网网站或者基于浏览器的B/S系统的服务端上的Java应用</td></tr><tr><td align="center">G1</td><td align="center">并发</td><td align="center">Both</td><td align="center">标记-整理+复制算法</td><td align="center">响应速度优先</td><td align="center">面向服务端应用，将来替换CMS</td></tr><tr><td align="center">Shenandoah</td><td align="center">并发</td><td align="center">Both</td><td align="center">标记-整理+复制算法</td><td align="center">低延迟</td><td align="center"></td></tr><tr><td align="center">ZGC</td><td align="center">并发</td><td align="center">Both</td><td align="center">标记-整理+复制算法</td><td align="center">低延迟</td><td align="center"></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;垃圾收集器&quot;&gt;&lt;a href=&quot;#垃圾收集器&quot; class=&quot;headerlink&quot; title=&quot;垃圾收集器&quot;&gt;&lt;/a&gt;垃圾收集器&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;垃圾收集器&lt;/th&gt;
&lt;th align=</summary>
      
    
    
    
    <category term="JVM" scheme="http://example.com/categories/JVM/"/>
    
    <category term="垃圾收集器" scheme="http://example.com/categories/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
    <category term="GC" scheme="http://example.com/tags/GC/"/>
    
    <category term="垃圾收集器" scheme="http://example.com/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>并发 | 线程池</title>
    <link href="http://example.com/2022/06/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0-1/"/>
    <id>http://example.com/2022/06/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0-1/</id>
    <published>2022-06-08T01:59:41.000Z</published>
    <updated>2022-06-08T09:56:54.956Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p><strong>线程池的实现原理</strong><br><img src="/2022/06/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0-1/1.jpg"><br><strong>线程池的使用</strong><br>（1）线程池的创建</p><pre><code>new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime,unit,workQueue, handler)Parameters:    corePoolSize: the number of threads to keep in the pool, even if they are idle, unless allowCoreThreadTimeOut is set    maximumPoolSize: the maximum number of threads to allow in the pool    keepAliveTime: when the number of threads is greater than the core, this is the maximum time that excess idle threads will wait for new tasks before terminating.    unit the time: unit for the keepAliveTime argument    workQueue：the queue to use for holding tasks before they are executed. This queue will hold only the Runnable tasks submitted by the execute method.    threadFactory: set thread factory    handler: the handler to use when execution is blocked because the thread bounds and queue capacities are reached    workQueue:    ArrayBlockingQueue：基于数组结构的有界阻塞队列    LinkedBlockingQueue：基于链表结果的阻塞队列    SynchronousQueue：不存储元素的阻塞队列    PriorityBlockingQueue:具有优先级的无限阻塞队列handler:    AbortPolicy:直接抛出RejectedExecutionException异常    CallerRunsPolicy:使用调用者所在线程来执行任务    DiscardOldestPolicy：丢弃掉在队列中存在时间最久的任务    DiscardPolicy:默认丢弃任务，不进行任何通知</code></pre><p><a href="https://victory-liao.github.io/2022/04/24/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%847%E4%B8%AD%E6%96%B9%E5%BC%8F/">创建线程池的7种方式</a><br><a href="https://blog.csdn.net/qq_45404693/article/details/121020639">Executor框架</a></p><span id="more"></span><p>（2）向线程池提交任务<br>    execute():用于提交不需要返回值的任务。<br>    submit():用于提交需要返回值的任务。<br>（3）关闭线程池<br>    shutdown()<br>    shutdownNow()<br><strong>线程池的配置</strong><br>（1）<br>CPU密集型任务：配置 CPU数量+1 个线程的线程池；<br>IO密集型任务：配置 2*CPU数量 个线程的线程池；<br>混合型任务：两个事务执行时间相差不大，如果可以拆分，将其分解成一个CPU密集型任务和一个IO密集型任务，如果两个任务的执行时间相差太大，则没有必要拆分。<br>（2）优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理，让优先级高的任务先执行。<br>（3）执行时间不同的任务可以交给不同规模的线程池来处理，或者可以使用优先级队列，让执行时间段的任务先执行。<br>（4）依赖数据库连接池的任务，因为线程提交SQL后选哟等待数据库返回结果，等待的时间越长，则CPU空闲时间越长，应该设置较大的线程数。<br>（5）建议使用有界队列。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;线程池&quot;&gt;&lt;a href=&quot;#线程池&quot; class=&quot;headerlink&quot; title=&quot;线程池&quot;&gt;&lt;/a&gt;线程池&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;线程池的实现原理&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;/2022/06/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0-1/1.jpg&quot;&gt;&lt;br&gt;&lt;strong&gt;线程池的使用&lt;/strong&gt;&lt;br&gt;（1）线程池的创建&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime,unit,workQueue, handler)

Parameters:
    corePoolSize: the number of threads to keep in the pool, even if they are idle, unless allowCoreThreadTimeOut is set
    maximumPoolSize: the maximum number of threads to allow in the pool
    keepAliveTime: when the number of threads is greater than the core, this is the maximum time that excess idle threads will wait for new tasks before terminating.
    unit the time: unit for the keepAliveTime argument
    workQueue：the queue to use for holding tasks before they are executed. This queue will hold only the Runnable tasks submitted by the execute method.
    threadFactory: set thread factory
    handler: the handler to use when execution is blocked because the thread bounds and queue capacities are reached
    
workQueue:
    ArrayBlockingQueue：基于数组结构的有界阻塞队列
    LinkedBlockingQueue：基于链表结果的阻塞队列
    SynchronousQueue：不存储元素的阻塞队列
    PriorityBlockingQueue:具有优先级的无限阻塞队列

handler:
    AbortPolicy:直接抛出RejectedExecutionException异常
    CallerRunsPolicy:使用调用者所在线程来执行任务
    DiscardOldestPolicy：丢弃掉在队列中存在时间最久的任务
    DiscardPolicy:默认丢弃任务，不进行任何通知
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://victory-liao.github.io/2022/04/24/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%847%E4%B8%AD%E6%96%B9%E5%BC%8F/&quot;&gt;创建线程池的7种方式&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/qq_45404693/article/details/121020639&quot;&gt;Executor框架&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="并发" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="线程池" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="线程池" scheme="http://example.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    <category term="Executor" scheme="http://example.com/tags/Executor/"/>
    
    <category term="Executors" scheme="http://example.com/tags/Executors/"/>
    
    <category term="ThreadPoolExecutor" scheme="http://example.com/tags/ThreadPoolExecutor/"/>
    
    <category term="ScheduledThreadPoolExecutor" scheme="http://example.com/tags/ScheduledThreadPoolExecutor/"/>
    
  </entry>
  
  <entry>
    <title>并发 | Exchanger</title>
    <link href="http://example.com/2022/06/07/Exchanger/"/>
    <id>http://example.com/2022/06/07/Exchanger/</id>
    <published>2022-06-07T14:14:03.000Z</published>
    <updated>2022-06-07T14:28:19.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h1><p>Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程<br>通过exchange方法交换数据，如果第一个线程先执行exchange方法，它会一直等待第二个线程也执行exchange方法，当<br>两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。<br><strong>应用场景</strong><br>（1）遗传算法<br>遗传算法里需要选出两个人作为交配对象，这时候会交换两个人的数据，并使用交叉规则得出2个交配结果。<br>（2）校对工作<br>例如，我们需要将纸制银行流水通过人工的方式录入成电子银行流水，为了避免错误，采用AB岗两个人进行录入，录入到<br>Excel后，系统需要加载这两个Excel，并对两个Excel数据进行校对，看看是否录入一致。<br><strong>示例代码：</strong></p><pre><code>package concurrency.exchanger;import java.util.concurrent.Exchanger;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class ExchangerTest &#123;    private static final Exchanger&lt;String&gt; exgr = new Exchanger&lt;String&gt;();        private static ExecutorService threadPool = Executors.newFixedThreadPool(2);        public static void main(String[] args) &#123;        threadPool.execute(new Runnable()&#123;            @Override            public void run() &#123;                try&#123;                    String A = &quot;银行流水A&quot;;//A录入银行流水数据                    exgr.exchange(A);                &#125;catch(InterruptedException e)&#123;                    e.printStackTrace();                &#125;            &#125;                    &#125;);                threadPool.execute(new Runnable()&#123;            @Override            public void run() &#123;                try&#123;                    String B = &quot;银行流水B&quot;;//B录入银行流水数据                    String A = exgr.exchange(B);                    System.out.println(&quot;A和B数据是否一致：&quot;+A.equals(B)+&quot;,A录入的是：&quot;+A+&quot;,B录入的是：&quot;+B);                &#125;catch(InterruptedException e)&#123;                    e.printStackTrace();                &#125;            &#125;                    &#125;);    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Exchanger&quot;&gt;&lt;a href=&quot;#Exchanger&quot; class=&quot;headerlink&quot; title=&quot;Exchanger&quot;&gt;&lt;/a&gt;Exchanger&lt;/h1&gt;&lt;p&gt;Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程</summary>
      
    
    
    
    <category term="并发" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="Exchanger" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/Exchanger/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="Exchanger" scheme="http://example.com/tags/Exchanger/"/>
    
  </entry>
  
  <entry>
    <title>并发 | Semaphore</title>
    <link href="http://example.com/2022/06/07/Semaphore/"/>
    <id>http://example.com/2022/06/07/Semaphore/</id>
    <published>2022-06-07T14:02:35.000Z</published>
    <updated>2022-06-07T14:11:47.673Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><p>Semaphore（信号量）是用来控制同时访问特定资源的数量，它通过协调各个线程，以保证合理的使用公共资源。<br><strong>应用场景：</strong><br>Semaphore可以用于做<strong>流量控制</strong>，特别是公共资源优先的应用场景，比如<strong>数据库连接</strong>。<br><strong>示例代码：</strong></p><pre><code>package concurrency.semaphore;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;public class SemaphoreTest &#123;    private static final int THREAD_COUNT = 30;        private static ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);        private static Semaphore s = new Semaphore(10);        public static void main(String[] args) &#123;        for(int i = 0; i &lt; THREAD_COUNT; i++)&#123;//虽然有30个线程在执行，但是只允许10个并发执行            threadPool.execute(new Runnable()&#123;                @Override                public void run()&#123;                    try&#123;                        s.acquire();                        System.out.println(&quot;save data&quot;);                        s.release();                    &#125;catch(InterruptedException e)&#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;);        &#125;        threadPool.shutdown();    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Semaphore&quot;&gt;&lt;a href=&quot;#Semaphore&quot; class=&quot;headerlink&quot; title=&quot;Semaphore&quot;&gt;&lt;/a&gt;Semaphore&lt;/h1&gt;&lt;p&gt;Semaphore（信号量）是用来控制同时访问特定资源的数量，它通过协调各个线程，以</summary>
      
    
    
    
    <category term="并发" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="Semaphore" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/Semaphore/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="Semaphore" scheme="http://example.com/tags/Semaphore/"/>
    
  </entry>
  
  <entry>
    <title>并发 | Java中的12个原子操作类</title>
    <link href="http://example.com/2022/06/07/Java%E4%B8%AD%E7%9A%8413%E4%B8%AA%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/"/>
    <id>http://example.com/2022/06/07/Java%E4%B8%AD%E7%9A%8413%E4%B8%AA%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/</id>
    <published>2022-06-07T13:29:19.000Z</published>
    <updated>2022-06-07T13:54:03.288Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java中的13个原子操作类"><a href="#Java中的13个原子操作类" class="headerlink" title="Java中的13个原子操作类"></a>Java中的13个原子操作类</h1><p>在java.util.concurrent.atomic包中包含了12个原子类，属于四种类型的原子更新方式，分别是：<br>（1）原子更新基本类型<br>    AtomicInteger:原子更新整型；<br>    AtomicBoolean:原子更新布尔类型；<br>    AtomicLong:源自更新长整型。<br>（2）原子更新数组<br>    AtomicIntegerArray:原子更新整型数组里的元素；<br>    AtomicLongArray:原子更新长整型数组里的元素；<br>    AtomicReferenceArray:原子更新引用类型数组里的元素<br>（3）原子更新引用<br>    AtomicReference:原子更新引用类型；<br>    AtomicReferenceFieldUpdater:原子更新引用类型里的字段；<br>    AtomicMarkableReference:原子更新带有标记位的引用类型（可以原子更新一个布尔类型的标记位和引用类型）。<br>（4）原子更新属性（字段）<br>    AtomicIntegerFieldUpdater:原子更新整型的字段的更新器；<br>    AtomicLongFieldUpdater:原子更新长整型的字段的更新器；<br>    AtomicStampedReference:原子更新带有版本号的引用类型，能够解决使用CAS进行原子更新时可能出现的ABA问题。<br>以下给出每个类型的原子更新的一个示例代码：</p><span id="more"></span><p><strong>示例代码1-原子更新基本类型</strong></p><pre><code>package concurrency.atomic;import java.util.concurrent.atomic.AtomicInteger;public class AtomicIntegerTest1 &#123;    static AtomicInteger ai = new AtomicInteger(1);        public static void main(String[] args)&#123;        int addAndGet = ai.addAndGet(2);        System.out.println(addAndGet);            boolean compareAndSet = ai.compareAndSet(1, 2);        System.out.println(compareAndSet);        System.out.println(ai.get());                System.out.println(ai.getAndIncrement());        System.out.println(ai.get());                ai.lazySet(3);        System.out.println(ai.get());                int andSet = ai.getAndSet(2);        System.out.println(andSet);        System.out.println(ai.get());    &#125;&#125;</code></pre><p><strong>示例代码2-原子更新数组</strong></p><pre><code>package concurrency.atomic;import java.util.concurrent.atomic.AtomicIntegerArray;public class AtomicIntegerArrayTest &#123;    static int[] value = new int[]&#123;1,2&#125;;    static AtomicIntegerArray ai = new AtomicIntegerArray(value);        public static void main(String[] args)&#123;        System.out.println(ai.getAndSet(0, 3));        System.out.println(ai.get(0));        System.out.println(value[0]);        int addAndGet = ai.addAndGet(0, 3);        System.out.println(addAndGet);        System.out.println(ai.get(0));        System.out.println(ai.compareAndSet(0, 3, 33));        System.out.println(ai.compareAndSet(0, 6, 66));    &#125;&#125;</code></pre><p><strong>示例代码3-原子更新引用</strong></p><pre><code>package concurrency.atomic;import java.util.concurrent.atomic.AtomicReference;public class AtomicReferenceTest &#123;    public static AtomicReference&lt;User&gt; atomicUserRef = new AtomicReference&lt;User&gt;();        public static void main(String[] args)&#123;        User user = new User(&quot;conan&quot;, 15);        atomicUserRef.set(user);        User updateUser = new User(&quot;Shinichi&quot;, 17);        atomicUserRef.compareAndSet(user, updateUser);        System.out.println(atomicUserRef.get().getName());        System.out.println(atomicUserRef.get().getOld());    &#125;        static class User&#123;        private String name;        private int old;                public User(String name, int old)&#123;            this.name = name;            this.old = old;        &#125;        public String getName() &#123;            return name;        &#125;        public void setName(String name) &#123;            this.name = name;        &#125;        public int getOld() &#123;            return old;        &#125;        public void setOld(int old) &#123;            this.old = old;        &#125;    &#125;&#125;</code></pre><p><strong>示例代码4-原子更新属性</strong></p><pre><code>package concurrency.atomic;import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;public class AtomicIntegerFieldUpdaterTest &#123;    //创建原子更新器，并设置需要更新的对象和对象的属性    private static AtomicIntegerFieldUpdater&lt;User&gt; a = AtomicIntegerFieldUpdater.newUpdater(User.class, &quot;old&quot;);        public static void main(String[] args)&#123;        //设置柯南的年龄是10岁        User conan = new User(&quot;conan&quot;, 10);        //柯南长了一岁，但是仍然会输出旧的年龄        System.out.println(a.getAndIncrement(conan));        //输出柯南现在的年龄        System.out.println(a.get(conan));    &#125;        public static class User&#123;        private String name;        public volatile int old;                public User(String name, int old)&#123;            this.name = name;            this.old = old;        &#125;        public String getName() &#123;            return name;        &#125;        public int getOld() &#123;            return old;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Java中的13个原子操作类&quot;&gt;&lt;a href=&quot;#Java中的13个原子操作类&quot; class=&quot;headerlink&quot; title=&quot;Java中的13个原子操作类&quot;&gt;&lt;/a&gt;Java中的13个原子操作类&lt;/h1&gt;&lt;p&gt;在java.util.concurrent.atomic包中包含了12个原子类，属于四种类型的原子更新方式，分别是：&lt;br&gt;（1）原子更新基本类型&lt;br&gt;    AtomicInteger:原子更新整型；&lt;br&gt;    AtomicBoolean:原子更新布尔类型；&lt;br&gt;    AtomicLong:源自更新长整型。&lt;br&gt;（2）原子更新数组&lt;br&gt;    AtomicIntegerArray:原子更新整型数组里的元素；&lt;br&gt;    AtomicLongArray:原子更新长整型数组里的元素；&lt;br&gt;    AtomicReferenceArray:原子更新引用类型数组里的元素&lt;br&gt;（3）原子更新引用&lt;br&gt;    AtomicReference:原子更新引用类型；&lt;br&gt;    AtomicReferenceFieldUpdater:原子更新引用类型里的字段；&lt;br&gt;    AtomicMarkableReference:原子更新带有标记位的引用类型（可以原子更新一个布尔类型的标记位和引用类型）。&lt;br&gt;（4）原子更新属性（字段）&lt;br&gt;    AtomicIntegerFieldUpdater:原子更新整型的字段的更新器；&lt;br&gt;    AtomicLongFieldUpdater:原子更新长整型的字段的更新器；&lt;br&gt;    AtomicStampedReference:原子更新带有版本号的引用类型，能够解决使用CAS进行原子更新时可能出现的ABA问题。&lt;br&gt;以下给出每个类型的原子更新的一个示例代码：&lt;/p&gt;</summary>
    
    
    
    <category term="并发" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="Java中的12个原子操作类" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/Java%E4%B8%AD%E7%9A%8412%E4%B8%AA%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="原子类" scheme="http://example.com/tags/%E5%8E%9F%E5%AD%90%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>并发 | CyclicBarrier用于多线程计算数据并合并计算结果</title>
    <link href="http://example.com/2022/06/07/CyclicBarrier%E7%94%A8%E4%BA%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%A1%E7%AE%97%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%90%88%E5%B9%B6%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%9C/"/>
    <id>http://example.com/2022/06/07/CyclicBarrier%E7%94%A8%E4%BA%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%A1%E7%AE%97%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%90%88%E5%B9%B6%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%9C/</id>
    <published>2022-06-07T12:51:58.000Z</published>
    <updated>2022-06-07T13:23:56.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CyclicBarrier用于多线程计算数据并合并计算结果"><a href="#CyclicBarrier用于多线程计算数据并合并计算结果" class="headerlink" title="CyclicBarrier用于多线程计算数据并合并计算结果"></a>CyclicBarrier用于多线程计算数据并合并计算结果</h1><p><strong>CyclicBarrier</strong><br>CyclicBarrier让一组线程到达一个屏障（同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，<br>所有被屏障拦截的线程才会继续执行。<br><strong>注：CyclicBarrier的计数器可以使用reset()方法重置</strong></p><span id="more"></span><p><strong>使用方式1：</strong></p><pre><code>package concurrency.cyclicbarrier;import java.util.concurrent.CyclicBarrier;public class CyclicBarrierTest &#123;    static CyclicBarrier c = new CyclicBarrier(2);    public static void main(String[] args) &#123;        new Thread(new Runnable()&#123;            @Override            public void run()&#123;                try&#123;                    c.await();                &#125;catch(Exception e)&#123;                                    &#125;                System.out.println(1);            &#125;        &#125;).start();                try&#123;            c.await();        &#125;catch(Exception e)&#123;                    &#125;        System.out.println(2);    &#125;&#125;</code></pre><p><strong>使用方式2：</strong></p><pre><code>package concurrency.cyclicbarrier;import java.util.concurrent.CyclicBarrier;public class CyclicBarrierTest2 &#123;    static CyclicBarrier c = new CyclicBarrier(2, new A());        public static void main(String[] args) &#123;        new Thread(new Runnable()&#123;            @Override            public void run()&#123;                try&#123;                    c.await();                &#125;catch(Exception e)&#123;                                    &#125;                System.out.println(1);            &#125;        &#125;).start();                try&#123;            c.await();        &#125;catch(Exception e)&#123;                    &#125;        System.out.println(2);    &#125;        static class A implements Runnable&#123;        @Override        public void run() &#123;            System.out.println(3);        &#125;    &#125;&#125;</code></pre><p><strong>应用场景：</strong> 一个Excel保存了用户所有银行流水，每个Sheet保存一个账户近一年的每笔银行流水，现在<br>需要统计用户的日均银行流水，先用多线程处理每个sheet里的银行流水，都执行完之后，得到每个sheet<br>的日均银行流水，最后，再用barrierAction用这些线程的计算结果，计算出整个Excel的日均银行流水。<br><strong>代码：</strong></p><pre><code>package concurrency.cyclicbarrier;import java.util.Map.Entry;import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.CyclicBarrier;import java.util.concurrent.Executor;import java.util.concurrent.Executors;public class BankWaterService implements Runnable&#123;    //创建4个屏障，处理完之后执行当前类的run方法    private CyclicBarrier c = new CyclicBarrier(4, this);        //假设只有4个sheet，所以只启动4个线程    private Executor executor = Executors.newFixedThreadPool(4);        //保存每个sheet计算出的银流结果    private ConcurrentHashMap&lt;String, Integer&gt; sheetBankWaterCount = new ConcurrentHashMap&lt;String, Integer&gt;();        private void count()&#123;        for(int i = 0; i &lt; 4; i++)&#123;            executor.execute(new Runnable()&#123;                @Override                public void run() &#123;                    //计算当前sheet的银流数据，计算代码省略                    sheetBankWaterCount.put(Thread.currentThread().getName(), 1);                    //银流计算完成，插入一个屏障                    try&#123;                        c.await();                    &#125;catch(InterruptedException | BrokenBarrierException e)&#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;);        &#125;    &#125;        @Override    public void run() &#123;        int result = 0;                //汇总每个sheet计算出的结果        for(Entry&lt;String, Integer&gt; sheet : sheetBankWaterCount.entrySet())&#123;            result += sheet.getValue();        &#125;                //将结果输出        sheetBankWaterCount.put(&quot;result&quot;, result);        System.out.println(result);    &#125;        public static void main(String[] args)&#123;        BankWaterService bankWaterCount = new BankWaterService();        bankWaterCount.count();    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;CyclicBarrier用于多线程计算数据并合并计算结果&quot;&gt;&lt;a href=&quot;#CyclicBarrier用于多线程计算数据并合并计算结果&quot; class=&quot;headerlink&quot; title=&quot;CyclicBarrier用于多线程计算数据并合并计算结果&quot;&gt;&lt;/a&gt;CyclicBarrier用于多线程计算数据并合并计算结果&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;CyclicBarrier&lt;/strong&gt;&lt;br&gt;CyclicBarrier让一组线程到达一个屏障（同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，&lt;br&gt;所有被屏障拦截的线程才会继续执行。&lt;br&gt;&lt;strong&gt;注：CyclicBarrier的计数器可以使用reset()方法重置&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="并发" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="CyclicBarrier" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/CyclicBarrier/"/>
    
    <category term="CyclicBarrier用于多线程计算数据并合并计算结果" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/CyclicBarrier/CyclicBarrier%E7%94%A8%E4%BA%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%A1%E7%AE%97%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%90%88%E5%B9%B6%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%9C/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="CyclicBarrier" scheme="http://example.com/tags/CyclicBarrier/"/>
    
  </entry>
  
  <entry>
    <title>使用ForkJoin框架计算整数相加的结果</title>
    <link href="http://example.com/2022/06/06/%E4%BD%BF%E7%94%A8ForkJoin%E6%A1%86%E6%9E%B6%E8%AE%A1%E7%AE%97%E6%95%B4%E6%95%B0%E7%9B%B8%E5%8A%A0%E7%9A%84%E7%BB%93%E6%9E%9C/"/>
    <id>http://example.com/2022/06/06/%E4%BD%BF%E7%94%A8ForkJoin%E6%A1%86%E6%9E%B6%E8%AE%A1%E7%AE%97%E6%95%B4%E6%95%B0%E7%9B%B8%E5%8A%A0%E7%9A%84%E7%BB%93%E6%9E%9C/</id>
    <published>2022-06-06T13:29:43.000Z</published>
    <updated>2022-06-06T13:34:29.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用ForkJoin框架计算整数相加的结果"><a href="#使用ForkJoin框架计算整数相加的结果" class="headerlink" title="使用ForkJoin框架计算整数相加的结果"></a>使用ForkJoin框架计算整数相加的结果</h1><p><strong>需求：</strong> 使用Fork/Join框架计算1+2+3+4的结果。<br><strong>分析：</strong> 使用Fork/Join框架首先要考虑到的是如何分割任务，如果希望每个子任务最多执行两个数的相加<br>，那么我们设置分割的阈值是2，由于是四个数字相加，所以Fork/Join框架会把这个任务fork成两个子<br>任务，子任务1负责计算1+2，子任务2负责3+4，然后再join两个子任务的结果。因为是有结果的任务，所<br>以必须继承RecursiveTask。<br><strong>实现代码：</strong></p><pre><code>package concurrency.forkjoin;import java.util.concurrent.ExecutionException;import java.util.concurrent.ForkJoinPool;import java.util.concurrent.Future;import java.util.concurrent.RecursiveTask;public class CountTask extends RecursiveTask&lt;Integer&gt;&#123;    private static final int THRESHOLD = 2;//阈值    private int start;    private int end;        public CountTask(int start, int end)&#123;        this.start = start;        this.end = end;    &#125;    @Override    protected Integer compute() &#123;        int sum = 0;                //如果任务足够小就计算任务        boolean canCompute = (end - start) &lt;= THRESHOLD;        if(canCompute)&#123;            for(int i = start; i &lt;= end; i++)&#123;                sum += i;            &#125;        &#125;else&#123;            //如果任务大虚与之，就分裂成两个子任务计算            int middle = (start + end) / 2;            CountTask leftTask = new CountTask(start, middle);            CountTask rightTask = new CountTask(middle + 1, end);            //执行子任务            leftTask.fork();            rightTask.fork();            //等待子任务执行完，并得到其结果            int leftResult = leftTask.join();            int rightResult = rightTask.join();            //合并子任务            sum = leftResult + rightResult;        &#125;        return sum;    &#125;        public static void main(String[] args)&#123;        ForkJoinPool forkJoinPool = new ForkJoinPool();        //生成一个计算任务，负责计算1+2+3+4        CountTask task = new CountTask(1, 4);        //执行一个任务        Future&lt;Integer&gt; result = forkJoinPool.submit(task);        try&#123;            System.out.println(result.get());        &#125;catch(InterruptedException e)&#123;            e.printStackTrace();        &#125;catch(ExecutionException e)&#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用ForkJoin框架计算整数相加的结果&quot;&gt;&lt;a href=&quot;#使用ForkJoin框架计算整数相加的结果&quot; class=&quot;headerlink&quot; title=&quot;使用ForkJoin框架计算整数相加的结果&quot;&gt;&lt;/a&gt;使用ForkJoin框架计算整数相加的结果&lt;/</summary>
      
    
    
    
    <category term="并发" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="ForkJoin" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/ForkJoin/"/>
    
    <category term="使用ForkJoin框架计算整数相加的结果" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/ForkJoin/%E4%BD%BF%E7%94%A8ForkJoin%E6%A1%86%E6%9E%B6%E8%AE%A1%E7%AE%97%E6%95%B4%E6%95%B0%E7%9B%B8%E5%8A%A0%E7%9A%84%E7%BB%93%E6%9E%9C/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="ForkJoin" scheme="http://example.com/tags/ForkJoin/"/>
    
  </entry>
  
  <entry>
    <title>锁 | 读写锁+HashMap实现线程安全的HashMap</title>
    <link href="http://example.com/2022/06/06/%E8%AF%BB%E5%86%99%E9%94%81-HashMap%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84HashMap/"/>
    <id>http://example.com/2022/06/06/%E8%AF%BB%E5%86%99%E9%94%81-HashMap%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84HashMap/</id>
    <published>2022-06-06T08:12:53.000Z</published>
    <updated>2022-06-06T08:31:49.622Z</updated>
    
    <content type="html"><![CDATA[<h1 id="读写锁-HashMap实现线程安全的HashMap"><a href="#读写锁-HashMap实现线程安全的HashMap" class="headerlink" title="读写锁+HashMap实现线程安全的HashMap"></a>读写锁+HashMap实现线程安全的HashMap</h1><p>ReadWriteLockCache组合一个非线程安全的HashMap作为缓存的实现，同时使用读写锁的读锁和写锁来保证ReadWriteLockCaChe是线程安全的。<br><strong>代码：</strong></p><pre><code>package concurrency.AQS; import java.util.HashMap;import java.util.Map;import java.util.Map.Entry;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantReadWriteLock;public class ReadWriteLockCache &#123;    public static void main(String[] args) &#123;        ReadWriteLockCache.put(&quot;user1&quot;, &quot;123&quot;);        ReadWriteLockCache.put(&quot;user2&quot;, &quot;456&quot;);        ReadWriteLockCache.put(&quot;user3&quot;, &quot;789&quot;);        for(Entry entry : ReadWriteLockCache.map.entrySet())&#123;            System.out.println(entry.getKey()+&quot;:&quot;+entry.getValue());        &#125;        System.out.println(&quot;==========================&quot;);        ReadWriteLockCache.put(&quot;user1&quot;, &quot;1233&quot;);        for(Entry entry : ReadWriteLockCache.map.entrySet())&#123;            System.out.println(entry.getKey()+&quot;:&quot;+entry.getValue());        &#125;        System.out.println(&quot;==========================&quot;);        System.out.println(&quot;user1&quot; + ReadWriteLockCache.get(&quot;user1&quot;));        System.out.println(&quot;==========================&quot;);        ReadWriteLockCache.clear();        for(Entry entry : ReadWriteLockCache.map.entrySet())&#123;            System.out.println(entry.getKey()+&quot;:&quot;+entry.getValue());        &#125;            &#125;        static Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();    static ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();    static Lock r = rwl.readLock();    static Lock w = rwl.writeLock();        //获取一个key对应的value    public static final Object get(String key)&#123;        r.lock();        try&#123;            return map.get(key);        &#125;finally&#123;            r.unlock();        &#125;    &#125;        //设置key对应的value，并返回旧的value    public static final Object put(String key, Object value)&#123;        w.lock();        try&#123;            return map.put(key, value);        &#125;finally&#123;            w.unlock();        &#125;    &#125;        //清空所有内容    public static final void clear()&#123;        w.lock();        try&#123;            map.clear();        &#125;finally&#123;            w.unlock();        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;读写锁-HashMap实现线程安全的HashMap&quot;&gt;&lt;a href=&quot;#读写锁-HashMap实现线程安全的HashMap&quot; class=&quot;headerlink&quot; title=&quot;读写锁+HashMap实现线程安全的HashMap&quot;&gt;&lt;/a&gt;读写锁+HashMap</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="锁" scheme="http://example.com/categories/Java/%E5%B9%B6%E5%8F%91/%E9%94%81/"/>
    
    <category term="读写锁+HashMap实现线程安全的HashMap" scheme="http://example.com/categories/Java/%E5%B9%B6%E5%8F%91/%E9%94%81/%E8%AF%BB%E5%86%99%E9%94%81-HashMap%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84HashMap/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="锁" scheme="http://example.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>负载均衡</title>
    <link href="http://example.com/2022/05/31/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>http://example.com/2022/05/31/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</id>
    <published>2022-06-01T02:49:27.000Z</published>
    <updated>2022-06-01T02:51:23.240Z</updated>
    
    <content type="html"><![CDATA[<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p><a href="https://blog.csdn.net/wanghangzhen/article/details/118554304">负载均衡</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;负载均衡&quot;&gt;&lt;a href=&quot;#负载均衡&quot; class=&quot;headerlink&quot; title=&quot;负载均衡&quot;&gt;&lt;/a&gt;负载均衡&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/wanghangzhen/article/details/11</summary>
      
    
    
    
    
    <category term="负载均衡" scheme="http://example.com/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
  <entry>
    <title>并发 | 基于线程池技术的简单Web服务器</title>
    <link href="http://example.com/2022/05/30/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8A%80%E6%9C%AF%E7%9A%84%E7%AE%80%E5%8D%95Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://example.com/2022/05/30/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8A%80%E6%9C%AF%E7%9A%84%E7%AE%80%E5%8D%95Web%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2022-05-31T03:11:39.000Z</published>
    <updated>2022-05-31T03:16:52.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于线程池技术的简单Web服务器"><a href="#基于线程池技术的简单Web服务器" class="headerlink" title="基于线程池技术的简单Web服务器"></a>基于线程池技术的简单Web服务器</h1><p>基于线程池技术的简单Web服务器，这个Web服务器用来处理HTTP请求(目前智能处理简单的文本和JPG图片内容)。这个服务器使用<br>main线程不断地接受可换段Socket的连接，将连接以及请求提交给线程池处理，这样使得Web服务器能够同时处理多个客户端请求。</p><span id="more"></span><p><strong>Web服务器示例代码</strong></p><pre><code>package concurrency.threadPool;import java.io.BufferedReader;import java.io.ByteArrayOutputStream;import java.io.Closeable;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.ServerSocket;import java.net.Socket;public class SimpleHttpServer &#123;    //处理HttpRequest的线程池    static ThreadPool&lt;HttpRequestHandler&gt; threadPool = new DefaultThreadPool&lt;HttpRequestHandler&gt;(1);        //SimpleHttpServer的根路径    static String basePath;        static ServerSocket serverSocket;        //服务器监听端口    static int port = 8080;        public static void setPort(int port)&#123;        if(port &gt; 0)&#123;            SimpleHttpServer.port = port;        &#125;    &#125;        public static void setBasePath(String basePath)&#123;        if(basePath != null &amp;&amp; new File(basePath).exists() &amp;&amp; new File(basePath).isDirectory())&#123;            SimpleHttpServer.basePath = basePath;        &#125;    &#125;        //启动SimpleHttpServer    public static void start() throws IOException&#123;        serverSocket = new ServerSocket(port);        Socket socket = null;        while((socket = serverSocket.accept()) != null)&#123;            //接收一个可换段Socket，生成一个HttpRequestHandler，放入线程池执行            threadPool.execute(new HttpRequestHandler(socket));        &#125;        serverSocket.close();    &#125;        static class HttpRequestHandler implements Runnable&#123;        private Socket socket;        public HttpRequestHandler(Socket socket)&#123;            this.socket = socket;        &#125;                @Override        public void run() &#123;            String line = null;            BufferedReader br = null;            BufferedReader reader = null;            PrintWriter out = null;            InputStream in = null;            try&#123;                reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));                String header = reader.readLine();                //由相对路径计算出绝对路径                String filePath = basePath + header.split(&quot; &quot;)[1];                out = new PrintWriter(socket.getOutputStream());                //如果请求资源为jpg或者ico，则读取资源并输出                if(filePath.endsWith(&quot;jpg&quot;) || filePath.endsWith(&quot;ico&quot;))&#123;                    in = new FileInputStream(filePath);                    ByteArrayOutputStream baos = new ByteArrayOutputStream();                    int i = 0;                    while((i = in.read()) != -1)&#123;                        baos.write(i);                    &#125;                    byte[] array = baos.toByteArray();                    out.println(&quot;HTTP/1.1 200 OK&quot;);                    out.println(&quot;Server: Molly&quot;);                    out.println(&quot;Content-Type: image/jpeg&quot;);                    out.println(&quot;Content-Length: &quot;+array.length);                    out.println(&quot;&quot;);                    socket.getOutputStream().write(array, 0, array.length);                &#125;else&#123;                    br = new BufferedReader(new InputStreamReader(new FileInputStream(filePath)));                    out = new PrintWriter(socket.getOutputStream());                    out.println(&quot;HTTP/1.1 200 OK&quot;);                    out.println(&quot;Server: Molly&quot;);                    out.println(&quot;Content-Type: text/html; charset=UTF-8&quot;);                    out.println(&quot;&quot;);                    while((line = br.readLine()) != null)&#123;                        out.println(line);                    &#125;                &#125;                out.flush();            &#125;catch(Exception ex)&#123;                out.println(&quot;HTTP/1.1 500&quot;);                out.println(&quot;&quot;);                out.flush();            &#125;finally&#123;                close(br, in, reader, out, socket);            &#125;        &#125;            &#125;        //关闭流或者Socket    private static void close(Closeable... closeables)&#123;        if(closeables != null)&#123;            for(Closeable closeable : closeables)&#123;                try &#123;                    closeable.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><p><strong>ThreadPool.java</strong></p><pre><code>package concurrency.threadPool;public interface ThreadPool&lt;Job extends Runnable&gt; &#123;    //执行一个Job，这个Job需要实现Runnable    void execute(Job job);        //关闭线程池    void shutdown();        //增加工作者线程    void addWorkers(int num);        //减少工作者线程    void remvoeWorkers(int num);        //得到正在等待执行的任务数量    int getJobSize();&#125;</code></pre><p><strong>DefaultThreadPool.java</strong></p><pre><code>package concurrency.threadPool;import java.util.ArrayList;import java.util.Collections;import java.util.LinkedList;import java.util.List;import java.util.concurrent.atomic.AtomicLong;public class DefaultThreadPool&lt;Job extends Runnable&gt; implements ThreadPool&lt;Job&gt; &#123;    //线程池最大数量    private static final int MAX_WORKER_NUMBERS = 10;        //线程池默认数量    private static final int DEFAULT_WORKER_NUMBERS = 5;        //线程池最小的数量    private static final int MIN_WORKER_NUMBERS = 1;        //这是一个工作列表，将会向里面插入工作    private final LinkedList&lt;Job&gt; jobs = new LinkedList&lt;Job&gt;();//生产者        //工作者列表    private final List&lt;Worker&gt; workers = Collections.synchronizedList(new ArrayList&lt;Worker&gt;());//消费者        //工作者线程的数量    private int workerNum = DEFAULT_WORKER_NUMBERS;        //线程编号的生成    private AtomicLong threadNum = new AtomicLong();        //工作者，负责消费任务    class Worker implements Runnable&#123;        //是否工作        private volatile boolean running = true;        @Override        public void run()&#123;            while(running)&#123;                Job job = null;                synchronized(jobs)&#123;                    //如果工作者列表是空的，那么就wait                    while(jobs.isEmpty())&#123;                        try&#123;                            jobs.wait();                        &#125;catch(InterruptedException ex)&#123;                            //感知到外部对WorkerThread的中断操作，返回                            Thread.currentThread().interrupt();                            return;                        &#125;                    &#125;                    //取出一个Job                    job = jobs.removeFirst();                &#125;                if(job != null)&#123;                    try&#123;                        job.run();                    &#125;catch(Exception ex)&#123;                        //忽略Job执行中的Exception                    &#125;                &#125;            &#125;        &#125;                public void shutdown()&#123;            running = false;        &#125;    &#125;        //初始化线程工作者    private void initializeWorkers(int num)&#123;        for(int i = 0; i &lt; num; i++)&#123;            Worker worker = new Worker();            workers.add(worker);            Thread thread = new Thread(worker, &quot;ThreadPool-Worker-&quot; + threadNum.incrementAndGet());            thread.start();        &#125;    &#125;        public DefaultThreadPool()&#123;        initializeWorkers(DEFAULT_WORKER_NUMBERS);    &#125;        public DefaultThreadPool(int num)&#123;        workerNum = num &gt; MAX_WORKER_NUMBERS ? MAX_WORKER_NUMBERS : num &lt; MIN_WORKER_NUMBERS ? MIN_WORKER_NUMBERS : num;        initializeWorkers(workerNum);    &#125;        @Override    public void execute(Job job) &#123;        if(job != null)&#123;            //添加一个工作，然后进行通知            synchronized(jobs)&#123;                jobs.addLast(job);                jobs.notify();            &#125;        &#125;    &#125;    @Override    public void shutdown() &#123;        for(Worker worker : workers)&#123;            worker.shutdown();        &#125;    &#125;    @Override    public void addWorkers(int num) &#123;        synchronized(jobs)&#123;            //限制新增的Worker数量不能超过最大值            if(num + this.workerNum &gt; MAX_WORKER_NUMBERS)&#123;                num = MAX_WORKER_NUMBERS - this.workerNum;            &#125;            initializeWorkers(num);            this.workerNum += num;        &#125;    &#125;    @Override    public void remvoeWorkers(int num) &#123;        synchronized(jobs)&#123;            if(num &gt;= this.workerNum)&#123;                throw new IllegalArgumentException(&quot;beyond workNum&quot;);            &#125;            //按照给定的数量停止Worker            int count = 0;            while(count &lt; num)&#123;                Worker worker = workers.get(count);                if(workers.remove(worker))&#123;                    worker.shutdown();                    count++;                &#125;            &#125;            this.workerNum -= count;        &#125;    &#125;    @Override    public int getJobSize() &#123;        return jobs.size();    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;基于线程池技术的简单Web服务器&quot;&gt;&lt;a href=&quot;#基于线程池技术的简单Web服务器&quot; class=&quot;headerlink&quot; title=&quot;基于线程池技术的简单Web服务器&quot;&gt;&lt;/a&gt;基于线程池技术的简单Web服务器&lt;/h1&gt;&lt;p&gt;基于线程池技术的简单Web服务器，这个Web服务器用来处理HTTP请求(目前智能处理简单的文本和JPG图片内容)。这个服务器使用&lt;br&gt;main线程不断地接受可换段Socket的连接，将连接以及请求提交给线程池处理，这样使得Web服务器能够同时处理多个客户端请求。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="基于线程池技术的简单Web服务器" scheme="http://example.com/categories/Java/%E5%B9%B6%E5%8F%91/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8A%80%E6%9C%AF%E7%9A%84%E7%AE%80%E5%8D%95Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="基于线程池技术的简单Web服务器" scheme="http://example.com/tags/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8A%80%E6%9C%AF%E7%9A%84%E7%AE%80%E5%8D%95Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>并发 | CountDownLatch</title>
    <link href="http://example.com/2022/05/30/CountDownLatch/"/>
    <id>http://example.com/2022/05/30/CountDownLatch/</id>
    <published>2022-05-31T02:01:48.000Z</published>
    <updated>2022-06-07T13:17:45.566Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><p>CountDownLatch允许一个或多个线程等待其他线程完成操作。<br>例如：</p><pre><code>CountDownLatch c = new CountDownLatch(2)；</code></pre><p>CountDownLatch的构造函数接收一个int类型的参数作为计数器，如果你想等待N个点完成，这里就传入N.<br>当我们调用CountDownLatch的countDown方法时，N就会减1，CountDownLatch的await方法会阻塞当前<br>线程，直到N变为0。由于countDown方法可以用在任何地方，所以这里说的<strong>N个点，可以是N个线程，也可以<br>是1个线程里的N个步骤</strong>。<br><strong>注：CountDownLatch的计数器智能使用一次</strong></p><span id="more"></span><p><strong>示例代码1</strong></p><pre><code>package concurrency.countdownlatch;import java.util.concurrent.CountDownLatch;public class CountDownLatchTest1 &#123;    static CountDownLatch c = new CountDownLatch(2);        public static void main(String[] args) throws InterruptedException &#123;        new Thread(new Runnable()&#123;            @Override            public void run() &#123;                System.out.println(&quot;parser1 finished&quot;);                c.countDown();            &#125;        &#125;).start();                new Thread(new Runnable()&#123;            @Override            public void run() &#123;                System.out.println(&quot;parser2 finished&quot;);                c.countDown();            &#125;        &#125;).start();        c.await();        System.out.println(&quot;all parsers finished&quot;);    &#125;&#125;</code></pre><p><strong>示例代码2</strong></p><pre><code>package concurrency.countdownlatch;import java.util.concurrent.CountDownLatch;public class CountDownLatchTest2 &#123;    static CountDownLatch c = new CountDownLatch(2);    public static void main(String[] args) throws InterruptedException &#123;        new Thread(new Runnable()&#123;            @Override            public void run() &#123;                System.out.println(&quot;1&quot;);                c.countDown();                System.out.println(&quot;2&quot;);                c.countDown();            &#125;        &#125;).start();        c.await();        System.out.println(&quot;3&quot;);    &#125; &#125;</code></pre><p><a href="https://blog.csdn.net/hbtj_1216/article/details/109655995">CountDownLatch</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;CountDownLatch&quot;&gt;&lt;a href=&quot;#CountDownLatch&quot; class=&quot;headerlink&quot; title=&quot;CountDownLatch&quot;&gt;&lt;/a&gt;CountDownLatch&lt;/h1&gt;&lt;p&gt;CountDownLatch允许一个或多个线程等待其他线程完成操作。&lt;br&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CountDownLatch c = new CountDownLatch(2)；
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CountDownLatch的构造函数接收一个int类型的参数作为计数器，如果你想等待N个点完成，这里就传入N.&lt;br&gt;当我们调用CountDownLatch的countDown方法时，N就会减1，CountDownLatch的await方法会阻塞当前&lt;br&gt;线程，直到N变为0。由于countDown方法可以用在任何地方，所以这里说的&lt;strong&gt;N个点，可以是N个线程，也可以&lt;br&gt;是1个线程里的N个步骤&lt;/strong&gt;。&lt;br&gt;&lt;strong&gt;注：CountDownLatch的计数器智能使用一次&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="CountDownLatch" scheme="http://example.com/categories/Java/%E5%B9%B6%E5%8F%91/CountDownLatch/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="CountDownLatch" scheme="http://example.com/tags/CountDownLatch/"/>
    
  </entry>
  
  <entry>
    <title>并发 | 线程池</title>
    <link href="http://example.com/2022/05/29/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://example.com/2022/05/29/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2022-05-29T08:44:53.000Z</published>
    <updated>2022-05-30T06:51:22.751Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>1.线程池的作用<br>对于服务器端的程序，如果服务端每接收到一个任务，创建一个线程，然后进行执行；这样的做法在面对成千上万的任务递交进服务器时，<br>那么会创建数以万记的线程，这样会时操作系统频繁的进行上下文切换，无故增加系统的负载，而线程的创建和小王都是需要好耗费<br>系统资源的，也无疑浪费了系统资源。线程池技术（通过使用固定或较为固定数目的线程来完成任务的执行）能够很好地解决这个问题，<br>消除频繁创建和消亡线程的系统资源开销。<br>2.线程池的本质<br>使用了一个线程安全的工作队列连接工作者线程和客户端线程，客户端线程将任务放入工作队列后便返回，而工作者线程则不断地从工作<br>队列取出工作并执行。当工作队列为空时，所有的工作者线程均等待在工作队列上，当有客户端提交了一个任务之后会通知任意一个工作者<br>线程，随着大量任务被提交，更多的工作者线程会被唤醒。<br>3.线程池示例<br><strong>ThreadPool.java</strong></p><pre><code>package concurrency.threadPool;public interface ThreadPool&lt;Job extends Runnable&gt; &#123;    //执行一个Job，这个Job需要实现Runnable    void execute(Job job);        //关闭线程池    void shutdown();        //增加工作者线程    void addWorkers(int num);        //减少工作者线程    void remvoeWorkers(int num);        //得到正在等待执行的任务数量    int getJobSize();&#125;</code></pre><p><strong>DefaultThreadPool.java</strong></p><pre><code>package concurrency.threadPool;import java.util.ArrayList;import java.util.Collections;import java.util.LinkedList;import java.util.List;import java.util.concurrent.atomic.AtomicLong;public class DefaultThreadPool&lt;Job extends Runnable&gt; implements ThreadPool&lt;Job&gt; &#123;    //线程池最大数量    private static final int MAX_WORKER_NUMBERS = 10;        //线程池默认数量    private static final int DEFAULT_WORKER_NUMBERS = 5;        //线程池最小的数量    private static final int MIN_WORKER_NUMBERS = 1;        //这是一个工作列表，将会向里面插入工作    private final LinkedList&lt;Job&gt; jobs = new LinkedList&lt;Job&gt;();        //工作者列表    private final List&lt;Worker&gt; workers = Collections.synchronizedList(new ArrayList&lt;Worker&gt;());        //工作者线程的数量    private int workerNum = DEFAULT_WORKER_NUMBERS;        //线程编号的生成    private AtomicLong threadNum = new AtomicLong();        //工作者，负责消费任务    class Worker implements Runnable&#123;        //是否工作        private volatile boolean running = true;        @Override        public void run()&#123;            while(running)&#123;                Job job = null;                synchronized(jobs)&#123;                    //如果工作者列表是空的，那么就wait                    while(jobs.isEmpty())&#123;                        try&#123;                            jobs.wait();                        &#125;catch(InterruptedException ex)&#123;                            //感知到外部对WorkerThread的中断操作，返回                            Thread.currentThread().interrupt();                            return;                        &#125;                    &#125;                    //取出一个Job                    job = jobs.removeFirst();                &#125;                if(job != null)&#123;                    try&#123;                        job.run();                    &#125;catch(Exception ex)&#123;                        //忽略Job执行中的Exception                    &#125;                &#125;            &#125;        &#125;                public void shutdown()&#123;            running = false;        &#125;    &#125;        //初始化线程工作者    private void initializeWorkers(int num)&#123;        for(int i = 0; i &lt; num; i++)&#123;            Worker worker = new Worker();            workers.add(worker);            Thread thread = new Thread(worker, &quot;ThreadPool-Worker-&quot; + threadNum.incrementAndGet());            thread.start();        &#125;    &#125;        public DefaultThreadPool()&#123;        initializeWorkers(DEFAULT_WORKER_NUMBERS);    &#125;        public DefaultThreadPool(int num)&#123;        workerNum = num &gt; MAX_WORKER_NUMBERS ? MAX_WORKER_NUMBERS : num &lt; MIN_WORKER_NUMBERS ? MIN_WORKER_NUMBERS : num;        initializeWorkers(workerNum);    &#125;        @Override    public void execute(Job job) &#123;        if(job != null)&#123;            //添加一个工作，然后进行通知            synchronized(jobs)&#123;                jobs.addLast(job);                jobs.notify();            &#125;        &#125;    &#125;    @Override    public void shutdown() &#123;        for(Worker worker : workers)&#123;            worker.shutdown();        &#125;    &#125;    @Override    public void addWorkers(int num) &#123;        synchronized(jobs)&#123;            //限制新增的Worker数量不能超过最大值            if(num + this.workerNum &gt; MAX_WORKER_NUMBERS)&#123;                num = MAX_WORKER_NUMBERS - this.workerNum;            &#125;            initializeWorkers(num);            this.workerNum += num;        &#125;    &#125;    @Override    public void remvoeWorkers(int num) &#123;        synchronized(jobs)&#123;            if(num &gt;= this.workerNum)&#123;                throw new IllegalArgumentException(&quot;beyond workNum&quot;);            &#125;            //按照给定的数量停止Worker            int count = 0;            while(count &lt; num)&#123;                Worker worker = workers.get(count);                if(workers.remove(worker))&#123;                    worker.shutdown();                    count++;                &#125;            &#125;            this.workerNum -= count;        &#125;    &#125;    @Override    public int getJobSize() &#123;        return jobs.size();    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线程池&quot;&gt;&lt;a href=&quot;#线程池&quot; class=&quot;headerlink&quot; title=&quot;线程池&quot;&gt;&lt;/a&gt;线程池&lt;/h1&gt;&lt;p&gt;1.线程池的作用&lt;br&gt;对于服务器端的程序，如果服务端每接收到一个任务，创建一个线程，然后进行执行；这样的做法在面对成千上万的任务递</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="线程池" scheme="http://example.com/categories/Java/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="线程池" scheme="http://example.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>并发 | 等待/通知机制</title>
    <link href="http://example.com/2022/05/28/%E7%AD%89%E5%BE%85-%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2022/05/28/%E7%AD%89%E5%BE%85-%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/</id>
    <published>2022-05-29T07:37:56.000Z</published>
    <updated>2022-05-30T06:51:06.543Z</updated>
    
    <content type="html"><![CDATA[<h1 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h1><p>等待通知机制，是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或着notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。<br><strong>示例代码</strong></p><pre><code>package concurrency;import java.text.SimpleDateFormat;import java.util.Date;import java.util.concurrent.TimeUnit;public class WaitNotify &#123;    static boolean flag = true;    static Object lock = new Object();        public static void main(String[] args) throws InterruptedException &#123;        Thread waitThread = new Thread(new Wait(), &quot;WaitThread&quot;);        waitThread.start();        TimeUnit.SECONDS.sleep(1);        Thread notifyThread = new Thread(new Notify(), &quot;NotifyThread&quot;);        notifyThread.start();    &#125;        static class Wait implements Runnable&#123;        @Override        public void run()&#123;            //加锁，用于lock的Monitor            synchronized(lock)&#123;                //当条件不满足时，继续wait，同时释放了lock的锁                while(flag)&#123;                    try &#123;                        System.out.println(Thread.currentThread()+&quot; flag is true. wait@ &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));                        lock.wait();                    &#125; catch (InterruptedException e) &#123;                    &#125;                &#125;                //条件满足时，完成工作                System.out.println(Thread.currentThread() + &quot;flag is false. running@ &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            &#125;        &#125;    &#125;        static class Notify implements Runnable&#123;        @Override        public void run() &#123;            synchronized(lock)&#123;                //获取lock的锁，然后进行通知，通知时不会释放lock的锁                //直到当前线程释放了lock后，WaitThread才能从wait方法中返回                System.out.println(Thread.currentThread() + &quot; hold lock. notify @ &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));                lock.notifyAll();                flag = false;                SleepUtils.second(5);            &#125;                        //再次加锁            synchronized(lock)&#123;                System.out.println(Thread.currentThread()+ &quot;hold lock again. sleep@ &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));                SleepUtils.second(5);            &#125;                    &#125;    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;等待-通知机制&quot;&gt;&lt;a href=&quot;#等待-通知机制&quot; class=&quot;headerlink&quot; title=&quot;等待/通知机制&quot;&gt;&lt;/a&gt;等待/通知机制&lt;/h1&gt;&lt;p&gt;等待通知机制，是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="等待/通知机制" scheme="http://example.com/categories/Java/%E5%B9%B6%E5%8F%91/%E7%AD%89%E5%BE%85-%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="等待/通知机制" scheme="http://example.com/tags/%E7%AD%89%E5%BE%85-%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>并发 | 等待超时模式构造简单的数据库连接池</title>
    <link href="http://example.com/2022/05/28/%E7%AD%89%E5%BE%85%E8%B6%85%E6%97%B6%E6%A8%A1%E5%BC%8F%E6%9E%84%E9%80%A0%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    <id>http://example.com/2022/05/28/%E7%AD%89%E5%BE%85%E8%B6%85%E6%97%B6%E6%A8%A1%E5%BC%8F%E6%9E%84%E9%80%A0%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</id>
    <published>2022-05-29T07:33:57.000Z</published>
    <updated>2022-05-30T06:49:15.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="等待超时模式构造简单的数据库连接池"><a href="#等待超时模式构造简单的数据库连接池" class="headerlink" title="等待超时模式构造简单的数据库连接池"></a>等待超时模式构造简单的数据库连接池</h1><p><strong>ConnectionPool.java</strong></p><pre><code>package concurrency.connetionPool;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.sql.Connection;import java.util.LinkedList;import java.util.concurrent.TimeUnit;class ConnectionDriver&#123;    static class ConnectionHandler implements InvocationHandler&#123;        @Override        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;            if(method.getName().equals(&quot;commit&quot;))&#123;                TimeUnit.MILLISECONDS.sleep(100);            &#125;            return null;        &#125;    &#125;        //创建一个Connection的代理，在commit时休眠100毫秒    public static final Connection createConnection()&#123;        return (Connection) Proxy.newProxyInstance(ConnectionDriver.class.getClassLoader(), new Class&lt;?&gt;[] &#123; Connection.class &#125;, new ConnectionHandler());    &#125;&#125;public class ConnectionPool &#123;    private LinkedList&lt;Connection&gt; pool = new LinkedList&lt;Connection&gt;();        public ConnectionPool(int initialSize)&#123;        if(initialSize &gt; 0)&#123;            for(int i = 0; i &lt; initialSize; i++)&#123;                pool.addLast(ConnectionDriver.createConnection());            &#125;        &#125;    &#125;        public void releaseConnection(Connection connection)&#123;        if(connection != null)&#123;            synchronized(pool)&#123;                //连接释放后需要进行通知，这样其他消费者能够感知到连接池中已经归还了一个连接                pool.addLast(connection);                pool.notifyAll();            &#125;        &#125;    &#125;        //在mills内无法获取到连接，将会返回null    public Connection fetchConnection(long mills) throws InterruptedException&#123;        synchronized(pool)&#123;            //完全超时            if(mills &lt; 0)&#123;                while(pool.isEmpty())&#123;                    pool.wait();                &#125;                return pool.removeFirst();//Removes and returns the first element from this list.            &#125;else&#123;                long future = System.currentTimeMillis() + mills;                long remaining = mills;                while(pool.isEmpty() &amp;&amp; remaining &gt; 0)&#123;                    pool.wait(remaining);                    remaining = future - System.currentTimeMillis();                &#125;                Connection result = null;                if(!pool.isEmpty())&#123;                    result = pool.removeFirst();                &#125;                return result;            &#125;        &#125;    &#125;&#125;</code></pre><p><strong>ConnectionPoolTest.java</strong></p><pre><code>package concurrency.connetionPool;import java.sql.Connection;import java.util.concurrent.CountDownLatch;import java.util.concurrent.atomic.AtomicInteger;public class ConnectionPoolTest &#123;    static ConnectionPool pool = new ConnectionPool(10);        //保证所有ConnectionRunner能够同时开始    static CountDownLatch start = new CountDownLatch(1);        //main线程将会等待所有ConnectionRunner结束后才能继续执行    static CountDownLatch end;        public static void main(String[] args) throws InterruptedException&#123;        //线程数量，可以修改线程数量进行观察        int threadCount = 50;        end = new CountDownLatch(threadCount);        int count = 20;        AtomicInteger got = new AtomicInteger();        AtomicInteger notGot = new AtomicInteger();        for(int i = 0; i &lt; threadCount; i++)&#123;            Thread thread = new Thread(new ConnectionRunner(count, got, notGot), &quot;ConnectionRunnerThread&quot;);            thread.start();        &#125;        start.countDown();//使latch的值减1，如果减到了0，则会唤醒所有等待在这个latch上的线程。        end.await();//使当前线程进入同步队列进行等待，直到latch的值被减到0或者当前线程被中断，当前线程就会被唤醒。        System.out.println(&quot;total invoke: &quot; + (threadCount * count));        System.out.println(&quot;got connection: &quot; + got);        System.out.println(&quot;not got connection: &quot; + notGot);    &#125;    static class ConnectionRunner implements Runnable&#123;        int count;        AtomicInteger got;        AtomicInteger notGot;                public ConnectionRunner(int count, AtomicInteger got, AtomicInteger notGot)&#123;            this.count = count;            this.got = got;            this.notGot = notGot;        &#125;                public void run()&#123;            try&#123;                start.await();            &#125;catch(Exception ex)&#123;                            &#125;            while(count &gt; 0)&#123;                try&#123;                    //从线程池中获取连接，如果1000ms内无法获取到，将会返回null                    //分别统计连接获取的数量got和未获取到的数量notGot                    Connection connection = pool.fetchConnection(1000);                    if(connection != null)&#123;                        try&#123;                            connection.createStatement();                            connection.commit();                        &#125;finally&#123;                            pool.releaseConnection(connection);                            got.incrementAndGet();                        &#125;                    &#125;else&#123;                        notGot.incrementAndGet();                    &#125;                &#125;catch(Exception ex)&#123;                                    &#125;finally&#123;                    count--;                &#125;                            &#125;            end.countDown();        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;等待超时模式构造简单的数据库连接池&quot;&gt;&lt;a href=&quot;#等待超时模式构造简单的数据库连接池&quot; class=&quot;headerlink&quot; title=&quot;等待超时模式构造简单的数据库连接池&quot;&gt;&lt;/a&gt;等待超时模式构造简单的数据库连接池&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Co</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="等待超时模式构造简单的数据库连接池" scheme="http://example.com/categories/Java/%E5%B9%B6%E5%8F%91/%E7%AD%89%E5%BE%85%E8%B6%85%E6%97%B6%E6%A8%A1%E5%BC%8F%E6%9E%84%E9%80%A0%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
</feed>
