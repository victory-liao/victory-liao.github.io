<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Victory&#39;s Blog</title>
  
  <subtitle>非宁静无以致远</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-03-07T13:59:46.185Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>victory-liao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>pytest | fixtures执行顺序及清理顺序</title>
    <link href="http://example.com/2024/03/07/fixtures%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E5%8F%8A%E6%B8%85%E7%90%86%E9%A1%BA%E5%BA%8F/"/>
    <id>http://example.com/2024/03/07/fixtures%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E5%8F%8A%E6%B8%85%E7%90%86%E9%A1%BA%E5%BA%8F/</id>
    <published>2024-03-07T13:56:45.000Z</published>
    <updated>2024-03-07T13:59:46.185Z</updated>
    
    <content type="html"><![CDATA[<h3 id="pytest-fixtures执行顺序和清理顺序"><a href="#pytest-fixtures执行顺序和清理顺序" class="headerlink" title="pytest fixtures执行顺序和清理顺序"></a>pytest fixtures执行顺序和清理顺序</h3><ol><li>fixtures执行顺序</li></ol><p>pytest一个test请求多个fixture时，fixtures的执行顺序是什么？</p><span id="more"></span><p>以下面的demo为例，在这段代码中test_string_only请求了append_first，order，fisrt_entry三个fixtures，从代码中可以看出append_first fixture依赖于order和first_entry fixtures。</p><p>pytest会对多个fixtures进行<strong>依赖解析</strong>，<strong>如果一个fixture依赖于其他fixture(s)，那么被依赖的fixtures会先于依赖它们的fixture执行</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># contents of test_append.py</span></span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Arrange</span></span><br><span class="line"><span class="meta">@pytest.fixture</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first_entry</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;3 - first_entry fixture has been executed.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;a&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Arrange</span></span><br><span class="line"><span class="meta">@pytest.fixture</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">order</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;2 - order fixture has been executed.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Act</span></span><br><span class="line"><span class="meta">@pytest.fixture</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">append_first</span>(<span class="params">order, first_entry</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;1 - append_first fixture has been executed.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> order.append(first_entry)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_string_only</span>(<span class="params">append_first, order, first_entry</span>):</span></span><br><span class="line">    <span class="comment"># Assert</span></span><br><span class="line">    <span class="keyword">assert</span> order == [first_entry]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行以上代码的结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">============================= test session starts =============================</span><br><span class="line">collecting ... collected 1 item</span><br><span class="line"></span><br><span class="line">test_append.py::test_string_only </span><br><span class="line">2 - order fixture has been executed.</span><br><span class="line">3 - first_entry fixture has been executed.</span><br><span class="line">1 - append_first fixture has been executed.</span><br><span class="line">PASSED                                  [100%]</span><br><span class="line"></span><br><span class="line">============================== 1 passed in 0.04s ==============================</span><br></pre></td></tr></table></figure><p>从运行结果可以看出，order fixture和first_entry fixture先于append_firt fixture执行。</p><p><strong>fixtures之间不存在依赖关系的，按照它们被声明的顺序执行</strong>，以下面的demo为例，假设有两个 fixtures，fixture A 和 fixture B，其中 fixture A 依赖于 fixture B。下面是一个示例来说明它们按照声明顺序执行的情况：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fixture_b</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Executing fixture B&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Cleaning up fixture B&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fixture_a</span>(<span class="params">fixture_b</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Executing fixture A&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Cleaning up fixture A&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_example</span>(<span class="params">fixture_a, fixture_b</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Executing test example&quot;</span>)</span><br><span class="line">    <span class="keyword">assert</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>fixture_b</code> 和 <code>fixture_a</code> 都使用了 <code>@pytest.fixture</code> 装饰器进行声明。在测试函数 <code>test_example</code> 的参数列表中，<code>fixture_b</code> 在 <code>fixture_a</code> 之前声明。</p><p>当运行这个测试时，pytest 会首先执行 <code>fixture_b</code>，然后执行 <code>fixture_a</code>。这是因为 <code>fixture_a</code> 依赖于 <code>fixture_b</code>，所以需要先执行它。最后，测试函数 <code>test_example</code> 会被执行。</p><p>输出结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Executing fixture B</span><br><span class="line">Executing fixture A</span><br><span class="line">Executing test example</span><br><span class="line">Cleaning up fixture A</span><br><span class="line">Cleaning up fixture B</span><br></pre></td></tr></table></figure><p>可以看到，fixtures 是按照它们被声明的顺序执行的，首先是 <code>fixture_b</code>，然后是 <code>fixture_a</code>。 </p><ol><li>fixtures清理顺序</li></ol><p>每个fixture在它自己的代码块执行完毕后立即进行清理。有依赖关系的fixtures的清理工作先从清理被依赖fixture开始，例如fixture A依赖于fixture B，那么执行顺序将会是：首先执行fixture B，然后执行fixture A，最后清理工作会先从fixture A开始，然后是fixture B。这种设计确保了每个fixture能及时清理自己使用的资源，避免了潜在的资源冲突或泄露问题。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;pytest-fixtures执行顺序和清理顺序&quot;&gt;&lt;a href=&quot;#pytest-fixtures执行顺序和清理顺序&quot; class=&quot;headerlink&quot; title=&quot;pytest fixtures执行顺序和清理顺序&quot;&gt;&lt;/a&gt;pytest fixtures执行顺序和清理顺序&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;fixtures执行顺序&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;pytest一个test请求多个fixture时，fixtures的执行顺序是什么？&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="python测试框架" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="pytest" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/pytest/"/>
    
    <category term="fixtures执行顺序及清理顺序" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/pytest/fixtures%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E5%8F%8A%E6%B8%85%E7%90%86%E9%A1%BA%E5%BA%8F/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="pytest" scheme="http://example.com/tags/pytest/"/>
    
    <category term="fixtures" scheme="http://example.com/tags/fixtures/"/>
    
  </entry>
  
  <entry>
    <title>pytest | 自定义失败断言解释</title>
    <link href="http://example.com/2024/03/07/%E6%96%AD%E8%A8%80%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E9%87%8D%E5%86%99/"/>
    <id>http://example.com/2024/03/07/%E6%96%AD%E8%A8%80%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E9%87%8D%E5%86%99/</id>
    <published>2024-03-07T13:52:36.000Z</published>
    <updated>2024-03-07T13:55:32.432Z</updated>
    
    <content type="html"><![CDATA[<h3 id="自定义失败断言解释"><a href="#自定义失败断言解释" class="headerlink" title="自定义失败断言解释"></a>自定义失败断言解释</h3><p>使用pytest测试代码块（Code Block）或函数（Functions）时，通常使用assert语句对代码块或函数的执行结果与预期结果进行比较，从而判断代码块或函数的正确性。如果在测试过程中某测试用例中的断言失败，即代码块或函数的实际执行结果与预期结果不一致，pytest将会报告错误信息。</p><span id="more"></span><p>在pytest中我们可以通过实现pytest_assertrepr_coompare钩子函数（Hook Function）来自定义失败断言的错误信息。</p><p>pytest_assertrepr_coompare钩子函数的语法如下：</p><p><strong>pytest_assertrepr_compare</strong>(<em>config</em>, <em>op</em>, <em>left</em>, <em>right</em>)[<a href="https://docs.pytest.org/en/8.0.x/_modules/_pytest/hookspec.html#pytest_assertrepr_compare">source]</a></p><p>​    Return explanation for comparisons in failing assert expressions.（返回失败断言表达式的解释信息）</p><p>​    Parameters:</p><p>​        <strong>config</strong> (<a href="https://docs.pytest.org/en/8.0.x/reference/reference.html#pytest.Config"><em>Config</em></a>) – The pytest config object.（pytest配置对象）</p><p>​        <strong>op</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#str"><em>str</em></a>) – The operator, e.g. <code>&quot;==&quot;</code>, <code>&quot;!=&quot;</code>, <code>&quot;not in&quot;</code>.（操作符）</p><p>​        <strong>left</strong> (<a href="https://docs.python.org/3/library/functions.html#object"><em>object</em></a>) – The left operand.（操作数1）</p><p>​        <strong>right</strong> (<a href="https://docs.python.org/3/library/functions.html#object"><em>object</em></a>) – The right operand.（操作数2）</p><p>通过钩子函数自定义错误断言信息的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># content of conftest.py</span></span><br><span class="line"><span class="keyword">from</span> test_foocompare <span class="keyword">import</span> Foo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 钩子函数，自定义断言信息</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pytest_assertrepr_compare</span>(<span class="params">op, left, right</span>):</span></span><br><span class="line">    <span class="comment"># 若Foo对象作相等断言（==）时失败，则输入自定义信息</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(left, Foo) <span class="keyword">and</span> <span class="built_in">isinstance</span>(right, Foo) <span class="keyword">and</span> op == <span class="string">&quot;==&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            <span class="string">&quot;Comparing Foo instances:&quot;</span>,</span><br><span class="line">            <span class="string">f&quot;   vals: <span class="subst">&#123;left.val&#125;</span> != <span class="subst">&#123;right.val&#125;</span>&quot;</span>,</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># content of test_foocompare.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.val == other.val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_compare</span>():</span></span><br><span class="line">    f1 = Foo(<span class="number">1</span>)</span><br><span class="line">    f2 = Foo(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">assert</span> f1 == f2</span><br></pre></td></tr></table></figure><p>运行test_foocompare.py模块，控制台会输出一下信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E       assert Comparing Foo instances:</span><br><span class="line">E            vals: 1 != 2</span><br></pre></td></tr></table></figure><p>自定义失败断言信息时通过重写断言表达式实现的，我们可以通过在代码中关闭”断言重写“功能：</p><ul><li><p>关闭特定模块的断言重写：在docstring中增加PYTEST_DONT_REWRITE字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    PYTEST_DONT_REWRITE</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">......</span><br><span class="line">python test code</span><br><span class="line">......</span><br></pre></td></tr></table></figure></li><li><p>关闭所有模块的断言重写：使用–assert=plain</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest --assert=plain</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;自定义失败断言解释&quot;&gt;&lt;a href=&quot;#自定义失败断言解释&quot; class=&quot;headerlink&quot; title=&quot;自定义失败断言解释&quot;&gt;&lt;/a&gt;自定义失败断言解释&lt;/h3&gt;&lt;p&gt;使用pytest测试代码块（Code Block）或函数（Functions）时，通常使用assert语句对代码块或函数的执行结果与预期结果进行比较，从而判断代码块或函数的正确性。如果在测试过程中某测试用例中的断言失败，即代码块或函数的实际执行结果与预期结果不一致，pytest将会报告错误信息。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="python测试框架" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="pytest" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/pytest/"/>
    
    <category term="自定义失败断言解释" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/pytest/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%B1%E8%B4%A5%E6%96%AD%E8%A8%80%E8%A7%A3%E9%87%8A/"/>
    
    
    <category term="pytest" scheme="http://example.com/tags/pytest/"/>
    
    <category term="断言" scheme="http://example.com/tags/%E6%96%AD%E8%A8%80/"/>
    
    <category term="钩子函数" scheme="http://example.com/tags/%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>python | 钩子函数、python中定义钩子函数</title>
    <link href="http://example.com/2024/03/06/%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E3%80%81python%E4%B8%AD%E5%AE%9A%E4%B9%89%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2024/03/06/%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E3%80%81python%E4%B8%AD%E5%AE%9A%E4%B9%89%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/</id>
    <published>2024-03-07T03:45:38.000Z</published>
    <updated>2024-03-07T03:50:24.308Z</updated>
    
    <content type="html"><![CDATA[<h3 id="钩子函数、python中定义钩子函数"><a href="#钩子函数、python中定义钩子函数" class="headerlink" title="钩子函数、python中定义钩子函数"></a>钩子函数、python中定义钩子函数</h3><p>钩子函数的概念来源于其工作原理，即<strong>在系统或框架的特定阶段“钩住”某一刻以执行自定义代码</strong>。</p><p>钩子函数是一种在特定事件发生时由系统自动调用的自定义函数。这个术语“钩子”（hook）形象地描述了这种机制：它允许开发者“钩住”程序执行过程中的某些点，以便在这些点上插入自己的代码。这些函数通常用于响应系统事件、修改程序行为或执行特定任务。以下是钩子函数由来的几个方面：</p><ul><li><strong>系统级钩子函数</strong>：在操作系统层面，钩子函数可以监视和处理系统消息，如键盘按键、鼠标动作或窗口消息等。这些函数在消息传递到目标之前截获它们，允许开发者执行自定义操作。</li><li><strong>编程框架中的钩子函数</strong>：在应用程序框架中，钩子函数用于扩展框架的功能而无需修改框架本身的代码。</li><li><strong>函数式编程中的钩子函数</strong>：在函数式编程中，钩子函数可以用来实现纯函数，确保函数的输出仅依赖于输入并且不产生副作用。</li></ul><p>总的来说，钩子函数提供了一种灵活的方式来处理程序流程中的特定事件，使得开发者能够在不改变原有程序结构的情况下，添加或修改功能。 </p><p>在Python中，可以使用<strong>装饰器</strong>来实现钩子函数。以下是一个简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hook_decorator</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;在函数执行前执行的钩子函数&quot;</span>)</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;在函数执行后执行的钩子函数&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@hook_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">example_function</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;这是一个示例函数&quot;</span>)</span><br><span class="line"></span><br><span class="line">example_function()</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输出结果：</span></span><br><span class="line"><span class="string">在函数执行前执行的钩子函数</span></span><br><span class="line"><span class="string">这是一个示例函数</span></span><br><span class="line"><span class="string">在函数执行后执行的钩子函数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;钩子函数、python中定义钩子函数&quot;&gt;&lt;a href=&quot;#钩子函数、python中定义钩子函数&quot; class=&quot;headerlink&quot; title=&quot;钩子函数、python中定义钩子函数&quot;&gt;&lt;/a&gt;钩子函数、python中定义钩子函数&lt;/h3&gt;&lt;p&gt;钩子函数的概</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="基础" scheme="http://example.com/categories/python/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="钩子函数" scheme="http://example.com/categories/python/%E5%9F%BA%E7%A1%80/%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="钩子函数" scheme="http://example.com/tags/%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/"/>
    
    <category term="装饰器" scheme="http://example.com/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    
    <category term="hook" scheme="http://example.com/tags/hook/"/>
    
  </entry>
  
  <entry>
    <title>纯函数</title>
    <link href="http://example.com/2024/03/06/%E7%BA%AF%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2024/03/06/%E7%BA%AF%E5%87%BD%E6%95%B0/</id>
    <published>2024-03-07T03:45:08.000Z</published>
    <updated>2024-03-07T03:49:11.775Z</updated>
    
    <content type="html"><![CDATA[<h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><p><strong>纯函数（Pure Function）是一种在函数式编程中非常重要的概念，它指的是那些给定相同的输入，总是返回相同输出，并且在执行过程中不会产生副作用的函数</strong>。</p><p>纯函数的核心特征包括：</p><ul><li><strong>相同的输入产生相同的输出</strong>：这意味着如果两次调用函数时的参数完全相同，那么这两次调用的结果也应该是相同的。</li><li><strong>无副作用</strong>：纯函数在执行过程中不会改变任何状态，也不会与系统外部有任何可观察的交互，例如修改全局变量、进行I/O操作等。</li><li><strong>结果只依赖于输入参数</strong>：函数的返回值只能由它的参数决定，不依赖于任何外部状态或额外的输入。</li></ul><p>纯函数的优势在于它们具有可预测性，易于测试和重用。由于它们的输出完全由输入决定，因此可以在不产生副作用的情况下自由地替换和使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;纯函数&quot;&gt;&lt;a href=&quot;#纯函数&quot; class=&quot;headerlink&quot; title=&quot;纯函数&quot;&gt;&lt;/a&gt;纯函数&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;纯函数（Pure Function）是一种在函数式编程中非常重要的概念，它指的是那些给定相同的输入，总是返回相同输出</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="基础" scheme="http://example.com/categories/python/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="纯函数" scheme="http://example.com/categories/python/%E5%9F%BA%E7%A1%80/%E7%BA%AF%E5%87%BD%E6%95%B0/"/>
    
    
    <category term="纯函数" scheme="http://example.com/tags/%E7%BA%AF%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>pytest | 异常断言</title>
    <link href="http://example.com/2024/03/06/pytest%E5%BC%82%E5%B8%B8%E6%96%AD%E8%A8%80/"/>
    <id>http://example.com/2024/03/06/pytest%E5%BC%82%E5%B8%B8%E6%96%AD%E8%A8%80/</id>
    <published>2024-03-07T03:44:37.000Z</published>
    <updated>2024-03-07T03:48:08.198Z</updated>
    
    <content type="html"><![CDATA[<h3 id="pytest异常断言"><a href="#pytest异常断言" class="headerlink" title="pytest异常断言"></a>pytest异常断言</h3><p><strong>异常断言</strong>即测试待测代码段是否会抛出特定的异常。异常断言最常用的两种方式如下：</p><ol><li>pytest.raises()</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_zero_division</span>():</span></span><br><span class="line">    <span class="comment"># pytest.raises(ZeroDivisionError)作为一个上下文管理器（context manageer）断言with后的代码块是否会抛出“ZeroDivisionError”除零异常</span></span><br><span class="line">    <span class="keyword">with</span> pytest.raises(ZeroDivisionError) <span class="keyword">as</span> excpinfo:</span><br><span class="line">        <span class="number">1</span> / <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 异常信息excpinfo中匹配除零异常信息“division by zero”</span></span><br><span class="line">    <span class="keyword">assert</span> excpinfo.match(<span class="string">&quot;division by zero&quot;</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li>@pytest.mark.xfail</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>():</span></span><br><span class="line">    <span class="keyword">raise</span> IndexError()</span><br><span class="line"></span><br><span class="line"><span class="comment"># @pytest.mark.xfail(raises=IndexError)是一个python装饰器，用于标记（mark）一个测试用例为预期失败，该例子中若f()函数抛出IndexError异常，则标记该测试为预期失败，测试报告（report）中会报告一个1 xfail，若f()函数未抛出IndexError异常，则测试报告中会报告一个1 xpass</span></span><br><span class="line"><span class="meta">@pytest.mark.xfail(<span class="params">raises=IndexError</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_f</span>():</span></span><br><span class="line">    f()</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>将<code>pytest.mark.xfail</code>与<code>raises</code>参数一起使用可能更适合于记录未修复的bug，使用<code>pytest.reises()</code>可能更适合于测试自己的代码故意引发的异常的情况。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;pytest异常断言&quot;&gt;&lt;a href=&quot;#pytest异常断言&quot; class=&quot;headerlink&quot; title=&quot;pytest异常断言&quot;&gt;&lt;/a&gt;pytest异常断言&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;异常断言&lt;/strong&gt;即测试待测代码段是否会抛出特定的异</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="python测试框架" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="pytest" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/pytest/"/>
    
    <category term="异常断言" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/pytest/%E5%BC%82%E5%B8%B8%E6%96%AD%E8%A8%80/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="pytest" scheme="http://example.com/tags/pytest/"/>
    
    <category term="python测试框架" scheme="http://example.com/tags/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="异常断言" scheme="http://example.com/tags/%E5%BC%82%E5%B8%B8%E6%96%AD%E8%A8%80/"/>
    
    <category term="pytest.mark.xfail" scheme="http://example.com/tags/pytest-mark-xfail/"/>
    
    <category term="pytest.raises" scheme="http://example.com/tags/pytest-raises/"/>
    
  </entry>
  
  <entry>
    <title>并行计算 | GPU加速原理</title>
    <link href="http://example.com/2024/03/01/GPU%E5%8A%A0%E9%80%9F%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2024/03/01/GPU%E5%8A%A0%E9%80%9F%E5%8E%9F%E7%90%86/</id>
    <published>2024-03-01T13:32:48.000Z</published>
    <updated>2024-03-01T13:35:08.092Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GPU加速原理"><a href="#GPU加速原理" class="headerlink" title="GPU加速原理"></a>GPU加速原理</h3><p>GPU加速的原理是利用多核处理器进行并行运算来实现程序的加速运行**。与CPU不同，GPU拥有数以千计的核心，专门为同时处理多任务而设计，可以高效地处理并行任务。</p><p>CPU几倍很强的通用性，可以处理不同类型的数据，同时擅长处理逻辑判断导致的大量分支跳转和中断处理，CPU相当于一个博学多闻的博士在完成一项工作。而GPU处理的数据类型高度统一，且GPU有数以千计的核心，可以并行计算任务，相当于1000个小学生在完成一个任务，呈现“人多力量大”的优势。</p><p>实际使用中，GPU需要CPU的配合来完成任务的计算，并行计算部分会运行在GPU上，串行计算部分运行在CPU上，CPU负责总体的程序流程。</p><p><a href="https://blog.csdn.net/qq_41632117/article/details/118737557">参考资料：GPU加速原理，博主写的非常详细！</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;GPU加速原理&quot;&gt;&lt;a href=&quot;#GPU加速原理&quot; class=&quot;headerlink&quot; title=&quot;GPU加速原理&quot;&gt;&lt;/a&gt;GPU加速原理&lt;/h3&gt;&lt;p&gt;GPU加速的原理是利用多核处理器进行并行运算来实现程序的加速运行**。与CPU不同，GPU拥有数以千</summary>
      
    
    
    
    <category term="并行计算" scheme="http://example.com/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
    <category term="GPU" scheme="http://example.com/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/GPU/"/>
    
    <category term="GPU加速原理" scheme="http://example.com/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/GPU/GPU%E5%8A%A0%E9%80%9F%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="GPU" scheme="http://example.com/tags/GPU/"/>
    
    <category term="CPU" scheme="http://example.com/tags/CPU/"/>
    
    <category term="并行计算" scheme="http://example.com/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
    <category term="串行计算" scheme="http://example.com/tags/%E4%B8%B2%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
    <category term="GPU加速原理" scheme="http://example.com/tags/GPU%E5%8A%A0%E9%80%9F%E5%8E%9F%E7%90%86/"/>
    
    <category term="多核处理器" scheme="http://example.com/tags/%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>pytest | 如何调用pytest</title>
    <link href="http://example.com/2024/02/29/%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8pytest/"/>
    <id>http://example.com/2024/02/29/%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8pytest/</id>
    <published>2024-02-29T11:38:53.000Z</published>
    <updated>2024-02-29T11:42:48.245Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何调用pytest"><a href="#如何调用pytest" class="headerlink" title="如何调用pytest"></a>如何调用pytest</h3><p>pytest支持命令行参数选择特定的tests去执行，以下是常见的一些选择方法。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> run tests <span class="keyword">in</span> a module</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行测试文件中的所有符合pytest测试发现规则的测试用例(测试文件中符合test_*()的函数、TestXxx类中的测试用例)</span></span><br><span class="line">pytest test_mod.py</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> run tests <span class="keyword">in</span> a directory</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行testing目录下的所有文件名符合test_*.py或*_test.py的测试文件中的测试用例</span></span><br><span class="line">pytest testing/</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># run tests by keyword expressions</span></span><br><span class="line">pytest -k <span class="string">&quot;MyClass and not method&quot;</span></span><br><span class="line"><span class="comment"># 通过关键词表达式指定pytest运行的测试用例，pytest会在testpaths或者当前目录下找到类名为TestMyClass的类中的方法名不带method的方法去执行。如下示例，运行pytest -k &quot;MyClass and not method&quot;会执行test_a方法而不会运行test_method_add()方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编写测试文件test_keyword_exp.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestMyClass</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_a</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="string">&quot;a&quot;</span> == <span class="string">&quot;a&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_method_add</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> add(<span class="number">1</span>, <span class="number">2</span>) == <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> run tests by collection arguments</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> To run a specific <span class="built_in">test</span> within a module</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行test_mod.py测试文件中的test_func测试用例</span></span><br><span class="line">pytest tests/test_mod.py::test_func</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> To run all tests <span class="keyword">in</span> a class:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行test_mod.py测试文件中的TestClass类中的测试用例</span></span><br><span class="line">pytest tests/test_mod.py::TestClass</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Specifying a specific <span class="built_in">test</span> method:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行test_mod.py测试文件中的TestClass类中的test_method测试用例</span></span><br><span class="line">pytest tests/test_mod.py::TestClass::test_method</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Specifying a specific parametrization of a <span class="built_in">test</span>:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行test_mod.py测试文件中的带参数的test_func测试用例</span></span><br><span class="line">pytest tests/test_mod.py::test_func[x1,y2]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Run tests by marker expressions</span></span><br><span class="line"><span class="comment"># 运行带有@pytest.mark.slow装饰器的测试</span></span><br><span class="line">pytest -m slow</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下示例中，pytest将运行test_a测试用例，而不会运行test_b测试用例</span></span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestMarkDecoration</span>:</span></span><br><span class="line"><span class="meta">    @pytest.mark.slow</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_a</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="number">1</span> == <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @pytest.mark.quick</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_b</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="number">2</span> == <span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> run tests from packages</span></span><br><span class="line">pytest --pyargs pkg.testing</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这将导入pkg.testing，并使用其文件系统位置从中查找和运行测试</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;如何调用pytest&quot;&gt;&lt;a href=&quot;#如何调用pytest&quot; class=&quot;headerlink&quot; title=&quot;如何调用pytest&quot;&gt;&lt;/a&gt;如何调用pytest&lt;/h3&gt;&lt;p&gt;pytest支持命令行参数选择特定的tests去执行，以下是常见的一些选择方</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="python测试框架" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="pytest" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/pytest/"/>
    
    <category term="如何调用pytest" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/pytest/%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8pytest/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="pytest" scheme="http://example.com/tags/pytest/"/>
    
    <category term="测试框架" scheme="http://example.com/tags/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>pytest | pytest使用规则及示例</title>
    <link href="http://example.com/2024/02/29/pytest%E6%B5%8B%E8%AF%95%E7%A4%BA%E4%BE%8B/"/>
    <id>http://example.com/2024/02/29/pytest%E6%B5%8B%E8%AF%95%E7%A4%BA%E4%BE%8B/</id>
    <published>2024-02-29T11:10:36.000Z</published>
    <updated>2024-02-29T11:36:05.332Z</updated>
    
    <content type="html"><![CDATA[<h3 id="pytest使用规则及示例"><a href="#pytest使用规则及示例" class="headerlink" title="pytest使用规则及示例"></a>pytest使用规则及示例</h3><p>Pytest是一个功能强大且易于使用的<code>python测试框架</code>，支持编写<code>单元测试</code>、<code>集成测试</code>和<code>功能测试</code>。</p><p>Pytest使用规则：</p><ol><li>测试文件命名应符合<code>test_*.py</code>或<code>*_test.py</code></li><li>若使用class对测试用例进行分组，测试类名应符合<code>TestXxx</code></li><li>测试用例函数/方法名称应符合<code>test_*()</code></li></ol><p>另外，值得注意的是，pytest支持在测试类中定义<code>setup</code>和<code>teardown</code>方法，这写方法会<strong>在每个测试方法运行前后分别调用</strong>，用于设置测试环境和清理资源。<code>setup_class</code>和<code>teardown_class</code>方法在测试类中的<strong>所有测试方法之前和之后分别只运行一次</strong>。</p><p>下面编写一个计算器类Calculator，并使用pytest进行测试。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test_calculator.py 测试文件名称符合test_*.py</span></span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义计算器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sub</span>(<span class="params">a, b</span>):</span></span><br><span class="line">        <span class="keyword">return</span> a - b</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mul</span>(<span class="params">a, b</span>):</span></span><br><span class="line">        <span class="keyword">return</span> a * b</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">div</span>(<span class="params">a, b</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> a / b</span><br><span class="line">        <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;zero Division Error Exception&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义测试类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCalc</span>:</span>  <span class="comment"># 测试类名符合TestXxx</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_calc_add</span>(<span class="params">self</span>):</span>  <span class="comment"># 测试用例方法名符合test_*()</span></span><br><span class="line">        <span class="keyword">assert</span> Calculator.add(<span class="number">1</span>, <span class="number">2</span>) == <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_calc_sub</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> Calculator.sub(<span class="number">3</span>, <span class="number">1</span>) == <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_calc_mul</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> Calculator.mul(<span class="number">2</span>, <span class="number">4</span>) == <span class="number">8</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_calc_div</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> Calculator.div(<span class="number">8</span>, <span class="number">4</span>) == <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_calc_div_zero_div_exp</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">with</span> pytest.raises(ZeroDivisionError):</span><br><span class="line">            Calculator.div(<span class="number">3</span>, <span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;pytest使用规则及示例&quot;&gt;&lt;a href=&quot;#pytest使用规则及示例&quot; class=&quot;headerlink&quot; title=&quot;pytest使用规则及示例&quot;&gt;&lt;/a&gt;pytest使用规则及示例&lt;/h3&gt;&lt;p&gt;Pytest是一个功能强大且易于使用的&lt;code&gt;p</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="python测试框架" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="pytest" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/pytest/"/>
    
    <category term="pytest使用规则及示例" scheme="http://example.com/categories/python/python%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/pytest/pytest%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99%E5%8F%8A%E7%A4%BA%E4%BE%8B/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="pytest" scheme="http://example.com/tags/pytest/"/>
    
    <category term="单元测试" scheme="http://example.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
    <category term="集成测试" scheme="http://example.com/tags/%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95/"/>
    
    <category term="功能测试" scheme="http://example.com/tags/%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
    <category term="测试框架" scheme="http://example.com/tags/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>DevOps | CI/CD</title>
    <link href="http://example.com/2024/02/28/CI-CD/"/>
    <id>http://example.com/2024/02/28/CI-CD/</id>
    <published>2024-02-28T11:41:24.000Z</published>
    <updated>2024-02-28T11:55:43.510Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI/CD"></a>CI/CD</h3><p><strong>CI/CD</strong>:持续集成和持续交付/持续部署，是DevOps实践中的关键组成部分，包括<strong>代码的自动构建、测试和部署</strong>，以确保软件的快速和健壮开发。</p><p><code>DevOps</code>是软件开发中的一种文化和实践，强调开发（Development），测试，运维（Operations）三个领域的合并，通过自动化软件交付和架构变更的流程，实现构建、测试、发布软件的快捷、频繁和可靠。</p><p><a href="https://www.redhat.com/zh/topics/devops/what-is-ci-cd">参考资料1：什么是 CI/CD？</a></p><p><a href="https://zhuanlan.zhihu.com/p/136843588">参考资料2：使用gitlab实现CI/CD</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;CI-CD&quot;&gt;&lt;a href=&quot;#CI-CD&quot; class=&quot;headerlink&quot; title=&quot;CI/CD&quot;&gt;&lt;/a&gt;CI/CD&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;CI/CD&lt;/strong&gt;:持续集成和持续交付/持续部署，是DevOps实践中的关键组成部分，包括</summary>
      
    
    
    
    <category term="DevOps" scheme="http://example.com/categories/DevOps/"/>
    
    <category term="CI/CD" scheme="http://example.com/categories/DevOps/CI-CD/"/>
    
    
    <category term="DevOps" scheme="http://example.com/tags/DevOps/"/>
    
    <category term="CI" scheme="http://example.com/tags/CI/"/>
    
    <category term="CD" scheme="http://example.com/tags/CD/"/>
    
    <category term="持续集成" scheme="http://example.com/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
    <category term="持续交付" scheme="http://example.com/tags/%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98/"/>
    
    <category term="持续部署" scheme="http://example.com/tags/%E6%8C%81%E7%BB%AD%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>python | 迭代器与生成器的区别</title>
    <link href="http://example.com/2024/02/28/python%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2024/02/28/python%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2024-02-28T11:30:00.000Z</published>
    <updated>2024-02-28T11:32:59.296Z</updated>
    
    <content type="html"><![CDATA[<h3 id="迭代器与生成器的区别"><a href="#迭代器与生成器的区别" class="headerlink" title="迭代器与生成器的区别"></a>迭代器与生成器的区别</h3><ol><li><p>python迭代器</p><p>Python中的迭代器是一个可以记住遍历位置的对象，用于访问集合元素的一种方式。迭代器是Python中处理数据集合的一种高效机制，它们<strong>允许开发者逐个访问集合中的元素，而不需要一次性将所有数据加载到内存中</strong>。</p><p>迭代器通过实现<code>__iter__()</code>和<code>__next__()</code>方法来定义其行为。<code>__iter__()</code>方法返回迭代器对象本身，而<code>__next__()</code>方法负责返回容器中的下一个值。当没有更多元素可以返回时，<code>__next__()</code>方法会抛出<code>StopIteration</code>异常，通知调用者所有元素已经被遍历完毕。</p><span id="more"></span><p>​    在Python中，可以使用<code>iter()</code>函数获取一个对象的迭代器，然后使用<code>next()</code>函数来访问迭代器中的下一个元素。此外，Python的for循环本质上就是在使用迭代器，它可以自动处理<code>StopIteration</code>异常，使得代码更加简洁易读。以下是使用for循环遍历可迭代对象中元素的示例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用for循环遍历list、tuple、dict、str、set等可迭代对象</span></span><br><span class="line"><span class="comment"># 遍历列表list</span></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line">    <span class="built_in">print</span>(element)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 编译元组tuple</span></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(element)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 遍历字典dict</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> &#123;<span class="string">&#x27;one&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>: <span class="number">2</span>&#125;:</span><br><span class="line">    <span class="built_in">print</span>(key)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 遍历字符串str</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> <span class="string">&quot;123&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(char)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 遍历集合</span></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> &#123;<span class="string">&#x27;1&#x27;</span>, <span class="number">2</span>, <span class="number">3.0</span>&#125;:</span><br><span class="line">    <span class="built_in">print</span>(element)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 使用python内置方法iter()获取对象的迭代器iterator</span></span><br><span class="line"><span class="comment"># 获取字符串迭代器</span></span><br><span class="line">s = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">it_s = <span class="built_in">iter</span>(s)</span><br><span class="line"><span class="built_in">print</span>(it_s)  <span class="comment"># &lt;str_iterator object at 0x10c90e650&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_s))  <span class="comment"># &#x27;a&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_s))  <span class="comment"># &#x27;b&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_s))  <span class="comment"># &#x27;c&#x27;</span></span><br><span class="line"><span class="comment"># print(next(it)) # StopIteration</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取列表迭代器</span></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">it_list1 = <span class="built_in">iter</span>(list1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_list1))  <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_list1))  <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_list1))  <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取集合迭代器</span></span><br><span class="line">set1 = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line">it_set1 = <span class="built_in">iter</span>(set1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_set1))  <span class="comment"># &#x27;a&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_set1))  <span class="comment"># &#x27;b&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_set1))  <span class="comment"># &#x27;c&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取字典迭代器</span></span><br><span class="line">dict1 = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line">it_dict1 = <span class="built_in">iter</span>(dict1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_dict1))  <span class="comment"># ’a‘</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_dict1))  <span class="comment"># ’b‘</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_dict1))  <span class="comment"># ’c‘</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取元组迭代器</span></span><br><span class="line">tuple1 = (<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>)</span><br><span class="line">it_tuple1 = <span class="built_in">iter</span>(tuple1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_tuple1))  <span class="comment"># 1.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_tuple1))  <span class="comment"># 2.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it_tuple1))  <span class="comment"># 3.0</span></span><br></pre></td></tr></table></figure></li><li><p>python生成器</p><p>Python中的生成器是一种<strong>特殊类型的迭代器</strong>，它使用<code>yield</code>关键字来返回数据。</p><p>生成器是一种特殊的函数，它可以在执行过程中暂停并保存其状态，以便稍后从上次停止的位置继续执行。当生成器被调用时，它不会立即执行，而是返回一个生成器对象。只有当开始迭代该对象时，生成器才会逐步执行，并在每次遇到<code>yield</code>语句时返回一个值。</p><p><strong>生成器的主要优点是它们可以按需生成数据，而不是一次性生成所有数据</strong>。这在<strong>处理大量数据</strong>或需要<strong>延迟计算结果</strong>的情况下非常有用。生成器还可以用于实现协程（coroutines），这是一种允许多个任务协作执行的编程模式。</p><p>以下是一个简单的生成器示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_up_to</span>(<span class="params"><span class="built_in">max</span></span>):</span></span><br><span class="line">    count = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> count &lt;= <span class="built_in">max</span>:</span><br><span class="line">        <span class="keyword">yield</span> count</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个生成器对象</span></span><br><span class="line">counter = count_up_to(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代生成器对象</span></span><br><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> counter:</span><br><span class="line">    <span class="built_in">print</span>(number)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 使用生成器表达式定义生成器，采用()</span></span><br><span class="line">num_iterator = (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(num_iterator)</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> num_iterator:</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line"></span><br><span class="line">num_iterator2 = (i*i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(num_iterator2))  <span class="comment"># 求平方和</span></span><br><span class="line"></span><br><span class="line">xvec = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line">yvec = [<span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(x*y <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(xvec, yvec)))  <span class="comment"># 点积</span></span><br><span class="line"></span><br><span class="line">data = <span class="string">&#x27;golf&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(data[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>)))  <span class="comment"># 反转输出字符串</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;迭代器与生成器的区别&quot;&gt;&lt;a href=&quot;#迭代器与生成器的区别&quot; class=&quot;headerlink&quot; title=&quot;迭代器与生成器的区别&quot;&gt;&lt;/a&gt;迭代器与生成器的区别&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;python迭代器&lt;/p&gt;
&lt;p&gt;Python中的迭代器是一个可以记住遍历位置的对象，用于访问集合元素的一种方式。迭代器是Python中处理数据集合的一种高效机制，它们&lt;strong&gt;允许开发者逐个访问集合中的元素，而不需要一次性将所有数据加载到内存中&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;迭代器通过实现&lt;code&gt;__iter__()&lt;/code&gt;和&lt;code&gt;__next__()&lt;/code&gt;方法来定义其行为。&lt;code&gt;__iter__()&lt;/code&gt;方法返回迭代器对象本身，而&lt;code&gt;__next__()&lt;/code&gt;方法负责返回容器中的下一个值。当没有更多元素可以返回时，&lt;code&gt;__next__()&lt;/code&gt;方法会抛出&lt;code&gt;StopIteration&lt;/code&gt;异常，通知调用者所有元素已经被遍历完毕。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="基础" scheme="http://example.com/categories/python/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="迭代器与生成器的区别" scheme="http://example.com/categories/python/%E5%9F%BA%E7%A1%80/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="迭代器" scheme="http://example.com/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    
    <category term="生成器" scheme="http://example.com/tags/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
    <category term="yield" scheme="http://example.com/tags/yield/"/>
    
    <category term="iter()" scheme="http://example.com/tags/iter/"/>
    
    <category term="next()" scheme="http://example.com/tags/next/"/>
    
  </entry>
  
  <entry>
    <title>C++ | GCC或Clang头文件搜索路径</title>
    <link href="http://example.com/2024/02/26/GCC%E6%88%96Clang%E5%A4%B4%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84/"/>
    <id>http://example.com/2024/02/26/GCC%E6%88%96Clang%E5%A4%B4%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84/</id>
    <published>2024-02-26T12:45:07.000Z</published>
    <updated>2024-02-26T12:56:19.195Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GCC-Clang的头文件搜索路径"><a href="#GCC-Clang的头文件搜索路径" class="headerlink" title="GCC/Clang的头文件搜索路径"></a>GCC/Clang的头文件搜索路径</h3><ul><li><p>GCC/Clang编译器在对C++源代码文件进行预处理时，会对C++源代码头部包含的头文件进行搜索，搜索时根据环境变量CPLUS_INCLUDE_PATH中的路径进行搜索，如果搜索不到某头文件会报错。若CPLUS_INCLUDE_PATH中没有包含所使用头文件所在路径，也可以通过-I参数制定使用到的头文件的路径，例如，gcc -I /your/header/file/ test.cpp。</p></li><li><p>添加GCC头文件搜索路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export CPLUS_INCLUDE_PATH=$CPLUS_INCLUDE_PATH:/xxx/include</span><br></pre></td></tr></table></figure></li><li><p>查看C++编译器（GCC）的头文件搜索路径命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gcc -x c++ -v -E -</span><br><span class="line"><span class="meta">#</span><span class="bash"> gcc：表示使用GCC编译器进行编译。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -x c++：表示指定编译的语言为C++。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -v：表示显示详细的编译过程信息。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -E：表示仅执行预处理阶段，不进行编译和链接。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -：表示从标准输入读取源代码。</span></span><br></pre></td></tr></table></figure></li><li><p>查看C++编译器（Clang）的头文件搜索路径命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">clang -x c++ -v -E -</span><br><span class="line"><span class="meta">#</span><span class="bash"> clang：表示使用GCC编译器进行编译。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -x c++：表示指定编译的语言为C++。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -v：表示显示详细的编译过程信息。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -E：表示仅执行预处理阶段，不进行编译和链接。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -：表示从标准输入读取源代码。</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;GCC-Clang的头文件搜索路径&quot;&gt;&lt;a href=&quot;#GCC-Clang的头文件搜索路径&quot; class=&quot;headerlink&quot; title=&quot;GCC/Clang的头文件搜索路径&quot;&gt;&lt;/a&gt;GCC/Clang的头文件搜索路径&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;G</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    <category term="头文件搜索路径" scheme="http://example.com/categories/C/%E5%A4%B4%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="GCC" scheme="http://example.com/tags/GCC/"/>
    
    <category term="Clang" scheme="http://example.com/tags/Clang/"/>
    
    <category term="头文件搜索路径" scheme="http://example.com/tags/%E5%A4%B4%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>python | 将python程序打包成exe</title>
    <link href="http://example.com/2024/02/22/%E5%B0%86python%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85%E6%88%90exe/"/>
    <id>http://example.com/2024/02/22/%E5%B0%86python%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85%E6%88%90exe/</id>
    <published>2024-02-22T13:03:22.000Z</published>
    <updated>2024-02-22T13:36:23.779Z</updated>
    
    <content type="html"><![CDATA[<h3 id="将python程序打包成exe"><a href="#将python程序打包成exe" class="headerlink" title="将python程序打包成exe"></a>将python程序打包成exe</h3><ol><li><p>编写python程序（例如test.py）</p></li><li><p>安装pyinstaller</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U pyinstaller</span><br></pre></td></tr></table></figure></li><li><p>打包python程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller test.py</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;将python程序打包成exe&quot;&gt;&lt;a href=&quot;#将python程序打包成exe&quot; class=&quot;headerlink&quot; title=&quot;将python程序打包成exe&quot;&gt;&lt;/a&gt;将python程序打包成exe&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;编写python程</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="pyinstaller" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pyinstaller/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="打包" scheme="http://example.com/tags/%E6%89%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>python | python是否支持多线程</title>
    <link href="http://example.com/2024/01/24/python%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://example.com/2024/01/24/python%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2024-01-24T12:41:30.000Z</published>
    <updated>2024-01-24T12:44:17.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python是否支持多线程"><a href="#Python是否支持多线程" class="headerlink" title="Python是否支持多线程"></a>Python是否支持多线程</h1><ol><li><p>多线程</p><p><strong>线程在CPU上运行，是操作系统进行调度和执行的基本单位</strong>。</p></li></ol><p>​    首先，要明确进程与线程的关系。一个进程可以包含多个线程，而每个线程都是进程中的一个执行流。可以把进程比作一个工厂，而线程就像是工厂里的工人，它们共同协作完成工作。</p><p>​    其次，线程的创建和运行是在一个进程中进行的。当启动一个线程时（例如，通过调用<code>Thread.start()</code>方法），操作系统会为这个线程分配必要的资源，包括寄存器、栈等，并在CPU上执行该线程的代码。</p><p>​    再者，在<strong>多核CPU</strong>系统中，<strong>不同的线程可以被分配到不同的核心上并行运行</strong>。而在<strong>单核CPU</strong>中，<strong>线程的运行会通过时间片轮转或优先级调度等方式进行切换</strong>，从而实现并发执行。</p><p>​    最后，<strong>线程之间共享所属进程的内存空间</strong>，包括代码段、数据段、堆和栈。这意味着线程可以访问相同的变量和数据结构，但同时需要注意<strong>同步机制</strong>来避免数据竞争和不一致的问题。</p><p>综上所述，线程是在CPU上运行的，它们利用进程中的资源和内存空间，按照操作系统的调度策略执行任务。</p><ol><li>python是否支持多线程？</li></ol><p>Python支持<strong>多线程</strong>，但由于全局解释器锁（GIL）的存在，在任意时刻只能有一个线程执行Python字节码。Python中的多线程是通过<strong>在一个进程中创建多个线程来实现的</strong>，每个线程可以执行不同的任务。然而，由于Python解释器（cpython，由c语言编写的python解释器库）的GIL限制，这些线程并不是真正意义上的并行执行。GIL确保了同一时间只有一个线程能够访问Python的对象和内存空间，这意味着即使在多核处理器上，Python的多线程也无法实现真正的并行计算。</p><p>​    尽管如此，Python的多线程对于<strong>I/O密集型任务</strong>仍然非常有用，因为它们可以在等待I/O操作完成时释放GIL，从而允许其他线程执行。在这种情况下，多线程可以提高程序的效率，因为它们可以减少因等待I/O而浪费的时间。</p><p>​    此外，如果需要执行<strong>CPU密集型任务</strong>，或者希望充分利用多核处理器的能力，可以考虑使用Python的<strong>多进程</strong>模块<code>multiprocessing</code>。多进程可以绕过GIL的限制，因为<strong>每个进程都有自己的Python解释器和内存空间</strong>，从而实现真正的并行执行。</p><p>​    multiprocessing实现多进程并行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_cube</span>(<span class="params">num</span>):</span> </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Cube: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(num * num * num)) </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_square</span>(<span class="params">num</span>):</span> </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Square: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(num * num)) </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>: </span><br><span class="line">    <span class="comment"># 创建进程</span></span><br><span class="line">    p1 = multiprocessing.Process(target=print_square, args=(<span class="number">10</span>, )) </span><br><span class="line">    p2 = multiprocessing.Process(target=print_cube, args=(<span class="number">10</span>, )) </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开启进程</span></span><br><span class="line">    p1.start() </span><br><span class="line">    p2.start() </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待p1、p2线程都执行完</span></span><br><span class="line">    p1.join() </span><br><span class="line">    p2.join() </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Done!&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Python是否支持多线程&quot;&gt;&lt;a href=&quot;#Python是否支持多线程&quot; class=&quot;headerlink&quot; title=&quot;Python是否支持多线程&quot;&gt;&lt;/a&gt;Python是否支持多线程&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;多线程&lt;/p&gt;
&lt;p&gt;&lt;stron</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="基础" scheme="http://example.com/categories/python/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="python是否支持多线程" scheme="http://example.com/categories/python/%E5%9F%BA%E7%A1%80/python%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="multiprocessing" scheme="http://example.com/tags/multiprocessing/"/>
    
    <category term="多线程" scheme="http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="python解释器" scheme="http://example.com/tags/python%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
    
    <category term="cpython" scheme="http://example.com/tags/cpython/"/>
    
  </entry>
  
  <entry>
    <title>记录生活 | 回顾过去七年</title>
    <link href="http://example.com/2024/01/14/%E5%9B%9E%E9%A1%BE%E8%BF%87%E5%8E%BB%E4%B8%83%E5%B9%B4/"/>
    <id>http://example.com/2024/01/14/%E5%9B%9E%E9%A1%BE%E8%BF%87%E5%8E%BB%E4%B8%83%E5%B9%B4/</id>
    <published>2024-01-14T13:05:29.000Z</published>
    <updated>2024-01-14T14:16:50.094Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="27e6817d642bc8140dc16eef201868f96f2609ba8b663023ea9e9147c3c5e7f5">b780b0a90ab26cc39689a6bfa1e86daac6442d6de9743a9acd3f0a2af43b85bdb715df0ebdb51ad32f6a5c32379787da49754b6d64ef0f02bc11fe93600aa0ba3a7a0eb9b2c3860f78bf73f5530e7151d69ecab0d672f1a03902e66963d3d7d3e46b7274546f6ffe6a543802835573f898159d5c126b8ab13f510e6cc7c9654b7db00e9e42999592df4d41b9dff36a8b5d671aef5ee92548d0a71772dcffc87d88e21224f1c60a24627c5aae61e6ec1064ae7e99d3c3dfa21422752fe488128e283b4d751aa97f95603c65485cdc8ccb8e7521e1907de08874e611ce3774e9b11bf928767ecb99b4243b2034b317cdfca49ea7e8e33ad7e549dad741371251e9a574e00eb0236a5412c9646d60bd09680d2ddab49d398ca6d38f41c9d779956edc2f850b251dc91a6156932c055053c082208f6ab34fe04daa3591916d86e270466f0deb70ccf75177083639925460e22a9d3c547b3105295a4f8bc7300aa64b4bc037923b2e822fdabb68b77e3e76599076709e4fa4659d55bff65db3662140243cf18ad27d609579c991d39e429d41d34824b9e76e7c5b390545522cda880964fd356bc654e6fd4f9b4fc4e5d663672983f2fa85564e0f0e5360af66838a80e7becf77a5f38a929225536db201b29fc1f03be52a305cba271bd50ef401aae717d2073559aca3f3574655630e5a2d57ea3ee83307ad452339012334d327da40c73b4e925f8f2232810d5d256aa74cc85464321b6bd23c67cf3d0e2576696c52aadd9e232b8e1f3d32af4f8d271a634b290c5402a28998ac5acce2e311fbb8c80d5fbd5f4b33473af210f9393a509103acea363659de510e040ddc5a6dad19efa0e5d0b3dd95c483946db7c8adb5cd6b7cb57f5d169e7f67d442e7a7b25a11049fd30f5dba604f0ecac2a36a487bae69e547dd1beb43b3077147bba95d600eefd55e3d54e6a579678f6013d4ba9e1d731030a5b17fdae327100bc00280038d0d3f9c027ec603c759fd87b1026174c936b18d8872b8b3c28bc4a9fdfd5d536a72b60fe73f7d49fd67b29389451e17a24205362bf0d62cad7076bd5d47a1a06b2caee77dfd337318e68f40a7d151360b67bae8a0cc874217e2c676f3a62f9bf07b9f657e26d04a210f54ed84c7d82c036dbb22a20757808ccc4370406e2ee060d8ad8a10ff8cc969db95ea68c2c3dfebb01943d77c067956072f3f587bc0994c860ebfe89b6f19433b042ef14d234d41842e3b4761cea9567a7f9d0f23f699582be2ff7f44f1d08dafc360259d107b5091f365c29ad3b7403e63e7f5730c5ce58ad524c5931e6d92ff78c5ce4284889cae4f2f1e68d5f6c8fe2161a7086df744cdbe2e5b7099ef9fa267d78bad60be2148a1f864a8f7c7b8e5d122e7a3525dc506813c4cf708266db032f636030fcc14063d318355b4321912f78bb8dc0a14d5528fc989ddee5e809cd1fb71dcadfc52cc47d8265c762f6bfe2012b38d79524fcaa1012fd737cde7d26ffc87845452e1cd56777b08b59af38083ff3c9c13e9601d8f50220cf74fec358637cb1e9021075d82f0fc2b9a172b27eb83979591c17cd8f6f96a3a65fb7cb97041f800109b70befeabba168fe05b52027b0a74e1c1016621cf725a975ac4da24e728a9413622fdaae45061d5073786788e3188c0a982594b0cc71d38581383f75d87accfd584252e6d29f9e3ebcfbbe3e38e7b45d082613cb3571bdefb3bf0b351e9e896fc226b8918f2c852028ba23702a8a6a5c27bd2cf045c6c4c48082efff5ed4811b199f248330dd95b83ede847a1fb309a6fc849fcf319d398f7c7e3e390a50a7d5c3fe3d6510bd1efcc69ef1d258dcf346309723b1da6a5622367a7e279b4aecbc0a8fd3bb12a51424dea3447321d6d2f449ebd1b0025f9fa778c5e0176302a7450787f7130a2ce010317e47f56ebf7f93cb36094654c81e10ab2dab2bed01269284637f6c4c22ba21d0135e08e6c7cefd8f7f8f612cf4a831898b71db92b35c5db1f11652738723388006f5ca3827a4d8cb7edce64860d2cc91e4032ae025397605b181d8a5c6c8ae55b0c6d1bf55053cca5b14ea45e2caed66d22a97bd5f353d410d792bb409d751ea0818608e2ac320238bfb936e6e4c978e1657fe5f9515e1fcfc9e09341633737c6b2c544f0f2b45459ac23784c4606afa42f84bfa32f760ee811e41e9be4ccf7cf38b7bac66edbff9ce1b3e1a5a741d832271147a46ebe3a97003d5751350dbc8dc4328336bc7047112b812beb5b699035d585c86eb884cb1aebf08be2dad1e0a676f67dd471c4bb2a41b2abacd794e1c9f846f2837a19946c0ea9679d60c770482164269167b8f4863816458d5bc153cbbc1adeb0fff88ee44cbb4f3c4af6fe7b9e4e7c77154d71d8ece4de67765abe0ade375d2e0d1ba0c45e065bc26523a3fa1c67ad6bde7636394a18f617bef78d4adb027a4f734f5ee57ea4b80f2b7598965bdb92f198e3218e1651ac87f8ee66cdab49d46379c0dc67976483c5a1d74d4b3e5e2e4f2358cccaa06b0fcae6d32ac16ad0748cc1c3b31724fd9d77cff876c9006da4f78bc0bdacac7ec57ade50cf0915854cd97ca7421635d5bbd84ab125145d9cf1c60b8073955235b007c83fda33479686f1e528f5366de8915a3608d12b51c028ed3644c6ff474a7be3c775372d2ec5048dcabcfbd3a5ba1de45078819af9f2e8787892ebba6771be39b4224818a194629d2e69e740a6a2c7e973bd666562f02c676e02f2bd547af3fd426e329f369dcb284ecc55630fbbee7a1335b04458366b19e9b45542da2fe31ed568329cde6fd41867974dd0e1034ba6ebdbfe28e26ae1d28aca4c5410a366b91d3caacdbd536f67e0bc82e948fffc80bf61e7f25014df02dc835a49ce682c87a9362fd270f84b8187fa24f204c991597b9dad86d0e31adb958209b2241d2f3bff0aac3b99d3251d5be04f3087bdeca114257961e201de55a66fa07c72dacfbabb9d8722b2a8eefec54fc146c1866fbef2d91f59a6a3d9d64577366d41bf2d6e83a96bd44073d3383c2d10f8179271e6cb2b5c3166bf86c93da1fe586843f05fce0af82151e54a552a1d8a49a52c4cb2c006fafdd43f8fda62be68a412582656eb72d55eb22f9d925d0fc0cc2ad0e143e7247871a58f2e3fb87e19aa51640d2631969dc3a7a5c3f23dd4b7de7b92760495de12ff143a54591e37becf42a915ac3459f5597a4060f4e9139514ee37405d4e49b47c3b8357271e439b682efd77b45ef7e21046722bc964a4370ce571e825b4ad109df4325b152480c2a0e2b92d3a682313de09c5a9816a48d4951a42f0e5015b5c5cfe1ddf16bc14cc39245c47d4bb16863ae322cc4df453a7ab522044ebb5c8451fc1478cc63237bf24fbb75f464b7532b2bee4c892b8179dc86a714b49bcdb9e7b5ce651c7dd9fd0ae35f7c881f4d0550b86a345d0e41e5ea66c9ee1f1648ecda62b3003f10dff48d5416de75df08b503a0c41d94602ead624db85c378519c6c5b9b87c99b0e049aa6c8a72ec3ae750443075f66e00536741c0b240bfdfd4fe055cac97acaf9b4581a8bfdc9e25ddb0880777f4f62fa1935faeff788041859783b34a137273d58256b64d04fe1f1550dacbf56bb6cbe2bf845a4d01c12827cc481924e9ef7048600d98784b7393e0d4744fce15fc1fedbc775e77e7c9132177759243fdf5274b014016d9f17e4391c97048487b75517707bcb66e2fc08accc5ad14a4e7f56d27b82bd606c751b5fcf3c5db974358d8c64d71d3928e4ac3c3ae7da637de7f8cb5e0c4f239793f33256ec40568ec99810762eda17364f847e88c0208db67decd42c2d100eaf5545f4b5c599609b651303d268b3032443775b18f448158ff880936c6afc6a4c7eaf1205c50adce1756d8b7dbf57b308e3f7804466b8b5f89dfd800bec8daadb19b14e2224a15b5201c070ff6fa49e9004b02b40a879eabe54baba9a3fbd8290568e2ee12710183fd842ec0d0b7fb26c617ad0c25653f3c4145dd4e898bbe10e717de2b35c26346fbfb65fcdd15c37080c12f83d12e2d945e0730cc34f081cfc12a9a3b7105b268ba6620f65c3ea82d5a73e9655be3a7242521fdd367da0eafc12efc791e02b0403f2deede7e1429bf28b1e56ed2651c30ebafe7b307fedc201c73178bf5d06e748f986d2f74c218ba05997bb4deb08e1029b242f73f207d0d8cf127d9fda0eea9c7593b80204b26743dae55848b296aa4cac31fffc301466bcb453f35bb65a26a7de13063befd6a3279687cf1038bc4e335ea6bca3155de2fcc231114e99f605b9e6528dfeb410b848023d0486f7cd870f6778298cfc0123644d4ab2dd20fd7ae3914dfe99403edd765bb91a043d47c540f8c1a62e4c47f663a765c08e1e058e75e484c4afbf9c2548c6c70542a5d8fd1491a3cef9f69f6b4421b40f4f49165c7907c96c942fd518d0a2597a149f83837bd52b6205306fc4e9948ebb3d803e3cf8841338de3cb0ab809ee5e13f8432f302f8b7b248e0b042300b75bb77b2b14df7be763be09eac4e30d86917deaa61faccd96ba4275d27d73185da55962deb5a0177d31dfb38a41ff8b16f291ac57ce3130390b3c990ac9c050fb5378b19f69010870af28cf2cd1933c3c212114c6acf37b6c3bb2e43db3bc45dd088ecb33694211244ae8b6a302b15241c357571749b0001f5286c2b8e461ffb78c1dbf54c200acfdeec51af399e7839151d66924d1d8d87537b43ba4c500b28d0da57ccda0df0b9b5a292514a504e54cf1191eb9946ea2dbde9d9b17837e8debbb9bdab86f0affacc950451718a2dc4a0060b8fd2a84afda90101d08b50306853cf01ab41e186868d909569d2fef8c6b4f32de75375810f8607d09120121db8fe978623c34a35d8b4df309ac8952e6748fe0720fdfeb6e4c824a5b548cc2fcb19ce152509b37acd2240c7a5531d564f63ec7843d0d65c56532548a62773a9d9041be4eba4b013ffbd733088a72dc2afb4b2ffea5f7bb9b727499fbfa78376c3e9d455e2f6f07d6565bd31432a5a4110dfa1009c8c1aea5233d7bcb406f9e81e84c2c7ea0e5c27ee790c9da705c4f693637cdb435fb7fdec116d60e8048ede165fcafc035561e16d874c54707a971634ecf5431a913f6d54719c6e4195ed272f3a792d7328cdb334228f43f0c69f28185c41520f4266430efb89ee9d47b4122fb2b0121c24ac458d2b3b0fd0c886819939672f4110d22fe1f243f5d2f72235dedb5a5b400b68f54a9b7da405b9b7b7791ab05f34d736aaef74f47864b42d76c67cc4961b391d8ec674d1511c58230d1b43829a7d8121b278fb0c18c00597e4eba297e9b313c158f32102548aa1fd8356e99e1191a95b9fc035562e914c464440f7ba84ab8f0a6dac5dc97324cd0c20599fefb245705ca0a283c542662e91b3ebc501644f8faea7371be3b75af751f0279871f542f19c4432c46975d624d3625791ade85caa4d2409c36ffcbe555adbf20b8b6d5f893e749c124f73509aa43109c1f1a7b06f4b4c80e474fbff99b5a3a2f70e6f01b358e010a29c3bfbdcdc0f18bd7b772921ff64fe32d355be227b92c88d077feb20bae6fe78c63dd2637914daa27940445e6402470e1be1b32e7254339eefa8f4e789f529a88eaa20a4da651c589e5268927d8215c7e1465e251d20a6bd9485ca0d76ceee5621e3c28cfb6191d178d6a9db0574ba1dc53157a5024b1b904eece92c6e0ccd7fe5f573c61c9b7bfe3ecc12b56611a8a8498e5a2c6626be4640a1ab01a99b6cf960d0798f624ed22b7a3135534e523eba4e71a1e4d4c4bfd887248d8c0482d2f4eea9cf874c3c094d2e81e18223628250f22f5071faaf0ec9e4823426ff0f8685b346870017bd3205577c1b90fdd7540921ee0a2de3d8fe044073a8690ac6d532cb7a398b045cd98c3f735bb57f0a71e3eee88ba03de174bad4a10418873e03f4bac141db0e523df2e1711de58bb7bb54ccf2721c318addc5d7cd5b6a1d04ef20a5e2d151abda8e5b78fde6391c6fe589532669e0124d8ebc4b7b47c68eaa3d68b21fd2efe3951c9763dac6bb0282c23e692c2aaafa0e90f13087bc1aea4f2eec9b1a1f46ee3f1774bc98754ec25cf4af35346b97fb56ad03634c4b1c56ec50bfbfebc50f5b069592a1f608add5f202af5e3bb21b56a89ad9f61ed907248ec5c699e12e537480adda31bcce61f9647e94139bf9ca56a7fb79ef08e94317bdd56dfcb4944953035c0529e004fed3b5e535dc2b8c013c01f23233e52e3a6a8c0817e159321bdb6314f82c206132250746944573ac65533c6dd6317d659fb2287750f1a5c347a7e3e1891a23f057a50e62739dc3b28a8922d22af8ce33a4f19c95b788a304a849f89fe06c86e3872c29c283f2bcf90f9051025d81352f2ab2f586f6caf75fc95c062b8648dcf7aa9148310b624e83d826842195bae0e4f420e6be43d1f00c5519b40247659788937b4964f44971e12ffbf4cdd54b521635febbcb79fdaeb211371f26e7fe129d3e7c8283e1af00c8798e069193da50b2f4850aa550940c9de284f26431e5191d4e7ac2170c37da7c5e608e1e500aa344b2e43bff12412a0dcfcfd92ed77150adbd321d7deed06d965cfb93cf74a93a90d103c66fd721b076cb05eb60cbc821003e90a859af67a2541841bb1d74db1dd7582834bc9e389b9827af81af48d10637b828cfd4ce4d58fa21125000c4396a9a7d3cd41961d0151752081ca67776bb892e8648cce8169a492a1fc1b379abfe61a57aef80f974f0516b9e12166d372a338c651ace40fd28fbe79680e5d92ac0cc92fcb951de3d7594daac82e4c838d8e761f75a8415bdff7d0db3b71f4c039d81bca202b919f686a2df9cbbb0a7f7e700a2f44887886eeab0e1023abd0cb22599b04041983a1d9569ce6ac96fe48b0561221c9b8ec44411bfa1533a87ca61d8ac1f2f7cc2dfc54cf48c5b67895788a89a79e370717a863508fb3d45a81f19f6aa69acb01cc3fc267d953d459726da3dc098b3e314b2e35ec8a4db0a77b55bf7e464c6b7585f8453fd233062c75536e66fd9a3563436bfb41827646f292335a963d81ef6861ca3d56a61120ec734b198936288b2922e8e8d51f8122b66251a30d3bbaf158bf1647e8c21dc35204f41df9dc383eb01f8bcb3613ff1</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">此文涉及个人经历，暂不公开！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="记录生活" scheme="http://example.com/categories/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/"/>
    
    <category term="回顾过去七年" scheme="http://example.com/categories/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E5%9B%9E%E9%A1%BE%E8%BF%87%E5%8E%BB%E4%B8%83%E5%B9%B4/"/>
    
    
    <category term="记录生活" scheme="http://example.com/tags/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>C++ | 字符串分割</title>
    <link href="http://example.com/2023/10/12/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2/"/>
    <id>http://example.com/2023/10/12/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2/</id>
    <published>2023-10-12T15:54:27.000Z</published>
    <updated>2023-10-12T15:56:10.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-字符串分割"><a href="#C-字符串分割" class="headerlink" title="C++字符串分割"></a>C++字符串分割</h1><p>字符串分割是编程中经常遇到的一个问题，采用C++语言实现字符串分割与其他语言有所不同，下面将采用C++语言实现字符串分割并对用到的字符串操作函数进行详细的描述。</p><ul><li><p>字符串分割Java实现</p><p>Java通过调用String.split(String delimiter)方法可直接完成对字符串的分割。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    String str = <span class="string">&quot;I am a good programmer!&quot;</span>;</span><br><span class="line">    String[] splited_string = str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(String s : splited_string)&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>字符串分割Python实现</p><p>python实现字符串分割代码更为间接，很多功能使用python实现仅用一行代码，江湖上称之为“一行流”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;I am a good programmer!&quot;</span>.split(<span class="string">&quot; &quot;</span>))</span><br></pre></td></tr></table></figure></li><li><p>字符串分割C++实现</p><p>比起Java和python实现，采用C++实现字符串分割的过程则略为繁琐。需要用到c_str()、strcpy()、strtok()等方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splitString</span><span class="params">(<span class="keyword">const</span> string &amp;str, <span class="keyword">const</span> string &amp;split, vector&lt;string&gt; &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// str:要处理的字符串</span></span><br><span class="line">    <span class="comment">// split:分隔符</span></span><br><span class="line">    <span class="comment">// res:存放分割后的结果</span></span><br><span class="line">    <span class="keyword">char</span> *strc = <span class="keyword">new</span> <span class="keyword">char</span>[str.<span class="built_in">size</span>() + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(strc, str.<span class="built_in">c_str</span>()); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *temp = <span class="built_in">strtok</span>(strc, split.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="comment">//strtok()的源码为char *__cdecl strtok(char * __restrict__ _Str,const char * __restrict__ _Delim)</span></span><br><span class="line">    <span class="comment">//strtok接收的参数时char*类型，因此进行字符串分割前需要将string类型的字符串转为char*类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(<span class="built_in">string</span>(temp));</span><br><span class="line">        temp = <span class="built_in">strtok</span>(<span class="literal">NULL</span>, split.<span class="built_in">c_str</span>()); <span class="comment">//strtok第一个参数传入NULL，使用之前保存的SAVE_PTR定位下一个待处理的字符的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] strc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="built_in">splitString</span>(<span class="string">&quot;I am a good programmer!&quot;</span>, <span class="string">&quot; &quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;分割的子字符串的数量为：&quot;</span> &lt;&lt; result.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;分割后的字符串为：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; result[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>字符串分割所使用方法详解</p><ul><li><p>string.c_str()</p><p>c_str()方法的原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> _CharT* <span class="title">c_str</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>该方法返回一个指向常量的指针，指针所指向的内容不能被修改，在字符串分割中主要使用该方法将string类型转为char*类型，与字符串分割函数strtok()方法的接收参数类型保持一致。注意：一定要使用strcpy()函数等来操作方法c_str()返回的指针。</p></li><li><p>string.strcpy()</p><p>strcpy()方法的原型如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char * __cdecl strcpy(char * __restrict__ _Dest,const char * __restrict__ _Source);</span><br></pre></td></tr></table></figure><p>该方法将字符串Source复制到Dest。该方法线程不安全，c++提供了线程安全的字符串拷贝方法strcpy_s()。</p></li><li><p>string.strtok()</p><p>strtok()方法的原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *__cdecl <span class="title">strtok</span><span class="params">(<span class="keyword">char</span> * __restrict__ _Str,<span class="keyword">const</span> <span class="keyword">char</span> * __restrict__ _Delim)</span></span></span><br></pre></td></tr></table></figure><p>其中，Str表示要进行分割的字符串，Delim为字符串分隔符，该方法将Delim中的字符作为分隔符对字符串Str进行分割。如果Str为空，则函数内部的SAVE_PTR指针在下一次调用中将作为下一个分割字符串的起始位置。其实这就说明在函数strtok()内部使用了一个<strong>静态变量SAVE_PTR指针</strong>，用以<strong>记录分割一次之后_String中下一个字符串的位置</strong>。这种方法导致了一个问题，就是<strong>strtok()函数</strong>是<strong>线程不安全</strong>的（因为其<strong>函数内部使用到了静态存储区</strong>）。</p><p>除此之外，从函数的定义，第一个传入参数<strong>_String</strong>定义为<strong>char*而不是const char*</strong>，就说明<strong>strtok()函数不保证不修改传入数据的内容</strong>。实际上，<strong>第一个参数_String传进来的字符串，是会被strtok()函数所修改的</strong>，因此调用strtok()函数的时候应当注意。</p><p>c++中也提供了线程安全的字符串分割方法strtok_s，其原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *__cdecl <span class="title">strtok_s</span><span class="params">(<span class="keyword">char</span> *_Str,<span class="keyword">const</span> <span class="keyword">char</span> *_Delim,<span class="keyword">char</span> **_Context)</span></span>;</span><br></pre></td></tr></table></figure><p>strtok_s()函数增加了一个参数<strong>_Context</strong>，这个参数就是<strong>相当于strtok()函数中内部定义的静态SAVE_PTR指针</strong>，用来传递对字符串_String的处理进行到了哪里。</p></li></ul></li></ul><p><a href="https://blog.csdn.net/jay_zzs/article/details/106883832">参考文章：C/C++——字符串分割（strtok, strtok_s）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-字符串分割&quot;&gt;&lt;a href=&quot;#C-字符串分割&quot; class=&quot;headerlink&quot; title=&quot;C++字符串分割&quot;&gt;&lt;/a&gt;C++字符串分割&lt;/h1&gt;&lt;p&gt;字符串分割是编程中经常遇到的一个问题，采用C++语言实现字符串分割与其他语言有所不同，下面将采用</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    <category term="字符串分割" scheme="http://example.com/categories/C/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>C++ | OOP方法实现链式队列</title>
    <link href="http://example.com/2023/10/12/OOP%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97/"/>
    <id>http://example.com/2023/10/12/OOP%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97/</id>
    <published>2023-10-12T15:30:22.000Z</published>
    <updated>2023-10-12T15:31:24.215Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-OOP方法实现链式队列"><a href="#C-OOP方法实现链式队列" class="headerlink" title="C++ OOP方法实现链式队列"></a>C++ OOP方法实现链式队列</h1><ul><li><p>队列</p><p>队列（Queue）是一个<strong>先进先出（First In First Out, FIFO）</strong>的数据结构，即先入队的元素先出队。队列有<strong>两种存储形式：顺序存储和链式存储</strong>，采用顺序存储方式的队列称为顺序队列，采用链式存储的队列称为链式队列。顺序队列采用数组存储队列中的元素，由队头指针head和队尾指针tail表示队列的头尾。<strong>链式队列采用链表实现，由头结点和若干个队列元素节点组成，头结点包括队头指针head、队尾指针和队列大小size三个域，head指针指向队头，tail指针指向队尾，队列元素节点由值域val和指针域next组成，val代表队列元素的值，next代表指向下一个队列结点的指针。</strong>其中，较为常用的是链式队列，下面将详细介绍链式队列的属性、方法以及C++代码实现。</p></li><li><p>队列属性和方法介绍</p><p>对队列进行抽象，可将其表示为包括队头指针、队尾指针和队列大小三个属性的数据结构。队列的基本操作包括入队、出队、队列判空、队列销毁、队列元素输出等，其伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列定义</span></span><br><span class="line">queue：</span><br><span class="line">    head, tail, size<span class="comment">//head:队头指针、tail：队尾指针、size：队列大小</span></span><br><span class="line">    <span class="built_in">enqueue</span>(elem)<span class="comment">//入队</span></span><br><span class="line">    <span class="built_in">dequeue</span>()<span class="comment">//出队</span></span><br><span class="line">    <span class="built_in">is_empty</span>()<span class="comment">//队列判空</span></span><br><span class="line">    <span class="built_in">destory</span>()<span class="comment">//队列销毁</span></span><br><span class="line">    <span class="built_in">traverse</span>()<span class="comment">//队列元素输出</span></span><br></pre></td></tr></table></figure></li><li><p>链式队列C++实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列中的元素结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> val;<span class="comment">//值域</span></span><br><span class="line">        QueueNode *next;<span class="comment">//指针域，指向下一个队列元素</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> size;<span class="comment">//队列大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        QueueNode *head;<span class="comment">//队头指针</span></span><br><span class="line">        QueueNode *tail;<span class="comment">//队尾指针</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">Queue</span>();<span class="comment">//构造函数，完成对象初始化工作</span></span><br><span class="line">        ~<span class="built_in">Queue</span>();<span class="comment">//析构函数</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">int</span> val)</span></span>;<span class="comment">//入队</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">dequeue</span><span class="params">()</span></span>;<span class="comment">//出队</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">is_empty</span><span class="params">()</span></span>;<span class="comment">//队列判空</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span></span>;<span class="comment">//销毁队列</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">()</span></span>;<span class="comment">//输出队列中的所有元素</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">get_size</span><span class="params">()</span></span>;<span class="comment">//获取队列大小</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取队列大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Queue::get_size</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">Queue::<span class="built_in">Queue</span>()&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;head = <span class="keyword">this</span>-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">Queue::~<span class="built_in">Queue</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Queue::enqueue</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    QueueNode *node = (QueueNode *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(QueueNode));</span><br><span class="line"></span><br><span class="line">    node-&gt;val = val;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;head = node;</span><br><span class="line">        <span class="keyword">this</span>-&gt;tail = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;tail-&gt;next = node;</span><br><span class="line">        <span class="keyword">this</span>-&gt;tail = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;size += <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Queue::dequeue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;<span class="built_in">is_empty</span>() == <span class="number">1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;队列为空，没有元素可以出队，请先向队列中添加元素！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> val = <span class="keyword">this</span>-&gt;head-&gt;val;</span><br><span class="line">    <span class="keyword">this</span>-&gt;head = <span class="keyword">this</span>-&gt;head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;size -= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列判空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Queue::is_empty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;size == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出所有队列元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Queue::traverse</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;<span class="built_in">is_empty</span>() == <span class="number">1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;队列为空！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;队列所有元素如下：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    QueueNode *p_node = <span class="keyword">this</span>-&gt;head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p_node != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; p_node-&gt;val &lt;&lt; endl;</span><br><span class="line">        p_node = p_node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Queue::destory</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;<span class="built_in">is_empty</span>() == <span class="number">1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;队列中没有元素！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="keyword">this</span>-&gt;<span class="built_in">dequeue</span>();</span><br><span class="line">    <span class="keyword">while</span>(val != <span class="number">-1</span>)&#123;</span><br><span class="line">        val = <span class="keyword">this</span>-&gt;<span class="built_in">dequeue</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;queue is destroyed!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//队列定义</span></span><br><span class="line">    Queue queue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作队列</span></span><br><span class="line">    queue.<span class="built_in">enqueue</span>(<span class="number">1</span>);<span class="comment">//元素入队列</span></span><br><span class="line">    queue.<span class="built_in">enqueue</span>(<span class="number">2</span>);</span><br><span class="line">    queue.<span class="built_in">enqueue</span>(<span class="number">3</span>);</span><br><span class="line">    queue.<span class="built_in">enqueue</span>(<span class="number">4</span>);</span><br><span class="line">    queue.<span class="built_in">enqueue</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">int</span> val = queue.<span class="built_in">dequeue</span>();<span class="comment">//元素出队列</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;出队元素为：&quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">    queue.<span class="built_in">traverse</span>();<span class="comment">//输出所有队列元素</span></span><br><span class="line">    queue.<span class="built_in">destory</span>();<span class="comment">//销毁队列</span></span><br><span class="line">    queue.<span class="built_in">traverse</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;queue.size:&quot;</span> &lt;&lt; queue.<span class="built_in">get_size</span>() &lt;&lt; endl;<span class="comment">//输出队列大小</span></span><br><span class="line">    cout &lt;&lt; queue.<span class="built_in">is_empty</span>() &lt;&lt; endl;<span class="comment">//队列判空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><a href="https://blog.csdn.net/LiuBo_01/article/details/80412290">参考资料：队列的基本操作（顺序队列、循环队列、链式队列）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-OOP方法实现链式队列&quot;&gt;&lt;a href=&quot;#C-OOP方法实现链式队列&quot; class=&quot;headerlink&quot; title=&quot;C++ OOP方法实现链式队列&quot;&gt;&lt;/a&gt;C++ OOP方法实现链式队列&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;队列&lt;/p&gt;
&lt;p&gt;队列（</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    <category term="OOP方法实现链式队列" scheme="http://example.com/categories/C/OOP%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="OOP" scheme="http://example.com/tags/OOP/"/>
    
    <category term="链式队列" scheme="http://example.com/tags/%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>C++ | lambda表达式</title>
    <link href="http://example.com/2023/10/10/cpluspluslambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://example.com/2023/10/10/cpluspluslambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2023-10-11T03:46:38.000Z</published>
    <updated>2023-10-11T03:48:09.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><ol><li><p>lambda表达式是什么？</p><p>Lambda 表达式（通常称为 Lambda）是一种在被调用的位置或作为参数传递给函数的位置定义匿名函数对象（闭包）的简便方法。</p></li><li><p>lambda表达式的语法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture list] (parameters) <span class="function"><span class="keyword">mutable</span> <span class="title">throw</span><span class="params">()</span> -&gt; <span class="keyword">return</span>-type </span>&#123;statement&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p><strong>capture list</strong>: 在C ++规范中也称为<strong>Lambda导入器</strong>， 捕获列表总是出现在Lambda函数的开始处。实际上，[]是Lambda引出符。编译器根据该引出符判断接下来的代码是否是Lambda函数，<strong>捕获列表能够捕捉上下文中的变量以供Lambda函数使用</strong>。</p><p><strong>parameters</strong>: 与普通函数参数列表一致。不需要参数传递时，可以省略“（）”。</p><p><strong>mutable</strong>: mutable修饰符修饰的函数为可变函数， 默认情况下Lambda函数总是一个const函数，mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）。</p><p><strong>throw()</strong>:  用于Lamdba表达式内部函数抛出异常。</p><p><strong>return-type</strong>: 函数的返回值类型，不需要返回值时可以连“-&gt;”一起省略。若在返回值类型明确的情况下省略该部分，编译器会对返回值类型进行自动推导。</p><p><strong>{statement}</strong>: 函数体，可以使用函数参数和所有capture list捕获的变量。</p></li><li><p>capture list详解</p><p>Lambda 可在其主体中引入新的变量（用 C++14），它还可以访问（或“捕获”）周边范围内的变量。 Lambda 以 capture 子句开头。 它指定捕获哪些变量，以及捕获是通过值还是通过引用进行的。 有与号 (<code>&amp;</code>) 前缀的变量通过引用进行访问，没有该前缀的变量通过值进行访问。</p><p><strong>空 capture 子句 <code>[ ]</code> 指示 lambda 表达式的主体不访问封闭范围中的变量。</strong></p><p><strong><code>[&amp;]</code> 表示通过引用捕获引用的所有变量，而 <code>[=]</code> 表示通过值捕获它们。</strong></p></li></ol><p>​        注意：捕获列表不允许变量重复传递。例如[=, a]或[&amp;,&amp;a]，=已经通过值捕获方式捕获了所有变量，&amp;已经通        过引用捕获方式捕获了所有变量。</p><ol><li><p>lambda表达式示例</p><ul><li><p>[]不捕获任何变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> func = [](string words) -&gt; <span class="keyword">void</span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        []:捕获列表为空，表示不捕获任何变量</span></span><br><span class="line"><span class="comment">        words:函数参数</span></span><br><span class="line"><span class="comment">        -&gt;void：函数返回值为void</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;hello,&quot;</span> &lt;&lt; words &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">func</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>[&amp;]以引用传递方式捕获所有变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">auto</span> func = [&amp;]() -&gt; <span class="keyword">void</span>&#123;</span><br><span class="line">        <span class="comment">// [&amp;]:以引用传递方式捕获变量</span></span><br><span class="line">        <span class="comment">// -&gt;void：函数返回值为void</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;i:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; j:&quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>[=]以值传递方式捕获所有变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">int num1 = 1;</span><br><span class="line">int num2 = 2;</span><br><span class="line">    auto add = [=]() -&gt; int&#123;</span><br><span class="line">        /*</span><br><span class="line">        [=]:以值传递方式捕获变量</span><br><span class="line">        -&gt;int：函数返回值为int</span><br><span class="line">        */</span><br><span class="line">        return num1 + num2;</span><br><span class="line">    &#125;;</span><br><span class="line">    int sum = add();</span><br><span class="line">    cout &lt;&lt; &quot;num1+num2=&quot; &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;lambda表达式&quot;&gt;&lt;a href=&quot;#lambda表达式&quot; class=&quot;headerlink&quot; title=&quot;lambda表达式&quot;&gt;&lt;/a&gt;lambda表达式&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;lambda表达式是什么？&lt;/p&gt;
&lt;p&gt;Lambda 表达式（通常称为 Lambda）是一种在被调用的位置或作为参数传递给函数的位置定义匿名函数对象（闭包）的简便方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;lambda表达式的语法&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[capture list] (parameters) &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;mutable&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;throw&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; -&amp;gt; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;-type &lt;/span&gt;&amp;#123;statement&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    <category term="lambda表达式" scheme="http://example.com/categories/C/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="lambda表达式" scheme="http://example.com/tags/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>C++ | 二级指针</title>
    <link href="http://example.com/2023/10/10/cplusplus%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88/"/>
    <id>http://example.com/2023/10/10/cplusplus%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88/</id>
    <published>2023-10-11T03:43:43.000Z</published>
    <updated>2023-10-11T03:44:51.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="c-二级指针"><a href="#c-二级指针" class="headerlink" title="c++二级指针"></a>c++二级指针</h1><ul><li><p>普通变量作为形参</p><p>在函数中采用普通变量接收实参传递的变量，对变量的操作是对实参拷贝值的操作，不会改变原有变量的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change_value</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">  a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;before changed,a=&quot;</span> &lt;&lt; a &lt;&lt; endl;<span class="comment">//输出：before changed,a=10</span></span><br><span class="line">    <span class="built_in">change_value</span>(a);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after changed,a=&quot;</span> &lt;&lt; a &lt;&lt; endl;<span class="comment">//输出：after changed,a=10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>指针变量作为形参</p><p>由上可知，普通变量作为形参时，对变量的操作其实是对拷贝值的操作，不会改变原来变量的值，若要改变原来变量的值，可采用指针变量作为形参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change_value</span><span class="params">(<span class="keyword">int</span> *p)</span></span>&#123;</span><br><span class="line">    *p = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;before changed,a=&quot;</span> &lt;&lt; a &lt;&lt; endl;<span class="comment">//输出：before changed,a=10</span></span><br><span class="line">    <span class="built_in">change_value</span>(&amp;a);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after changed,a=&quot;</span> &lt;&lt; a &lt;&lt; endl;<span class="comment">//输出：after changed,a=20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二级指针作为形参</p><p>以上是通过函数修改普通变量的值，若要对指针变量的指向进行修改，则需要使用二级指针来实现。</p><p>首先在函数中，采用指针变量作为形参接收实参传递的指针，示例代码如下，由代码输出结果可知，用指针变量作为形参不能够修改原来指针的指向。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change_value</span><span class="params">(<span class="keyword">int</span> *p)</span></span>&#123;</span><br><span class="line">p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;before changed,*p=&quot;</span> &lt;&lt; *p &lt;&lt; endl;<span class="comment">//before changed,*p=10</span></span><br><span class="line">    <span class="built_in">change_value</span>(p);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after changed,*p=&quot;</span> &lt;&lt; *p &lt;&lt; endl;<span class="comment">//after changed,*p=10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下代码是二级指针作为形参的示例代码，由代码输出可知，二级指针作为形参时可以修改原来指针变量的指向。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change_value</span><span class="params">(<span class="keyword">int</span> **p)</span></span>&#123;</span><br><span class="line">    *p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">    <span class="keyword">int</span> **pp = &amp;p;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;before changed,*p&quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">change_value</span>(pp);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;before changed,*p&quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after changed,**pp&quot;</span> &lt;&lt; **pp &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>此外，二级指针还常与结构体、数组一起使用，二级指针搭配结构体/数组的使用将在后续补充 ！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;c-二级指针&quot;&gt;&lt;a href=&quot;#c-二级指针&quot; class=&quot;headerlink&quot; title=&quot;c++二级指针&quot;&gt;&lt;/a&gt;c++二级指针&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;普通变量作为形参&lt;/p&gt;
&lt;p&gt;在函数中采用普通变量接收实参传递的变量，对变量的操作是</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    <category term="二级指针" scheme="http://example.com/categories/C/%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="二级指针" scheme="http://example.com/tags/%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>C++ | 指针与引用的区别</title>
    <link href="http://example.com/2023/10/09/C-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2023/10/09/C-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2023-10-09T12:26:43.000Z</published>
    <updated>2023-10-09T12:40:06.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-指针与引用"><a href="#C-指针与引用" class="headerlink" title="C++指针与引用"></a>C++指针与引用</h1><p>学习c++时，很容易混淆指针和引用的用法，以及对指针与引用的使用存在些许疑惑，下面通过示例代码说明指针和引用的区别。</p><ul><li>指针与引用的区别？</li></ul><ol><li>定义和性质不同</li></ol><p>指针是一个变量，其存储的是一个地址，该地址指向内存的一个存储单元；举例，张三的身份证看做一个指针，这个指针指向了张三，张三的妈妈夸奖了身份证不等于张三的妈妈夸奖了张三。</p><p>引用是一个变量的别名，跟原来的变量实质上是同一个东西，类似于日常生活中“小名”的意思，例如张三的小名叫毛蛋，张三与毛蛋都指的是张三这个人，张三的妈妈夸奖了张三等于张三的妈妈夸奖了毛蛋。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">996</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a; <span class="comment">// p是指针, &amp;在此是求地址运算</span></span><br><span class="line"><span class="keyword">int</span> &amp;r = a; <span class="comment">// r是引用, &amp;在此起标识作用</span></span><br></pre></td></tr></table></figure><p>上面定义了一个整型变量 a，p 是一个指针变量，p 的值是变量 a 的地址；</p><p>而引用 r，是 a 的一个别名，在内存中 r 和 a 占有同一个存储单元。</p><span id="more"></span><ol start="2"><li>指针可以有多级，引用只能是一级</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> **p; <span class="comment">// 合法</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;a; <span class="comment">// 不合法</span></span><br></pre></td></tr></table></figure><ol start="3"><li>指针可以在定义的时候不初始化，引用必须在定义的时候初始化</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p; <span class="comment">// 合法</span></span><br><span class="line"><span class="keyword">int</span> &amp;r; <span class="comment">// 不合法</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">996</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r = a; <span class="comment">// 合法</span></span><br></pre></td></tr></table></figure><ol start="4"><li>指针可以指向NULL，引用不可以为NULL</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>; <span class="comment">// 合法</span></span><br><span class="line"><span class="keyword">int</span> &amp;r = <span class="literal">NULL</span>; <span class="comment">// 不合法</span></span><br></pre></td></tr></table></figure><ol start="5"><li>指针初始化之后可以再改变，引用不可以</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">996</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a; <span class="comment">// 初始化, p 是 a 的地址</span></span><br><span class="line"><span class="keyword">int</span> &amp;r = a; <span class="comment">// 初始化, r 是 a 的引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">885</span>;</span><br><span class="line">p = &amp;b;<span class="comment">// 合法, p 更改为 b 的地址</span></span><br><span class="line">r = b; <span class="comment">// 不合法, r 不可以再变,运行不会报错，实际上是将别名为r的a变量的值修改为b的值885</span></span><br></pre></td></tr></table></figure><ol start="6"><li>sizeof 的运算结果不同</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">996</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"><span class="keyword">int</span> &amp;r = a;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(p); <span class="comment">// 返回 int* 类型的大小</span></span><br><span class="line">cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(r); <span class="comment">// 返回 int 类型的大小</span></span><br></pre></td></tr></table></figure><ol start="7"><li>自增运算意义不同</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">996</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"><span class="keyword">int</span> &amp;r = a;</span><br><span class="line"></span><br><span class="line">p++;<span class="comment">//p++之后指向a后面的内存</span></span><br><span class="line">r++;<span class="comment">//r++相当于a++</span></span><br></pre></td></tr></table></figure><ol start="8"><li>指针和引用作为函数参数时，指针需要检查是否为空，引用不需要</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun_p</span><span class="params">(<span class="keyword">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 需要检查P是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun_r</span><span class="params">(<span class="keyword">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 不需要检查r</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>指针与引用的使用</li></ul><p>指针和引用都可以作为函数参数，指针和引用作为函数参数时，函数直接对函数形参对应的实参的值进行修改。因此，当函数会修改形参对应实参的值时，采用指针和引用作为函数参数，当函数不需要修改形参对应实参值时，采用值传递即可，即采用普通变量作为函数参数。关于指针与引用的推荐使用方法如下所示：</p><table><thead><tr><th align="center">数据类型</th><th>只使用传递过来的值，而不对值进行修改</th><th>需要修改传递过来的值</th></tr></thead><tbody><tr><td align="center">内置数据类型</td><td>按值传递（小型结构）</td><td>指针传递</td></tr><tr><td align="center">数组</td><td>指针传递</td><td>指针传递</td></tr><tr><td align="center">结构</td><td>指针或引用（较大的结构）</td><td>指针或引用</td></tr><tr><td align="center">类、对象</td><td>引用传递</td><td>引用传递</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;C-指针与引用&quot;&gt;&lt;a href=&quot;#C-指针与引用&quot; class=&quot;headerlink&quot; title=&quot;C++指针与引用&quot;&gt;&lt;/a&gt;C++指针与引用&lt;/h1&gt;&lt;p&gt;学习c++时，很容易混淆指针和引用的用法，以及对指针与引用的使用存在些许疑惑，下面通过示例代码说明指针和引用的区别。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指针与引用的区别？&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;定义和性质不同&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;指针是一个变量，其存储的是一个地址，该地址指向内存的一个存储单元；举例，张三的身份证看做一个指针，这个指针指向了张三，张三的妈妈夸奖了身份证不等于张三的妈妈夸奖了张三。&lt;/p&gt;
&lt;p&gt;引用是一个变量的别名，跟原来的变量实质上是同一个东西，类似于日常生活中“小名”的意思，例如张三的小名叫毛蛋，张三与毛蛋都指的是张三这个人，张三的妈妈夸奖了张三等于张三的妈妈夸奖了毛蛋。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;996&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *p = &amp;amp;a; &lt;span class=&quot;comment&quot;&gt;// p是指针, &amp;amp;在此是求地址运算&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &amp;amp;r = a; &lt;span class=&quot;comment&quot;&gt;// r是引用, &amp;amp;在此起标识作用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;上面定义了一个整型变量 a，p 是一个指针变量，p 的值是变量 a 的地址；&lt;/p&gt;
&lt;p&gt;而引用 r，是 a 的一个别名，在内存中 r 和 a 占有同一个存储单元。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    <category term="指针与引用" scheme="http://example.com/categories/C/%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="指针" scheme="http://example.com/tags/%E6%8C%87%E9%92%88/"/>
    
    <category term="引用" scheme="http://example.com/tags/%E5%BC%95%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux | shell脚本</title>
    <link href="http://example.com/2023/10/07/shell%E8%84%9A%E6%9C%AC/"/>
    <id>http://example.com/2023/10/07/shell%E8%84%9A%E6%9C%AC/</id>
    <published>2023-10-07T12:56:01.000Z</published>
    <updated>2023-10-07T13:57:09.164Z</updated>
    
    <content type="html"><![CDATA[<h1 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h1><ul><li><p>shell脚本可将环境变量添加、依赖安装、二进制文件执行等命令包含在一个后缀为.sh的文本文件中，从而便于对应用的<strong>自动化运维</strong>。</p></li><li><p>常见的shell脚本语法</p><ol><li>向窗口输出文本</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;hello world&quot;</span><br></pre></td></tr></table></figure><ol start="2"><li>for  loop</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for file in `ls /etc`;do</span><br><span class="line">echo $file</span><br><span class="line">done</span><br></pre></td></tr></table></figure><ol start="3"><li><p>变量定义以及使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 输出变量内容</span></span><br><span class="line">word=&quot;this is a string!&quot;</span><br><span class="line">echo $word</span><br><span class="line">echo &quot;word变量的内容是$&#123;word&#125;。&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 只读变量</span></span><br><span class="line">my_name=&quot;liao sheng li&quot;</span><br><span class="line">readonly my_name</span><br><span class="line">echo $my_name</span><br><span class="line">my_name=&quot;sheng li&quot; # ./test.sh:行20: my_name：只读变量</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除变量</span></span><br><span class="line">username=&quot;zhang san&quot;</span><br><span class="line">echo $username</span><br><span class="line">unset username</span><br><span class="line">echo $suername  # 不会输出内容</span><br></pre></td></tr></table></figure></li><li><p>shell字符串</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 输出字符串</span></span><br><span class="line">echo &quot;hello&quot; # 双引号方式表示字符串</span><br><span class="line">echo &#x27;hello&#x27; # 单引号方式表示字符串</span><br><span class="line">echo hello # 不使用引号方式</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拼接字符串</span></span><br><span class="line">echo &quot;hello,&quot;world&quot;!&quot;</span><br><span class="line">echo &#x27;hello,&#x27;world&#x27;!&#x27;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取字符串长度</span></span><br><span class="line">string=&quot;hello&quot;</span><br><span class="line">echo &quot;字符串的长度为：$&#123;#string&#125;&quot;</span><br><span class="line">echo &quot;字符串的长度为：$&#123;#string[0]&#125;&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提取子字符串</span></span><br><span class="line">string1=&quot;the sky is blue!&quot;</span><br><span class="line">echo $&#123;string1:4:3&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找子字符串</span></span><br><span class="line">string2=&quot;this is a long string!&quot;</span><br><span class="line">echo `expr index &quot;$string2&quot; is`</span><br></pre></td></tr></table></figure></li></ol></li></ul><ol start="5"><li><p>shell数组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 定义数组</span></span><br><span class="line">arr1=(1 2 3 4 5 6 7 8 9 10)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 读取数组</span></span><br><span class="line">echo $&#123;arr1&#125;</span><br><span class="line">elem1=$&#123;arr1[0]&#125; # 输出下表为0时的数组元素</span><br><span class="line">echo $elem1</span><br><span class="line">echo $&#123;arr1[@]&#125; #输出数组所有元素</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取数组的长度</span></span><br><span class="line">echo $&#123;#arr1[@]&#125;  # 输出数组长度</span><br><span class="line">echo $&#123;#arr1[*]&#125; # 输出数组长度</span><br><span class="line">echo $&#123;#arr1[0]&#125; #输出下表为0的数组元素的长度</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关联数组</span></span><br><span class="line">declare -A site1=([&quot;google&quot;]=&quot;www.google.com&quot; [&quot;runoob&quot;]=&quot;www.runoob.com&quot; [&quot;taobao&quot;]=&quot;www.taobao.com&quot;)</span><br><span class="line">echo $&#123;site1[&quot;google&quot;]&#125;</span><br><span class="line">echo $&#123;site1[@]&#125;</span><br><span class="line">declare -A site2</span><br><span class="line">site2[&quot;google&quot;]=&quot;www.google.com&quot;</span><br><span class="line">site2[&quot;runoob&quot;]=&quot;www.runoob.com&quot;</span><br><span class="line">site2[&quot;taobao&quot;]=&quot;www.taobao.com&quot;</span><br><span class="line">echo $&#123;site2[&quot;taobao&quot;]&#125;</span><br><span class="line">echo $&#123;site2[*]&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>shell注释</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这是一个单行注释</span></span><br><span class="line"></span><br><span class="line">: &lt;&lt;COMMENT</span><br><span class="line">这是</span><br><span class="line">一个</span><br><span class="line">多行注释！</span><br><span class="line">COMMENT</span><br><span class="line"></span><br><span class="line">: &#x27;</span><br><span class="line">这是一个</span><br><span class="line">多行注释</span><br><span class="line">&#x27;</span><br></pre></td></tr></table></figure></li><li><p>shell传递参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;此处执行shell脚本的命令为./test.sh 1 2 3&quot;</span><br><span class="line">echo &quot;执行的文件名：$0&quot;</span><br><span class="line">echo &quot;执行的文件名：$1&quot;</span><br><span class="line">echo &quot;执行的文件名：$2&quot;</span><br><span class="line">echo &quot;执行的文件名：$3&quot;</span><br><span class="line">: &#x27;</span><br><span class="line">执行结果：</span><br><span class="line">执行的文件名：./test.sh</span><br><span class="line">执行的文件名：1</span><br><span class="line">执行的文件名：2</span><br><span class="line">执行的文件名：3</span><br><span class="line">&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 处理参数的集中特殊字符</span></span><br><span class="line">echo $# # 输出传递给脚本的参数个数，执行脚本./test.sh 1 2 3输出3</span><br><span class="line">echo $* # 以单个字符串显示所有传递个脚本的参数就，执行脚本./test.sh 1 2 3输出1 2 3</span><br><span class="line">echo $$ # 输出脚本运行的当前进行ID号</span><br><span class="line">echo $@ # 与$*相同</span><br><span class="line">echo $-</span><br><span class="line">echo $? #显示最后命令的退出状态，0表示没有错误，其他任何值表明有错误</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> $*与<span class="variable">$@</span>的区别</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> $*</span></span><br><span class="line">for i in &quot;$*&quot;; do</span><br><span class="line">echo $i</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="variable">$@</span></span></span><br><span class="line">for i in &quot;$@&quot;; do</span><br><span class="line">echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li><li><p>shell运算符</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 算数运算符</span></span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line">val=`expr $a + $b`</span><br><span class="line">echo &quot;a + b : $val&quot;</span><br><span class="line">val=`expr $a - $b`</span><br><span class="line">echo &quot;a - b : $val&quot;</span><br><span class="line">val=`expr $a \* $b`</span><br><span class="line">echo &quot;a * b : $val&quot;</span><br><span class="line">val=`expr $b / $a`</span><br><span class="line">echo &quot;b / a : $val&quot;</span><br><span class="line">val=`expr $b % $a`</span><br><span class="line">echo &quot;b % a : $val&quot;</span><br><span class="line">if [ $a == $b ]</span><br><span class="line">then</span><br><span class="line">echo &quot;a 等于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a != $b ]</span><br><span class="line">then</span><br><span class="line">echo &quot;a 不等于 b&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关系运算符</span></span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line">if [ $a -eq $b ] # 判断两个数字的值是否相等</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -eq $b : a 等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -eq $b: a 不等于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a -ne $b ] # 判断两个数字的值是否不相等</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -ne $b: a 不等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -ne $b : a 等于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a -gt $b ] # 判断一个数字是否大于另一个数字</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -gt $b: a 大于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -gt $b: a 不大于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a -lt $b ] # 判断一个数字是否小于另一个数字</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -lt $b: a 小于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -lt $b: a 不小于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a -ge $b ] # 判断一个数字是否大于小于另一个数字</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -ge $b: a 大于或等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -ge $b: a 小于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a -le $b ] # 判断一个数字是否小于等于另一个数字</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -le $b: a 小于或等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -le $b: a 大于 b&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 布尔运算符</span></span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line">if [ $a != $b ] # 非</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a != $b : a 不等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a == $b: a 等于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a -lt 100 -a $b -gt 15 ] # 与</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a 小于 100 且 $b 大于 15 : 返回 true&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a 小于 100 且 $b 大于 15 : 返回 false&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a -lt 100 -o $b -gt 100 ] # 或</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a 小于 100 或 $b 大于 100 : 返回 true&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a 小于 100 或 $b 大于 100 : 返回 false&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a -lt 5 -o $b -gt 100 ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a 小于 5 或 $b 大于 100 : 返回 true&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a 小于 5 或 $b 大于 100 : 返回 false&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 逻辑运算符</span></span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line">if [[ $a -lt 100 &amp;&amp; $b -gt 100 ]] # 逻辑与</span><br><span class="line">then</span><br><span class="line">   echo &quot;返回 true&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;返回 false&quot;</span><br><span class="line">fi</span><br><span class="line">if [[ $a -lt 100 || $b -gt 100 ]] # 逻辑或</span><br><span class="line">then</span><br><span class="line">   echo &quot;返回 true&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;返回 false&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 字符串运算符</span></span><br><span class="line">a=&quot;abc&quot;</span><br><span class="line">b=&quot;efg&quot;</span><br><span class="line">if [ $a = $b ] #  判断字符串是否相等</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a = $b : a 等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a = $b: a 不等于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a != $b ] #  判断字符串是否不相等</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a != $b : a 不等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a != $b: a 等于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ -z $a ] #  判断字符串长度是否为0</span><br><span class="line">then</span><br><span class="line">   echo &quot;-z $a : 字符串长度为 0&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;-z $a : 字符串长度不为 0&quot;</span><br><span class="line">fi</span><br><span class="line">if [ -n &quot;$a&quot; ] #  判断字符串长度是否不为0</span><br><span class="line">then</span><br><span class="line">   echo &quot;-n $a : 字符串长度不为 0&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;-n $a : 字符串长度为 0&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a ] #  判断字符串是否为空</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a : 字符串不为空&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a : 字符串为空&quot;</span><br><span class="line">fi</span><br><span class="line">echo &quot;&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 文件测试运算符</span></span><br><span class="line">file=&quot;./test.sh&quot;</span><br><span class="line">if [ -r $file ] # 判断文件是否可读</span><br><span class="line">then</span><br><span class="line">   echo &quot;文件可读&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;文件不可读&quot;</span><br><span class="line">fi</span><br><span class="line">if [ -w $file ] # 判断文件是否可写</span><br><span class="line">then</span><br><span class="line">   echo &quot;文件可写&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;文件不可写&quot;</span><br><span class="line">fi</span><br><span class="line">if [ -x $file ] # 判断文件是否可执行</span><br><span class="line">then</span><br><span class="line">   echo &quot;文件可执行&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;文件不可执行&quot;</span><br><span class="line">fi</span><br><span class="line">if [ -f $file ] # 判断文件是普通文件还是特殊文件</span><br><span class="line">then</span><br><span class="line">   echo &quot;文件为普通文件&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;文件为特殊文件&quot;</span><br><span class="line">fi</span><br><span class="line">if [ -d $file ] # 判断文件是不是一个目录</span><br><span class="line">then</span><br><span class="line">   echo &quot;文件是个目录&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;文件不是个目录&quot;</span><br><span class="line">fi</span><br><span class="line">if [ -s $file ] # 判断文件是否为空</span><br><span class="line">then</span><br><span class="line">   echo &quot;文件不为空&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;文件为空&quot;</span><br><span class="line">fi</span><br><span class="line">if [ -e $file ] # 判断文件是否存在</span><br><span class="line">then</span><br><span class="line">   echo &quot;文件存在&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;文件不存在&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li><li><p>shell echo命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显示普通字符串</span></span><br><span class="line">echo &quot;\&quot;显示转义字符\&quot;&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示变量</span></span><br><span class="line">read name # read 命令从标准输入中读取一行并赋值给name变量</span><br><span class="line">echo &quot;$name is one kind of color&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示换行</span></span><br><span class="line">echo -e &quot;hello\n&quot; # -e开启转义</span><br><span class="line">echo &quot;world&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示不换行</span></span><br><span class="line">echo -e &quot;OK! \c&quot; # \c不换行</span><br><span class="line">echo &quot;It is a test&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 原样输出字符串</span></span><br><span class="line">echo &#x27;$name\&quot;&#x27;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示命令执行结果</span></span><br><span class="line">echo `date`</span><br></pre></td></tr></table></figure></li><li><p>shell printf命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;hello&quot;</span><br><span class="line">printf &quot;hello\n&quot;</span><br><span class="line"></span><br><span class="line">printf &quot;%-10s %-8s %-4s\n&quot; 姓名 性别 体重kg  </span><br><span class="line">printf &quot;%-10s %-8s %-4.2f\n&quot; 郭靖 男 66.1234 </span><br><span class="line">printf &quot;%-10s %-8s %-4.2f\n&quot; 杨过 男 48.6543 </span><br><span class="line">printf &quot;%-10s %-8s %-4.2f\n&quot; 郭芙 女 47.9876</span><br></pre></td></tr></table></figure></li><li><p>test 命令</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">test</span> 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 数值测试</span></span><br><span class="line">num1=100</span><br><span class="line">num2=100</span><br><span class="line">if test $[num1] -eq $[num2] # 代码中的 [] 执行基本的算数运算</span><br><span class="line">then</span><br><span class="line">    echo &#x27;两个数相等！&#x27;</span><br><span class="line">else</span><br><span class="line">    echo &#x27;两个数不相等！&#x27;</span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 字符串测试</span></span><br><span class="line">num1=&quot;ru1noob&quot;</span><br><span class="line">num2=&quot;runoob&quot;</span><br><span class="line">if test $num1 = $num2</span><br><span class="line">then</span><br><span class="line">    echo &#x27;两个字符串相等!&#x27;</span><br><span class="line">else</span><br><span class="line">    echo &#x27;两个字符串不相等!&#x27;</span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 文件测试</span></span><br><span class="line">if test -e ./test.sh</span><br><span class="line">then</span><br><span class="line">    echo &#x27;文件已存在!&#x27;</span><br><span class="line">else</span><br><span class="line">    echo &#x27;文件不存在!&#x27;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><ol start="12"><li><p>shell 流程控制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 条件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用[...] 作为判断语句</span></span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line">if [ $a == $b ]</span><br><span class="line">then</span><br><span class="line">echo &quot;a 等于 b&quot;</span><br><span class="line">elif [ $a -gt $b ]</span><br><span class="line">then</span><br><span class="line">echo &quot;a 大于 b&quot;</span><br><span class="line">elif [ $a -lt $b ]</span><br><span class="line">then</span><br><span class="line">echo &quot;a 小于 b&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;没有符合的条件&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 ((...)) 作为判断语句,大于和小于可以直接使用 &gt; 和 &lt;</span></span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line">if (( $a == $b ))</span><br><span class="line">then</span><br><span class="line">echo &quot;a 等于 b&quot;</span><br><span class="line">elif (( $a &gt; $b ))</span><br><span class="line">then</span><br><span class="line">echo &quot;a 大于 b&quot;</span><br><span class="line">elif (( $a &lt; $b ))</span><br><span class="line">then</span><br><span class="line">echo &quot;a 小于 b&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;没有符合的条件&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 循环</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">for</span>循环</span></span><br><span class="line">for loop in 1 2 3 4 5</span><br><span class="line">do</span><br><span class="line">    echo &quot;The value is: $loop&quot;</span><br><span class="line">done</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">while</span>循环</span></span><br><span class="line">int=1</span><br><span class="line">while(( $int&lt;=5 ))</span><br><span class="line">do</span><br><span class="line">    echo $int</span><br><span class="line">    let &quot;int++&quot; # Bash let 命令，它用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量</span><br><span class="line">done</span><br><span class="line">: &#x27;</span><br><span class="line">无限循环</span><br><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">while true</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">for (( ; ; ))</span><br><span class="line">&#x27;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> until循环</span></span><br><span class="line">a=0</span><br><span class="line">until [ ! $a -lt 10 ]</span><br><span class="line">do</span><br><span class="line">   echo $a</span><br><span class="line">   a=`expr $a + 1`</span><br><span class="line">done</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">case</span>多选择语句</span></span><br><span class="line">echo &#x27;输入 1 到 4 之间的数字:&#x27;</span><br><span class="line">echo &#x27;你输入的数字为:&#x27;</span><br><span class="line">read aNum</span><br><span class="line">case $aNum in</span><br><span class="line">    1)  echo &#x27;你选择了 1&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    2)  echo &#x27;你选择了 2&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    3)  echo &#x27;你选择了 3&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    4)  echo &#x27;你选择了 4&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    *)  echo &#x27;你没有输入 1 到 4 之间的数字&#x27;</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 跳出循环</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">break</span></span></span><br><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    echo -n &quot;输入 1 到 5 之间的数字:&quot;</span><br><span class="line">    read aNum</span><br><span class="line">    case $aNum in</span><br><span class="line">        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;</span><br><span class="line">        ;;</span><br><span class="line">        *) echo &quot;你输入的数字不是 1 到 5 之间的! 游戏结束&quot;</span><br><span class="line">            break</span><br><span class="line">        ;;</span><br><span class="line">    esac</span><br><span class="line">done</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">continue</span></span></span><br><span class="line">: &#x27;</span><br><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    echo -n &quot;输入 1 到 5 之间的数字: &quot;</span><br><span class="line">    read aNum</span><br><span class="line">    case $aNum in</span><br><span class="line">        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;</span><br><span class="line">        ;;</span><br><span class="line">        *) echo &quot;你输入的数字不是 1 到 5 之间的!&quot;</span><br><span class="line">            continue</span><br><span class="line">            echo &quot;游戏结束&quot;</span><br><span class="line">        ;;</span><br><span class="line">    esac</span><br><span class="line">done</span><br><span class="line">&#x27;</span><br></pre></td></tr></table></figure></li><li><p>shell 函数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 无返回值函数</span></span><br><span class="line">demoFun()&#123;</span><br><span class="line">echo &quot;这是我的第一个 shell 函数!&quot;</span><br><span class="line">&#125;</span><br><span class="line">echo &quot;-----函数开始执行-----&quot;</span><br><span class="line">demoFun</span><br><span class="line">echo &quot;-----函数执行完毕-----&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 有返回值函数</span></span><br><span class="line">funWithReturn()&#123;</span><br><span class="line">    echo &quot;这个函数会对输入的两个数字进行相加运算...&quot;</span><br><span class="line">    echo &quot;输入第一个数字: &quot;</span><br><span class="line">    read aNum</span><br><span class="line">    echo &quot;输入第二个数字: &quot;</span><br><span class="line">    read anotherNum</span><br><span class="line">    echo &quot;两个数字分别为 $aNum 和 $anotherNum !&quot;</span><br><span class="line">    return $(($aNum+$anotherNum))</span><br><span class="line">&#125;</span><br><span class="line">funWithReturn</span><br><span class="line">echo &quot;输入的两个数字之和为 $? !&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 函数参数</span></span><br><span class="line">funWithParam()&#123;</span><br><span class="line">    echo &quot;第一个参数为 $1 !&quot;</span><br><span class="line">    echo &quot;第二个参数为 $2 !&quot;</span><br><span class="line">    echo &quot;第十个参数为 $10 !&quot;</span><br><span class="line">    echo &quot;第十个参数为 $&#123;10&#125; !&quot;</span><br><span class="line">    echo &quot;第十一个参数为 $&#123;11&#125; !&quot;</span><br><span class="line">    echo &quot;参数总数有 $# 个!&quot;</span><br><span class="line">    echo &quot;作为一个字符串输出所有参数 $* !&quot;</span><br><span class="line">&#125;</span><br><span class="line">funWithParam 1 2 3 4 5 6 7 8 9 34 73</span><br></pre></td></tr></table></figure></li><li><p>输入/输出重定向</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;print(&quot;hello&quot;)&#x27; &gt; hello.py</span><br></pre></td></tr></table></figure></li><li><p>shell文件包含</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">: &#x27;</span><br><span class="line">shell 脚本中可以包含外部脚本</span><br><span class="line"></span><br><span class="line">语法格式:</span><br><span class="line">. filename   # 注意点号(.)和文件名中间有一空格</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">source filename</span><br><span class="line">&#x27;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;shell脚本&quot;&gt;&lt;a href=&quot;#shell脚本&quot; class=&quot;headerlink&quot; title=&quot;shell脚本&quot;&gt;&lt;/a&gt;shell脚本&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;shell脚本可将环境变量添加、依赖安装、二进制文件执行等命令包含在一个后缀为.s</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    <category term="shell脚本" scheme="http://example.com/categories/Linux/shell%E8%84%9A%E6%9C%AC/"/>
    
    
    <category term="shell脚本" scheme="http://example.com/tags/shell%E8%84%9A%E6%9C%AC/"/>
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
</feed>
