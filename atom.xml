<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Victory&#39;s Blog</title>
  
  <subtitle>非淡泊无以明志，非宁静无以致远</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-09-04T10:54:29.587Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>victory-liao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>itertools | product</title>
    <link href="http://example.com/2021/09/04/product/"/>
    <id>http://example.com/2021/09/04/product/</id>
    <published>2021-09-04T09:16:27.000Z</published>
    <updated>2021-09-04T10:54:29.587Z</updated>
    
    <content type="html"><![CDATA[<h1 id="itertools-product"><a href="#itertools-product" class="headerlink" title="itertools.product()"></a>itertools.product()</h1><p>使用product()前需要导入itertools库<br><strong>用法1：</strong></p><pre><code>print(list(itertools.product(‘a&#39;, repeat=4)))   # 等价于 print(list(itertools.product(&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;)))a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]print(list(itertools.product(a, repeat=2)))  # s等价于 print(list(itertools.product(a, a)))</code></pre><p><strong>用法2：</strong></p><pre><code>print(list(itertools.product(a, b)))  # 等价于 print(list((x, y) for x in a for y in b))</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;itertools-product&quot;&gt;&lt;a href=&quot;#itertools-product&quot; class=&quot;headerlink&quot; title=&quot;itertools.product()&quot;&gt;&lt;/a&gt;itertools.product()&lt;/h1&gt;&lt;p&gt;使用prod</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="内置模块" scheme="http://example.com/categories/python/%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/"/>
    
    <category term="itertools" scheme="http://example.com/categories/python/%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/itertools/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="itertools" scheme="http://example.com/tags/itertools/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 电话号码的字母组合</title>
    <link href="http://example.com/2021/09/04/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    <id>http://example.com/2021/09/04/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</id>
    <published>2021-09-04T07:57:00.000Z</published>
    <updated>2021-09-04T10:52:21.422Z</updated>
    
    <content type="html"><![CDATA[<h1 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17.电话号码的字母组合"></a>17.电话号码的字母组合</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。<br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><span id="more"></span><p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.遍历并组合每一个数字对应的字母列表 –&gt; letterCombinations()<br><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/zhi-xing-yong-shi-ji-bai-9954nei-cun-xia-gwkb/">点击这里查看完整解题思路！！！</a><br>2.使用内置库 –&gt; letterCombinations1()<br>3.回溯 –&gt; letterCombinations2()<br><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/dian-hua-hao-ma-de-zi-mu-zu-he-by-leetcode-solutio/">回溯法和使用内置库思路见leetcode题解</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:    num2ch = &#123;        &#39;2&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],        &#39;3&#39;: [&#39;d&#39;, &#39;e&#39;, &#39;f&#39;],        &#39;4&#39;: [&#39;g&#39;, &#39;h&#39;, &#39;i&#39;],        &#39;5&#39;: [&#39;j&#39;, &#39;k&#39;, &#39;l&#39;],        &#39;6&#39;: [&#39;m&#39;, &#39;n&#39;, &#39;o&#39;],        &#39;7&#39;: [&#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;],        &#39;8&#39;: [&#39;t&#39;, &#39;u&#39;, &#39;v&#39;],        &#39;9&#39;: [&#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;]    &#125;    def letterCombinations(self, digits: str) -&gt; list:        if len(digits) == 0:            return []        list1 = []  # 用于存储digits数组中每个字符对应的字母列表        for d in digits:            list1.append(self.num2ch[d])        i = 0        j = 1        while j &lt; len(list1):            list1[j] = self.concat(list1[i], list1[j])            i = j            j += 1        return list1[-1]    def concat(self, list1, list2):        res = []        for e1 in list1:            for e2 in list2:                res.append(e1 + e2)        return res    def letterCombinations1(self, digits: str):        if not digits:            return list()        phoneMap = &#123;            &quot;2&quot;: &quot;abc&quot;,            &quot;3&quot;: &quot;def&quot;,            &quot;4&quot;: &quot;ghi&quot;,            &quot;5&quot;: &quot;jkl&quot;,            &quot;6&quot;: &quot;mno&quot;,            &quot;7&quot;: &quot;pqrs&quot;,            &quot;8&quot;: &quot;tuv&quot;,            &quot;9&quot;: &quot;wxyz&quot;,        &#125;        groups = (phoneMap[digit] for digit in digits)        import itertools        return [&quot;&quot;.join(combination) for combination in itertools.product(*groups)]    def letterCombinations2(self, digits: str):        if not digits:            return list()        phoneMap = &#123;            &quot;2&quot;: &quot;abc&quot;,            &quot;3&quot;: &quot;def&quot;,            &quot;4&quot;: &quot;ghi&quot;,            &quot;5&quot;: &quot;jkl&quot;,            &quot;6&quot;: &quot;mno&quot;,            &quot;7&quot;: &quot;pqrs&quot;,            &quot;8&quot;: &quot;tuv&quot;,            &quot;9&quot;: &quot;wxyz&quot;,        &#125;        def backtrack(index: int):            if index == len(digits):                combinations.append(&#39;&#39;.join(combination))            else:                digit = digits[index]                for letter in phoneMap[digit]:                    combination.append(letter)                    backtrack(index + 1)                    combination.pop()        combination = list()        combinations = list()        backtrack(0)        return combinationsif __name__ == &#39;__main__&#39;:    slt = Solution()    digits = &quot;23&quot;    res = slt.letterCombinations2(digits)    print(res)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;17-电话号码的字母组合&quot;&gt;&lt;a href=&quot;#17-电话号码的字母组合&quot; class=&quot;headerlink&quot; title=&quot;17.电话号码的字母组合&quot;&gt;&lt;/a&gt;17.电话号码的字母组合&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。&lt;br&gt;给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。&lt;/p&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="字符串" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 最长回文串</title>
    <link href="http://example.com/2021/09/03/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    <id>http://example.com/2021/09/03/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/</id>
    <published>2021-09-03T10:23:45.000Z</published>
    <updated>2021-09-04T07:55:21.821Z</updated>
    
    <content type="html"><![CDATA[<h1 id="5-最长回文串"><a href="#5-最长回文串" class="headerlink" title="5.最长回文串"></a>5.最长回文串</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 s，找到 s 中最长的回文子串。</p><span id="more"></span><p>示例 1：<br>输入：s = “babad”<br>输出：”bab”<br>解释：”aba” 同样是符合题意的答案。</p><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.暴力解法<br><strong>2.动态规划</strong><br><strong>3.中心扩展算法</strong><br>4.Manacher 算法<br>注：算法详情请参考leetcode题解</p><p><a href="https://writings.sh/post/algorithm-longest-palindromic-substring">几种方法的总结！！！强烈推荐！！！</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:    def longestPalindrome(self, s: str) -&gt; str:        &quot;&quot;&quot;暴力解法（超出时间限制）&quot;&quot;&quot;        # max_len = 0        # longest_palindrome = &quot;&quot;        # for i in range(0, len(s)):        #     for j in range(i+1, len(s)+1):        #         string = s[i:j]        #         # print(string)        #         if self.isPalindrome(string):        #             if len(string) &gt; max_len:        #                 max_len = len(string)        #                 longest_palindrome = string        #        # return longest_palindrome        len_s = len(s)        if len_s &lt; 2:            return s        max_len = 1        begin = 0        # 枚举所有长度严格大于1的字串        for i in range(0, len_s-1):            for j in range(i + 1, len_s):                if j - i + 1 &gt; max_len and self.isPalindrome(s[i: j+1]):                    max_len = j - i + 1                    begin = i        return s[begin:begin + max_len]    def isPalindrome(self, s: str) -&gt; bool:        &quot;&quot;&quot;        筛选+判断（判断反转字符串是否与原字符串相同）        &quot;&quot;&quot;        new_s = &quot;&quot;.join(ch.lower() for ch in s if ch.isalnum())        return new_s == new_s[::-1]    def longestPalindrome1(self, s: str) -&gt; str:        &quot;&quot;&quot;        动态规划算法        一个回文串去掉两头以后，剩下的部分依然是回文        -状态：dp[i][j]表示字串s[i..j]是否为回文子串        -得到状态转移方程：dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]         边界条件：j - 1 - (i + 1) + 1 &lt; 2,整理得j - i &lt; 3 &lt;===&gt; j - i + 1 &lt; 4         (s[i][j]长度为2或者3时，不用检查字串是否回文)        -初始化：dp[i][i] = true        -输出：在得到一个状态的值为true的时候，记录起始位置和长度，填表完成以后再截取        状态转移方程：dp[i][j] = (s[i] == s[j]) and (j - i &lt; 3 or dp[i + 1][j - 1]        &quot;&quot;&quot;        n = len(s)        if n &lt; 2:            return s        max_len = 1        begin = 0        # dp[i][j]表示s[i..j]是否是回文串        dp = [[False] * n for _ in range(n)]        for i in range(n):            dp[i][i] = True        # 注意：先填左下角        for j in range(1, n):            for i in range(0, j):                if s[i] != s[j]:                    dp[i][j] = False                else:                    if j - i &lt; 3:                        dp[i][j] = True                    else:                        dp[i][j] = dp[i + 1][j-1]                # 只要 dp[i][j] == true 成立，就表示子串 s[i..j] 是回文，此时记录回文长度和起始位置                if dp[i][j] and j - i + 1 &gt; max_len:                    max_len = j - i + 1                    begin = i        return s[begin:begin + max_len]    def longestPalindrome2(self, s: str) -&gt; str:        &quot;&quot;&quot;中心扩展算法&quot;&quot;&quot;        start = 0  # 最长回文串的起始位置        end = 0  # 最长回文串的结束位置        for i in range(len(s)):            left1, right1 = self.expandAroundCenter(s, i, i)  # 边界情况1：子串长度为1的情况            left2, right2 = self.expandAroundCenter(s, i, i + 1)  # # 边界情况2：子串长度为2的情况            if right1 - left1 &gt; end - start:  # 扩展的新回文串长度大于当前最长回文串                start, end = left1, right1            if right2 - left2 &gt; end - start:                start, end = left2, right2        return s[start:end + 1]    def expandAroundCenter(self, s, left, right):        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:            left -= 1            right += 1        return left + 1, right - 1    def expand(self, s, left, right):        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:            left -= 1            right += 1        return (right - left - 2) // 2    def longestPalindrome3(self, s: str) -&gt; str:        &quot;&quot;&quot;Manacher 算法&quot;&quot;&quot;        end = -1        start = 0        s = &#39;#&#39; + &#39;#&#39;.join(list(s)) + &#39;#&#39;        arm_len = []        right = -1        j = -1        for i in range(len(s)):            if right &gt;= i:                i_sym = 2 * j - i                min_arm_len = min(arm_len[i_sym], right - i)                cur_arm_len = self.expand(s, i - min_arm_len, i + min_arm_len)            else:                cur_arm_len = self.expand(s, i, i)            arm_len.append(cur_arm_len)            if i + cur_arm_len &gt; right:                j = i                right = i + cur_arm_len            if 2 * cur_arm_len + 1 &gt; end - start:                start = i - cur_arm_len                end = i + cur_arm_len        return s[start + 1:end + 1:2]if __name__ == &#39;__main__&#39;:    slt = Solution()    s = &quot;abad&quot;    res = slt.longestPalindrome(s)    print(&quot;最长的回文串为：&quot;, res)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;5-最长回文串&quot;&gt;&lt;a href=&quot;#5-最长回文串&quot; class=&quot;headerlink&quot; title=&quot;5.最长回文串&quot;&gt;&lt;/a&gt;5.最长回文串&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你一个字符串 s，找到 s 中最长的回文子串。&lt;/p&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="字符串" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 机器人能否返回原点</title>
    <link href="http://example.com/2021/09/03/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%83%BD%E5%90%A6%E8%BF%94%E5%9B%9E%E5%8E%9F%E7%82%B9/"/>
    <id>http://example.com/2021/09/03/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%83%BD%E5%90%A6%E8%BF%94%E5%9B%9E%E5%8E%9F%E7%82%B9/</id>
    <published>2021-09-03T08:33:46.000Z</published>
    <updated>2021-09-03T08:38:31.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="657-机器人能够返回原点"><a href="#657-机器人能够返回原点" class="headerlink" title="657.机器人能够返回原点"></a>657.机器人能够返回原点</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在二维平面上，有一个机器人从原点 (0, 0) 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 (0, 0) 处结束。<br>移动顺序由字符串表示。字符 move[i] 表示其第 i 次移动。机器人的有效动作有 R（右），L（左），U（上）和 D（下）。如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。<br>注意：机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。</p><span id="more"></span><p><a href="https://leetcode-cn.com/problems/robot-return-to-origin/">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>起始时机器人的坐标为 (0,0)，在遍历完所有指令并对机器人进行移动之后，判断机器人的坐标是否为 (0,0) 即可。</p><p>具体来说，我们用两个变量 x 和 y 来表示机器人当前所在的坐标为 (x,y)，起始时 x=0，y=0。接下来我们遍历指令并更新机器人的坐标：<br>    如果指令是 U，则令 y=y−1<br>    如果指令是 D，则令 y=y+1<br>    如果指令是 L，则令 x=x−1<br>    如果指令是 R，则令 x=x+1<br>最后判断 (x,y) 是否为 (0,0) 即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:    def judgeCircle(self, moves: str) -&gt; bool:        if len(moves) % 2 != 0:            return False        pos_x = 0        pos_y = 0        for move in moves:            if move == &#39;U&#39;:                pos_y += 1            elif move == &#39;D&#39;:                pos_y -= 1            elif move == &#39;R&#39;:                pos_x += 1            elif move == &#39;L&#39;:                pos_x -= 1        if pos_x == 0 and pos_y == 0:            return True        else:            return False    def judgeCircle1(self, moves: str) -&gt; bool:        if moves.count(&#39;L&#39;) == moves.count(&#39;R&#39;) and moves.count(&#39;U&#39;) == moves.count(&#39;D&#39;):            return True        else:            return Falseif __name__ == &quot;__main__&quot;:    slt = Solution()    res = slt.judgeCircle(&quot;UD&quot;)    # res = slt.judgeCircle1(&quot;LLL&quot;)    print(res)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;657-机器人能够返回原点&quot;&gt;&lt;a href=&quot;#657-机器人能够返回原点&quot; class=&quot;headerlink&quot; title=&quot;657.机器人能够返回原点&quot;&gt;&lt;/a&gt;657.机器人能够返回原点&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;在二维平面上，有一个机器人从原点 (0, 0) 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 (0, 0) 处结束。&lt;br&gt;移动顺序由字符串表示。字符 move[i] 表示其第 i 次移动。机器人的有效动作有 R（右），L（左），U（上）和 D（下）。如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。&lt;br&gt;注意：机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。&lt;/p&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="字符串" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 反转字符串中的单词3</title>
    <link href="http://example.com/2021/09/02/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D3/"/>
    <id>http://example.com/2021/09/02/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D3/</id>
    <published>2021-09-02T12:21:14.000Z</published>
    <updated>2021-09-03T08:50:04.125Z</updated>
    
    <content type="html"><![CDATA[<h1 id="557-反转字符串中的单词3"><a href="#557-反转字符串中的单词3" class="headerlink" title="557.反转字符串中的单词3"></a>557.反转字符串中的单词3</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p><span id="more"></span><p>示例：<br>输入：”Let’s take LeetCode contest”<br>输出：”s’teL ekat edoCteeL tsetnoc”</p><p><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.将字符串按照空格划分开得到字符串中的每一个单词,然后将每个单词反转<br>，在将反转后的所有单词用空格拼接起来<br>2.使用额外空间<br>开辟一个新字符串。然后从头到尾遍历原字符串，直到找到空格为止，此时找到了一个单词，并能得到单词的起止位置。随后，根据单词的起止位置，可以将该单词逆序放到新字符串当中。如此循环多次，直到遍历完原字符串，就能得到翻转后的结果。<br>3.原地解法<br>此题也可以直接在原字符串上进行操作，避免额外的空间开销。当找到一个单词的时候，我们交换字符串第一个字符与倒数第一个字符，随后交换第二个字符与倒数第二个字符……如此反复，就可以在原空间上翻转单词。<br>需要注意的是，原地解法在某些语言（比如 Java，JavaScript，python）中不适用，因为在这些语言中 String 类型是一个不可变的类型。<br>在python中可以先将字符串转为列表然后进行算法设计。</p><p><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/solution/python-fan-zhuan-zi-fu-chuan-zhong-dan-ci-si-lu-xi/">更多思路参考“一行流”，简直牛逼！！！</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:    def reverseWords(self, s: str) -&gt; str:        &quot;&quot;&quot;        将字符串按照空格划分开得到字符串中的每一个单词        将每个单词反转        将反转后的所有单词用空格拼接起来        &quot;&quot;&quot;        words = s.split(&#39; &#39;)        reversed_words = []        for word in words:            reversed_words.append(self.reverseStr(word))        return &#39; &#39;.join(reversed_words)    def reverseStr(self, s: str) -&gt; str:        s = list(s)        s[:] = s[::-1]        return &#39;&#39;.join(s)    def reverseWords2(self, s: str) -&gt; str:        &quot;&quot;&quot;使用额外空间&quot;&quot;&quot;        ret = &#39;&#39;        length = len(s)        i = 0        while i &lt; length:            start = i            # 遍历字符串找到空格位置（找到了一个单词）            while i &lt; length and s[i] != &#39; &#39;:                i += 1            # 根据单词的起止位置，可以将该单词逆序放到新字符串当中            for p in range(start, i):                ret += s[start + i - 1 - p]            # 拼上单词后的空格            while i &lt; length and s[i] == &#39; &#39;:                i += 1                ret += &#39; &#39;        return ret    def reverseWords3(self, s: str) -&gt; str:        s = list(s)  # python中字符串为不可变类型，不支持原地修改，可转列表        length = len(s)        i = 0        while i &lt; length:            start = i            while i &lt; length and s[i] != &#39; &#39;:                i += 1            left = start            right = i - 1            while left &lt; right:                s[left], s[right] = s[right], s[left]                left += 1                right -= 1            while i &lt; length and s[i] == &#39; &#39;:                i += 1        return &#39;&#39;.join(s)if __name__ == &quot;__main__&quot;:    slt = Solution()    s = &quot;Let&#39;s take LeetCode contest&quot;    res = slt.reverseWords3(s)    print(&quot;反转单词后的字符串：&quot;, res)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;557-反转字符串中的单词3&quot;&gt;&lt;a href=&quot;#557-反转字符串中的单词3&quot; class=&quot;headerlink&quot; title=&quot;557.反转字符串中的单词3&quot;&gt;&lt;/a&gt;557.反转字符串中的单词3&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。&lt;/p&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="字符串" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 学生出勤记录1</title>
    <link href="http://example.com/2021/09/02/%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E8%AE%B0%E5%BD%951/"/>
    <id>http://example.com/2021/09/02/%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E8%AE%B0%E5%BD%951/</id>
    <published>2021-09-02T12:13:33.000Z</published>
    <updated>2021-09-02T12:18:17.164Z</updated>
    
    <content type="html"><![CDATA[<h1 id="551-学生出勤记录1"><a href="#551-学生出勤记录1" class="headerlink" title="551.学生出勤记录1"></a>551.学生出勤记录1</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 s 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：<br>    ‘A’：Absent，缺勤<br>    ‘L’：Late，迟到<br>    ‘P’：Present，到场<br>如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：<br>    按 总出勤 计，学生缺勤（’A’）严格 少于两天。<br>    学生 不会 存在 连续 3 天或 连续 3 天以上的迟到（’L’）记录。<br>如果学生可以获得出勤奖励，返回 true ；否则，返回 false 。</p><span id="more"></span><p>示例 1：<br>输入：s = “PPALLP”<br>输出：true<br>解释：学生缺勤次数少于 2 次，且不存在 3 天或以上的连续迟到记录。</p><p><a href>题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.一次遍历<br>可奖励的出勤记录要求缺勤次数少于 2 和连续迟到次数少于 3。判断出勤记录是否可奖励，只需要遍历出勤记录，判断这两个条件是否同时满足即可。<br>遍历过程中，记录缺勤次数和连续迟到次数，根据遍历到的字符更新缺勤次数和连续迟到次数：<br>    如果遇到 ‘A’，即缺勤，则将缺勤次数加 1，否则缺勤次数不变；<br>    如果遇到 ‘L’，即迟到，则将连续迟到次数加 1，否则将连续迟到次数清零。<br>如果在更新缺勤次数和连续迟到次数之后，出现缺勤次数大于或等于 2 或者连续迟到次数大于或等于 3，则该出勤记录不满足可奖励的要求，返回 false。如果遍历结束时未出现出勤记录不满足可奖励的要求的情况，则返回 true。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:    def checkRecord(self, s: str) -&gt; bool:        # 统计字符串中出现‘A’的的次数        count_A = s.count(&#39;A&#39;)        # 字符串中是否有连续3个以上的‘L&#39;        for i in range(len(s)):            if i + 2 &lt; len(s) and s[i] == &#39;L&#39; and s[i+1] == &#39;L&#39; and s[i+2] == &#39;L&#39;:                    return False        return True if count_A &lt; 2 else False    def checkRecord1(self, s: str) -&gt; bool:        absents = lates = 0        for char in s:            if char == &quot;A&quot;:                absents += 1                lates = 0            elif char == &quot;L&quot;:                lates += 1            else:                lates = 0            if lates &gt;= 3 or absents &gt; 1:                return False        return True        # absents = lates = 0        # for i, c in enumerate(s):        #     if c == &quot;A&quot;:        #         absents += 1        #         if absents &gt;= 2:        #             return False        #        #     if c == &quot;L&quot;:        #         lates += 1        #         if lates &gt;= 3:        #             return False        #     else:        #         lates = 0        #        # return Trueif __name__ == &quot;__main__&quot;:    slt = Solution()    # res = slt.checkRecord2(&quot;PPALLL&quot;)    res = slt.checkRecord2(&quot;PPALLP&quot;)    print(res)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;551-学生出勤记录1&quot;&gt;&lt;a href=&quot;#551-学生出勤记录1&quot; class=&quot;headerlink&quot; title=&quot;551.学生出勤记录1&quot;&gt;&lt;/a&gt;551.学生出勤记录1&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你一个字符串 s 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：&lt;br&gt;    ‘A’：Absent，缺勤&lt;br&gt;    ‘L’：Late，迟到&lt;br&gt;    ‘P’：Present，到场&lt;br&gt;如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：&lt;br&gt;    按 总出勤 计，学生缺勤（’A’）严格 少于两天。&lt;br&gt;    学生 不会 存在 连续 3 天或 连续 3 天以上的迟到（’L’）记录。&lt;br&gt;如果学生可以获得出勤奖励，返回 true ；否则，返回 false 。&lt;/p&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="字符串" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 反转字符串2</title>
    <link href="http://example.com/2021/09/01/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B22/"/>
    <id>http://example.com/2021/09/01/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B22/</id>
    <published>2021-09-01T12:05:22.000Z</published>
    <updated>2021-09-02T04:13:05.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="541-反转字符串2"><a href="#541-反转字符串2" class="headerlink" title="541.反转字符串2"></a>541.反转字符串2</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串 s 和一个整数 k，从字符串开头算起，每 2k 个字符反转前 k 个字符。<br>    如果剩余字符少于 k 个，则将剩余字符全部反转。<br>    如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p><span id="more"></span><p>示例 1：<br>输入：s = “abcdefg”, k = 2<br>输出：”bacdfeg”</p><p><a href="https://leetcode-cn.com/problems/reverse-string-ii/">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>反转每个下标从 2k 的倍数开始的，长度为 k 的子串。若该子串长度不足 k，则反转整个子串</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:    def reverseStr(self, s: str, k: int) -&gt; str:        t = list(s)        for i in range(0, len(t), 2 * k):            t[i: i + k] = reversed(t[i: i + k])        return &quot;&quot;.join(t)if __name__ == &#39;__main__&#39;:    slt = Solution()    s = &quot;abcdefg&quot;    k = 2    res = slt.reverseStr(s, k)  # bacdfeg    print(res)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;541-反转字符串2&quot;&gt;&lt;a href=&quot;#541-反转字符串2&quot; class=&quot;headerlink&quot; title=&quot;541.反转字符串2&quot;&gt;&lt;/a&gt;541.反转字符串2&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个字符串 s 和一个整数 k，从字符串开头算起，每 2k 个字符反转前 k 个字符。&lt;br&gt;    如果剩余字符少于 k 个，则将剩余字符全部反转。&lt;br&gt;    如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。&lt;/p&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="字符串" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 最长特殊序列</title>
    <link href="http://example.com/2021/09/01/%E6%9C%80%E9%95%BF%E7%89%B9%E6%AE%8A%E5%BA%8F%E5%88%97/"/>
    <id>http://example.com/2021/09/01/%E6%9C%80%E9%95%BF%E7%89%B9%E6%AE%8A%E5%BA%8F%E5%88%97/</id>
    <published>2021-09-01T10:41:31.000Z</published>
    <updated>2021-09-01T12:02:33.977Z</updated>
    
    <content type="html"><![CDATA[<h1 id="521-最长特殊序列"><a href="#521-最长特殊序列" class="headerlink" title="521.最长特殊序列"></a>521.最长特殊序列</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两个字符串，请你从这两个字符串中找出最长的特殊序列。<br>「最长特殊序列」定义如下：该序列为某字符串独有的最长子序列（即不能是其他字符串的子序列）。<br>子序列 可以通过删去字符串中的某些字符实现，但不能改变剩余字符的相对顺序。空序列为所有字符串的子序列，任何字符串为其自身的子序列。<br>输入为两个字符串，输出最长特殊序列的长度。如果不存在，则返回 -1。</p><span id="more"></span><p>刷到这道题目时我表示有点没看懂，然后就看了leetcode的评论，也有许多人没看懂，最后就看了题解。。。<br>我认为，本题按照leetcode官方题解解法二的解决方案容易理解。</p><p><a href="https://leetcode-cn.com/problems/longest-uncommon-subsequence-i/">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>字符串 aaa 和 bbb 共有 3 种情况：<br>    a=b。如果两个字符串相同，则没有特殊子序列，返回 -1。<br>    length(a)=length(b) 且 a≠b。例如：abc 和 abd。这种情况下，一个字符串一定不会是另外一个字符串的子序列，因此可以将任意一个字符串看作是特殊子序列，返回 length(a) 或 length(b)。<br>    length(a)≠length(b)。例如：abcd 和 abc。这种情况下，长的字符串一定不会是短字符串的子序列，因此可以将长字符串看作是特殊子序列，返回 max(length(a),length(b))。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:    def findLUSlength(self, a: str, b: str) -&gt; int:        if a == b:            return -1        return max(len(a), len(b))if __name__ == &quot;__main__&quot;:    slt = Solution()    a = &quot;aaa&quot;    b = &quot;bbb&quot;    res = slt.findLUSlength(a, b)    print(res)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;521-最长特殊序列&quot;&gt;&lt;a href=&quot;#521-最长特殊序列&quot; class=&quot;headerlink&quot; title=&quot;521.最长特殊序列&quot;&gt;&lt;/a&gt;521.最长特殊序列&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你两个字符串，请你从这两个字符串中找出最长的特殊序列。&lt;br&gt;「最长特殊序列」定义如下：该序列为某字符串独有的最长子序列（即不能是其他字符串的子序列）。&lt;br&gt;子序列 可以通过删去字符串中的某些字符实现，但不能改变剩余字符的相对顺序。空序列为所有字符串的子序列，任何字符串为其自身的子序列。&lt;br&gt;输入为两个字符串，输出最长特殊序列的长度。如果不存在，则返回 -1。&lt;/p&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="字符串" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 检测大写字母</title>
    <link href="http://example.com/2021/09/01/%E6%A3%80%E6%B5%8B%E5%A4%A7%E5%86%99%E5%AD%97%E6%AF%8D/"/>
    <id>http://example.com/2021/09/01/%E6%A3%80%E6%B5%8B%E5%A4%A7%E5%86%99%E5%AD%97%E6%AF%8D/</id>
    <published>2021-09-01T10:29:42.000Z</published>
    <updated>2021-09-01T10:39:54.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="520-检测大写字母"><a href="#520-检测大写字母" class="headerlink" title="520.检测大写字母"></a>520.检测大写字母</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个单词，你需要判断单词的大写使用是否正确。<br>我们定义，在以下情况时，单词的大写用法是正确的：<br>    全部字母都是大写，比如”USA”。<br>    单词中所有字母都不是大写，比如”leetcode”。<br>    如果单词不只含有一个字母，只有首字母大写， 比如 “Google”。<br>否则，我们定义这个单词没有正确使用大写字母。</p><span id="more"></span><p>示例 1:<br>输入: “USA”<br>输出: True<br>示例 2:<br>输入: “FlaG”<br>输出: False<br>注意: 输入是由大写和小写拉丁字母组成的非空单词。</p><p><a href="https://leetcode-cn.com/problems/detect-capital/">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>按照单词大写用法进行判断，满足返回True，不满足返回False</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:    def detectCapitalUse(self, word: str) -&gt; bool:        if word.islower() or word.isupper():            return True        elif word[0].isupper() and word[1:].islower():            return True        else:            return Falseif __name__ == &quot;__main__&quot;:    slt = Solution()    # word = &quot;USA&quot;    # word = &quot;leetcode&quot;    # word = &quot;Google&quot;    word = &quot;flaG&quot;    res = slt.detectCapitalUse(word)    print(res)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;520-检测大写字母&quot;&gt;&lt;a href=&quot;#520-检测大写字母&quot; class=&quot;headerlink&quot; title=&quot;520.检测大写字母&quot;&gt;&lt;/a&gt;520.检测大写字母&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个单词，你需要判断单词的大写使用是否正确。&lt;br&gt;我们定义，在以下情况时，单词的大写用法是正确的：&lt;br&gt;    全部字母都是大写，比如”USA”。&lt;br&gt;    单词中所有字母都不是大写，比如”leetcode”。&lt;br&gt;    如果单词不只含有一个字母，只有首字母大写， 比如 “Google”。&lt;br&gt;否则，我们定义这个单词没有正确使用大写字母。&lt;/p&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="字符串" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 字符串中的单词数</title>
    <link href="http://example.com/2021/09/01/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0/"/>
    <id>http://example.com/2021/09/01/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0/</id>
    <published>2021-09-01T10:25:59.000Z</published>
    <updated>2021-09-01T10:31:00.206Z</updated>
    
    <content type="html"><![CDATA[<h1 id="434-字符串中的单词数"><a href="#434-字符串中的单词数" class="headerlink" title="434.字符串中的单词数"></a>434.字符串中的单词数</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。<br>请注意，你可以假定字符串里不包括任何不可打印的字符。</p><span id="more"></span><p><a href="https://leetcode-cn.com/problems/number-of-segments-in-a-string/">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.使用语言内置函数split()<br>2.原地法<br>计算单词的数量，就等同于计数单词开始的下标个数。因此，只需要定义好下标的条件，就可以遍历整个字符串，检测每个下标。定义如下：若该下标前为空格（或者为初始下标），且自身不为空格，则其为单词开始的下标。该条件可以以常数时间检测。最后，返回满足条件的下标个数。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:    def countSegments(self, s: str) -&gt; int:        list_s = s.split(&#39; &#39;)        for i in range(list_s.count(&#39;&#39;)):            list_s.remove(&#39;&#39;)        if not list_s:            return 0        return len(list_s)    def countSegments1(self, s):        return len(s.split())    def countSegments2(self, s):        segment_count = 0        for i in range(len(s)):            if (i == 0 or s[i-1] == &#39; &#39;) and s[i] != &#39; &#39;:                segment_count +=1        return segment_countif __name__ == &#39;__main__&#39;:    slt = Solution()    # s = &quot;      &quot;    s = &quot;The one-hour drama series Westworld is a dark odyssey about the dawn of artificial consciousness and the evolution of sin. Set at the intersection of the near future and the reimagined past, it explores a world in which every human appetite, no matter how noble or depraved, can be indulged.&quot;    res = slt.countSegments2(s)    print(res)    # 分割文本    # s = &quot;The sky is very blue.&quot;    # words = s.split(&quot; &quot;)    # print(words)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;434-字符串中的单词数&quot;&gt;&lt;a href=&quot;#434-字符串中的单词数&quot; class=&quot;headerlink&quot; title=&quot;434.字符串中的单词数&quot;&gt;&lt;/a&gt;434.字符串中的单词数&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。&lt;br&gt;请注意，你可以假定字符串里不包括任何不可打印的字符。&lt;/p&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="字符串" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 赎金信</title>
    <link href="http://example.com/2021/09/01/%E8%B5%8E%E9%87%91%E4%BF%A1/"/>
    <id>http://example.com/2021/09/01/%E8%B5%8E%E9%87%91%E4%BF%A1/</id>
    <published>2021-09-01T09:32:57.000Z</published>
    <updated>2021-09-01T09:35:33.280Z</updated>
    
    <content type="html"><![CDATA[<h1 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383.赎金信"></a>383.赎金信</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。<br>(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)</p><span id="more"></span><p><a href="https://leetcode-cn.com/problems/ransom-note/">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>遍历ransomNote中的每一个元素，并查找这个元素是否在magazine中，如果没有查找到，则返回False，如果查找到了，则将这个元素在magazine中移除，以此类推，直到遍历完ransomNote中的每一个元素。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:    def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool:        ransomNote = list(ransomNote)        magazine = list(magazine)        for i in range(len(ransomNote)):            if ransomNote[i] in magazine:                magazine.remove(ransomNote[i])                print(ransomNote)            else:                return False        if i == len(ransomNote)-1:            return Trueif __name__ == &#39;__main__&#39;:    s = Solution()    res = s.canConstruct(&#39;aa&#39;, &#39;aab&#39;)    print(res)    # list1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;]    # list1.remove(&#39;a&#39;)    # print(list1)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;383-赎金信&quot;&gt;&lt;a href=&quot;#383-赎金信&quot; class=&quot;headerlink&quot; title=&quot;383.赎金信&quot;&gt;&lt;/a&gt;383.赎金信&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。&lt;br&gt;(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)&lt;/p&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="字符串" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 反转字符串中的元音字母</title>
    <link href="http://example.com/2021/09/01/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D/"/>
    <id>http://example.com/2021/09/01/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D/</id>
    <published>2021-09-01T03:05:01.000Z</published>
    <updated>2021-09-01T03:12:51.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="345-反转字符串中的元音字母"><a href="#345-反转字符串中的元音字母" class="headerlink" title="345.反转字符串中的元音字母"></a>345.反转字符串中的元音字母</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 s ，仅反转字符串中的所有元音字母，并返回结果字符串。<br>元音字母包括 ‘a’、’e’、’i’、’o’、’u’，且可能以大小写两种形式出现。</p><span id="more"></span><p><a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string">题目链接</a>+</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.先将字符串中的元音字母的位置找出来，然后再将各元音字母反转<br>2.双指针<br>我们可以使用两个指针 i 和 j 对字符串相向地进行遍历。<br>具体地，指针 i 初始时指向字符串 s 的首位，指针 j 初始时指向字符串 s 的末位。在遍历的过程中，我们不停地将 i 向右移动，直到 i 指向一个元音字母（或者超出字符串的边界范围）；同时，我们不停地将 j 向左移动，直到 j 指向一个元音字母。此时，如果 i&lt;j，那么我们交换 i 和 j 指向的元音字母，否则说明所有的元音字母均已遍历过，就可以退出遍历的过程。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:    def reverseVowels(self, s: str) -&gt; str:        &quot;&quot;&quot;        find ans reverse        :param s:        :return:        &quot;&quot;&quot;        vowels = list()        s = list(s)        for i in range(len(s)):            ch = s[i].lower()            if ch == &#39;a&#39; or ch == &#39;e&#39; or ch == &#39;i&#39; or ch == &#39;o&#39; or ch == &#39;u&#39;:                vowels.append(i)        for i in range(len(vowels)//2):            s[vowels[i]], s[vowels[len(vowels) - i -1]] = s[vowels[len(vowels) - i -1]], s[vowels[i]]        return &#39;&#39;.join(s)    def reverseVowels1(self, s: str) -&gt; str:        &quot;&quot;&quot;双指针&quot;&quot;&quot;        def isVowel(ch: str) -&gt; bool:            return ch in &quot;aeiouAEIOU&quot;        n = len(s)        s = list(s)        i, j = 0, n - 1        while i &lt; j:            while i &lt; n and not isVowel(s[i]):                i += 1            while j &gt; 0 and not isVowel(s[j]):                j -= 1            if i &lt; j:                s[i], s[j] = s[j], s[i]                i += 1                j -= 1        return &#39;&#39;.join(s)if __name__ == &quot;__main__&quot;:    s = Solution()    string = &quot;hello&quot;    res = s.reverseVowels(string)    print(res)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;345-反转字符串中的元音字母&quot;&gt;&lt;a href=&quot;#345-反转字符串中的元音字母&quot; class=&quot;headerlink&quot; title=&quot;345.反转字符串中的元音字母&quot;&gt;&lt;/a&gt;345.反转字符串中的元音字母&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你一个字符串 s ，仅反转字符串中的所有元音字母，并返回结果字符串。&lt;br&gt;元音字母包括 ‘a’、’e’、’i’、’o’、’u’，且可能以大小写两种形式出现。&lt;/p&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="字符串" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>hexo | hexo博客换电脑了怎么办</title>
    <link href="http://example.com/2021/08/30/hexo%E5%8D%9A%E5%AE%A2%E6%8D%A2%E7%94%B5%E8%84%91%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E/"/>
    <id>http://example.com/2021/08/30/hexo%E5%8D%9A%E5%AE%A2%E6%8D%A2%E7%94%B5%E8%84%91%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E/</id>
    <published>2021-08-30T02:41:12.000Z</published>
    <updated>2021-08-30T02:57:30.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hexo博客换电脑了怎么办"><a href="#hexo博客换电脑了怎么办" class="headerlink" title="hexo博客换电脑了怎么办"></a>hexo博客换电脑了怎么办</h1><p>我们搭建的hexo博客在更换电脑之后，如果重新搭建博客比较费时费力，可以按照以下资料快速在新的电脑上使用hexo博客发布内容。</p><p><a href="https://www.cnblogs.com/study-everyday/p/8902136.html">参考资料链接</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;hexo博客换电脑了怎么办&quot;&gt;&lt;a href=&quot;#hexo博客换电脑了怎么办&quot; class=&quot;headerlink&quot; title=&quot;hexo博客换电脑了怎么办&quot;&gt;&lt;/a&gt;hexo博客换电脑了怎么办&lt;/h1&gt;&lt;p&gt;我们搭建的hexo博客在更换电脑之后，如果重新搭建博</summary>
      
    
    
    
    <category term="hexo" scheme="http://example.com/categories/hexo/"/>
    
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 反转字符串</title>
    <link href="http://example.com/2021/08/29/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://example.com/2021/08/29/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2021-08-29T03:05:55.000Z</published>
    <updated>2021-09-01T03:15:10.271Z</updated>
    
    <content type="html"><![CDATA[<h1 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。<br>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。<br>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><span id="more"></span><p>示例 1：<br>输入：[“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]</p><p><a href="https://leetcode-cn.com/problems/reverse-string">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.字符串切片 —&gt; reversString()<br>2.使用list.reverse()方法 —&gt; reversString1()<br>3.使用reversed()函数 —&gt; reversString2()<br>4.使用栈 —&gt; reversString3()<br>将s列表看作一个栈，低端作为栈底，高端作为栈顶，依次将栈顶元素出栈即可。<br>5.for —&gt; reversString4()<br>将列表中的第i个元素与倒数第i个元素交换（0&lt; i &lt; len(s)//2）<br>6.递归 —&gt; reversString5()</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):    def reverseString(self, s):        &quot;&quot;&quot;        :type s: List[str]        :rtype: None Do not return anything, modify s in-place instead.        &quot;&quot;&quot;        return s[::-1]    def reverseString1(self, s):        s.reverse()    def reverseString2(self, s):        s[:] = list(reversed(s))    def reverseString3(self, s):        result = list()        while len(s) &gt; 0:            result.append(s.pop())        s[:] = result    def reverseString4(self, s):        for i in range(len(s)//2):            s[i], s[len(s) - i - 1] = s[len(s) - i - 1], s[i]    # def reverseString5(self, s):    #     if len(s) &lt; 1:    #         return s    #     return self.reverseString4(s[1:]) + s[0]</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;344-反转字符串&quot;&gt;&lt;a href=&quot;#344-反转字符串&quot; class=&quot;headerlink&quot; title=&quot;344.反转字符串&quot;&gt;&lt;/a&gt;344.反转字符串&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。&lt;br&gt;不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。&lt;br&gt;你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。&lt;/p&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="字符串" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 二进制求和</title>
    <link href="http://example.com/2021/08/29/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/"/>
    <id>http://example.com/2021/08/29/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/</id>
    <published>2021-08-29T02:49:05.000Z</published>
    <updated>2021-09-01T03:15:26.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67.二进制求和"></a>67.二进制求和</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两个二进制字符串，返回它们的和（用二进制表示）。<br>输入为 非空 字符串且只包含数字 1 和 0。</p><span id="more"></span><p>示例 1:<br>输入: a = “11”, b = “1”<br>输出: “100”</p><p><a href="https://leetcode-cn.com/problems/add-binary/">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.先将 a 和 b 转化成十进制数，求和后再转化为二进制数<br>2.列竖式<br>末尾对齐，逐位相加，逢二进一<br>具体的，我们可以取 n=max{∣a∣,∣b∣}，循环 n 次，从最低位开始遍历。我们使用一个变量 carry 表示上一个位置的进位，初始值为 0。记当前位置对其的两个位为 ai​ 和 bi​，则每一位的答案为 (carry+ai+bi) mod 2，下一位的进位为 ⌊(carry+ai+bi)/2⌋。重复上述步骤，直到数字 a 和 b 的每一位计算完毕。最后如果 carry 的最高位不为 0，则将最高位添加到计算结果的末尾。<br>注意，为了让各个位置对齐，你可以先反转这个代表二进制数字的字符串，然后低下标对应低位，高下标对应高位。当然你也可以直接把 a 和 b 中短的那一个补 0 直到和长的那个一样长，然后从高位向低位遍历，对应位置的答案按照顺序存入答案字符串内，最终将答案串反转。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:    def addBinary(self, a: str, b: str) -&gt; str:        &quot;&quot;&quot;        先将 aaa 和 bbb 转化成十进制数，求和后再转化为二进制数        :param a:        :param b:        :return:        &quot;&quot;&quot;        # a = int(a, 2)  # 将二进制数转为十进制        # b = int(b, 2)        # print(a)        # print(b)        # return bin(a+b)[2:]        return &#39;&#123;0:b&#125;&#39;.format(int(a, 2) + int(b, 2))    def addBinary1(self, a: str, b: str) -&gt; str:        ans = list()        n = max(len(a), len(b))        carry = 0        list_a = []        list_b = []        for e in a:            list_a.append(int(e))        for e in b:            list_b.append(int(e))        print(list_a)        print(list_b)        for i in range(n):            carry += list_a[len(a) - i - 1] if i &lt; len(a) else 0            carry += list_b[len(b) - i - 1] if i &lt; len(b) else 0            ans.append(str(int(carry % 2)))            carry /= 2        if carry &gt; 0:            ans.append(&#39;1&#39;)        return &#39;&#39;.join(ans[::-1])if __name__ == &#39;__main__&#39;:    s = Solution()    a = &quot;11&quot;    b = &quot;1&quot;    res = s.addBinary1(a, b)    print(res)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;67-二进制求和&quot;&gt;&lt;a href=&quot;#67-二进制求和&quot; class=&quot;headerlink&quot; title=&quot;67.二进制求和&quot;&gt;&lt;/a&gt;67.二进制求和&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你两个二进制字符串，返回它们的和（用二进制表示）。&lt;br&gt;输入为 非空 字符串且只包含数字 1 和 0。&lt;/p&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="字符串" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 验证回文串</title>
    <link href="http://example.com/2021/08/28/%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    <id>http://example.com/2021/08/28/%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/</id>
    <published>2021-08-28T02:58:08.000Z</published>
    <updated>2021-09-01T03:15:33.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125.验证回文串"></a>125.验证回文串</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。<br>说明：本题中，我们将空字符串定义为有效的回文串。</p><span id="more"></span><p>示例 1:<br>输入: “A man, a plan, a canal: Panama”<br>输出: true<br>解释：”amanaplanacanalpanama” 是回文串</p><p><a href="https://leetcode-cn.com/problems/count-and-say/">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.判断第i(0 &lt; i &lt; len(new_s)//2)个字符与倒数第i个字符是否相等来确定字符串是否回文，其中new_s是去除了除数字字母外字符的字符串<br>2.判断反转字符串是否与原字符串相同<br>3.双指针（去除除数字字母外的其他字符）<br>初始时，左右指针分别指向字符串的两侧，随后我们不断地将这两个指针相向移动，每次移动一步，并判断这两个指针指向的字符是否相同。当这两个指针相遇时，就说明是回文串。<br>4.双指针（直接在原字符串上进行判断）<br>与3.相同</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:    def isPalindrome(self, s: str) -&gt; bool:        import re        new_s = re.sub(r&#39;\W|_&#39;, &#39;&#39;, s).lower()        len_new_s = len(new_s)        i = 0        while i &lt; len_new_s // 2:            if new_s[i] == new_s[len_new_s-i-1]:                i += 1            else:                break        if i == len_new_s // 2:            return True        else:            return False    def isPalindrome1(self, s: str) -&gt; bool:        &quot;&quot;&quot;        筛选+判断（判断反转字符串是否与原字符串相同）        :param s:        :return:        &quot;&quot;&quot;        new_s = &quot;&quot;.join(ch.lower() for ch in s if ch.isalnum())        return new_s == new_s[::-1]    def isPalindrome2(self, s: str) -&gt; bool:        &quot;&quot;&quot;        双指针        &quot;&quot;&quot;        new_s = &quot;&quot;.join(ch.lower() for ch in s if ch.isalnum())        left, right = 0, len(new_s) - 1        while left &lt; right:            if new_s[left] != new_s[right]:                return False            left, right = left + 1, right - 1        return True    def isPalindrome3(self, s: str) -&gt; bool:        &quot;&quot;&quot;在原字符串上直接判断&quot;&quot;&quot;        n = len(s)        left, right = 0, n - 1        while left &lt; right:            while left &lt; right and not s[left].isalnum():                left += 1            while left &lt; right and not s[right].isalnum():                right -= 1            if left &lt; right:                if s[left].lower() != s[right].lower():                    return False                left, right = left + 1, right - 1        return Trueif __name__ == &quot;__main__&quot;:    slt = Solution()    string = &quot;abcb&quot;    res = slt.isPalindrome(string)    print(res)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;125-验证回文串&quot;&gt;&lt;a href=&quot;#125-验证回文串&quot; class=&quot;headerlink&quot; title=&quot;125.验证回文串&quot;&gt;&lt;/a&gt;125.验证回文串&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。&lt;br&gt;说明：本题中，我们将空字符串定义为有效的回文串。&lt;/p&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="字符串" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 外观数列</title>
    <link href="http://example.com/2021/08/28/%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/"/>
    <id>http://example.com/2021/08/28/%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/</id>
    <published>2021-08-28T01:45:20.000Z</published>
    <updated>2021-08-28T02:06:38.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="38-外观数列"><a href="#38-外观数列" class="headerlink" title="38.外观数列"></a>38.外观数列</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个正整数 n ，输出外观数列的第 n 项。<br>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。</p><span id="more"></span><p>你可以将其视作是由递归公式定义的数字字符串序列：<br>    countAndSay(1) = “1”<br>    countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。<br>前五项如下：</p><ol><li><pre><code>1</code></pre></li><li><pre><code>11</code></pre></li><li><pre><code>21</code></pre></li><li><pre><code>1211</code></pre></li><li><pre><code>111221</code></pre>第一项是数字 1<br>描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 “11”<br>描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 “21”<br>描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 “1211”<br>描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 “111221”<br>要 描述 一个数字字符串，首先要将字符串分割为 最小 数量的组，每个组都由连续的最多 相同字符 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。</li></ol><p><a href="https://leetcode-cn.com/problems/count-and-say/">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.递归<br>递归出口为n == 1时，返回”1”；<br>当n &gt; 1时，我们只需要计算countAndSay(n - 1)中每个数字的个数：<br>对于计算字符串中每个数字出现的个数，使用双指针i, j，其中i表示当前字符，j则是计数指针，向后移动判断；<br>以求n = 5，lastStr = countAndSay(4) = “1211”为例，answer = “”，一开始让i = 0, j = 1，此时’1’ != ‘2’，<br>故answer += (j - i) + lastStr.charAt(i)，ans = “11”；然后让i = j（第二个不同字符起始位置），<br>然后j++往后移动；此时i = j = 1，j = j + 1 = 2，又’2’ != ‘1’，<br>所以answer += (j - i) + lastStr.charAt(i),ans = “1112”,重复i = j = 2， j = ++j = 3；此时’1’ = ‘1’；<br>故直接j = ++j = 4 == lastStr.length()，所以跳出循环，然后把最后一次的字符个数字符加上，即执行：<br>answer += (j - i) + lastStr.charAt(i),ans = “111221”，即countAndSay(5) = “111221”。<br>2.正则表达式<br>用正则表达式匹配一个数字的重复序列和数字本身，然后将匹配的序列的长度加上数字本身替换原字符串中重复序列，…，以此类推。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:    def countAndSay(self, n: int) -&gt; str:        &quot;&quot;&quot;        递归法        :param n:        :return:        &quot;&quot;&quot;        if n == 1:  # 递归出口            return &quot;1&quot;        else:            lastStr = self.countAndSay(n - 1)            ans = &quot;&quot;            i = 0            j = 1            while j &lt; len(lastStr):                if lastStr[i] != lastStr[j]:                    ans += str(j-i)                    ans += str(lastStr[i])                    i = j  # 下一个不同字符的起始位置                j += 1            ans += str(j - i)            ans += str(lastStr[i])            return str(ans)    def countAndSay1(self, n):        &quot;&quot;&quot;        :type n: int        :rtype: str        &quot;&quot;&quot;        import re        s = &#39;1&#39;        for _ in range(n - 1):            s = re.sub(r&#39;(.)\1*&#39;, lambda a: str(len(a.group(0))) + a.group(1), s)  # sub(pattern, repl, string)            # r&#39;(.)\1*&#39; (.)匹配一个任意字符作为一个分组 \1*匹配与第一个分组相同内容0次/多次        return sif __name__ == &#39;__main__&#39;:    s = Solution()    res = s.countAndSay1(5)    print(res)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;38-外观数列&quot;&gt;&lt;a href=&quot;#38-外观数列&quot; class=&quot;headerlink&quot; title=&quot;38.外观数列&quot;&gt;&lt;/a&gt;38.外观数列&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个正整数 n ，输出外观数列的第 n 项。&lt;br&gt;「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。&lt;/p&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="字符串" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>python | 匹配第n个分组的内容</title>
    <link href="http://example.com/2021/08/28/%E5%8C%B9%E9%85%8D%E7%AC%ACn%E4%B8%AA%E5%88%86%E7%BB%84%E7%9A%84%E5%86%85%E5%AE%B9/"/>
    <id>http://example.com/2021/08/28/%E5%8C%B9%E9%85%8D%E7%AC%ACn%E4%B8%AA%E5%88%86%E7%BB%84%E7%9A%84%E5%86%85%E5%AE%B9/</id>
    <published>2021-08-28T01:22:29.000Z</published>
    <updated>2021-08-28T01:35:00.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1…-9"><a href="#1…-9" class="headerlink" title="\1…\9"></a>\1…\9</h1><p>\1…\9用来匹配与第n(1~9)个分组的内容，必须与()配合使用<br>例：在以下代码段中\2表示匹配第2个分组（一个括号代表一个分组）的内容，即\2匹配”world”字符串</p><pre><code>import restring = &quot;helloworld world&quot;pattern = r&#39;^(\w+)(world) \2$&#39;print(re.search(pattern, string))</code></pre><p><a href="https://www.jianshu.com/p/8a4ce87ef4b2">参考资料</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1…-9&quot;&gt;&lt;a href=&quot;#1…-9&quot; class=&quot;headerlink&quot; title=&quot;\1…\9&quot;&gt;&lt;/a&gt;\1…\9&lt;/h1&gt;&lt;p&gt;\1…\9用来匹配与第n(1~9)个分组的内容，必须与()配合使用&lt;br&gt;例：在以下代码段中\2表示匹配第2个分组（一个</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="re" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/re/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="re" scheme="http://example.com/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>python | re sub的使用方法</title>
    <link href="http://example.com/2021/08/27/re-sub%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2021/08/27/re-sub%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</id>
    <published>2021-08-27T12:20:52.000Z</published>
    <updated>2021-08-27T12:28:57.692Z</updated>
    
    <content type="html"><![CDATA[<h1 id="re-sub的使用方法"><a href="#re-sub的使用方法" class="headerlink" title="re.sub的使用方法"></a>re.sub的使用方法</h1><p>re.sub()实现相对复杂的替换</p><p><a href="https://www.jianshu.com/p/8c1d1a38f9b9">使用方法</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;re-sub的使用方法&quot;&gt;&lt;a href=&quot;#re-sub的使用方法&quot; class=&quot;headerlink&quot; title=&quot;re.sub的使用方法&quot;&gt;&lt;/a&gt;re.sub的使用方法&lt;/h1&gt;&lt;p&gt;re.sub()实现相对复杂的替换&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="re" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/re/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="re" scheme="http://example.com/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>实现strStr方法</title>
    <link href="http://example.com/2021/08/27/%E5%AE%9E%E7%8E%B0strStr%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2021/08/27/%E5%AE%9E%E7%8E%B0strStr%E6%96%B9%E6%B3%95/</id>
    <published>2021-08-27T09:55:12.000Z</published>
    <updated>2021-08-27T10:05:49.936Z</updated>
    
    <content type="html"><![CDATA[<h1 id="28-实现strStr"><a href="#28-实现strStr" class="headerlink" title="28.实现strStr()"></a>28.实现strStr()</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>实现 strStr() 函数。<br>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。<br><a href="https://leetcode-cn.com/problems/implement-strstr/">题目链接</a></p><span id="more"></span><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.直接调用python内置方法<br>2.暴力匹配<br>让字符串 needle 与字符串 haystack 的所有长度为 m（needle字符串的长度） 的子串均匹配一次。<br>为了减少不必要的匹配，我们每次匹配失败即立刻停止当前子串的匹配，对下一个子串继续匹配。如果当前子串匹配成功，我们返回当前子串的开始位置即可。如果所有子串都匹配失败，则返回 −1-1−1。<br><strong style="color:red">3.kmp算法</strong><br>kmp算法的目的：为了避免不必要的指针回溯<br>主串指针i不回溯，模式串指针j的变化取决于模式串的结构是否有重复<br>pi数组值的计算：<br>pi数组的值为最长相同前后缀长度+1(串本身不能作为前后缀)<br>pi[1]=0,其他情况next[]=1.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution:    &quot;&quot;&quot;    kmp算法的目的：为了避免不必要的指针回溯    主串指针i不回溯，模式串指针j的变化取决于模式串的结构是否有重复    pi数组值的计算：    pi数组的值为最长相同前后缀长度+1(串本身不能作为前后缀)    pi[1]=0,其他情况next[]=1.    &quot;&quot;&quot;    def strStr(self, haystack: str, needle: str) -&gt; int:        # 获取主串和模式串的长度        n = len(haystack)        m = len(needle)        # 如果模式串的长度为0，则返回0        if m == 0:            return 0        pi = [0]*m        # 求模式串的前缀函数值        i = 1        j = 0        while i &lt; m:            while j &gt; 0 and needle[i] != needle[j]:                j = pi[j-1]  # 回溯            if needle[i] == needle[j]:                j += 1            pi[i] = j            i += 1        print(&quot;模式串的前缀函数值:&quot;, pi)        # kmp        i = 0        j = 0        while i &lt; n:            while j &gt; 0 and haystack[i] != needle[j]:                j = pi[j-1]  # 回溯            if haystack[i] == needle[j]:                j += 1            if j == m:                return i - m + 1            i += 1        return -1    def strStr1(self, haystack: str, needle: str) -&gt; int:        &quot;&quot;&quot;调用内置方法&quot;&quot;&quot;        # 方法1        # return haystack.find(needle)        # 方法2        if not needle:            return 0        try:            return haystack.index(needle)        except ValueError:            return -1    def strStr2(self, haystack: str, needle: str) -&gt; int:        &quot;&quot;&quot;暴力匹配&quot;&quot;&quot;        n = len(haystack)        m = len(needle)        i = 0        while i + m &lt;= n:            flag = True            j = 0            while j &lt; m:                if haystack[i + j] != needle[j]:                    flag = False                    break                j += 1            if flag:                return i            i += 1        return -1if __name__ == &quot;__main__&quot;:    s = Solution()    # print(s.strStr(&quot;mississippi&quot;, &quot;issip&quot;))  # [0, 0, 0, 1, 0]    # print(s.strStr1(&quot;mississippi&quot;, &quot;issip&quot;))  # [0, 0, 0, 1, 0]    print(s.strStr2(&quot;mississippi&quot;, &quot;issip&quot;))  # [0, 0, 0, 1, 0]</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;28-实现strStr&quot;&gt;&lt;a href=&quot;#28-实现strStr&quot; class=&quot;headerlink&quot; title=&quot;28.实现strStr()&quot;&gt;&lt;/a&gt;28.实现strStr()&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;实现 strStr() 函数。&lt;br&gt;给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。&lt;br&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/implement-strstr/&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="字符串" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="kmp算法" scheme="http://example.com/tags/kmp%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
