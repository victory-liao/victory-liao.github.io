<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Victory&#39;s Blog</title>
  
  <subtitle>非淡泊无以明志，非宁静无以致远</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-11-05T02:24:08.537Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>victory-liao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>os | 批量新建文件夹</title>
    <link href="http://example.com/2021/11/04/%E6%89%B9%E9%87%8F%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/"/>
    <id>http://example.com/2021/11/04/%E6%89%B9%E9%87%8F%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/</id>
    <published>2021-11-05T02:22:22.000Z</published>
    <updated>2021-11-05T02:24:08.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="批量新建文件夹"><a href="#批量新建文件夹" class="headerlink" title="批量新建文件夹"></a>批量新建文件夹</h1><p>程序实现在指定目录下批量生成文件夹。</p><span id="more"></span><p>代码：</p><pre><code>import osfrom datetime import datetimefrom time import time, localtime, strftimefrom tkinter import Tk, Entry, Button, Listbox, X, Y, END, Scrollbar, RIGHT, BOTTOM, HORIZONTAL, StringVar, Labelfrom tkinter.filedialog import askdirectoryclass MainGUI():    def __init__(self):        myWindow = Tk()        myWindow.title(&quot;批量新建文件夹&quot;)        # 设置窗口大小        myWindow.geometry(&#39;590x400&#39;)        # 增加标签        self.label_1 = Label(myWindow, text=&#39; 目标目录:&#39;)        self.label_1.place(x=10, y=10, width=70, height=30)        self.label_2 = Label(myWindow, text=&#39;文件夹数量:&#39;)        self.label_2.place(x=10, y=50, width=70, height=30)        # 增加文本框        addr = StringVar(value=&#39;C:\\Users\\xxxx\\Desktop&#39;)  # 文本框默认显示的内容        self.input_entry = Entry(myWindow, highlightcolor=&#39;red&#39;, highlightthickness=1, textvariable=addr)        self.input_entry.place(x=80, y=10, width=410, height=30)        self.btn_in = Button(myWindow, text=&#39;选择目录&#39;, command=self.select_dir1, width=10, height=1)        self.btn_in.place(x=500, y=10)        folder_quantity = str(self.get_folder_qty())  # 从日志文件`log.txt`中读取最近使用过的文件夹数量        def_qty = StringVar(value=folder_quantity)        self.folderQty_entry = Entry(myWindow, highlightcolor=&#39;blue&#39;, highlightthickness=1, textvariable=def_qty)        self.folderQty_entry.place(x=80, y=50, width=410, height=30)        self.btn_exe = Button(myWindow, text=&#39;执行新建&#39;, command=self.create_folders, width=10, height=1)        self.btn_exe.place(x=500, y=50)        # 增加列表框        self.result_show = Listbox(myWindow, bg=&#39;Azure&#39;)        self.result_show.place(x=10, y=100, width=570, height=290)        self.sbY = Scrollbar(self.result_show, command=self.result_show.yview)  # 在列表框中增加Y轴滚动条        self.sbY.pack(side=RIGHT, fill=Y)        self.result_show.config(yscrollcommand=self.sbY.set)        self.sbX = Scrollbar(self.result_show, command=self.result_show.xview, orient=HORIZONTAL)  # 在列表框中增加X轴滚动条        self.sbX.pack(side=BOTTOM, fill=X)        self.result_show.config(xscrollcommand=self.sbX.set)        myWindow.mainloop()    def select_dir1(self):        self.input_entry.delete(0, END)        self.input_entry.insert(0, askdirectory(initialdir=&quot;D:\\&quot;))    def create_folders(self):        date = self.get_current_date()  # 获取日期        qty = int(self.folderQty_entry.get())  # 获取文本框中文件夹数量，并转为整数        for i in range(1, qty + 1):            folder = self.input_entry.get() + &quot;\\&quot; + date + &#39;-&#39; + str(i)            # 判断是否已经存在该目录            if not os.path.exists(folder):                # 目录不存在，进行创建操作                os.makedirs(folder)  # 使用os.makedirs()方法创建目录                f = f&quot;目录新建成功：&#123;folder&#125;&quot;  # 创建一个显示项                self.result_show.insert(&quot;end&quot;, f)  # 将结果添加到列表框中            else:                f = f&quot;目录已存在：&#123;folder&#125;&quot;  # 创建一个显示项                self.result_show.insert(&quot;end&quot;, f)  # 将结果添加到列表框中        f = &quot;-&quot; * 100  # 创建分割线        self.result_show.insert(&quot;end&quot;, f)  # 将分割线添加到列表框        f = f&quot;程序运行完成，请关闭窗口退出.&quot;  # 创建一个显示项        self.result_show.insert(&quot;end&quot;, f)  # 将结果添加到列表框        f = &quot; &quot; * 100        self.result_show.insert(&quot;end&quot;, f)  # 将以上空格添加到列表框        self.save_recent_folder_qty()  # 保存最新的文件夹数量    @staticmethod    def get_current_date():        time_stamp = time()        local_time = localtime(time_stamp)        str_time_month = int(strftime(&#39;%m&#39;, local_time))        str_time_day = int(strftime(&#39;%d&#39;, local_time))        return str(str_time_month) + &quot;.&quot; + str(str_time_day)    @staticmethod    def get_folder_qty():        &#39;&#39;&#39;从log.txt文件中获取最近的文件夹数量，若没有则返回0&#39;&#39;&#39;        log_file = os.getcwd() + &quot;\\log.txt&quot;        if os.path.exists(log_file):            with open(log_file, &quot;r&quot;) as f:                qty = f.readline()                return int(qty)        else:            return 0    def save_recent_folder_qty(self):        &quot;&quot;&quot;保存最近的文件夹数量&quot;&quot;&quot;        log_file = os.getcwd() + &quot;\\log.txt&quot;        with open(log_file, &quot;w&quot;) as f:            recent_qty = str(self.folderQty_entry.get())            f.write(recent_qty)if __name__ == &quot;__main__&quot;:    MainGUI()</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;批量新建文件夹&quot;&gt;&lt;a href=&quot;#批量新建文件夹&quot; class=&quot;headerlink&quot; title=&quot;批量新建文件夹&quot;&gt;&lt;/a&gt;批量新建文件夹&lt;/h1&gt;&lt;p&gt;程序实现在指定目录下批量生成文件夹。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="内置模块" scheme="http://example.com/categories/python/%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/"/>
    
    <category term="os" scheme="http://example.com/categories/python/%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/os/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="os" scheme="http://example.com/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>pandas | 一键更新Excel中的图表</title>
    <link href="http://example.com/2021/11/01/%E4%B8%80%E9%94%AE%E6%9B%B4%E6%96%B0Excel%E4%B8%AD%E7%9A%84%E5%9B%BE%E8%A1%A8/"/>
    <id>http://example.com/2021/11/01/%E4%B8%80%E9%94%AE%E6%9B%B4%E6%96%B0Excel%E4%B8%AD%E7%9A%84%E5%9B%BE%E8%A1%A8/</id>
    <published>2021-11-02T03:41:37.000Z</published>
    <updated>2021-11-05T02:08:35.614Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一键更新Excel中的图表"><a href="#一键更新Excel中的图表" class="headerlink" title="一键更新Excel中的图表"></a>一键更新Excel中的图表</h1><p><strong>场景：</strong> 小编每周都要更新最近12周的“生产订单周报”给老板，而且要对比最近两年相同周数的数据。主要是两张图，一张是“一周生产订单对比”，另一张是“各部门订单比例”。虽然在Excel表中建了数据透视表，但是每周都还是需要花时间进行一通凶猛的操作，才能搞定。可不可以每周一键更新，并得到这两张图呢？</p><span id="more"></span><p><strong>代码实现：</strong></p><pre><code>import pandas as pdfile = &#39;生产订单.xlsx&#39;df = pd.read_excel(file)df.fillna(0, inplace=True)df[&quot;数量&quot;] = df[&quot;数量&quot;].astype(&#39;int&#39;)# 增加周数字段df[&quot;周数&quot;] = df[&quot;日期&quot;].dt.weekdf[&quot;年份&quot;] = df[&quot;日期&quot;].dt.year# print(df.head())# 获取当前周数import datetimeyear, current_week, day = datetime.datetime.now().isocalendar()# print(current_week)# 只获取最近12周的数据df_required = df[(df[&quot;周数&quot;] &gt;= (current_week - 36)) &amp; (df[&quot;周数&quot;] &lt;= (current_week - 24))]# print(df_required[&#39;年份&#39;])result = df_required.groupby([&quot;周数&quot;, &quot;年份&quot;])[&#39;数量&#39;].sum().reset_index()  # reset后才是DF，不然是Series# print(result)## # print(result[result[&quot;年份&quot;]==2019][&quot;数量&quot;])## 如果有中文，需要配置中文字体，不然会显示成方框import matplotlib as mplimport matplotlib.pyplot as pltimport numpy as npplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;SimHei&#39;]  # 用来正常显示中文标签# 数据和标签qty_2019 = result[result[&quot;年份&quot;] == 2019][&quot;数量&quot;]qty_2020 = result[result[&quot;年份&quot;] == 2020][&quot;数量&quot;]print(qty_2020)x_label = result[result[&quot;年份&quot;] == 2019][&quot;周数&quot;]# 设置字体大小mpl.rcParams[&#39;font.size&#39;] = 12# 设置图片大小plt.figure(figsize=(12, 6))# 设置柱形图宽度bar_width = 0.45index = np.arange(13)qty_2019_list = [qty for qty in qty_2019]qty_2020_list = [qty for qty in qty_2020]print(f&quot;index: &#123;len(index)&#125;&quot;)print(len(qty_2019_list))print(len(qty_2020_list))# 绘制2019年数据qty1 = plt.bar(index, qty_2019, bar_width, color=&#39;#336633&#39;, label=&quot;2019&quot;)# 绘制2020年数据qty2 = plt.bar(index + bar_width, qty_2020, bar_width, color=&#39;#6666CC&#39;, label=&quot;2020&quot;)# X,Y轴标题plt.xticks(index + bar_width, x_label)plt.xlabel(&quot;周数&quot;, fontsize=14)plt.ylabel(&quot;产品数量/台&quot;, fontsize=14)# 图表标题plt.title(u&#39;每周生产订单对比&#39;, fontsize=20)# 图例显示plt.legend()# 添加数据标签def add_labels(qtys):    for qty in qtys:        height = qty.get_height()        plt.text(qty.get_x() + qty.get_width() / 2, height, height, ha=&#39;center&#39;, va=&#39;bottom&#39;)        # 柱形图边缘用白色填充        qty.set_edgecolor(&#39;white&#39;)add_labels(qty1)add_labels(qty2)plt.savefig(&#39;prod_order.png&#39;)# 按部门计算订单数量order_2019 = df_required[df_required[&quot;年份&quot;] == 2019]# print(order_2019)dept_2019 = order_2019[&quot;部门&quot;].value_counts()# print(dept_2019)order_2020 = df_required[df_required[&quot;年份&quot;] == 2020]# print(order_2020)dept_2020 = order_2020[&quot;部门&quot;].value_counts()# print(dept_2020)# 绘制饼图import matplotlib as mplimport numpy as npplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;SimHei&#39;]  # 用来正常显示中文标签mpl.rcParams[&#39;font.size&#39;] = 12fig = plt.figure(figsize=(12, 6))axl = fig.add_subplot(1, 2, 1)def my_label(pct, allvals):    absolute = int(pct / 100. * np.sum(allvals))    return &quot;&#123;:.1f&#125;%\n(&#123;:d&#125;)&quot;.format(pct, absolute)explode = (0.1, 0, 0, 0, 0)plt.pie(dept_2019, autopct=lambda x: my_label(x, dept_2019), explode=explode, labels=dept_2019.index, shadow=True,        startangle=150)plt.title(&quot;各部门订单比例\n(最近12周)_2019&quot;, fontsize=20)# plt.label(&quot;2019&quot;,fontsize = 14)ax2 = fig.add_subplot(1, 2, 2)plt.pie(dept_2020, autopct=lambda x: my_label(x, dept_2020), explode=explode, labels=dept_2020.index, shadow=True,        startangle=150)plt.title(&quot;各部门订单比例\n(最近12周)_2020&quot;, fontsize=20)plt.savefig(&#39;order_byDept.png&#39;)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一键更新Excel中的图表&quot;&gt;&lt;a href=&quot;#一键更新Excel中的图表&quot; class=&quot;headerlink&quot; title=&quot;一键更新Excel中的图表&quot;&gt;&lt;/a&gt;一键更新Excel中的图表&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;场景：&lt;/strong&gt; 小编每周都要更新最近12周的“生产订单周报”给老板，而且要对比最近两年相同周数的数据。主要是两张图，一张是“一周生产订单对比”，另一张是“各部门订单比例”。虽然在Excel表中建了数据透视表，但是每周都还是需要花时间进行一通凶猛的操作，才能搞定。可不可以每周一键更新，并得到这两张图呢？&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="pandas" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/"/>
    
    
    <category term="matplotlib" scheme="http://example.com/tags/matplotlib/"/>
    
    <category term="pandas" scheme="http://example.com/tags/pandas/"/>
    
    <category term="numpy" scheme="http://example.com/tags/numpy/"/>
    
    <category term="datetime" scheme="http://example.com/tags/datetime/"/>
    
  </entry>
  
  <entry>
    <title>生成器 | 生成器输出小于maxnum的偶数或奇数</title>
    <link href="http://example.com/2021/11/01/%E7%94%9F%E6%88%90%E5%99%A8%E8%BE%93%E5%87%BA%E5%B0%8F%E4%BA%8Emaxnum%E7%9A%84%E5%81%B6%E6%95%B0%E6%88%96%E5%A5%87%E6%95%B0/"/>
    <id>http://example.com/2021/11/01/%E7%94%9F%E6%88%90%E5%99%A8%E8%BE%93%E5%87%BA%E5%B0%8F%E4%BA%8Emaxnum%E7%9A%84%E5%81%B6%E6%95%B0%E6%88%96%E5%A5%87%E6%95%B0/</id>
    <published>2021-11-01T09:51:53.000Z</published>
    <updated>2021-11-02T02:29:10.162Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生成器输出小于max-num的偶数或奇数"><a href="#生成器输出小于max-num的偶数或奇数" class="headerlink" title="生成器输出小于max_num的偶数或奇数"></a>生成器输出小于max_num的偶数或奇数</h1><p>代码：</p><pre><code># 1.输出小于max_num的偶数或奇数def odd(max_num):        i = 1    while i &lt; max_num:        if i % 2 == 0:  # if % 2 == 1可生成奇数            yield i        i += 1g = odd(10)for n in g:    print(n)# 2.输出任意个偶数或奇数def odd():i = 2while i:    if i % 2 == 0:  # if % 2 == 1可生成奇数        yield i    i += 1g = odd()for i in range(100):    print(next(g))</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;生成器输出小于max-num的偶数或奇数&quot;&gt;&lt;a href=&quot;#生成器输出小于max-num的偶数或奇数&quot; class=&quot;headerlink&quot; title=&quot;生成器输出小于max_num的偶数或奇数&quot;&gt;&lt;/a&gt;生成器输出小于max_num的偶数或奇数&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="生成器" scheme="http://example.com/categories/python/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
    
    <category term="生成器" scheme="http://example.com/tags/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>生成器 | 生成器输出fibonacci数列</title>
    <link href="http://example.com/2021/11/01/%E7%94%9F%E6%88%90%E5%99%A8%E8%BE%93%E5%87%BAfibonacci%E6%95%B0%E5%88%97/"/>
    <id>http://example.com/2021/11/01/%E7%94%9F%E6%88%90%E5%99%A8%E8%BE%93%E5%87%BAfibonacci%E6%95%B0%E5%88%97/</id>
    <published>2021-11-01T09:47:51.000Z</published>
    <updated>2021-11-01T09:49:36.831Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生成器输出小于max-num的fibonacci数列"><a href="#生成器输出小于max-num的fibonacci数列" class="headerlink" title="生成器输出小于max_num的fibonacci数列"></a>生成器输出小于max_num的fibonacci数列</h1><p>代码：</p><pre><code>def feb(max_num):    n_1 = 1    n_2 = 1    n = 0    while n &lt; max_num:        if n == 0 or n == 1:            yield 1            n += 1        else:            yield n_1 + n_2            new_n_2 = n_1            n_1 = n_1 + n_2            n_2 = new_n_2            n += 1g = feb(5)for n in g:    print(n)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;生成器输出小于max-num的fibonacci数列&quot;&gt;&lt;a href=&quot;#生成器输出小于max-num的fibonacci数列&quot; class=&quot;headerlink&quot; title=&quot;生成器输出小于max_num的fibonacci数列&quot;&gt;&lt;/a&gt;生成器输出小于m</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="生成器" scheme="http://example.com/categories/python/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
    
    <category term="生成器" scheme="http://example.com/tags/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>生成器 | 生成器输出质数</title>
    <link href="http://example.com/2021/11/01/%E7%94%9F%E6%88%90%E5%99%A8%E8%BE%93%E5%87%BA%E8%B4%A8%E6%95%B0/"/>
    <id>http://example.com/2021/11/01/%E7%94%9F%E6%88%90%E5%99%A8%E8%BE%93%E5%87%BA%E8%B4%A8%E6%95%B0/</id>
    <published>2021-11-01T09:07:02.000Z</published>
    <updated>2021-11-01T09:29:27.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生成器输出小于max-num的质数"><a href="#生成器输出小于max-num的质数" class="headerlink" title="生成器输出小于max_num的质数"></a>生成器输出小于max_num的质数</h1><p>通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。<br>而且，创建一个包含成百上千完个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前<br>面几个元素，那后面绝大多数元素占用的空间都白白浪费了。生成器有效的解决了这个问题。</p><span id="more"></span><p>代码：</p><pre><code>def factor(max_num):    # 这是一个函数  用于输出所有小于max_num的质数    factor_list = []    n = 2    while n &lt; max_num:        find = False        for f in factor_list:            # 先看看列表里面有没有能整除它的            if n % f == 0:                find = True                break        if not find:            factor_list.append(n)            yield n        n += 1g = factor(10)for n in g:    print(n)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;生成器输出小于max-num的质数&quot;&gt;&lt;a href=&quot;#生成器输出小于max-num的质数&quot; class=&quot;headerlink&quot; title=&quot;生成器输出小于max_num的质数&quot;&gt;&lt;/a&gt;生成器输出小于max_num的质数&lt;/h1&gt;&lt;p&gt;通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。&lt;br&gt;而且，创建一个包含成百上千完个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前&lt;br&gt;面几个元素，那后面绝大多数元素占用的空间都白白浪费了。生成器有效的解决了这个问题。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="生成器" scheme="http://example.com/categories/python/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
    
    <category term="生成器" scheme="http://example.com/tags/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>requests | Python爬取博客的所有文章并存为带目录的word文档</title>
    <link href="http://example.com/2021/10/31/Python%E7%88%AC%E5%8F%96%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E7%AB%A0%E5%B9%B6%E5%AD%98%E4%B8%BA%E5%B8%A6%E7%9B%AE%E5%BD%95%E7%9A%84word%E6%96%87%E6%A1%A3/"/>
    <id>http://example.com/2021/10/31/Python%E7%88%AC%E5%8F%96%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E7%AB%A0%E5%B9%B6%E5%AD%98%E4%B8%BA%E5%B8%A6%E7%9B%AE%E5%BD%95%E7%9A%84word%E6%96%87%E6%A1%A3/</id>
    <published>2021-10-31T14:07:12.000Z</published>
    <updated>2021-10-31T14:09:22.349Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python爬取博客的所有文章并存为带目录的word文档"><a href="#Python爬取博客的所有文章并存为带目录的word文档" class="headerlink" title="Python爬取博客的所有文章并存为带目录的word文档"></a>Python爬取博客的所有文章并存为带目录的word文档</h1><p>Python爬取博客的所有文章并存为带目录的word文档,结果非常美丽！从此阅读博客文章轻松多了！！！</p><span id="more"></span><p>实现代码：</p><pre><code>import requestsfrom bs4 import BeautifulSoupurl = f&#39;http://blog.sina.com.cn/s/articlelist_5119330124_0_1.html&#39;wb_data = requests.get(url)soup = BeautifulSoup(wb_data.content)# 获取当页所有文章的标题和链接# print(soup.select(&#39;.atc_title&#39;))# 获取当页所有文章的发表时间# print(soup.select(&#39;.atc_tm&#39;))# print(soup.select(&#39;.atc_title&#39;)[0].select(&#39;a&#39;))# [&lt;a href=&quot;http://blog.sina.com.cn/s/blog_13122c74c0102zdsy.html&quot; target=&quot;_blank&quot; title=&quot;&quot;&gt;投资难在慢成毁于速成&lt;/a&gt;]# print(soup.select(&#39;.atc_title&#39;)[0].select(&#39;a&#39;)[0].get(&quot;href&quot;))# http://blog.sina.com.cn/s/blog_13122c74c0102zdsy.html# print(soup.select(&#39;.atc_title&#39;)[0].select(&#39;a&#39;)[0].text)# print(soup.select(&#39;.atc_tm&#39;)[0].text)# 获取所有博客文章的链接import requestsfrom bs4 import BeautifulSoupall_links = &#123;&#125;for i in range(1, 6):    url = f&#39;http://blog.sina.com.cn/s/articlelist_5119330124_0_&#123;i&#125;.html&#39;    wb_data = requests.get(url)    soup = BeautifulSoup(wb_data.content)    links = soup.select(&#39;.atc_title&#39;)    times = soup.select(&#39;.atc_tm&#39;)    for i in range(len(links)):        http_link = links[i].select(&#39;a&#39;)[0].get(&#39;href&#39;)        title = links[i].text.strip()        time = times[i].text        all_links[title] = [http_link, time]# print(len(all_links))# 获取单篇文章中的文字url = &#39;http://blog.sina.com.cn/s/blog_13122c74c0102zbt3.html&#39;wb_data = requests.get(url)soup = BeautifulSoup(wb_data.content)article = soup.select(&quot;.articalContent.newfont_family&quot;)# print(article)# print(article[0].text)# print(article[0].text.replace(&quot;\xa0&quot;, &quot;&quot;))# 获取单篇文章中的图片链接url = &#39;http://blog.sina.com.cn/s/blog_13122c74c0102zbud.html&#39;wb_data = requests.get(url)soup = BeautifulSoup(wb_data.content)img_link = soup.select(&quot;.articalContent.newfont_family&quot;)[0].find_all(&quot;img&quot;)[0].get(&quot;real_src&quot;)# 图片下载函数def downloadImg(img_url, file_path):    req = requests.get(url=img_url)    with open(file_path, &#39;wb&#39;) as f:        f.write(req.content)downloadImg(r&#39;http://s8.sinaimg.cn/middle/005AsbCIzy7vEfdM1M599&#39;,            r&#39;..\实例67_Python爬取博客的所有文章并存为带目录的word文档\1.jpg&#39;)# 写入标题，内容到word文件import docxfrom docx.oxml.ns import qn  # 用于应用中文字体def to_word(all_links):    header = &#123;        &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) &quot;                      &quot;Chrome/49.0.2623.221 Safari/537.36 SE 2.X MetaSr 1.0&quot;&#125;    doc = docx.Document()  # 新建word文档    doc.styles[&#39;Normal&#39;].font.name = u&#39;宋体&#39;    doc.styles[&#39;Normal&#39;]._element.rPr.rFonts.set(qn(&#39;w:eastAsia&#39;), u&#39;宋体&#39;)    counter = 0  # 计数器，用于记录写入word的文章数    for title in all_links.keys():        doc.add_heading(title, 1)        date = all_links[title][1][:10]  # 只取日期，不要时间        doc.add_paragraph(date)        wb_data = requests.get(all_links[title][0], headers=header)        soup = BeautifulSoup(wb_data.content)        article = soup.select(&quot;.articalContent.newfont_family&quot;)        # 有些文章被加密，获取不到内容，此时article为空，所以加个if语句判断        if article:            text = article[0].text.replace(&quot;\xa0&quot;, &quot;&quot;)            doc.add_paragraph(text)            print(f&quot;写入文章 &#123;title&#125; 。&quot;)            counter += 1    print(f&quot;共写入 &#123;counter&#125; 篇文章。&quot;)    doc.save(&quot;新浪微博文章.docx&quot;)to_word(all_links)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Python爬取博客的所有文章并存为带目录的word文档&quot;&gt;&lt;a href=&quot;#Python爬取博客的所有文章并存为带目录的word文档&quot; class=&quot;headerlink&quot; title=&quot;Python爬取博客的所有文章并存为带目录的word文档&quot;&gt;&lt;/a&gt;Python爬取博客的所有文章并存为带目录的word文档&lt;/h1&gt;&lt;p&gt;Python爬取博客的所有文章并存为带目录的word文档,结果非常美丽！从此阅读博客文章轻松多了！！！&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="requests" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="requests" scheme="http://example.com/tags/requests/"/>
    
    <category term="BeautifulSoup" scheme="http://example.com/tags/BeautifulSoup/"/>
    
  </entry>
  
  <entry>
    <title>win32com | 识别加密word文件</title>
    <link href="http://example.com/2021/10/31/%E8%AF%86%E5%88%AB%E5%8A%A0%E5%AF%86word%E6%96%87%E4%BB%B6/"/>
    <id>http://example.com/2021/10/31/%E8%AF%86%E5%88%AB%E5%8A%A0%E5%AF%86word%E6%96%87%E4%BB%B6/</id>
    <published>2021-10-31T13:32:56.000Z</published>
    <updated>2021-11-01T09:04:03.208Z</updated>
    
    <content type="html"><![CDATA[<h1 id="识别加密word文件"><a href="#识别加密word文件" class="headerlink" title="识别加密word文件"></a>识别加密word文件</h1><p>Python本身是难以识别word文件的加密状态的，那我们可以考虑利用程序在处理有密码的文档的时候的报错信息来进行处理。word文件有两种密码，一种是“打开密码”，另一种是“修改密码”。对于前者，若不输入正确的密码，是无法打开文件查看内容的；对于后者，即使不知道密码，还是可以用只读模式打开文件，查看内容并另存为新的文件的。<br>因此对于设置了“修改密码”的doc文件，并不影响用如下程序另存为docx文件。只是在另存之前，窗口会弹出如下对话框，我们只需要点击一下“只读”即可，程序就能正常运行下去。<br>如果设置了“打开密码”，程序在运行的时候也会弹出对话框，让输入密码。如果输入正确的密码，程序也是可以运行的；如果不知道密码或输入错误密码，则程序会出现如下的“com_error”错误。如果不知道密码，可以加入try..except..语句，让程序在except语句中将这个文件移动到名字为“有密码文件”的文件夹，以便后续处理。</p><span id="more"></span><p>实现代码：</p><pre><code>from win32com import client as wc  # 导入模块file = r&quot;C:\Users\dywei\python\python_excel\实例65_Python区分出加密的word文件\doc文件\\测试-有打开密码.doc&quot;word = wc.Dispatch(&quot;Word.Application&quot;)  # 打开word应用程序doc = word.Documents.Open(file)  # 打开word文件doc.SaveAs(&quot;&#123;&#125;x&quot;.format(file), 12)  # 另存为后缀为&quot;.docx&quot;的文件，其中参数12指docx文件doc.Close()  # 关闭原来word文件word.Quit()# 增加异常处理语句import shutil  # 用于操作文件和文件夹from win32com import client as wcfile = r&quot;C:\Users\dywei\python\python_excel\实例65_Python区分出加密的word文件\doc文件\\测试-有打开密码.doc&quot;try:    word = wc.Dispatch(&quot;Word.Application&quot;)  # 打开word应用程序    doc = word.Documents.Open(file)  # 打开word文件    doc.SaveAs(&quot;&#123;&#125;x&quot;.format(file), 12)  # 另存为后缀为&quot;.docx&quot;的文件，其中参数12指docx文件    doc.Close()  # 关闭原来word文件    word.Quit()except:    # 将有密码的文件移动到专门的文件夹    shutil.move(file, r&quot;C:\Users\dywei\python\python_excel\实例65_Python区分出加密的word文件\有密码文件&quot;)    print(f&quot;已移动加密文件 &#123;file&#125;&quot;)# #文件有“打开密码”的情况# import docx# doc = docx.Document(&#39;docx文件\\报告-有打开密码.docx&#39;)# PackageNotFoundError: Package not found at &#39;docx文件\报告-有打开密码.docx&#39;# 文件有“修改密码”的情况import docxdoc = docx.Document(&#39;docx文件\\报告-有修改密码.docx&#39;)p = doc.paragraphs[0]pNew = p.insert_paragraph_before()run = pNew.add_run(&quot;测试&quot;)doc.save(&quot;docx文件\\报告-有修改密码.docx&quot;)import docximport shutilfile = &quot;docx文件\\报告-有打开密码.docx&quot;try:    doc = docx.Document(file)    passexcept:    shutil.move(file, &#39;有密码文件&#39;)    print(f&quot;已移动加密文件 &#123;file&#125; 到指定文件夹&quot;)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;识别加密word文件&quot;&gt;&lt;a href=&quot;#识别加密word文件&quot; class=&quot;headerlink&quot; title=&quot;识别加密word文件&quot;&gt;&lt;/a&gt;识别加密word文件&lt;/h1&gt;&lt;p&gt;Python本身是难以识别word文件的加密状态的，那我们可以考虑利用程序在处理有密码的文档的时候的报错信息来进行处理。word文件有两种密码，一种是“打开密码”，另一种是“修改密码”。对于前者，若不输入正确的密码，是无法打开文件查看内容的；对于后者，即使不知道密码，还是可以用只读模式打开文件，查看内容并另存为新的文件的。&lt;br&gt;因此对于设置了“修改密码”的doc文件，并不影响用如下程序另存为docx文件。只是在另存之前，窗口会弹出如下对话框，我们只需要点击一下“只读”即可，程序就能正常运行下去。&lt;br&gt;如果设置了“打开密码”，程序在运行的时候也会弹出对话框，让输入密码。如果输入正确的密码，程序也是可以运行的；如果不知道密码或输入错误密码，则程序会出现如下的“com_error”错误。如果不知道密码，可以加入try..except..语句，让程序在except语句中将这个文件移动到名字为“有密码文件”的文件夹，以便后续处理。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="win32com" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/win32com/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="win32com" scheme="http://example.com/tags/win32com/"/>
    
    <category term="python-docx" scheme="http://example.com/tags/python-docx/"/>
    
    <category term="shutil" scheme="http://example.com/tags/shutil/"/>
    
  </entry>
  
  <entry>
    <title>python | 分块拆分txt文件中的数据</title>
    <link href="http://example.com/2021/10/30/python%E5%88%86%E5%9D%97%E6%8B%86%E5%88%86txt%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE/"/>
    <id>http://example.com/2021/10/30/python%E5%88%86%E5%9D%97%E6%8B%86%E5%88%86txt%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE/</id>
    <published>2021-10-31T02:50:47.000Z</published>
    <updated>2021-10-31T03:23:28.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分块拆分txt文件中的数据"><a href="#分块拆分txt文件中的数据" class="headerlink" title="分块拆分txt文件中的数据"></a>分块拆分txt文件中的数据</h1><p>代码：</p><pre><code># -*- coding:utf-8 -*-# 读取txt文件中的数据file = open(&quot;数据.txt&quot;)lines = file.readlines()# print(lines[:5])data = &#123;&#125;  # 储存分割的数据line_list = []  # 中转列表last_id = &quot;start&quot;  # 数据分块标识for line in lines:    row_data = line.split(&quot; &quot;)  # 将一行数据按空格分隔    ID = row_data[0]  # 获得ID    if last_id == &quot;start&quot;:  # 用于处理数据第一行        line_list.append(line)  # 将第一行数据放入中转列表    else:  # 不是第一行数据，则按如下执行        if ID != last_id:  # 如果出现新的数据块            if last_id in data:  # 新的数据块的ID已存在字典data中                data[last_id].append(line_list)  # 将中转列表的数据添加到对应的ID中            else:  # 新的数据快的ID不在字典data中                data[last_id] = [line_list]  # 将上一个数据块加入对应的ID            line_list = [line]  # 将中转列表清空，并放入新数据快的第一行数据        else:  # 没出现新的数据块            line_list.append(line)  # 将数据继续加入中转列表    last_id = ID  # 每处理一行，将分块标识last_id更行为最新的ID# 将最后一个文字块的数据放入字典if last_id in data:    data[last_id].append(line_list)else:    data[last_id] = [line_list]# print(data[&#39;89031&#39;])# for i in data.keys():#     for block in data[i]:#         print(block)#         print(&quot;- -&quot;*50)# 写入数据函数def to_txt(filename, data_list):  # filename为写入文件的名字，data为要写入数据列表    file = open(&quot;分块\\&quot; + filename + &#39;.txt&#39;, &#39;a&#39;)    for i in range(len(data_list)):        file.write(data_list[i])    file.close()  # 保存数据并关闭# 批量写入数据for ID in data.keys():    for i in range(len(data[ID])):        to_txt(f&quot;&#123;ID&#125;_&#123;i+1&#125;&quot;, data[ID][i])        </code></pre><p><a href="数据.txt">数据.txt</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分块拆分txt文件中的数据&quot;&gt;&lt;a href=&quot;#分块拆分txt文件中的数据&quot; class=&quot;headerlink&quot; title=&quot;分块拆分txt文件中的数据&quot;&gt;&lt;/a&gt;分块拆分txt文件中的数据&lt;/h1&gt;&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# -*- c</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="基础" scheme="http://example.com/categories/python/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>tkinter | Tkinter制作python程序的图形化界面</title>
    <link href="http://example.com/2021/10/30/Tkinter%E5%88%B6%E4%BD%9Cpython%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2/"/>
    <id>http://example.com/2021/10/30/Tkinter%E5%88%B6%E4%BD%9Cpython%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2/</id>
    <published>2021-10-31T02:42:14.000Z</published>
    <updated>2021-10-31T02:45:32.044Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tkinter制作python程序的图形化界面"><a href="#Tkinter制作python程序的图形化界面" class="headerlink" title="Tkinter制作python程序的图形化界面"></a>Tkinter制作python程序的图形化界面</h1><p>代码：</p><pre><code>from os import listdir, getcwdfrom xlrd import open_workbook, xldatefrom datetime import datetimefrom time import time, localtime, strftimefrom openpyxl import Workbookfrom openpyxl.styles import Border, Side, PatternFill, Font, GradientFill, Alignmentfrom tkinter import Tk, Entry, Button, Listbox, X, Y, END, Scrollbar, RIGHT, BOTTOM, HORIZONTALfrom tkinter.filedialog import askdirectoryclass MainGUI():    def __init__(self):        myWindow = Tk()        myWindow.title(&quot;领料记录汇总&quot;)        # 设置窗口大小        myWindow.geometry(&#39;590x400&#39;)        myWindow.iconbitmap(getcwd() + &quot;\\PO.ico&quot;)        # 增加文本框        self.input_entry = Entry(myWindow, highlightcolor=&#39;red&#39;, highlightthickness=1)        self.input_entry.place(x=10, y=10, width=480, height=30)        self.btn_in = Button(myWindow, text=&#39;输入文件目录&#39;, command=self.select_dir1, width=10, height=1)        self.btn_in.place(x=500, y=10)        self.output_entry = Entry(myWindow, highlightcolor=&#39;blue&#39;, highlightthickness=1)        self.output_entry.place(x=10, y=50, width=480, height=30)        self.btn_out = Button(myWindow, text=&#39;输出文件目录&#39;, command=self.select_dir2, width=10, height=1)        self.btn_out.place(x=500, y=50)        self.btn_run = Button(myWindow, text=&#39;执行汇总&#39;, width=10, height=1, command=self.Summary_data)        self.btn_run.place(x=500, y=90)        # 增加列表框        self.result_show = Listbox(myWindow, bg=&#39;DarkSeaGreen&#39;)  # yscrollcommand = scroll_bar,        self.result_show.place(x=10, y=130, width=570, height=260)        self.sbY = Scrollbar(self.result_show, command=self.result_show.yview)  # 在列表框中增加Y轴滚动条        self.sbY.pack(side=RIGHT, fill=Y)        self.result_show.config(yscrollcommand=self.sbY.set)        self.sbX = Scrollbar(self.result_show, command=self.result_show.xview, orient=HORIZONTAL)  # 在列表框中增加X轴滚动条        self.sbX.pack(side=BOTTOM, fill=X)        self.result_show.config(xscrollcommand=self.sbX.set)        myWindow.mainloop()    def select_dir1(self):        self.input_entry.delete(0, END)        self.input_entry.insert(0, askdirectory(initialdir=&quot;D:\\&quot;))    def select_dir2(self):        self.output_entry.delete(0, END)        self.output_entry.insert(0, askdirectory(initialdir=&quot;D:\\&quot;))    # 读取xls文件中的数据    def Get_data(self, file):        wb = open_workbook(file)  # 读取工作簿        ws = wb.sheets()[0]  # 选第一个工作表        data = &#123;&#125;        for row in range(7, ws.nrows - 2):            dept = ws.cell(2, 16).value  # 部门            dept_id = ws.cell(3, 16).value  # 部门编号            dt = ws.cell(row, 0).value  # 时间            if type(dt) is float:                date_time = xldate.xldate_as_datetime(dt, 0)            else:                date_time = datetime.strptime(dt, &#39;%Y-%m-%d %H:%M:%S&#39;)            business = ws.cell(row, 2).value  # 业务类型            model = ws.cell(row, 3).value  # 品种            qty = ws.cell(row, 4).value  # 数量            unit_price = ws.cell(row, 6).value  # 单价            price = ws.cell(row, 8).value  # 总价            reward = ws.cell(row, 9).value  # 额外值            discount = ws.cell(row, 11).value  # 调整            balance = ws.cell(row, 13).value  # 剩余            location = str(ws.cell(row, 15).value).strip()  # 库位            operator = ws.cell(row, 17).value  # 操作员            date = date_time.date()  # 日期            time = date_time.time()  # 时间            info_list = [dept, dept_id, date_time, business, model, qty, unit_price, price, reward, discount,                         balance, location, operator, date, time]            data.setdefault(date, [])  # 以日期为键            if info_list[3] != &quot;备注&quot;:  # 不要业务类型为“备注”的数据                data[date].append(info_list)        # 增加当日领取次数        for key in data.keys():            for i in data[key]:                i.append(len(data[key]))        return data    def Get_file_path(self, path):        files = []        for file in listdir(path):            if file.endswith(&quot;.xls&quot;):  # 排除文件夹内的其它干扰文件                files.append(path + &quot;\\&quot; + file)        return files    def Get_current_time(self):        time_stamp = time()  # 当前时间的时间戳        local_time = localtime(time_stamp)  #        str_time = strftime(&#39;%Y-%m-%d %H.%M.%S&#39;, local_time)        return str_time    def Summary_data(self):        thin = Side(border_style=&quot;thin&quot;, color=&quot;000000&quot;)  # 定义边框粗细及颜色        title = [&#39;部门&#39;, &#39;部门编号&#39;, &#39;时间&#39;, &#39;业务类型&#39;, &#39;品种&#39;, &#39;数量&#39;, &#39;单价&#39;, &#39;金额&#39;, &#39;额外值&#39;,                 &#39;调整&#39;, &#39;剩余&#39;, &#39;库位&#39;, &#39;操作员&#39;, &#39;领取日期&#39;, &#39;领取时间&#39;, &#39;领取次数&#39;]        wb = Workbook()        ws = wb.active        ws.merge_cells(&quot;A1:P1&quot;)        ws.cell(1, 1).value = &quot;领料明细汇总表&quot;        ws.cell(1, 1).font = Font(name=u&#39;黑体&#39;, bold=True, size=18)        ws.row_dimensions[1].height = 22.2        ws.cell(1, 1).alignment = Alignment(horizontal=&quot;center&quot;, vertical=&quot;center&quot;)        ws.append(title)        # 插入数据        files = self.Get_file_path(self.input_entry.get())  # get()获取文本编辑框中的输入文件目录，并获取目录下的xls文件        for file in files:            data = self.Get_data(file)            for key in data.keys():                for i in data[key]:                    ws.append(i)            f = f&quot;&#123;file&#125; 的内容已加入总表.&quot;  # 创建一个显示项            self.result_show.insert(&quot;end&quot;, f)  # 将结果添加到列表框中        # 设置字号，对齐，缩小字体填充，加边框        # Font(bold=True)可加粗字体        for row_number in range(2, ws.max_row + 1):            for col_number in range(1, 17):                c = ws.cell(row=row_number, column=col_number)                c.font = Font(size=9)                c.border = Border(top=thin, left=thin, right=thin, bottom=thin)                c.alignment = Alignment(horizontal=&quot;left&quot;, vertical=&quot;center&quot;)        col_name = list(&quot;ABCDEFGHIJKLMNOP&quot;)        col_width = [8, 8, 16, 8, 16, 8, 8, 9.8, 8, 8, 8, 11, 8.3, 9, 8, 8]        for i in range(len(col_name)):            ws.column_dimensions[col_name[i]].width = col_width[i]        ws.column_dimensions.group(&#39;I&#39;, &#39;K&#39;, hidden=True)        ws.column_dimensions.group(&#39;N&#39;, &#39;O&#39;, hidden=True)        wb.save(f&quot;&#123;self.output_entry.get()&#125;\\领料明细汇总表&#123;self.Get_current_time()&#125;.xlsx&quot;)        f = &quot;-&quot; * 100  # 创建分割线        self.result_show.insert(&quot;end&quot;, f)  # 将分割线添加到列表框        f = f&quot;领料明细汇总表&#123;self.Get_current_time()&#125;.xlsx 已生成，请去输出文件夹查看.&quot;  # 创建一个显示项        self.result_show.insert(&quot;end&quot;, f)  # 将结果添加到列表框        f = &quot; &quot; * 100        self.result_show.insert(&quot;end&quot;, f)  # 将以上空格添加到列表框if __name__ == &quot;__main__&quot;:    MainGUI()</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Tkinter制作python程序的图形化界面&quot;&gt;&lt;a href=&quot;#Tkinter制作python程序的图形化界面&quot; class=&quot;headerlink&quot; title=&quot;Tkinter制作python程序的图形化界面&quot;&gt;&lt;/a&gt;Tkinter制作python程序</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="tkinter" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/tkinter/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="tkinter" scheme="http://example.com/tags/tkinter/"/>
    
  </entry>
  
  <entry>
    <title>pyinstaller | python程序打包</title>
    <link href="http://example.com/2021/10/29/python%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85/"/>
    <id>http://example.com/2021/10/29/python%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85/</id>
    <published>2021-10-30T07:42:35.000Z</published>
    <updated>2021-10-30T08:53:44.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python程序打包"><a href="#python程序打包" class="headerlink" title="python程序打包"></a>python程序打包</h1><p>通常情况我们在pycharm中写的python程序只能在安装了python的电脑上运行，那么如何移植到其他电脑上也能运行呢？<br>我们可以将py文件打包成可执行程序(exe文件).</p><h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><h3 id="1-pyinstaller库安装"><a href="#1-pyinstaller库安装" class="headerlink" title="1. pyinstaller库安装"></a>1. pyinstaller库安装</h3><pre><code>pip install pyinstaller -i https://pypi.doubanio.com/simple/</code></pre><h3 id="2-打包"><a href="#2-打包" class="headerlink" title="2.打包"></a>2.打包</h3><pre><code>pyinstaller -D program.py ---&gt; 打包成一个文件夹（默认操作）pyinstaller -F program.py ---&gt; 打包成单个可执行文件</code></pre><p>程序运行后，会在目录生成一个文件：<br>1.program.spec(打包规则)<br>三个文件夹：<br>1.__pycache __(Python版本信息)<br>2.build(存储日志文件)<br>3.dist(储存可执行文件即相关的文件夹)<br><strong>注：打包完成后，除了dist文件夹，其它都可以删除，没什么用。</strong></p><h3 id="3-将打包好的文件制作成一个安装文件"><a href="#3-将打包好的文件制作成一个安装文件" class="headerlink" title="3.将打包好的文件制作成一个安装文件"></a>3.将打包好的文件制作成一个安装文件</h3><p>使用NSIS文件夹压缩器来制作安装文件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;python程序打包&quot;&gt;&lt;a href=&quot;#python程序打包&quot; class=&quot;headerlink&quot; title=&quot;python程序打包&quot;&gt;&lt;/a&gt;python程序打包&lt;/h1&gt;&lt;p&gt;通常情况我们在pycharm中写的python程序只能在安装了python的</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="pyinstaller" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pyinstaller/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="pyinstaller" scheme="http://example.com/tags/pyinstaller/"/>
    
    <category term="程序打包" scheme="http://example.com/tags/%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>PyQt5 | python制作图形用户界面让操作可视化</title>
    <link href="http://example.com/2021/10/29/python%E5%88%B6%E4%BD%9C%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E8%AE%A9%E6%93%8D%E4%BD%9C%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    <id>http://example.com/2021/10/29/python%E5%88%B6%E4%BD%9C%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E8%AE%A9%E6%93%8D%E4%BD%9C%E5%8F%AF%E8%A7%86%E5%8C%96/</id>
    <published>2021-10-30T02:33:58.000Z</published>
    <updated>2021-10-30T02:36:38.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python制作图形用户界面让操作可视化"><a href="#python制作图形用户界面让操作可视化" class="headerlink" title="python制作图形用户界面让操作可视化"></a>python制作图形用户界面让操作可视化</h1><p>代码：</p><pre><code>import sysimport osfrom PyQt5 import QtWidgetsfrom PyQt5.QtGui import QIconimport xlrdimport datetimeimport timefrom openpyxl import Workbookfrom openpyxl.styles import Border, Side, PatternFill, Font, GradientFill, Alignmentclass MainGUI(QtWidgets.QMainWindow):    def __init__(self):        super().__init__()        self.setWindowTitle(&quot;领料明细汇总&quot;)        self.resize(800, 400)        self.main_widget = QtWidgets.QWidget()        self.main_widget_layout = QtWidgets.QGridLayout()        self.main_widget.setLayout(self.main_widget_layout)        self.input = QtWidgets.QLineEdit()        self.input_btn = QtWidgets.QPushButton(&quot;选择输入文件夹&quot;)        self.output = QtWidgets.QLineEdit()        self.output_btn = QtWidgets.QPushButton(&quot;选择输出文件夹&quot;)        self.show_result = QtWidgets.QListWidget()        self.run = QtWidgets.QPushButton(&quot;执行汇总&quot;)        self.main_widget_layout.addWidget(self.input, 0, 0, 1, 2)        self.main_widget_layout.addWidget(self.input_btn, 0, 2, 1, 1)        self.main_widget_layout.addWidget(self.output, 1, 0, 1, 2)        self.main_widget_layout.addWidget(self.output_btn, 1, 2, 1, 1)        self.main_widget_layout.addWidget(self.run, 2, 2, 1, 1)        self.main_widget_layout.addWidget(self.show_result, 3, 0, 3, 3)        self.setCentralWidget(self.main_widget)        self.input_btn.clicked.connect(self.Choice_dir_input)  # 将&quot;选择输入文件夹&quot;按钮绑定Choice_dir_input函数        self.output_btn.clicked.connect(self.Choice_dir_output)  # 将&quot;选择输出文件夹&quot;按钮绑定Choice_dir_output函数        self.run.clicked.connect(self.Summary_data)  # “执行汇总”按钮绑定Summary_data函数    def Choice_dir_input(self):        # 选择目录操作        dir_path = QtWidgets.QFileDialog.getExistingDirectory(self, &quot;请选择文件夹路径&quot;, &quot;D:\\&quot;)        # 将选择的目录显示在文本编辑框中        self.input.setText(dir_path)    def Choice_dir_output(self):        dir_path = QtWidgets.QFileDialog.getExistingDirectory(self, &quot;请选择文件夹路径&quot;, &quot;D:\\&quot;)        self.output.setText(dir_path)    def Get_data(self, file):        &#39;&#39;&#39;获取单个Excel文件中的资料&#39;&#39;&#39;        wb = xlrd.open_workbook(file)        ws = wb.sheets()[0]        data = &#123;&#125;        for row in range(7, ws.nrows - 2):            card_id = ws.cell(2, 16).value            car = ws.cell(3, 16).value            dt = ws.cell(row, 0).value            if type(dt) is float:                date_time = xlrd.xldate.xldate_as_datetime(dt, 0)            else:                date_time = datetime.datetime.strptime(dt, &#39;%Y-%m-%d %H:%M:%S&#39;)            business = ws.cell(row, 2).value            model = ws.cell(row, 3).value            qty = ws.cell(row, 4).value            unit_price = ws.cell(row, 6).value            price = ws.cell(row, 8).value            reward = ws.cell(row, 9).value            discount = ws.cell(row, 11).value            balance = ws.cell(row, 13).value            location = str(ws.cell(row, 15).value).strip()            operator = ws.cell(row, 17).value            date = date_time.date()            time = date_time.time()            info_list = [card_id, car, date_time, business, model, qty, unit_price, price, reward, discount,                         balance, location, operator, date, time]            data.setdefault(date, [])            if info_list[3] != &quot;备注&quot;:                data[date].append(info_list)        # 增加当日加油次数        for key in data.keys():            for i in data[key]:                i.append(len(data[key]))        return data    def Get_file_path(self, path):        files = []        for file in os.listdir(path):            if file.endswith(&quot;.xls&quot;):  # 排除文件夹内的其它干扰文件                files.append(path + &quot;\\&quot; + file)        return files    def Get_current_time(self):        time_stamp = time.time()  # 当前时间的时间戳        local_time = time.localtime(time_stamp)  #        str_time = time.strftime(&#39;%Y-%m-%d %H.%M.%S&#39;, local_time)        return str_time    def Summary_data(self, files):        thin = Side(border_style=&quot;thin&quot;, color=&quot;000000&quot;)  # 定义边框粗细及颜色        title = [&#39;部门&#39;, &#39;部门编号&#39;, &#39;时间&#39;, &#39;业务类型&#39;, &#39;品种&#39;, &#39;数量&#39;, &#39;单价&#39;, &#39;金额&#39;, &#39;额外值&#39;,                 &#39;调整&#39;, &#39;剩余&#39;, &#39;库位&#39;, &#39;操作员&#39;, &#39;领取日期&#39;, &#39;领取时间&#39;, &#39;领取次数&#39;]        wb = Workbook()        ws = wb.active        ws.merge_cells(&quot;A1:P1&quot;)        ws.cell(1, 1).value = &quot;领料明细汇总表&quot;        ws.cell(1, 1).font = Font(name=u&#39;黑体&#39;, bold=True, size=18)        ws.row_dimensions[1].height = 22.2        ws.cell(1, 1).alignment = Alignment(horizontal=&quot;center&quot;, vertical=&quot;center&quot;)        ws.append(title)        # 插入数据        files = self.Get_file_path(self.input.text())  # 获取文本编辑框中的输入文件目录，并获取目录下的xls文件        for file in files:            data = self.Get_data(file)            for key in data.keys():                for i in data[key]:                    ws.append(i)            f = QtWidgets.QListWidgetItem(f&quot;&#123;file&#125; 的内容已加入总表.&quot;)  # 创建一个显示项            self.show_result.addItem(f)  # 将结果添加到部件中        # 设置字号，对齐，缩小字体填充，加边框        # Font(bold=True)可加粗字体        for row_number in range(2, ws.max_row + 1):            for col_number in range(1, 17):                c = ws.cell(row=row_number, column=col_number)                c.font = Font(size=9)                c.border = Border(top=thin, left=thin, right=thin, bottom=thin)                c.alignment = Alignment(horizontal=&quot;left&quot;, vertical=&quot;center&quot;)        col_name = list(&quot;ABCDEFGHIJKLMNOP&quot;)        col_width = [8, 8, 16, 8, 16, 8, 8, 9.8, 8, 8, 8, 11, 8.3, 9, 8, 8]        for i in range(len(col_name)):            ws.column_dimensions[col_name[i]].width = col_width[i]        ws.column_dimensions.group(&#39;I&#39;, &#39;K&#39;, hidden=True)        ws.column_dimensions.group(&#39;N&#39;, &#39;O&#39;, hidden=True)        wb.save(f&quot;&#123;self.output.text()&#125;\\领料明细汇总表&#123;self.Get_current_time()&#125;.xlsx&quot;)        f = QtWidgets.QListWidgetItem(f&quot;\n领料明细汇总表&#123;self.Get_current_time()&#125;.xlsx 已生成，请去输出文件夹查看.&quot;)  # 创建一个显示项        self.show_result.addItem(f)  # 将结果添加到部件中def main():    app = QtWidgets.QApplication(sys.argv)    app.setWindowIcon(QIcon(&quot;PO.ico&quot;))  # 设置界面左上角图标    gui = MainGUI()    gui.show()    sys.exit(app.exec_())if __name__ == &#39;__main__&#39;:    main()    </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;python制作图形用户界面让操作可视化&quot;&gt;&lt;a href=&quot;#python制作图形用户界面让操作可视化&quot; class=&quot;headerlink&quot; title=&quot;python制作图形用户界面让操作可视化&quot;&gt;&lt;/a&gt;python制作图形用户界面让操作可视化&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="PyQt5" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/PyQt5/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="openpyxl" scheme="http://example.com/tags/openpyxl/"/>
    
    <category term="PyQt5" scheme="http://example.com/tags/PyQt5/"/>
    
  </entry>
  
  <entry>
    <title>xlrd | Python汇总各单位Excel档领料记录并加总每日领用次数</title>
    <link href="http://example.com/2021/10/29/Python%E6%B1%87%E6%80%BB%E5%90%84%E5%8D%95%E4%BD%8DExcel%E6%A1%A3%E9%A2%86%E6%96%99%E8%AE%B0%E5%BD%95%E5%B9%B6%E5%8A%A0%E6%80%BB%E6%AF%8F%E6%97%A5%E9%A2%86%E7%94%A8%E6%AC%A1%E6%95%B0/"/>
    <id>http://example.com/2021/10/29/Python%E6%B1%87%E6%80%BB%E5%90%84%E5%8D%95%E4%BD%8DExcel%E6%A1%A3%E9%A2%86%E6%96%99%E8%AE%B0%E5%BD%95%E5%B9%B6%E5%8A%A0%E6%80%BB%E6%AF%8F%E6%97%A5%E9%A2%86%E7%94%A8%E6%AC%A1%E6%95%B0/</id>
    <published>2021-10-30T02:12:27.000Z</published>
    <updated>2021-10-30T02:18:55.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python汇总各单位Excel档领料记录并加总每日领用次数"><a href="#Python汇总各单位Excel档领料记录并加总每日领用次数" class="headerlink" title="Python汇总各单位Excel档领料记录并加总每日领用次数"></a>Python汇总各单位Excel档领料记录并加总每日领用次数</h1><p><a href="https://www.cnblogs.com/insane-Mr-Li/p/9092619.html">xlrd详解</a><br>代码：</p><pre><code>import timeimport xlrdimport datetime# 读取xls文件中的数据def Get_data(file):    wb = xlrd.open_workbook(file)  # 读取工作簿    ws = wb.sheets()[0]  # 选第一个工作表    data = &#123;&#125;    for row in range(7, ws.nrows - 2):        dept = ws.cell(2, 16).value  # 部门        dept_id = ws.cell(3, 16).value  # 部门编号        dt = ws.cell(row, 0).value  # 时间        if type(dt) is float:            date_time = xlrd.xldate.xldate_as_datetime(dt, 0)        else:            date_time = datetime.datetime.strptime(dt, &#39;%Y-%m-%d %H:%M:%S&#39;)        business = ws.cell(row, 2).value  # 业务类型        model = ws.cell(row, 3).value  # 品种        qty = ws.cell(row, 4).value  # 数量        unit_price = ws.cell(row, 6).value  # 单价        price = ws.cell(row, 8).value  # 总价        reward = ws.cell(row, 9).value  # 额外值        discount = ws.cell(row, 11).value  # 调整        balance = ws.cell(row, 13).value  # 剩余        location = str(ws.cell(row, 15).value).strip()  # 库位        operator = ws.cell(row, 17).value  # 操作员        date = date_time.date()  # 日期        time = date_time.time()  # 时间        info_list = [dept, dept_id, date_time, business, model, qty, unit_price, price, reward, discount,                     balance, location, operator, date, time]        data.setdefault(date, [])  # 以日期为键        if info_list[3] != &quot;备注&quot;:  # 不要业务类型为“备注”的数据            data[date].append(info_list)    # 增加当日领取次数    for key in data.keys():        for i in data[key]:            i.append(len(data[key]))    return dataimport os  # 用于获取目标文件所在路径path = os.getcwd() + &quot;\\记录\\&quot;  # 文件夹绝对路径files = []for file in os.listdir(path):    if file.endswith(&quot;.xls&quot;):  # 只获取&quot;.xls&quot;后缀的文件        files.append(path + file)# print(files)# Get_data(files[0])def Get_current_time():    time_stamp = time.time()  # 当前时间的时间戳    local_time = time.localtime(time_stamp)  #    str_time = time.strftime(&#39;%Y-%m-%d %H.%M.%S&#39;, local_time)    return str_time# print(Get_current_time())# 汇总数据到主文件from openpyxl import Workbookfrom openpyxl.styles import Border, Side, PatternFill, Font, GradientFill, Alignment  # 设置单元格格式thin = Side(border_style=&quot;thin&quot;, color=&quot;000000&quot;)  # 定义边框粗细及颜色title = [&#39;部门&#39;, &#39;部门编号&#39;, &#39;时间&#39;, &#39;业务类型&#39;, &#39;品种&#39;, &#39;数量&#39;, &#39;单价&#39;, &#39;金额&#39;, &#39;额外值&#39;,         &#39;调整&#39;, &#39;剩余&#39;, &#39;库位&#39;, &#39;操作员&#39;, &#39;领取日期&#39;, &#39;领取时间&#39;, &#39;领取次数&#39;]wb = Workbook()ws = wb.activews.merge_cells(&quot;A1:P1&quot;)  # 合并首行单元格ws.cell(1, 1).value = &quot;领料明细汇总表&quot;ws.cell(1, 1).font = Font(name=u&#39;黑体&#39;, bold=True, size=18)ws.row_dimensions[1].height = 22.2  # 设置首行行高ws.cell(1, 1).alignment = Alignment(horizontal=&quot;center&quot;, vertical=&quot;center&quot;)  # 设置对齐ws.append(title)  # 写入字段行# 写入各部门领料的数据for file in files:    data = Get_data(file)    for key in data.keys():        for i in data[key]:            ws.append(i)# 设置字号，对齐，缩小字体填充，加边框# Font(bold=True)可加粗字体for row_number in range(2, ws.max_row + 1):    for col_number in range(1, 17):        c = ws.cell(row=row_number, column=col_number)        c.font = Font(size=9)        c.border = Border(top=thin, left=thin, right=thin, bottom=thin)        c.alignment = Alignment(horizontal=&quot;left&quot;, vertical=&quot;center&quot;)# 设置列宽col_name = list(&quot;ABCDEFGHIJKLMNOP&quot;)col_width = [8, 8, 16, 8, 16, 8, 8, 9.8, 8, 8, 8, 11, 8.3, 9, 8, 8]for i in range(len(col_name)):    ws.column_dimensions[col_name[i]].width = col_width[i]# 分组隐藏列ws.column_dimensions.group(&#39;I&#39;, &#39;K&#39;, hidden=True)ws.column_dimensions.group(&#39;N&#39;, &#39;O&#39;, hidden=True)wb.save(f&quot;领料明细汇总表&#123;Get_current_time()&#125;.xlsx&quot;)</code></pre><p>记录：<br><a href="工程部领料明细.xls">工程部领料明细.xls</a><br><a href="生产部领料明细.xls">生产部领料明细.xls</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Python汇总各单位Excel档领料记录并加总每日领用次数&quot;&gt;&lt;a href=&quot;#Python汇总各单位Excel档领料记录并加总每日领用次数&quot; class=&quot;headerlink&quot; title=&quot;Python汇总各单位Excel档领料记录并加总每日领用次数&quot;&gt;</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="xlrd" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/xlrd/"/>
    
    
    <category term="openpyxl" scheme="http://example.com/tags/openpyxl/"/>
    
    <category term="xlrd" scheme="http://example.com/tags/xlrd/"/>
    
  </entry>
  
  <entry>
    <title>python-docx | Python检查word文件中的特殊标记词是否与文件名中的一致</title>
    <link href="http://example.com/2021/10/29/Python%E6%A3%80%E6%9F%A5word%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E6%A0%87%E8%AE%B0%E8%AF%8D%E6%98%AF%E5%90%A6%E4%B8%8E%E6%96%87%E4%BB%B6%E5%90%8D%E4%B8%AD%E7%9A%84%E4%B8%80%E8%87%B4/"/>
    <id>http://example.com/2021/10/29/Python%E6%A3%80%E6%9F%A5word%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E6%A0%87%E8%AE%B0%E8%AF%8D%E6%98%AF%E5%90%A6%E4%B8%8E%E6%96%87%E4%BB%B6%E5%90%8D%E4%B8%AD%E7%9A%84%E4%B8%80%E8%87%B4/</id>
    <published>2021-10-29T12:43:47.000Z</published>
    <updated>2021-10-29T12:46:11.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python检查word文件中的特殊标记词是否与文件名中的一致"><a href="#Python检查word文件中的特殊标记词是否与文件名中的一致" class="headerlink" title="Python检查word文件中的特殊标记词是否与文件名中的一致"></a>Python检查word文件中的特殊标记词是否与文件名中的一致</h1><p>公司的部分文件分为“内部”和“外部”。正常情况下，这个标识在文件名及文件首页左上角都有标注。然鹅，有时候操作一下，忘记改了，或者忘记标注了。就需要回头去一个一个地整理，非常麻烦。这种重复的，繁杂的操作，尽快冲Python来，人类还是应该多做做其它更有意思的事。</p><p>代码：</p><pre><code>import osfrom win32com import client as wc  # 导入模块import docxfrom docx.shared import Pt  # 用于设定字体大小（磅值）from docx.oxml.ns import qn  # 用于应用中文字体# 将文件夹内的所有doc转存为docx文件path = os.getcwd() + &quot;\\文件\\&quot;  # 文件夹绝对路径files = []for file in os.listdir(path):    if file.endswith(&quot;.doc&quot;):  # 排除文件夹内的其他干扰文件，只获取&quot;.doc&quot;后缀的word文件        files.append(path+file)word = wc.Dispatch(&quot;Word.Application&quot;)  # 打开word应用程序for file in files:    doc = word.Document(file)  # 打开word文件    doc.SaveAs(&quot;&#123;&#125;x&quot;.format(file), 12)  # 另存为后缀为&quot;.docx&quot;的文件，其中参数12指docx文件    doc.Close()  # 关闭原来word文件word.Quit()for file in files:  # 删除doc文件    os.remove(file)# 获取所有docx文件路径docx_files = []for file in os.listdir(path):  # 排除文件夹内的其它干扰文件，只获取&quot;.doc&quot;后缀的word文件    if file.endswith(&quot;.docx&quot;):        docx_files.append(path+file)counter = 0  # 计数器，用于记录有多少文件没被处理for file in docx_files:    file_head = file.split(&#39;.&#39;)[0].rstrip()  # 文件名头，类似这样的“C:\\Users\\文件\\测试”    file_tail = file.split(&#39;\\&#39;)[-1]  # 文件名尾，类似这样“测试.docx”    mark_words = [&quot;公开&quot;, &quot;内部&quot;]    mark_fileName = file_head[-3:-1]  # 文件名中倒数第2,3个文字    doc = docx.Document(file)    mark_doc = doc.paragraphs[0].text  # 文件中首段文字    # 比对标记词    if mark_doc in mark_words:  # 判断文件中有无标记        if mark_fileName in mark_words:  # 判断文件名中有无标记            if mark_doc == mark_fileName:  # 如果二者标记相同                counter += 1                pass            else:  # 二者标记不同                os.rename(file, file.replace(mark_fileName, mark_doc))  # 重命名文件                print(f&quot;【&#123;file_tail&#125;】文件名重命名标识为【&#123;mark_doc&#125;】&quot;)        else:            os.rename(file, f&quot;&#123;file_head&#125;（&#123;mark_doc&#125;）.docx&quot;)  # 文件名中无标记，则加标记            print(f&quot;【&#123;file_tail&#125;】文件名增加标识为【&#123;mark_doc&#125;】&quot;)    else:        # 文中无标记，则在首段前插入一段，写入标记        p = doc.paragraphs[0]        pNew = p.insert_paragraph_before()        run = pNew.add_run(mark_words[0])  # 写为“公开”        # 字体设置        run.font.size = Pt(16)        run.font.name = &quot;黑体&quot;        r = run._element.rPr.rFonts        r.set(qn(&quot;w:eastAsia&quot;), &quot;黑体&quot;)        doc.save(file)        print(f&quot;【&#123;file_tail&#125;】内容增加标识为【&#123;mark_words[0]&#125;】&quot;)        if mark_fileName in mark_words:  # 查看文件名中是否有标记            if mark_fileName == mark_words[0]:  # 标记是否为“公开”                pass            else:  # 标记不是“公开”则替换                os.rename(file, file.replace(mark_fileName, mark_words[0]))  # 重命名文件                print(f&quot;【&#123;file_tail&#125;】文件名重命名标识为【&#123;mark_words[0]&#125;】&quot;)        else:            os.rename(file, f&quot;&#123;file_head&#125;（&#123;mark_words[0]&#125;）.docx&quot;)  # 文件名中无标记，则加标记            print(f&quot;【&#123;file_tail&#125;】文件名增加标识为【&#123;mark_words[0]&#125;】&quot;)print(f&quot;完成！共检查&#123;len(docx_files)&#125;个文件,处理了 &#123;len(docx_files) - counter&#125; 个文件。&quot;)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Python检查word文件中的特殊标记词是否与文件名中的一致&quot;&gt;&lt;a href=&quot;#Python检查word文件中的特殊标记词是否与文件名中的一致&quot; class=&quot;headerlink&quot; title=&quot;Python检查word文件中的特殊标记词是否与文件名中的一</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="python-docx" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/python-docx/"/>
    
    
    <category term="os" scheme="http://example.com/tags/os/"/>
    
    <category term="win32com" scheme="http://example.com/tags/win32com/"/>
    
    <category term="python-docx" scheme="http://example.com/tags/python-docx/"/>
    
  </entry>
  
  <entry>
    <title>requests | 获取网站新文章</title>
    <link href="http://example.com/2021/10/29/%E8%8E%B7%E5%8F%96%E7%BD%91%E7%AB%99%E6%96%B0%E6%96%87%E7%AB%A0/"/>
    <id>http://example.com/2021/10/29/%E8%8E%B7%E5%8F%96%E7%BD%91%E7%AB%99%E6%96%B0%E6%96%87%E7%AB%A0/</id>
    <published>2021-10-29T12:15:03.000Z</published>
    <updated>2021-10-29T12:18:16.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python爬虫-已爬取目标网站所有文章，后续如何只获取新文章"><a href="#Python爬虫-已爬取目标网站所有文章，后续如何只获取新文章" class="headerlink" title="Python爬虫~已爬取目标网站所有文章，后续如何只获取新文章?"></a>Python爬虫~已爬取目标网站所有文章，后续如何只获取新文章?</h1><p>代码：</p><pre><code>print(&quot;文章刷新中......&quot;)# 定义函数，获取想要的文章并批量写入word文件import requestsfrom bs4 import BeautifulSoupimport docxfrom docx.shared import Pt  # 用于设定字体大小（磅值）from docx.oxml.ns import qn  # 用于应用中文字体import randomimport timeimport osdef Get_article_to_word(url, date):    user_agent_list = [        &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36&quot;,        &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&quot;,        &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36&quot;,        &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.62 Safari/537.36&quot;,        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36&quot;,        &quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)&quot;,        &quot;Mozilla/5.0 (Macintosh; U; PPC Mac OS X 10.5; en-US; rv:1.9.2.15) Gecko/20110303 Firefox/3.6.15&quot;        ]    header = &#123;&#39;User-Agent&#39;: random.choice(user_agent_list)&#125;    wb_data = requests.get(url, headers=header)    soup = BeautifulSoup(wb_data.content)    title = soup.select(&#39;.headword&#39;)[0].text.strip()  # 获得标题    content1 = soup.select(&quot;.MsoNormal&quot;)  # 针对正文布局为 class = &quot;MsoNormal&quot;    content2 = soup.select(&quot;#art_content&quot;)  # 针对正文布局为 id = &quot;art_content&quot;    doc = docx.Document()  # 新建空白word文档    # 设定全局字体    doc.styles[&#39;Normal&#39;].font.name = u&#39;宋体&#39;    doc.styles[&#39;Normal&#39;]._element.rPr.rFonts.set(qn(&#39;w:eastAsia&#39;), u&#39;宋体&#39;)    # 写入标题行，并设置字体格式    p = doc.add_paragraph()    r = p.add_run(title)    r.bold = True    r.font.size = Pt(18)    doc.add_paragraph(date)  # 写入日期    doc.add_paragraph(url)  # 写入文章链接    dirs = os.getcwd() + &quot;\\文章&quot;    if not os.path.exists(dirs):        os.makedirs(dirs)    # 写入正文    for i in content2:        doc.add_paragraph(i.text)    for i in content1:        doc.add_paragraph(i.text)    doc.save(f&quot;&#123;dirs&#125;\\&#123;title&#125;.docx&quot;)# 判断网站是否有新文章import requestsimport jsonheader = &#123;    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.75 &#39;                  &#39;Safari/537.36&#39;&#125;form_data = &#123;&#39;_q&#39;: &#39;Article.list&#39;,             &#39;siteId&#39;: &#39;7e0b3b27-2622-4aa7-b6f8-abfe5c5df922&#39;,             &#39;catalogId&#39;: &#39;34f92da3-d6d0-4e96-899f-d7f581c18162&#39;,             &#39;pub&#39;: &#39;true&#39;,             &#39;limit&#39;: 150,  # 网站更新速度较慢，每次查看是否有更新的时候，只获取前10页共150篇文章的信息             &#39;start&#39;: 1&#125;# 这是异步加载，请求方法是POSTurl = &quot;http://www.bicpa.org.cn/dtzj/zxgg/getArticles.action&quot;res = requests.post(url, data=form_data, headers=header)article_data0 = res.text.split(&quot;&#123;success:true,datas:&quot;)[1]  # 去掉字符串前面的无用信息“&#123;success:true,datas:”article_data = article_data0.split(&quot;,total:&quot;)[0]  # 去掉字符串后面的无用信息“,total:xxxx&#125;”obj = json.loads(article_data)# 载入数据库中的所有链接，作为判断基准f = open(os.getcwd() + &#39;\\links.txt&#39;, &#39;r&#39;)link_database = f.read()  # 读取成一个大字符串# 将所有新文章链接写入文本文件path = r&quot;http://www.bicpa.org.cn&quot;links_file = open(&#39;links.txt&#39;, &#39;a&#39;)  # 避免覆盖已有数据，用添加模式`a`写入counter_link = 0  # 新文章链接计数器counter_download = 0  # 新下载文章计数器for info in obj:    link = path + info[&#39;url&#39;] + info[&#39;primaryKey&#39;] + &quot;.html&quot;  # 拼接链接信息    if link in link_database:  # 判断新提取的链接是否已存在于数据库        pass    else:        links_file.write(link + &quot;\n&quot;)  # 写入链接信息        counter_link += 1        # 下载标题含有&quot;委员会专家提示&quot;的文章        if &quot;委员会专家提示&quot; in info[&#39;title&#39;]:            Get_article_to_word(link, info[&quot;publishDate&quot;])  # 调用写好的函数，下载文章到word文件            counter_download += 1  # 每下载一篇文章，计数器增加1links_file.close()  # 写完后关闭文件# 显示每次的结果if counter_link == 0:    print(&quot;没有文章更新！&quot;)else:    print(f&quot;共获取到 &#123;counter_link&#125; 篇新文章的链接，并加入数据库。&quot;)if counter_download == 0:    print(&quot;没有&#39;委员会专家提示&#39;文章更新！&quot;)else:    print(f&quot;共下载 &#123;counter_download&#125; 篇&#39;委员会专家提示&#39;新文章，请到文件夹查看。&quot;)print(&quot;程序运行完成，关闭窗口退出.&quot;)input()</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Python爬虫-已爬取目标网站所有文章，后续如何只获取新文章&quot;&gt;&lt;a href=&quot;#Python爬虫-已爬取目标网站所有文章，后续如何只获取新文章&quot; class=&quot;headerlink&quot; title=&quot;Python爬虫~已爬取目标网站所有文章，后续如何只获取新文</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="requests" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"/>
    
    
    <category term="os" scheme="http://example.com/tags/os/"/>
    
    <category term="python-docx" scheme="http://example.com/tags/python-docx/"/>
    
    <category term="requests" scheme="http://example.com/tags/requests/"/>
    
    <category term="BeautifulSoup" scheme="http://example.com/tags/BeautifulSoup/"/>
    
    <category term="random" scheme="http://example.com/tags/random/"/>
    
    <category term="json" scheme="http://example.com/tags/json/"/>
    
    <category term="time" scheme="http://example.com/tags/time/"/>
    
  </entry>
  
  <entry>
    <title>requests | python爬虫爬取会计师网站的指定文章</title>
    <link href="http://example.com/2021/10/29/python%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96%E4%BC%9A%E8%AE%A1%E5%B8%88%E7%BD%91%E7%AB%99%E7%9A%84%E6%8C%87%E5%AE%9A%E6%96%87%E7%AB%A0/"/>
    <id>http://example.com/2021/10/29/python%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96%E4%BC%9A%E8%AE%A1%E5%B8%88%E7%BD%91%E7%AB%99%E7%9A%84%E6%8C%87%E5%AE%9A%E6%96%87%E7%AB%A0/</id>
    <published>2021-10-29T10:52:51.000Z</published>
    <updated>2021-10-29T12:05:14.698Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python爬虫爬取会计师网站的指定文章"><a href="#python爬虫爬取会计师网站的指定文章" class="headerlink" title="python爬虫爬取会计师网站的指定文章"></a>python爬虫爬取会计师网站的指定文章</h1><p>还没学习爬虫，没看懂！有缘再见！后会有期！</p><p>贴上代码：</p><pre><code>import requestsimport osimport jsonprint(&quot;开始爬取文章......&quot;)header = &#123;    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.75 &#39;                  &#39;Safari/537.36&#39;&#125;form_data = &#123;&#39;_q&#39;: &#39;Article.list&#39;,             &#39;siteId&#39;: &#39;7e0b3b27-2622-4aa7-b6f8-abfe5c5df922&#39;,             &#39;catalogId&#39;: &#39;34f92da3-d6d0-4e96-899f-d7f581c18162&#39;,             &#39;pub&#39;: &#39;true&#39;,             &#39;limit&#39;: 5000,             &#39;start&#39;: 1&#125;# 这是异步加载，请求方法是POSTurl = &quot;http://www.bicpa.org.cn/dtzj/zxgg/getArticles.action&quot;res = requests.post(url, data=form_data, headers=header)article_data0 = res.text.split(&quot;&#123;success:true,datas:&quot;)[1]  # 去掉字符串前面的无用信息“&#123;success:true,datas:”article_data = article_data0.split(&quot;,total:&quot;)[0]  # 去掉字符串后面的无用信息“,total:4946&#125;”obj = json.loads(article_data)# 获取标题含有“委员会专家提示”的文章的标题，发布时间和链接path = r&quot;http://www.bicpa.org.cn&quot;articles = []for info in obj:    if &quot;委员会专家提示&quot; in info[&#39;title&#39;]:        article = &#123;            &quot;标题&quot;: info[&#39;title&#39;].strip(),  # strip()去除首尾空格            &quot;发布时间&quot;: info[&#39;publishDate&#39;],            &quot;链接&quot;: path + info[&#39;url&#39;] + info[&#39;primaryKey&#39;] + &quot;.html&quot;        &#125;        articles.append(article)import requestsfrom bs4 import BeautifulSoupimport docxfrom docx.shared import Pt  # 用于设定字体大小（磅值）from docx.oxml.ns import qn  # 用于应用中文字体import randomimport time# 获取想要的文章并批量写入word文件def Get_article_to_word(url, date):    user_agent_list = [        &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36&quot;,        &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&quot;,        &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36&quot;,        &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.62 Safari/537.36&quot;,        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36&quot;,        &quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)&quot;,        &quot;Mozilla/5.0 (Macintosh; U; PPC Mac OS X 10.5; en-US; rv:1.9.2.15) Gecko/20110303 Firefox/3.6.15&quot;    ]    header = &#123;&#39;User-Agent&#39;: random.choice(user_agent_list)&#125;    wb_data = requests.get(url, headers=header)    soup = BeautifulSoup(wb_data.content)    title = soup.select(&#39;.headword&#39;)[0].text.strip()  # 获得标题    content1 = soup.select(&quot;.MsoNormal&quot;)  # 针对正文布局为 class = &quot;MsoNormal&quot;    content2 = soup.select(&quot;#art_content&quot;)  # 针对正文布局为 id = &quot;art_content&quot;    doc = docx.Document()  # 新建空白word文档    # 设定全局字体    doc.styles[&#39;Normal&#39;].font.name = u&#39;宋体&#39;    doc.styles[&#39;Normal&#39;]._element.rPr.rFonts.set(qn(&#39;w:eastAsia&#39;), u&#39;宋体&#39;)    # 写入标题行，并设置字体格式    p = doc.add_paragraph()    r = p.add_run(title)    r.bold = True    r.font.size = Pt(18)    doc.add_paragraph(date)  # 写入日期    doc.add_paragraph(url)  # 写入文章链接    dirs = os.getcwd() + &quot;\\文章&quot;    if not os.path.exists(dirs):        os.makedirs(dirs)    # 写入正文    for i in content2:        doc.add_paragraph(i.text)    for i in content1:        doc.add_paragraph(i.text)    doc.save(f&quot;&#123;dirs&#125;\\&#123;title&#125;.docx&quot;)# 遍历所有文章的链接，调用以上函数执行for art in articles:    Get_article_to_word(art[&quot;链接&quot;], art[&quot;发布时间&quot;])    print(&quot;&#123;&#125; 下载完成。&quot;.format(art[&#39;标题&#39;]))    if articles.index(art) % 30 == 29:  # 每获取30篇文章，暂停5秒，避免频繁请求被服务器切断连接        time.sleep(5)print(f&quot;共下载 &#123;len(articles)&#125; 篇文章。&quot;)print(&quot;程序运行完成，关闭窗口退出.&quot;)input()</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;python爬虫爬取会计师网站的指定文章&quot;&gt;&lt;a href=&quot;#python爬虫爬取会计师网站的指定文章&quot; class=&quot;headerlink&quot; title=&quot;python爬虫爬取会计师网站的指定文章&quot;&gt;&lt;/a&gt;python爬虫爬取会计师网站的指定文章&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="requests" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"/>
    
    
    <category term="os" scheme="http://example.com/tags/os/"/>
    
    <category term="python-docx" scheme="http://example.com/tags/python-docx/"/>
    
    <category term="requests" scheme="http://example.com/tags/requests/"/>
    
    <category term="random" scheme="http://example.com/tags/random/"/>
    
    <category term="json" scheme="http://example.com/tags/json/"/>
    
    <category term="BeautifulSoup4" scheme="http://example.com/tags/BeautifulSoup4/"/>
    
    <category term="time" scheme="http://example.com/tags/time/"/>
    
  </entry>
  
  <entry>
    <title>os | os.listdir()和os.walk()</title>
    <link href="http://example.com/2021/10/29/listdir%E5%92%8Cwalk/"/>
    <id>http://example.com/2021/10/29/listdir%E5%92%8Cwalk/</id>
    <published>2021-10-29T10:21:40.000Z</published>
    <updated>2021-10-29T10:27:08.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="os-listdir-和os-walk"><a href="#os-listdir-和os-walk" class="headerlink" title="os.listdir()和os.walk()"></a>os.listdir()和os.walk()</h1><p><a href="https://www.jianshu.com/p/5c3b45d672d5">os.listdir()和os.walk()</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;os-listdir-和os-walk&quot;&gt;&lt;a href=&quot;#os-listdir-和os-walk&quot; class=&quot;headerlink&quot; title=&quot;os.listdir()和os.walk()&quot;&gt;&lt;/a&gt;os.listdir()和os.walk()&lt;/h1</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="内置模块" scheme="http://example.com/categories/python/%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/"/>
    
    <category term="os" scheme="http://example.com/categories/python/%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/os/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="os" scheme="http://example.com/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>openpyxl | 从多路径多Excel表中获取数据并存入新表</title>
    <link href="http://example.com/2021/10/29/%E4%BB%8E%E5%A4%9A%E8%B7%AF%E5%BE%84%E5%A4%9AExcel%E8%A1%A8%E4%B8%AD%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%AD%98%E5%85%A5%E6%96%B0%E8%A1%A8/"/>
    <id>http://example.com/2021/10/29/%E4%BB%8E%E5%A4%9A%E8%B7%AF%E5%BE%84%E5%A4%9AExcel%E8%A1%A8%E4%B8%AD%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%AD%98%E5%85%A5%E6%96%B0%E8%A1%A8/</id>
    <published>2021-10-29T10:14:32.000Z</published>
    <updated>2021-10-29T10:16:11.784Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从多路径多Excel表中获取数据并存入新表"><a href="#从多路径多Excel表中获取数据并存入新表" class="headerlink" title="从多路径多Excel表中获取数据并存入新表"></a>从多路径多Excel表中获取数据并存入新表</h1><p>实现代码：</p><pre><code>import oswork_path = os.getcwd() + &quot;\\资料&quot;  # 获取当前工作路径，指定“资料”文件夹# 获取路径下所有.xlsx文件，并存入列表pathss = []  # 存储文件夹内所有文件的路径（包括子目录内的文件）for root, dirs, files in os.walk(work_path):    path = [os.path.join(root, name) for name in files]  # 将目录和文件名连接起来，才是完整文件路径    for i in range(len(path)):  # 遍历所有文件的地址        if path[i].endswith(&quot;.xlsx&quot;):  # 只提取后缀为xlsx的文件            pathss.append(path[i])# 定义函数，获取Excel表格中的ID数据from openpyxl import load_workbook  # 用于读取Excel中的信息def Get_system_ID(file):    wb = load_workbook(file)    ws = wb.active    ID_list = []    for row in range(2, ws.max_row + 1):        ID = ws[&quot;A&quot; + str(row)].value  # ID信息在A列        if ID != None:  # 过滤空值            ID_list.append(ID)    return ID_list# 获取数据，存入总列表total_list = []for file in pathss:    info = Get_system_ID(file)    total_list += info# 写入数据到新的excel表，并设置格式from openpyxl import Workbookfrom openpyxl.styles import Font, colors, Alignment  # 字体，颜色，对齐from openpyxl.styles import PatternFill  # 单元格填充wb = Workbook()  # 新建Excel工作簿ws = wb.active  # 使用活动工作表ws.column_dimensions[&#39;A&#39;].width = 18.5  # 设定A列宽度ws.cell(row=1, column=1, value=&quot;ID&quot;)  # 写入字段名color_fill = PatternFill(fill_type=&#39;solid&#39;, fgColor=&quot;B3CFA1&quot;)  # 设置底色ws.cell(row=1, column=1).fill = color_fill  # 填充底色# 批量从列表中提取数据并写入for row in range(1, len(total_list) + 1):    ws.cell(row=row + 1, column=1, value=total_list[row - 1])# 设置字号及对齐font_set = Font(name=&#39;Arial&#39;, size=9)for i in range(1, ws.max_row + 1):    ws.cell(row=i, column=1).font = font_set    ws.cell(row=i, column=1).alignment = Alignment(horizontal=&#39;left&#39;, vertical=&#39;center&#39;, shrink_to_fit=True)wb.save(os.getcwd() + &quot;\\ID.xlsx&quot;)print(f&quot;\n共获取到 &#123;len(pathss)&#125; 个 Excel表，共 &#123;len(total_list)&#125; 个ID。&quot;)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;从多路径多Excel表中获取数据并存入新表&quot;&gt;&lt;a href=&quot;#从多路径多Excel表中获取数据并存入新表&quot; class=&quot;headerlink&quot; title=&quot;从多路径多Excel表中获取数据并存入新表&quot;&gt;&lt;/a&gt;从多路径多Excel表中获取数据并存入新表&lt;/</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="openpyxl" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/openpyxl/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="os" scheme="http://example.com/tags/os/"/>
    
    <category term="openpyxl" scheme="http://example.com/tags/openpyxl/"/>
    
  </entry>
  
  <entry>
    <title>random | python为每个学生出不一样的题</title>
    <link href="http://example.com/2021/10/29/python%E4%B8%BA%E6%AF%8F%E4%B8%AA%E5%AD%A6%E7%94%9F%E5%87%BA%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E9%A2%98/"/>
    <id>http://example.com/2021/10/29/python%E4%B8%BA%E6%AF%8F%E4%B8%AA%E5%AD%A6%E7%94%9F%E5%87%BA%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E9%A2%98/</id>
    <published>2021-10-29T10:01:54.000Z</published>
    <updated>2021-10-29T10:05:21.479Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python为每个学生出不一样的题"><a href="#python为每个学生出不一样的题" class="headerlink" title="python为每个学生出不一样的题"></a>python为每个学生出不一样的题</h1><p>实现代码：</p><pre><code>import random# 不重复随机整数生成函数def Random_num(num_max, num_qty):    &#39;&#39;&#39;    num_max:最大数    num_qty:生成随机数的个数    &#39;&#39;&#39;    num_list = []  # 储存生成的随机数    while len(num_list) &lt; num_qty:  # 控制随机数的个数        num = random.randint(2, num_max)  # 设定在此范围内取数        if num in num_list:  # 判断随机数是否重复            continue  # 若重复，则重新生成        else:            num_list.append(num)  # 将不重复的随机数放入列表    return num_list  # 生成完成后返回随机数列表# 定义函数，按随机数在题库中抽取对应编号的题目from openpyxl import load_workbookdef Question(que_type, numbers):    &#39;&#39;&#39;    que_type:试题类型（&quot;单选题&quot;,&quot;多选题&quot;,&quot;判断题&quot;,&quot;填空题&quot;）    numbers:需要抽取的试题编号    &#39;&#39;&#39;    questions = []  # 储存抽取的题目    wb = load_workbook(&quot;题库.xlsx&quot;)  # 载入题库    if que_type == &quot;单选题&quot;:        ws = wb[que_type]        for i in numbers:  # 按随机生成的编号抽题            question = ws[&quot;B&quot; + str(i)].value  # 问题在B列            answerA = &quot;A：\t&quot; + str(ws[&quot;C&quot; + str(i)].value)  # 选项A在C列，&quot;\t&quot;相当于按一下tab键，在字符间产生间隔            answerB = &quot;B：\t&quot; + str(ws[&quot;D&quot; + str(i)].value)  # 选项B在D列            answerC = &quot;C：\t&quot; + str(ws[&quot;E&quot; + str(i)].value)  # 选项C在E列            answerD = &quot;D：\t&quot; + str(ws[&quot;F&quot; + str(i)].value)  # 选项D在F列            right_answer = ws[&quot;G&quot; + str(i)].value  # 正确答案在G列            single_question = [question, answerA, answerB, answerC, answerD, right_answer]  # 每行的数据存入列表            questions.append(single_question)  # 每个题目的数据存入总列表    elif que_type == &quot;多选题&quot;:        ws = wb[que_type]        for i in numbers:            question = ws[&quot;B&quot; + str(i)].value            answerA = &quot;A：\t&quot; + str(ws[&quot;C&quot; + str(i)].value)            answerB = &quot;B：\t&quot; + str(ws[&quot;D&quot; + str(i)].value)            answerC = &quot;C：\t&quot; + str(ws[&quot;E&quot; + str(i)].value)            answerD = &quot;D：\t&quot; + str(ws[&quot;F&quot; + str(i)].value)            right_answer = ws[&quot;H&quot; + str(i)].value            single_question = [question, answerA, answerB, answerC, answerD, right_answer]            if ws[&quot;G&quot; + str(i)].value:  # 有些题有E选项，有些没有，因此需要判断一下是否有E选项                answerE = &quot;E：\t&quot; + str(ws[&quot;G&quot; + str(i)].value)                single_question.insert(-1, answerE)  # 将E选项插入到答案前面，保持答案是最后一个元素            questions.append(single_question)    else:  # 判断题和填空题，内容只取题干和答案        ws = wb[que_type]        for i in numbers:            question = ws[&quot;B&quot; + str(i)].value            right_answer = ws[&quot;C&quot; + str(i)].value            single_question = [question, right_answer]            questions.append(single_question)    return questions# 写入考试题到word文件from docx import Documentfrom docx.shared import Pt  # 用于设定字体大小（磅值）from docx.oxml.ns import qn  # 用于应用中文字体def To_word(number, questions_data):    doc = Document(&quot;试题-模板.docx&quot;)    # 写入单选题    title1 = &quot;一、单项选择题（共40题，每题1分）&quot;    p = doc.add_paragraph()  # 插入段落    r = p.add_run(title1)  # 插入文字块    r.bold = True  # 字体加粗    r.font.size = Pt(12)  # 字号设为12磅    for index, i in enumerate(questions_data[&quot;单选题&quot;], start=1):  # 给题目从1开始编号        doc.add_paragraph(f&quot;&#123;index&#125;. &#123;i[0]&#125;&quot;)  # 题干部分在单独一段        doc.add_paragraph(f&quot;\t&#123;i[1]&#125;\t\t&#123;i[2]&#125;&quot;)  # 选项A和选项B在同一段落        doc.add_paragraph(f&quot;\t&#123;i[3]&#125;\t\t&#123;i[4]&#125;&quot;)  # 选项C和选项D在同一段落    # 写入多选题    title2 = &quot;二、多项选择题（共20题，每题2分）&quot;    p = doc.add_paragraph()    r = p.add_run(title2)    r.bold = True    r.font.size = Pt(12)    for index, i in enumerate(questions_data[&quot;多选题&quot;], start=1):        doc.add_paragraph(f&quot;&#123;index&#125;. &#123;i[0]&#125;&quot;)        doc.add_paragraph(f&quot;\t&#123;i[1]&#125;\t\t&#123;i[2]&#125;&quot;)        doc.add_paragraph(f&quot;\t&#123;i[3]&#125;\t\t&#123;i[4]&#125;&quot;)        if len(i) == 7:  # 判断是否有E选项，若有，则新建一段落写入            doc.add_paragraph(f&quot;\t&#123;i[5]&#125;&quot;)    # 写入判断题    title3 = &quot;三、判断题（共10题，每题1分）&quot;    p = doc.add_paragraph()    r = p.add_run(title3)    r.bold = True    r.font.size = Pt(12)    for index, i in enumerate(questions_data[&quot;判断题&quot;], start=1):        doc.add_paragraph(f&quot;\t&#123;index&#125;. &#123;i[0]&#125;&quot;)    # 写入填空题    title4 = &quot;四、填空题（共10题，每题1分）&quot;    p = doc.add_paragraph()    r = p.add_run(title4)    r.bold = True    r.font.size = Pt(12)    for index, i in enumerate(questions_data[&quot;填空题&quot;], start=1):        doc.add_paragraph(f&quot;\t&#123;index&#125;. &#123;i[0]&#125;&quot;)    doc.save(f&quot;试卷及答案\\考试题&#123;number&#125;.docx&quot;)# 写入答案from docx import Documentfrom docx.shared import Pt  # 用于设定字体大小（磅值）from docx.oxml.ns import qn  # 用于应用中文字体def Answer(number, questions_data):    doc = Document()    # 全局字体设为“宋体”    doc.styles[&#39;Normal&#39;].font.name = u&#39;宋体&#39;    doc.styles[&#39;Normal&#39;]._element.rPr.rFonts.set(qn(&#39;w:eastAsia&#39;), u&#39;宋体&#39;)    title = &quot;计算机系2020第二学期期末考试题(答案)&quot;    p = doc.add_paragraph()    r = p.add_run(title)    r.bold = True    r.font.size = Pt(20)    # 写入单选题答案    title1 = &quot;一、单项选择题答案（共40题，每题1分）&quot;    p = doc.add_paragraph()    r = p.add_run(title1)    r.bold = True    r.font.size = Pt(12)    p = doc.add_paragraph()    for index, i in enumerate(questions_data[&quot;单选题&quot;], start=1):        p.add_run(f&quot;&#123;index&#125;. &#123;i[-1]&#125;\t&quot;)        if index % 10 == 0:  # 每段只显示10个答案            p = doc.add_paragraph()  # 满10个，则新建段落    # 写入多选题答案    title2 = &quot;二、多项选择题答案（共20题，每题2分）&quot;    p = doc.add_paragraph()    r = p.add_run(title2)    r.bold = True    r.font.size = Pt(12)    p = doc.add_paragraph()    for index, i in enumerate(questions_data[&quot;多选题&quot;], start=1):        p.add_run(f&quot;&#123;index&#125;. &#123;i[-1]&#125;\t&quot;)        if index % 3 == 0:            p = doc.add_paragraph()            # 写入判断题答案    title3 = &quot;三、判断题答案（共10题，每题1分）&quot;    p = doc.add_paragraph()    r = p.add_run(title3)    r.bold = True    r.font.size = Pt(12)    p = doc.add_paragraph()    for index, i in enumerate(questions_data[&quot;判断题&quot;], start=1):        p.add_run(f&quot;&#123;index&#125;. &#123;i[-1]&#125;\t&quot;)        if index % 5 == 0:  # 每段只显示5个答案            p = doc.add_paragraph()  # 满5个，则新建段落    # 写入填空题    title4 = &quot;四、填空题答案（共10题，每题1分）&quot;    p = doc.add_paragraph()    r = p.add_run(title4)    r.bold = True    r.font.size = Pt(12)    p = doc.add_paragraph()    for index, i in enumerate(questions_data[&quot;填空题&quot;], start=1):        p.add_run(f&quot;&#123;index&#125;. &#123;i[-1]&#125;\t\t&quot;)        if index % 2 == 0:  # 每段只显示2个答案            p = doc.add_paragraph()  # 满2个，则新建段落    doc.save(f&quot;试卷及答案\\考试题&#123;number&#125;答案.docx&quot;)# 主函数for number in range(1, 21):  # 不同的试卷数量，此处为20套    # 生成随机题目编号    num_single_choice = Random_num(566, 40)    num_mult_choice = Random_num(196, 20)    num_judgment = Random_num(418, 10)    num_completion = Random_num(190, 10)    # 将生成的编号存入字典`question_num`    question_num = &#123;&quot;单选题号&quot;: num_single_choice,                    &quot;多选题号&quot;: num_mult_choice,                    &quot;判断题号&quot;: num_judgment,                    &quot;填空题号&quot;: num_completion                    &#125;    # 根据随机生成的题目编号去题库选题，并存入`questions_data`    questions_data = &#123;        &quot;单选题&quot;: Question(&quot;单选题&quot;, question_num[&quot;单选题号&quot;]),        &quot;多选题&quot;: Question(&quot;多选题&quot;, question_num[&quot;多选题号&quot;]),        &quot;判断题&quot;: Question(&quot;判断题&quot;, question_num[&quot;判断题号&quot;]),        &quot;填空题&quot;: Question(&quot;填空题&quot;, question_num[&quot;填空题号&quot;])    &#125;    # 将试题写入word文档，并保存    To_word(number, questions_data)    # 将试题答案写入word文档，并保存    Answer(number, questions_data)    print(f&quot;试卷&#123;number&#125;及答案完成！&quot;)</code></pre><p><a href="试题-模板.docx">试题-模板.docx</a><br><a href="题库.xlsx">题库.xlsx</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;python为每个学生出不一样的题&quot;&gt;&lt;a href=&quot;#python为每个学生出不一样的题&quot; class=&quot;headerlink&quot; title=&quot;python为每个学生出不一样的题&quot;&gt;&lt;/a&gt;python为每个学生出不一样的题&lt;/h1&gt;&lt;p&gt;实现代码：&lt;/p&gt;
</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="内置模块" scheme="http://example.com/categories/python/%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/"/>
    
    <category term="random" scheme="http://example.com/categories/python/%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/random/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="python-docx" scheme="http://example.com/tags/python-docx/"/>
    
    <category term="openpyxl" scheme="http://example.com/tags/openpyxl/"/>
    
    <category term="random" scheme="http://example.com/tags/random/"/>
    
  </entry>
  
  <entry>
    <title>win32api | 批量打印文件</title>
    <link href="http://example.com/2021/10/29/%E6%89%B9%E9%87%8F%E6%89%93%E5%8D%B0%E6%96%87%E4%BB%B6/"/>
    <id>http://example.com/2021/10/29/%E6%89%B9%E9%87%8F%E6%89%93%E5%8D%B0%E6%96%87%E4%BB%B6/</id>
    <published>2021-10-29T09:44:23.000Z</published>
    <updated>2021-10-29T09:45:51.094Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义打印函数，以便重复调用"><a href="#定义打印函数，以便重复调用" class="headerlink" title="定义打印函数，以便重复调用"></a>定义打印函数，以便重复调用</h1><p>实现代码：</p><pre><code>import win32apidef Print(fileName):    win32api.ShellExecute(        0,  # 指定父窗口句柄，搞不懂        &quot;print&quot;,  # 指定操作，这里的&quot;print&quot;表示启动打印应用程序        fileName,  # 要打印的文件名        None,  # 打印机设置，若是&quot;None&quot;，则使用windows设置的默认打印机        &quot;.&quot;,  # 指定默认目录，照抄的，搞不懂        0  # 若fileName参数是一个可执行程序，则此参数指定程序窗口的初始显示方式，否则此参数应设置为0    )# 获取待打印文件的路径import ospath = &#39;文件&#39;  # 文件所在文件夹files = [path + &quot;\\&quot; + i for i in os.listdir(path)]  # 获取文件夹下的文件名,并拼接完整路径# 批量打印for file in files:    Print(file)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;定义打印函数，以便重复调用&quot;&gt;&lt;a href=&quot;#定义打印函数，以便重复调用&quot; class=&quot;headerlink&quot; title=&quot;定义打印函数，以便重复调用&quot;&gt;&lt;/a&gt;定义打印函数，以便重复调用&lt;/h1&gt;&lt;p&gt;实现代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;impor</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="win32api" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/win32api/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="os" scheme="http://example.com/tags/os/"/>
    
    <category term="win32api" scheme="http://example.com/tags/win32api/"/>
    
  </entry>
  
  <entry>
    <title>pandas | 从原Excel表中抽出数据存入同一文件的新的Sheet</title>
    <link href="http://example.com/2021/10/29/%E4%BB%8E%E5%8E%9FExcel%E8%A1%A8%E4%B8%AD%E6%8A%BD%E5%87%BA%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5%E5%90%8C%E4%B8%80%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B0%E7%9A%84Sheet/"/>
    <id>http://example.com/2021/10/29/%E4%BB%8E%E5%8E%9FExcel%E8%A1%A8%E4%B8%AD%E6%8A%BD%E5%87%BA%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5%E5%90%8C%E4%B8%80%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B0%E7%9A%84Sheet/</id>
    <published>2021-10-29T09:36:52.000Z</published>
    <updated>2021-10-29T09:38:14.476Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从原Excel表中抽出数据存入同一文件的新的Sheet"><a href="#从原Excel表中抽出数据存入同一文件的新的Sheet" class="headerlink" title="从原Excel表中抽出数据存入同一文件的新的Sheet"></a>从原Excel表中抽出数据存入同一文件的新的Sheet</h1><p>实现代码：</p><pre><code>import pandas as pddf = pd.read_excel(&quot;物料表.xlsx&quot;, header=2)df.head()#     请求单号     单位     物料编号     架位     批号     数量     日期# 0     A19X9239156     EA     11010XR0073700     LC000001     PC00001     3     2019-01-03# 1     A19X9239156     EA     11020XR0025500     LC000002     PC00002     10     2019-01-03# 2     A19X9239156     EA     11030XR0013200     LC000003     PC00003     3     2019-01-03# 3     A19X9239156     EA     11140XR0000100     LC000004     PC00004     3     2019-01-03# 4     A19X9239156     EA     12121XR0172300     LC000005     PC00005     3     2019-01-03df[&#39;月份&#39;] = df[&#39;日期&#39;].dt.monthdf.head()#     请求单号     单位     物料编号     架位     批号     数量     日期     月份# 0     A19X9239156     EA     11010XR0073700     LC000001     PC00001     3     2019-01-03     1# 1     A19X9239156     EA     11020XR0025500     LC000002     PC00002     10     2019-01-03     1# 2     A19X9239156     EA     11030XR0013200     LC000003     PC00003     3     2019-01-03     1# 3     A19X9239156     EA     11140XR0000100     LC000004     PC00004     3     2019-01-03     1# 4     A19X9239156     EA     12121XR0172300     LC000005     PC00005     3     2019-01-03     1df5 = df[df[&#39;月份&#39;] == 5]df5.head()#     请求单号     单位     物料编号     架位     批号     数量     日期     月份# 9649     A19X9280200     EA     36012XR0413200     LC009650     PC09650     66     2019-05-03     5# 9650     A19X9280200     EA     60022XR2298300     LC009651     PC09651     66     2019-05-03     5# 9651     A19X9280561     EA     72004XR2000001     LC009652     PC09652     604     2019-05-03     5# 9652     A19X9286759     EA     62010XR0161048     LC009653     PC09653     50     2019-05-03     5# 9653     A19X9286759     EA     62010XR0502208     LC009654     PC09654     100     2019-05-03     5df8 = df[df[&#39;月份&#39;] == 8]df8.head()#     请求单号     单位     物料编号     架位     批号     数量     日期     月份# 17213     A19X9317364     EA     62010XR0500126     LC017214     PC17214     230     2019-08-01     8# 17214     A19X9317364     EA     61010XR1120100     LC017215     PC17215     230     2019-08-01     8# 17215     A19X9317364     EA     62012XR0102262     LC017216     PC17216     230     2019-08-01     8# 17216     A19X9317364     EA     62010XR050150A     LC017217     PC17217     950     2019-08-01     8# 17217     A19X9317364     EA     61011XR1150500     LC017218     PC17218     230     2019-08-01     8# 去掉不需要的月份的数据def Remove_data(df, month=[]):    for i in month:        df = df[df[&#39;月份&#39;] != i]    return dfdf_rest = Remove_data(df, [5, 8])df_rest.head()#     请求单号     单位     物料编号     架位     批号     数量     日期     月份# 0     A19X9239156     EA     11010XR0073700     LC000001     PC00001     3     2019-01-03     1# 1     A19X9239156     EA     11020XR0025500     LC000002     PC00002     10     2019-01-03     1# 2     A19X9239156     EA     11030XR0013200     LC000003     PC00003     3     2019-01-03     1# 3     A19X9239156     EA     11140XR0000100     LC000004     PC00004     3     2019-01-03     1# 4     A19X9239156     EA     12121XR0172300     LC000005     PC00005     3     2019-01-03     1with pd.ExcelWriter(&#39;物料表_1.xlsx&#39;, engine=&#39;openpyxl&#39;,                    datetime_format=&#39;YYYY-MM-DD&#39;) as writer:    df5.drop(&#39;月份&#39;, axis=1).to_excel(writer, sheet_name=&#39;5月&#39;, index=False)    df8.drop(&#39;月份&#39;, axis=1).to_excel(writer, sheet_name=&#39;8月&#39;, index=False)    df_rest.drop(&#39;月份&#39;, axis=1).to_excel(writer, sheet_name=&#39;剩余月份&#39;, index=False)from openpyxl import load_workbookfrom openpyxl.styles import Border, Side, PatternFill, Font, GradientFill, Alignmentthin = Side(border_style=&quot;thin&quot;, color=&quot;000000&quot;)  # 定义边框粗细及颜色wb = load_workbook(&quot;物料表_1.xlsx&quot;)for sheetname in wb.sheetnames:    ws = wb[sheetname]    # 调整列宽    ws.column_dimensions[&#39;A&#39;].width = 12    ws.column_dimensions[&#39;C&#39;].width = 15.5    ws.column_dimensions[&#39;G&#39;].width = 10    # 设置字号，对齐，缩小字体填充，加边框    for row_number in range(2, ws.max_row + 1):        for col_number in range(1, ws.max_column + 1):            c = ws.cell(row=row_number, column=col_number)            c.font = Font(size=10)            c.border = Border(top=thin, left=thin, right=thin, bottom=thin)            c.alignment = Alignment(horizontal=&quot;left&quot;, vertical=&quot;center&quot;)wb.save(&quot;物料表_1.xlsx&quot;)</code></pre><p><a href="物料表.xlsx">物料表.xlsx</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;从原Excel表中抽出数据存入同一文件的新的Sheet&quot;&gt;&lt;a href=&quot;#从原Excel表中抽出数据存入同一文件的新的Sheet&quot; class=&quot;headerlink&quot; title=&quot;从原Excel表中抽出数据存入同一文件的新的Sheet&quot;&gt;&lt;/a&gt;从原Exc</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="第三方库" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="pandas" scheme="http://example.com/categories/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="openpyxl" scheme="http://example.com/tags/openpyxl/"/>
    
    <category term="pandas" scheme="http://example.com/tags/pandas/"/>
    
  </entry>
  
</feed>
