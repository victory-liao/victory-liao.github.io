<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Victory&#39;s Blog</title>
  
  <subtitle>非淡泊无以明志，非宁静无以致远</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-08-03T14:33:39.781Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>victory-liao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode | 219.存在重复元素2</title>
    <link href="http://example.com/2022/08/03/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A02/"/>
    <id>http://example.com/2022/08/03/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A02/</id>
    <published>2022-08-03T14:23:32.000Z</published>
    <updated>2022-08-03T14:33:39.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="219-存在重复元素2"><a href="#219-存在重复元素2" class="headerlink" title="219.存在重复元素2"></a>219.存在重复元素2</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数数组 nums 和一个整数 k ，判断数组中是否存在两个 不同的索引 i 和 j ，满足 nums[i] == nums[j] 且 abs(i - j) &lt;= k 。如果存在，返回 true ；否则，返回 false 。</p><p>示例 1：<br>输入：nums = [1,2,3,1], k = 3<br>输出：true</p><p>示例 2：<br>输入：nums = [1,0,1,1], k = 1<br>输出：true</p><p>示例 3：<br>输入：nums = [1,2,3,1,2,3], k = 2<br>输出：false</p><p><a href="https://leetcode.cn/problems/contains-duplicate-ii">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>哈希表<br>使用哈希表存储每一个元素的最大下表，在遍历元素的过程中，如果该元素已存在于哈希表中，则判断该元素当前下标减去该元素的最大下标，如果差值小于k，则返回True;<br>如果遍历过程中没有找到为相等元素且下标之差小于k的情况，则返回False。</li><li>滑动窗口<br>数组 nums 中的每个长度不超过 k+1 的滑动窗口，同一个滑动窗口中的任意两个下标差的绝对值不超过 k。如果存在一个滑动窗口，其中有重复元素，则存在两个不同的下标 i 和 j 满足 nums[i]=nums[j] 且 ∣i−j∣≤k。如果所有滑动窗口中都没有重复元素，则不存在符合要求的下标。因此，只要遍历每个滑动窗口，判断滑动窗口中是否有重复元素即可。<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">超出时间限制</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">dict1 = <span class="built_in">dict</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line"><span class="keyword">if</span> nums[i] <span class="keyword">not</span> <span class="keyword">in</span> dict1.keys():</span><br><span class="line">dict1[nums[i]] = [i]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">dict1[nums[i]].append(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> dict1.keys():</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dict1[key])):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, <span class="built_in">len</span>(dict1[key])):</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">abs</span>(dict1[key][i]-dict1[key][j]) &lt;= k:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate1</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;超出时间限制&quot;&quot;&quot;</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nums)-<span class="number">1</span>:</span><br><span class="line">j = i + <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> j &lt; <span class="built_in">len</span>(nums):</span><br><span class="line"><span class="keyword">if</span> nums[i] == nums[j] <span class="keyword">and</span> <span class="built_in">abs</span>(i-j) &lt;= k:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">j += <span class="number">1</span></span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate2</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;哈希表&quot;&quot;&quot;</span></span><br><span class="line">pos = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line"><span class="keyword">if</span> num <span class="keyword">in</span> pos <span class="keyword">and</span> i - pos[num] &lt;= k:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">pos[num] = i</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate3</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;集合&quot;&quot;&quot;</span></span><br><span class="line">s = <span class="built_in">set</span>()</span><br><span class="line"><span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line"><span class="keyword">if</span> i &gt; k:</span><br><span class="line">s.remove(nums[i - k - <span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> num <span class="keyword">in</span> s:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">s.add(num)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">slt = Solution()</span><br><span class="line"><span class="comment"># print(slt.containsNearbyDuplicate1([1, 2, 3, 1], 3))</span></span><br><span class="line"><span class="comment"># print(slt.containsNearbyDuplicate1([1, 0, 1, 1], 1))</span></span><br><span class="line"><span class="comment"># print(slt.containsNearbyDuplicate1([1, 2, 3, 1, 2, 3], 2))</span></span><br><span class="line"><span class="comment"># print(slt.containsNearbyDuplicate1([99, 99], 2))</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(slt.containsNearbyDuplicate2([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>], <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(slt.containsNearbyDuplicate2([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>], <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(slt.containsNearbyDuplicate2([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(slt.containsNearbyDuplicate2([<span class="number">99</span>, <span class="number">99</span>], <span class="number">2</span>))</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;219-存在重复元素2&quot;&gt;&lt;a href=&quot;#219-存在重复元素2&quot; class=&quot;headerlink&quot; title=&quot;219.存在重复元素2&quot;&gt;&lt;/a&gt;219.存在重复元素2&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;</summary>
      
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="数组" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    <category term="219.存在重复元素2" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/219-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A02/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="哈希表" scheme="http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="滑动窗口" scheme="http://example.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 217.存在重复元素</title>
    <link href="http://example.com/2022/07/31/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <id>http://example.com/2022/07/31/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</id>
    <published>2022-07-31T09:14:07.000Z</published>
    <updated>2022-07-31T09:18:05.993Z</updated>
    
    <content type="html"><![CDATA[<h1 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217.存在重复元素"></a>217.存在重复元素</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。</p><p>示例 1：<br>输入：nums = [1,2,3,1]<br>输出：true</p><p>示例 2：<br>输入：nums = [1,2,3,4]<br>输出：false</p><p><a href="https://leetcode.cn/problems/contains-duplicate">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>遍历并统计<br>遍历数组中的每一个数并统计这个数在数组中出现的次数，如果出现次数大于等于2，则返回True,<br>，如果正常结束，既遍历途中没有返回，则返回False<br>注：超出时间限制！！！</li><li>集合</li><li>1 使用集合对nums数组进行去重，如果去重后的集合长度不等于数组的长度，则返回True，否则返回False</li><li>2 对于数组中每个元素，我们将它插入到集合中。如果插入一个元素时发现该元素已经存在于集合中，则说明存在重复的元素。</li><li>排序<br>在对数字从小到大排序之后，数组的重复元素一定出现在相邻位置中。因此，我们可以扫描已排序的数组，每次判断相邻的两个元素是否相等，如果相等则说明存在重复的元素。<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span>(<span class="params">self, nums</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">遍历并统计</span></span><br><span class="line"><span class="string">遍历数组中的每一个数并统计这个数在数组中出现的次数，如果出现次数大于等于2，则返回True,</span></span><br><span class="line"><span class="string">，如果正常结束，既遍历途中没有返回，则返回False</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">超出时间限制</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line"><span class="keyword">if</span> nums.count(num) &gt;= <span class="number">2</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate1</span>(<span class="params">self, nums</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">集合</span></span><br><span class="line"><span class="string">使用集合对nums数组进行去重，如果去重后的集合长度不等于数组的长度，则返回True，否则返回False</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(<span class="built_in">set</span>(nums)) != <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate2</span>(<span class="params">self, nums</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">排序</span></span><br><span class="line"><span class="string">在对数字从小到大排序之后，数组的重复元素一定出现在相邻位置中。因此，我们可以扫描已排序的数组，每次判断相邻的两个元素是否相等，如果相等则说明存在重复的元素。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">nums.sort()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line"><span class="keyword">if</span> nums[i] == nums[i+<span class="number">1</span>]:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate3</span>(<span class="params">self, nums</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">集合</span></span><br><span class="line"><span class="string">对于数组中每个元素，我们将它插入到集合中。如果插入一个元素时发现该元素已经存在于集合中，则说明存在重复的元素。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">hash_table = <span class="built_in">set</span>()</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line"><span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> hash_table:</span><br><span class="line">hash_table.add(num)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">slt = Solution()</span><br><span class="line"><span class="comment"># result = slt.containsDuplicate([1, 2, 3, 1])</span></span><br><span class="line"><span class="comment"># result = slt.containsDuplicate1([1, 2, 3, 1])</span></span><br><span class="line"><span class="comment"># result = slt.containsDuplicate2([1, 2, 3, 1])</span></span><br><span class="line">result = slt.containsDuplicate3([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;217-存在重复元素&quot;&gt;&lt;a href=&quot;#217-存在重复元素&quot; class=&quot;headerlink&quot; title=&quot;217.存在重复元素&quot;&gt;&lt;/a&gt;217.存在重复元素&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;head</summary>
      
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="数组" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    <category term="217.存在重复元素" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/217-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 88.合并两个有序数组</title>
    <link href="http://example.com/2022/07/31/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>http://example.com/2022/07/31/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</id>
    <published>2022-07-31T08:13:54.000Z</published>
    <updated>2022-07-31T08:30:40.926Z</updated>
    
    <content type="html"><![CDATA[<h1 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88.合并两个有序数组"></a>88.合并两个有序数组</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。<br>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。<br>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p><p>示例 1：<br>输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3<br>输出：[1,2,2,3,5,6]<br>解释：需要合并 [1,2,3] 和 [2,5,6] 。<br>合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。</p><p><a href="https://leetcode.cn/problems/merge-sorted-array">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>归并<br>设置两个指针i,j,从头开始遍历两个数组，哪个指针指向位置的元素较小则加入结果列表中，该指针后移，…，依次类推。<br>如果两个数组长度不一样，循环结束后，需要将长度较长的数组剩余元素加入结果列表。</li><li>双指针<br>由于题目所给数组均有序，因此可以设置两个指针分别指向两个数组第一个元素，判断两个指针指向位置的元素大小，每次将较小的加入结果列表中。<br>如果某一个数组先遍历结束，后续只需要遍历另一个数组的剩余元素并将其加入结果列表中。</li><li>先将数组nums2放进数组nums1的尾部，然后直接对整个数组进行排序</li><li>逆向双指针<br>对双指针法进行改进，从后往前遍历数组，每次将较大元素放入结果列表中。<br>在双指针法中，我们需要创建长度为m+n的新数组保存结果，因为如果直接在nums1上保存，会覆盖nums1的元素。<br>与双指针方法不同的是，该方法可以原地地在nums1上保存结果（从后往前放入元素不会产生覆盖）。<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, nums1, m, nums2, n</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">归并</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line">result = []</span><br><span class="line"><span class="keyword">while</span> i &lt; m <span class="keyword">and</span> j &lt; n:</span><br><span class="line"><span class="keyword">if</span> nums1[i] &lt; nums2[j]:</span><br><span class="line">result.append(nums1[i])</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> nums1[i] &gt;= nums2[j]:</span><br><span class="line">result.append(nums2[j])</span><br><span class="line">j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> m - i != <span class="number">0</span>:</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(m - (m - i), m):</span><br><span class="line">result.append(nums1[k])</span><br><span class="line"><span class="keyword">if</span> n - j != <span class="number">0</span>:</span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">range</span>(n - (n - j), n):</span><br><span class="line">result.append(nums2[p])</span><br><span class="line"></span><br><span class="line">nums1[:] = result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge1</span>(<span class="params">self, nums1, m, nums2, n</span>):</span></span><br><span class="line"><span class="comment"># 先将数组nums2放进数组nums1的尾部，然后直接对整个数组进行排序</span></span><br><span class="line">nums1[m:] = nums2</span><br><span class="line">quick_sort(nums1, <span class="number">0</span>, <span class="built_in">len</span>(nums1) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge2</span>(<span class="params">self, nums1, m, nums2, n</span>):</span></span><br><span class="line"><span class="built_in">sorted</span> = []</span><br><span class="line">p1, p2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> p1 &lt; m <span class="keyword">or</span> p2 &lt; n:</span><br><span class="line"><span class="keyword">if</span> p1 == m:</span><br><span class="line"><span class="built_in">sorted</span>.append(nums2[p2])</span><br><span class="line">p2 += <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> p2 == n:</span><br><span class="line"><span class="built_in">sorted</span>.append(nums1[p1])</span><br><span class="line">p1 += <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> nums1[p1] &lt; nums2[p2]:</span><br><span class="line"><span class="built_in">sorted</span>.append(nums1[p1])</span><br><span class="line">p1 += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">sorted</span>.append(nums2[p2])</span><br><span class="line">p2 += <span class="number">1</span></span><br><span class="line">nums1[:] = <span class="built_in">sorted</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge3</span>(<span class="params">self, nums1, m, nums2, n</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;逆向双指针&quot;&quot;&quot;</span></span><br><span class="line">p1, p2 = m - <span class="number">1</span>, n - <span class="number">1</span></span><br><span class="line">tail = m + n - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> p1 &gt;= <span class="number">0</span> <span class="keyword">or</span> p2 &gt;= <span class="number">0</span>:</span><br><span class="line"><span class="keyword">if</span> p1 == -<span class="number">1</span>:  <span class="comment"># 如果nums1数组已经遍历完毕，遍历nums2中的剩余元素</span></span><br><span class="line">nums1[tail] = nums2[p2]</span><br><span class="line">p2 -= <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> p2 == -<span class="number">1</span>:  <span class="comment"># 如果nums2数组已经遍历完毕，遍历nums1中的剩余元素</span></span><br><span class="line">nums1[tail] = nums1[p1]</span><br><span class="line">p1 -= <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> nums1[p1] &gt; nums2[p2]:</span><br><span class="line">nums1[tail] = nums1[p1]</span><br><span class="line">p1 -= <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">nums1[tail] = nums2[p2]</span><br><span class="line">p2 -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">tail -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">arr, low, high</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;快速排序&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> low &lt; high:</span><br><span class="line">pivot = partition(arr, low, high)</span><br><span class="line">quick_sort(arr, low, pivot - <span class="number">1</span>)</span><br><span class="line">quick_sort(arr, pivot + <span class="number">1</span>, high)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">arr, low, high</span>):</span></span><br><span class="line">pivot_key = arr[low]</span><br><span class="line"><span class="keyword">while</span> low &lt; high:</span><br><span class="line"><span class="keyword">while</span> low &lt; high <span class="keyword">and</span> arr[high] &gt;= pivot_key:</span><br><span class="line">high -= <span class="number">1</span></span><br><span class="line">arr[low], arr[high] = arr[high], arr[low]</span><br><span class="line"><span class="keyword">while</span> low &lt; high <span class="keyword">and</span> arr[low] &lt;= pivot_key:</span><br><span class="line">low += <span class="number">1</span></span><br><span class="line">arr[low], arr[high] = arr[high], arr[low]</span><br><span class="line"><span class="keyword">return</span> low</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">slt = Solution()</span><br><span class="line">nums1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">nums2 = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="comment"># slt.merge(nums1, 3, nums2, 3)</span></span><br><span class="line"><span class="comment"># slt.merge1(nums1, 3, nums2, 3)</span></span><br><span class="line"><span class="comment"># slt.merge2(nums1, 3, nums2, 3)</span></span><br><span class="line">slt.merge3(nums1, <span class="number">3</span>, nums2, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(nums1)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;88-合并两个有序数组&quot;&gt;&lt;a href=&quot;#88-合并两个有序数组&quot; class=&quot;headerlink&quot; title=&quot;88.合并两个有序数组&quot;&gt;&lt;/a&gt;88.合并两个有序数组&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;</summary>
      
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="数组" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    <category term="88.合并两个有序数组" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="双指针" scheme="http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="归并" scheme="http://example.com/tags/%E5%BD%92%E5%B9%B6/"/>
    
    <category term="逆向双指针" scheme="http://example.com/tags/%E9%80%86%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 66.加一</title>
    <link href="http://example.com/2022/07/30/%E5%8A%A0%E4%B8%80/"/>
    <id>http://example.com/2022/07/30/%E5%8A%A0%E4%B8%80/</id>
    <published>2022-07-31T02:28:12.000Z</published>
    <updated>2022-07-31T02:31:18.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="66-加一"><a href="#66-加一" class="headerlink" title="66.加一"></a>66.加一</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。<br>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。<br>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><p>示例 1：<br>输入：digits = [1,2,3]<br>输出：[1,2,4]<br>解释：输入数组表示数字 123。</p><p><a href="https://leetcode.cn/problems/plus-one">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>从后往前找第一个不为9的元素，并将该位置后的9置零</li><li>将数组转化为数字加一再将结果转化为整数数组<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plusOne</span>(<span class="params">self, digits</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">从后往前找第一个不为9的元素，并将该位置后的9置零</span></span><br><span class="line"><span class="string">        :type digits: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">n = <span class="built_in">len</span>(digits)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line"><span class="keyword">if</span> digits[i] != <span class="number">9</span>:</span><br><span class="line">digits[i] += <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n):</span><br><span class="line">digits[j] = <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> digits</span><br><span class="line"><span class="keyword">return</span> [<span class="number">1</span>] + [<span class="number">0</span>] * n</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plusOne1</span>(<span class="params">self, digits</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;将数组转化为数字加一再将结果转化为整数数组&quot;&quot;&quot;</span></span><br><span class="line">num = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> digit <span class="keyword">in</span> digits:</span><br><span class="line">num += <span class="built_in">str</span>(digit)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">list</span>([<span class="built_in">int</span>(ch) <span class="keyword">for</span> ch <span class="keyword">in</span> <span class="built_in">str</span>(<span class="built_in">int</span>(num) + <span class="number">1</span>)])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">slt = Solution()</span><br><span class="line"><span class="comment"># result = slt.plusOne([1, 2, 3])</span></span><br><span class="line">result = slt.plusOne1([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;66-加一&quot;&gt;&lt;a href=&quot;#66-加一&quot; class=&quot;headerlink&quot; title=&quot;66.加一&quot;&gt;&lt;/a&gt;66.加一&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;</summary>
      
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="数组" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    <category term="66.加一" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/66-%E5%8A%A0%E4%B8%80/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 35.搜索插入位置</title>
    <link href="http://example.com/2022/07/29/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
    <id>http://example.com/2022/07/29/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</id>
    <published>2022-07-29T09:07:49.000Z</published>
    <updated>2022-07-29T09:51:33.231Z</updated>
    
    <content type="html"><![CDATA[<h1 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35.搜索插入位置"></a>35.搜索插入位置</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br>请必须使用时间复杂度为 O(log n) 的算法。</p><p>示例 1:<br>输入: nums = [1,3,5,6], target = 5<br>输出: 2</p><p>示例 2:<br>输入: nums = [1,3,5,6], target = 2<br>输出: 1</p><p><a href="https://leetcode.cn/problems/search-insert-position">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>利用二分查找目标值，如果存在，返回其索引，如果不存在，寻找插入位置。<br>（1）二分查找找到目标值，时间复杂度为O(log n)<br>（2）二分查找没找到目标值，时间复杂度为O(log n) + O(n)<br>因此，该方法会时间复杂度不符合题意。</li><li>根据题意，找到大于等于目标值的位置，该位置即为插入位置/目标值的位置。<br>该方法需要遍历数组，因此时间复杂度为O(n)，不符合题意。</li><li>二分查找变形<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">利用二分查找目标值，如果存在，返回其索引，如果不存在，寻找插入位置。</span></span><br><span class="line"><span class="string">（1）二分查找找到目标值，时间复杂度为O(log n)</span></span><br><span class="line"><span class="string">（2）二分查找没找到目标值，时间复杂度为O(log n) + O(n)</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">index = self.binarySearch(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums), target)</span><br><span class="line"><span class="keyword">if</span> index != -<span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> index</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> self.findBigger(nums, target)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span>(<span class="params">self, arr, low, high, key</span>):</span></span><br><span class="line"><span class="keyword">if</span> low &lt;= high:</span><br><span class="line">mid = (low + high) // <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> arr[mid] == key:</span><br><span class="line"><span class="keyword">return</span> mid</span><br><span class="line"><span class="keyword">elif</span> arr[mid] &gt; key:</span><br><span class="line"><span class="keyword">return</span> self.binarySearch(arr, low, mid - <span class="number">1</span>, key)</span><br><span class="line"><span class="keyword">elif</span> arr[mid] &lt; key:</span><br><span class="line"><span class="keyword">return</span> self.binarySearch(arr, mid + <span class="number">1</span>, high, key)</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findBigger</span>(<span class="params">self, arr, num</span>):</span></span><br><span class="line"><span class="keyword">if</span> num &lt; arr[<span class="number">0</span>]:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> num &gt; arr[<span class="built_in">len</span>(arr) - <span class="number">1</span>]:</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(arr)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line"><span class="keyword">if</span> arr[i] &lt; num:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchInsert1</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">找到大于等于目标值的位置，该位置即为插入位置/目标值的位置。</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> target &lt; nums[<span class="number">0</span>]:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> target &gt; nums[<span class="built_in">len</span>(nums) - <span class="number">1</span>]:</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line"><span class="keyword">if</span> nums[i] &gt;= target:</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line"><span class="keyword">elif</span> nums[i] &lt; target:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchInsert2</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;searchInsert1的简化版&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> target &gt; nums[<span class="built_in">len</span>(nums) - <span class="number">1</span>]:</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line"><span class="keyword">if</span> nums[i] &lt; target:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchInsert3</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        二分查找变形</span></span><br><span class="line"><span class="string">        不断用二分法逼近查找第一个大于等于 target的下标 </span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">l = <span class="number">0</span></span><br><span class="line">r = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> l &lt;= r:</span><br><span class="line">mid = l + (r - l) // <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">l = mid + <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">r = mid - <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> l</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">slt = Solution()</span><br><span class="line"><span class="comment"># result = slt.searchInsert([1, 3, 5, 6], 7)</span></span><br><span class="line"><span class="comment"># result = slt.searchInsert1([1, 3, 5, 6], 7)</span></span><br><span class="line"><span class="comment"># result = slt.searchInsert2([1, 3, 5, 6], 7)</span></span><br><span class="line">result = slt.searchInsert3([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="number">7</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;35-搜索插入位置&quot;&gt;&lt;a href=&quot;#35-搜索插入位置&quot; class=&quot;headerlink&quot; title=&quot;35.搜索插入位置&quot;&gt;&lt;/a&gt;35.搜索插入位置&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="数组" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    <category term="35.搜索插入位置" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="二分查找" scheme="http://example.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>线程池 | execute和submit方法的区别</title>
    <link href="http://example.com/2022/07/27/execute%E5%92%8Csubmit%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2022/07/27/execute%E5%92%8Csubmit%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-07-27T09:02:23.000Z</published>
    <updated>2022-07-27T09:07:29.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="execute-和submit-的区别"><a href="#execute-和submit-的区别" class="headerlink" title="execute()和submit()的区别"></a>execute()和submit()的区别</h1><ol><li>线程池类关系如下：<br><img src="/2022/07/27/execute%E5%92%8Csubmit%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/1658586453860.png"></li></ol><span id="more"></span><p><img src="/2022/07/27/execute%E5%92%8Csubmit%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/1658586628228.png"></p><ol><li><p>由类关系可以得到线程池的架构图</p><p><img src="/2022/07/27/execute%E5%92%8Csubmit%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/1658586004069.png" alt="1658586004069"></p></li><li><p>由下图可以看出Executor接口中的<strong>execute()只能执行Runnable类型的任务</strong></p></li></ol><p><img src="/2022/07/27/execute%E5%92%8Csubmit%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/1658586548515.png" alt="1658586548515"></p><ol><li><p>由下图可以看出ExecutorService中的<strong>submit()方法可以既可以执行Runnable类型的任务也可以执行Callable类型的任务</strong></p><p><img src="/2022/07/27/execute%E5%92%8Csubmit%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/1658586523414.png" alt="1658586523414"></p></li><li><p>由Executor接口的源码可以看出<strong>execute()方法无返回值</strong></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executes the given command at some time in the future.  The command</span></span><br><span class="line"><span class="comment">     * may execute in a new thread, in a pooled thread, or in the calling</span></span><br><span class="line"><span class="comment">     * thread, at the discretion of the &#123;<span class="doctag">@code</span> Executor&#125; implementation.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> command the runnable task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if this task cannot be</span></span><br><span class="line"><span class="comment">     * accepted for execution</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if command is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>由ExecutorService接口的源码可以看出<strong>submit()方法有返回值且返回值为Future类型</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initiates an orderly shutdown in which previously submitted</span></span><br><span class="line"><span class="comment">     * tasks are executed, but no new tasks will be accepted.</span></span><br><span class="line"><span class="comment">     * Invocation has no additional effect if already shut down.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This method does not wait for previously submitted tasks to</span></span><br><span class="line"><span class="comment">     * complete execution.  Use &#123;<span class="doctag">@link</span> #awaitTermination awaitTermination&#125;</span></span><br><span class="line"><span class="comment">     * to do that.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SecurityException if a security manager exists and</span></span><br><span class="line"><span class="comment">     *         shutting down this ExecutorService may manipulate</span></span><br><span class="line"><span class="comment">     *         threads that the caller is not permitted to modify</span></span><br><span class="line"><span class="comment">     *         because it does not hold &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     *         java.lang.RuntimePermission&#125;&#123;<span class="doctag">@code</span> (&quot;modifyThread&quot;)&#125;,</span></span><br><span class="line"><span class="comment">     *         or the security manager&#x27;s &#123;<span class="doctag">@code</span> checkAccess&#125; method</span></span><br><span class="line"><span class="comment">     *         denies access.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Attempts to stop all actively executing tasks, halts the</span></span><br><span class="line"><span class="comment">     * processing of waiting tasks, and returns a list of the tasks</span></span><br><span class="line"><span class="comment">     * that were awaiting execution.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This method does not wait for actively executing tasks to</span></span><br><span class="line"><span class="comment">     * terminate.  Use &#123;<span class="doctag">@link</span> #awaitTermination awaitTermination&#125; to</span></span><br><span class="line"><span class="comment">     * do that.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;There are no guarantees beyond best-effort attempts to stop</span></span><br><span class="line"><span class="comment">     * processing actively executing tasks.  For example, typical</span></span><br><span class="line"><span class="comment">     * implementations will cancel via &#123;<span class="doctag">@link</span> Thread#interrupt&#125;, so any</span></span><br><span class="line"><span class="comment">     * task that fails to respond to interrupts may never terminate.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> list of tasks that never commenced execution</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SecurityException if a security manager exists and</span></span><br><span class="line"><span class="comment">     *         shutting down this ExecutorService may manipulate</span></span><br><span class="line"><span class="comment">     *         threads that the caller is not permitted to modify</span></span><br><span class="line"><span class="comment">     *         because it does not hold &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     *         java.lang.RuntimePermission&#125;&#123;<span class="doctag">@code</span> (&quot;modifyThread&quot;)&#125;,</span></span><br><span class="line"><span class="comment">     *         or the security manager&#x27;s &#123;<span class="doctag">@code</span> checkAccess&#125; method</span></span><br><span class="line"><span class="comment">     *         denies access.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; if this executor has been shut down.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this executor has been shut down</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; if all tasks have completed following shut down.</span></span><br><span class="line"><span class="comment">     * Note that &#123;<span class="doctag">@code</span> isTerminated&#125; is never &#123;<span class="doctag">@code</span> true&#125; unless</span></span><br><span class="line"><span class="comment">     * either &#123;<span class="doctag">@code</span> shutdown&#125; or &#123;<span class="doctag">@code</span> shutdownNow&#125; was called first.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if all tasks have completed following shut down</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Blocks until all tasks have completed execution after a shutdown</span></span><br><span class="line"><span class="comment">     * request, or the timeout occurs, or the current thread is</span></span><br><span class="line"><span class="comment">     * interrupted, whichever happens first.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout the maximum time to wait</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit the time unit of the timeout argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this executor terminated and</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> false&#125; if the timeout elapsed before termination</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if interrupted while waiting</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Submits a value-returning task for execution and returns a</span></span><br><span class="line"><span class="comment">     * Future representing the pending results of the task. The</span></span><br><span class="line"><span class="comment">     * Future&#x27;s &#123;<span class="doctag">@code</span> get&#125; method will return the task&#x27;s result upon</span></span><br><span class="line"><span class="comment">     * successful completion.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * If you would like to immediately block waiting</span></span><br><span class="line"><span class="comment">     * for a task, you can use constructions of the form</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> result = exec.submit(aCallable).get();&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Note: The &#123;<span class="doctag">@link</span> Executors&#125; class includes a set of methods</span></span><br><span class="line"><span class="comment">     * that can convert some other common closure-like objects,</span></span><br><span class="line"><span class="comment">     * for example, &#123;<span class="doctag">@link</span> java.security.PrivilegedAction&#125; to</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Callable&#125; form so they can be submitted.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task the task to submit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the task&#x27;s result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a Future representing pending completion of the task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if the task cannot be</span></span><br><span class="line"><span class="comment">     *         scheduled for execution</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the task is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Submits a Runnable task for execution and returns a Future</span></span><br><span class="line"><span class="comment">     * representing that task. The Future&#x27;s &#123;<span class="doctag">@code</span> get&#125; method will</span></span><br><span class="line"><span class="comment">     * return the given result upon successful completion.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task the task to submit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result the result to return</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a Future representing pending completion of the task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if the task cannot be</span></span><br><span class="line"><span class="comment">     *         scheduled for execution</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the task is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Submits a Runnable task for execution and returns a Future</span></span><br><span class="line"><span class="comment">     * representing that task. The Future&#x27;s &#123;<span class="doctag">@code</span> get&#125; method will</span></span><br><span class="line"><span class="comment">     * return &#123;<span class="doctag">@code</span> null&#125; upon &lt;em&gt;successful&lt;/em&gt; completion.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task the task to submit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a Future representing pending completion of the task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if the task cannot be</span></span><br><span class="line"><span class="comment">     *         scheduled for execution</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the task is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executes the given tasks, returning a list of Futures holding</span></span><br><span class="line"><span class="comment">     * their status and results when all complete.</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Future#isDone&#125; is &#123;<span class="doctag">@code</span> true&#125; for each</span></span><br><span class="line"><span class="comment">     * element of the returned list.</span></span><br><span class="line"><span class="comment">     * Note that a &lt;em&gt;completed&lt;/em&gt; task could have</span></span><br><span class="line"><span class="comment">     * terminated either normally or by throwing an exception.</span></span><br><span class="line"><span class="comment">     * The results of this method are undefined if the given</span></span><br><span class="line"><span class="comment">     * collection is modified while this operation is in progress.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tasks the collection of tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the values returned from the tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a list of Futures representing the tasks, in the same</span></span><br><span class="line"><span class="comment">     *         sequential order as produced by the iterator for the</span></span><br><span class="line"><span class="comment">     *         given task list, each of which has completed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if interrupted while waiting, in</span></span><br><span class="line"><span class="comment">     *         which case unfinished tasks are cancelled</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if tasks or any of its elements are &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if any task cannot be</span></span><br><span class="line"><span class="comment">     *         scheduled for execution</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executes the given tasks, returning a list of Futures holding</span></span><br><span class="line"><span class="comment">     * their status and results</span></span><br><span class="line"><span class="comment">     * when all complete or the timeout expires, whichever happens first.</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Future#isDone&#125; is &#123;<span class="doctag">@code</span> true&#125; for each</span></span><br><span class="line"><span class="comment">     * element of the returned list.</span></span><br><span class="line"><span class="comment">     * Upon return, tasks that have not completed are cancelled.</span></span><br><span class="line"><span class="comment">     * Note that a &lt;em&gt;completed&lt;/em&gt; task could have</span></span><br><span class="line"><span class="comment">     * terminated either normally or by throwing an exception.</span></span><br><span class="line"><span class="comment">     * The results of this method are undefined if the given</span></span><br><span class="line"><span class="comment">     * collection is modified while this operation is in progress.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tasks the collection of tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout the maximum time to wait</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit the time unit of the timeout argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the values returned from the tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a list of Futures representing the tasks, in the same</span></span><br><span class="line"><span class="comment">     *         sequential order as produced by the iterator for the</span></span><br><span class="line"><span class="comment">     *         given task list. If the operation did not time out,</span></span><br><span class="line"><span class="comment">     *         each task will have completed. If it did time out, some</span></span><br><span class="line"><span class="comment">     *         of these tasks will not have completed.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if interrupted while waiting, in</span></span><br><span class="line"><span class="comment">     *         which case unfinished tasks are cancelled</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if tasks, any of its elements, or</span></span><br><span class="line"><span class="comment">     *         unit are &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if any task cannot be scheduled</span></span><br><span class="line"><span class="comment">     *         for execution</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                  <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executes the given tasks, returning the result</span></span><br><span class="line"><span class="comment">     * of one that has completed successfully (i.e., without throwing</span></span><br><span class="line"><span class="comment">     * an exception), if any do. Upon normal or exceptional return,</span></span><br><span class="line"><span class="comment">     * tasks that have not completed are cancelled.</span></span><br><span class="line"><span class="comment">     * The results of this method are undefined if the given</span></span><br><span class="line"><span class="comment">     * collection is modified while this operation is in progress.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tasks the collection of tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the values returned from the tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the result returned by one of the tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if interrupted while waiting</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if tasks or any element task</span></span><br><span class="line"><span class="comment">     *         subject to execution is &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if tasks is empty</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ExecutionException if no task successfully completes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if tasks cannot be scheduled</span></span><br><span class="line"><span class="comment">     *         for execution</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executes the given tasks, returning the result</span></span><br><span class="line"><span class="comment">     * of one that has completed successfully (i.e., without throwing</span></span><br><span class="line"><span class="comment">     * an exception), if any do before the given timeout elapses.</span></span><br><span class="line"><span class="comment">     * Upon normal or exceptional return, tasks that have not</span></span><br><span class="line"><span class="comment">     * completed are cancelled.</span></span><br><span class="line"><span class="comment">     * The results of this method are undefined if the given</span></span><br><span class="line"><span class="comment">     * collection is modified while this operation is in progress.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tasks the collection of tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout the maximum time to wait</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit the time unit of the timeout argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the values returned from the tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the result returned by one of the tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if interrupted while waiting</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if tasks, or unit, or any element</span></span><br><span class="line"><span class="comment">     *         task subject to execution is &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> TimeoutException if the given timeout elapses before</span></span><br><span class="line"><span class="comment">     *         any task successfully completes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ExecutionException if no task successfully completes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if tasks cannot be scheduled</span></span><br><span class="line"><span class="comment">     *         for execution</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>结论：</strong></p><ul><li>execute()只能执行Runnable类型的任务，方法无返回值</li><li>submit()方法可以既可以执行Runnable类型的任务也可以执行Callable类型的任务，方法有返回值且返回值为Future类型</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;execute-和submit-的区别&quot;&gt;&lt;a href=&quot;#execute-和submit-的区别&quot; class=&quot;headerlink&quot; title=&quot;execute()和submit()的区别&quot;&gt;&lt;/a&gt;execute()和submit()的区别&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;线程池类关系如下：&lt;br&gt;&lt;img src=&quot;/2022/07/27/execute%E5%92%8Csubmit%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/1658586453860.png&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="线程池" scheme="http://example.com/categories/Java/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    <category term="execute()和submit()方法的区别" scheme="http://example.com/categories/Java/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%B1%A0/execute-%E5%92%8Csubmit-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    
    
    <category term="线程池" scheme="http://example.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    <category term="execute()" scheme="http://example.com/tags/execute/"/>
    
    <category term="submit()" scheme="http://example.com/tags/submit/"/>
    
  </entry>
  
  <entry>
    <title>秋招面经 | 721开发测试面经</title>
    <link href="http://example.com/2022/07/21/721%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E9%9D%A2%E7%BB%8F/"/>
    <id>http://example.com/2022/07/21/721%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E9%9D%A2%E7%BB%8F/</id>
    <published>2022-07-21T09:39:08.000Z</published>
    <updated>2022-07-21T09:44:06.172Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7-21百度开发测试面经"><a href="#7-21百度开发测试面经" class="headerlink" title="7.21百度开发测试面经"></a>7.21百度开发测试面经</h1><ul><li><p>sql语句 </p><p>表结构</p><p>​    表名：student<br>​    字段：id name score</p><p>问题：成绩倒数第二/正数第二的学生名字</p><p>SELECT student.name, student.scores FROM student ORDER BY scores DESC LIMIT 1, 1</p><p>SELECT student.name, student.scores FROM student ORDER BY scores ASC LIMIT 1, 1</p></li><li><p>内外连接</p><p>SELECT student.name, student.scores, class.id FROM student INNER JOIN class ON student.<code>classid</code> = class.id</p><p>SELECT student.name, student.scores, class.id FROM student LEFT JOIN class ON student.<code>classid</code> = class.<code>id</code></p><p>SELECT student.name, student.scores, class.id FROM student RIGHT JOIN class ON student.<code>classid</code> = class.id</p></li><li><p>selenium定位元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">driver.find_element_by_xpath()</span><br><span class="line">driver.find_element_by_name()</span><br><span class="line">driver.find_element_by_tag_name()</span><br><span class="line">driver.find_element_by_link_text()</span><br><span class="line">driver.find_element_by_partial_link_text()</span><br><span class="line">driver.find_element_by_class_name()</span><br><span class="line">driver.find_element_by_css_selector()</span><br><span class="line">driver.find_element_by_id()</span><br></pre></td></tr></table></figure></li><li><p>tcp三次握手?握手的时候怎么确认对方的身份？</p><ul><li><p>三次握手过程</p><ul><li>第一次握手，客户端发送(seq=x)，客户端进入<code>SYN_SEND</code>状态</li><li>第二次握手，服务端响应(Seq=y, Ack=x+1)，服务器端就进入<code>SYN_RCV</code>状态</li><li>第三次握手，客户端收到服务端的确认后，发送(Ack=y+1)，客户端进入<code>ESTABLISHED</code>状态。当服务器端接收到这个包时，也进入<code>ESTABLISHED</code>状态。</li></ul></li><li><p>确认身份</p><p>TCP报文首部中有源端口和目的端口</p><p><img src="https://img-blog.csdnimg.cn/img_convert/4f7b277a642040f8ec83c5d54b57801b.png" alt="图片"></p></li></ul></li><li><p>TCP四次挥手</p><ul><li><p>挥手过程</p><ul><li><p>第一次挥手：客户端向服务端发送连接释放报文</p></li><li><p>第二次挥手：服务端收到连接释放报文后，立即发出确认报文。这时 TCP 连接处于半关闭状态，即客户端到服务端的连接已经释放了，但是服务端到客户端的连接还未释放。表示客户端已经没有数据发送了，但是服务端可能还要给客户端发送数据。</p></li><li><p>第三次挥手：服务端向客户端发送连接释放报文</p></li><li><p>第四次挥手：客户端收到服务端的连接释放报文后，立即发出确认报文。此时，客户端就进入了 <code>TIME-WAIT</code> 状态。注意此时客户端到 TCP 连接还没有释放，必须经过 2*MSL（最长报文段寿命）的时间后，才进入<code>CLOSED</code> 状态。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/deb7601528a2b863bd70567eec32407d.png" alt="img"></p></li></ul></li></ul></li><li><p>网络七层模型及各层常见协议</p><ul><li><p>物理层（IEEE802.2,Ethernet）</p></li><li><p>数据链路层(STP:生成树协议,PPP：点对点协议,ARP,RARP)</p></li><li><p>网络层（IP,ICMP：互联网控制信息协议,VRRP：虚拟路由器冗余协议）</p></li><li><p>传输层 (TCP,UDP)</p></li><li><p>会话层（SSL:安全套接字层协议,TLS：传输层安全协议）</p></li><li><p>表示层(LPP:轻量级表示协议)</p></li><li><p>应用层（HTTP,FTP,SMTP） </p><p><img src="https://img-blog.csdnimg.cn/daa7b60ef1584b3faca6810d0b193e00.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55-c6L6w5omA6Ie0,size_1,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p></li></ul></li><li><p>算法</p><ul><li><p>两数之和</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line"></span><br><span class="line">hashtable = <span class="built_in">dict</span>()</span><br><span class="line"><span class="keyword">for</span> i,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line"><span class="keyword">if</span> target - num <span class="keyword">in</span> hashtable:</span><br><span class="line"><span class="keyword">return</span> [hashtable[target-num], i]</span><br><span class="line">hashtable[nums[i]] = i</span><br><span class="line"><span class="keyword">return</span> []</span><br></pre></td></tr></table></figure></li><li><p>实现LRU</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRU</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;7-21百度开发测试面经&quot;&gt;&lt;a href=&quot;#7-21百度开发测试面经&quot; class=&quot;headerlink&quot; title=&quot;7.21百度开发测试面经&quot;&gt;&lt;/a&gt;7.21百度开发测试面经&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;sql语句 &lt;/p&gt;
&lt;p&gt;表结构&lt;/p&gt;</summary>
      
    
    
    
    <category term="秋招面经" scheme="http://example.com/categories/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/"/>
    
    <category term="开发测试" scheme="http://example.com/categories/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="秋招面经" scheme="http://example.com/tags/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 27.移除元素</title>
    <link href="http://example.com/2022/07/19/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
    <id>http://example.com/2022/07/19/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</id>
    <published>2022-07-19T09:40:06.000Z</published>
    <updated>2022-07-19T10:04:47.888Z</updated>
    
    <content type="html"><![CDATA[<h1 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.移除元素</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。<br>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p>示例 1：<br>输入：nums = [3,2,2,3], val = 3<br>输出：2, nums = [2,2]<br>解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</p><p><a href="https://leetcode.cn/problems/remove-element">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li><p>双指针<br>设置两个指针，左指针left，右指针right，左指针left指向待插入不等于val的值，right指针遍历寻找不等于val的值，如果找到，就将right指针指向的值复制到left指针指向的位置，<br>然后left指针后移到下一个待插入位置，right指针继续后移寻找下一个不等于val的值，依次类推。</p></li><li><p>双指针优化<br>如果左指针 left 指向的元素等于 val，此时将右指针 right 指向的元素复制到左指针 left 的位置，然后右指针 right 左移一位。如果赋值过来的元素恰好也等于 val，可以继续把右指针 right 指向的元素的值赋值过来（左指针 left 指向的等于 val 的元素的位置继续被覆盖），直到左指针指向的元素的值不等于 val 为止。<br>当左指针 left 和右指针 right 重合的时候，左右指针遍历完数组中所有的元素。<br>这样的方法两个指针在最坏的情况下合起来只遍历了数组一次。与方法一不同的是，方法二避免了需要保留的元素的重复赋值操作。</p><span id="more"></span><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p> class Solution(object):</p><pre><code> def removeElement(self, nums, val):     &quot;&quot;&quot;     双指针     :type nums: List[int]     :type val: int     :rtype: int     &quot;&quot;&quot;     left = 0     right = 0     while right &lt; len(nums):         if nums[right] != val:             nums[left] = nums[right]             left += 1         right += 1     return left  def removeElement1(self, nums, val):     &quot;&quot;&quot;双指针优化&quot;&quot;&quot;     left = 0     right = len(nums)     while left &lt; right:         if nums[left] == val:             nums[left] = nums[right - 1]             right -= 1         else:             left += 1          return left</code></pre><p> if <strong>name</strong> == “<strong>main</strong>“:</p><pre><code> slt = Solution() result = slt.removeElement([3, 2, 2, 3], 3) print(result)</code></pre></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;27-移除元素&quot;&gt;&lt;a href=&quot;#27-移除元素&quot; class=&quot;headerlink&quot; title=&quot;27.移除元素&quot;&gt;&lt;/a&gt;27.移除元素&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。&lt;br&gt;不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。&lt;br&gt;元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;br&gt;输入：nums = [3,2,2,3], val = 3&lt;br&gt;输出：2, nums = [2,2]&lt;br&gt;解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/remove-element&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;双指针&lt;br&gt;设置两个指针，左指针left，右指针right，左指针left指向待插入不等于val的值，right指针遍历寻找不等于val的值，如果找到，就将right指针指向的值复制到left指针指向的位置，&lt;br&gt;然后left指针后移到下一个待插入位置，right指针继续后移寻找下一个不等于val的值，依次类推。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;双指针优化&lt;br&gt;如果左指针 left 指向的元素等于 val，此时将右指针 right 指向的元素复制到左指针 left 的位置，然后右指针 right 左移一位。如果赋值过来的元素恰好也等于 val，可以继续把右指针 right 指向的元素的值赋值过来（左指针 left 指向的等于 val 的元素的位置继续被覆盖），直到左指针指向的元素的值不等于 val 为止。&lt;br&gt;当左指针 left 和右指针 right 重合的时候，左右指针遍历完数组中所有的元素。&lt;br&gt;这样的方法两个指针在最坏的情况下合起来只遍历了数组一次。与方法一不同的是，方法二避免了需要保留的元素的重复赋值操作。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="数组" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    <category term="27.移除元素" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="双指针" scheme="http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 26.删除有序数组中的重复项</title>
    <link href="http://example.com/2022/07/19/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <id>http://example.com/2022/07/19/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</id>
    <published>2022-07-19T08:41:08.000Z</published>
    <updated>2022-07-19T08:51:11.958Z</updated>
    
    <content type="html"><![CDATA[<h1 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26.删除有序数组中的重复项"></a>26.删除有序数组中的重复项</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。<br>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。<br>将最终结果插入 nums 的前 k 个位置后返回 k 。<br>不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p>示例 1：<br>输入：nums = [1,1,2]<br>输出：2, nums = [1,2,_]<br>解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</p><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li><p>双指针<br>（1）如果数组为空，返回0<br>（2）如果数组只有一个元素，返回1<br>（3）如果数组中有超过两个元素，第一个元素肯定不会被删除，所以从第二位位置开始删除重复元素，设置两个指针，一个快指针<br>fast，一个慢指针slow，快指针fast用来遍历数组寻找下一个不重复元素，慢指针slow指向存放下一个不重复元素的位置；每当<br>fast指针遍历到一个新的不重复元素（fast指向的元素不等于fast-1位置的元素），就将该元素复制到慢指针slow执行的位置，<br>同时慢指针slow指向下一个位置，快指针fast继续寻找下一个不重复元素，依次类推。</p><span id="more"></span><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p> class Solution(object):</p><pre><code> def removeDuplicates(self, nums):     &quot;&quot;&quot;     双指针     :type nums: List[int]     :rtype: int     &quot;&quot;&quot;     if not nums:         return 0          n = len(nums)     fast = slow = 1     while fast &lt; n:         if nums[fast] != nums[fast - 1]:             nums[slow] = nums[fast]             slow += 1         fast += 1     return slow </code></pre><p> if <strong>name</strong> == “<strong>main</strong>“:</p><pre><code> slt = Solution() nums = [1, 1, 2] result = slt.removeDuplicates(nums) print(result)</code></pre></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;26-删除有序数组中的重复项&quot;&gt;&lt;a href=&quot;#26-删除有序数组中的重复项&quot; class=&quot;headerlink&quot; title=&quot;26.删除有序数组中的重复项&quot;&gt;&lt;/a&gt;26.删除有序数组中的重复项&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。&lt;br&gt;由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。&lt;br&gt;将最终结果插入 nums 的前 k 个位置后返回 k 。&lt;br&gt;不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;br&gt;输入：nums = [1,1,2]&lt;br&gt;输出：2, nums = [1,2,_]&lt;br&gt;解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/remove-duplicates-from-sorted-array&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;双指针&lt;br&gt;（1）如果数组为空，返回0&lt;br&gt;（2）如果数组只有一个元素，返回1&lt;br&gt;（3）如果数组中有超过两个元素，第一个元素肯定不会被删除，所以从第二位位置开始删除重复元素，设置两个指针，一个快指针&lt;br&gt;fast，一个慢指针slow，快指针fast用来遍历数组寻找下一个不重复元素，慢指针slow指向存放下一个不重复元素的位置；每当&lt;br&gt;fast指针遍历到一个新的不重复元素（fast指向的元素不等于fast-1位置的元素），就将该元素复制到慢指针slow执行的位置，&lt;br&gt;同时慢指针slow指向下一个位置，快指针fast继续寻找下一个不重复元素，依次类推。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="数组" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    <category term="26.删除有序数组中的重复项" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="双指针" scheme="http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 121.买卖股票的最佳时机</title>
    <link href="http://example.com/2022/07/18/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
    <id>http://example.com/2022/07/18/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</id>
    <published>2022-07-19T07:11:24.000Z</published>
    <updated>2022-07-19T07:47:43.441Z</updated>
    
    <content type="html"><![CDATA[<h1 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121.买卖股票的最佳时机"></a>121.买卖股票的最佳时机</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。<br>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。<br>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><p>示例 1：<br>输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</p><p>示例 2：<br>输入：prices = [7,6,4,3,1]<br>输出：0<br>解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</p><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li><p>暴力法</p></li><li><p>一次遍历<br>遍历一遍数组，计算每次 到当天为止 的最小股票价格和最大利润。</p></li></ol><p><strong>3. 动态规划</strong><br>动态规划一般分为一维、二维、多维（使用状态压缩），对应形式为 dp(i)、dp(i)(j)、二进制dp(i)(j)。<br>（1）动态规划做题步骤<br>    明确 dp(i) 应该表示什么（二维情况：dp(i)(j)）；<br>    根据 dp(i)和 dp(i−1) 的关系得出状态转移方程；<br>    确定初始条件，如 dp(0)。<br>（2）本题思路<br>其实方法一的思路不是凭空想象的，而是由动态规划的思想演变而来。这里介绍一维动态规划思想。<br>dp[i] 表示前 i 天的最大利润，因为我们始终要使利润最大化，则：</p><pre><code>dp[i]=max(dp[i−1],prices[i]−minprice)</code></pre><span id="more"></span><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):    def maxProfit(self, prices):        &quot;&quot;&quot;        暴力法(超出时间限制)        :type prices: List[int]        :rtype: int        &quot;&quot;&quot;        # ans = 0        #        # for i in range(0, len(prices)):        #     for j in range(i + 1, len(prices)):        #         ans = max(ans, prices[j] - prices[i])        #        # return ans                if len(prices) &lt; 2:            return 0        result = max([prices[j] - prices[i] for i in range(0, len(prices)) for j in range(i + 1, len(prices))])        return result if result &gt; 0 else 0        def maxProfit1(self, prices):        &quot;&quot;&quot;一次遍历&quot;&quot;&quot;        minprice = max(prices)  # 记录最小的股值        maxprofit = 0  #                # 循环迭代输入的prices，当前价格小于最小的股值时修改minprice，        # 当前获得的利润大于最大的利润时修改maxprofit        for price in prices:            maxprofit = max(price - minprice, maxprofit)            minprice = min(price, minprice)                    return maxprofit        def maxProfit2(self, prices):        &quot;&quot;&quot;动态规划（按照估值最低点列动态规划方程）&quot;&quot;&quot;        maxprofit = 0        dp = [prices[0] for j in range(0, len(prices))]        for i in range(1, len(prices)):            dp[i] = min(dp[i-1], prices[i])            maxprofit = max(maxprofit, prices[i] - dp[i])        return maxprofit        def maxProfit3(self, prices):        &quot;&quot;&quot;动态规划（按照最大利润列动态规划方程）&quot;&quot;&quot;        minprice = prices[0]        dp = [0]*len(prices)                for i in range(0, len(prices)):            minprice = min(minprice, prices[i])            dp[i] = max(dp[i - 1], prices[i] - minprice)                return dp[-1]if __name__ == &quot;__main__&quot;:    slt = Solution()    prices = [7, 1, 5, 3, 6, 4]    # prices = [7, 6, 4, 3, 1]    # profit = slt.maxProfit(prices)    # profit = slt.maxProfit1(prices)    # profit = slt.maxProfit2(prices)    profit = slt.maxProfit3(prices)    print(profit)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;121-买卖股票的最佳时机&quot;&gt;&lt;a href=&quot;#121-买卖股票的最佳时机&quot; class=&quot;headerlink&quot; title=&quot;121.买卖股票的最佳时机&quot;&gt;&lt;/a&gt;121.买卖股票的最佳时机&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。&lt;br&gt;你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。&lt;br&gt;返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;br&gt;输入：[7,1,5,3,6,4]&lt;br&gt;输出：5&lt;br&gt;解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。&lt;br&gt;     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。&lt;/p&gt;
&lt;p&gt;示例 2：&lt;br&gt;输入：prices = [7,6,4,3,1]&lt;br&gt;输出：0&lt;br&gt;解释：在这种情况下, 没有交易完成, 所以最大利润为 0。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/best-time-to-buy-and-sell-stock&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;暴力法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一次遍历&lt;br&gt;遍历一遍数组，计算每次 到当天为止 的最小股票价格和最大利润。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;3. 动态规划&lt;/strong&gt;&lt;br&gt;动态规划一般分为一维、二维、多维（使用状态压缩），对应形式为 dp(i)、dp(i)(j)、二进制dp(i)(j)。&lt;br&gt;（1）动态规划做题步骤&lt;br&gt;    明确 dp(i) 应该表示什么（二维情况：dp(i)(j)）；&lt;br&gt;    根据 dp(i)和 dp(i−1) 的关系得出状态转移方程；&lt;br&gt;    确定初始条件，如 dp(0)。&lt;br&gt;（2）本题思路&lt;br&gt;其实方法一的思路不是凭空想象的，而是由动态规划的思想演变而来。这里介绍一维动态规划思想。&lt;br&gt;dp[i] 表示前 i 天的最大利润，因为我们始终要使利润最大化，则：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dp[i]=max(dp[i−1],prices[i]−minprice)
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="数组" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    <category term="121.买卖股票的最佳时机" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 136.只出现一次的数字</title>
    <link href="http://example.com/2022/07/18/%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://example.com/2022/07/18/%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2022-07-18T12:20:37.000Z</published>
    <updated>2022-07-18T12:25:38.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136.只出现一次的数字"></a>136.只出现一次的数字</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。<br>说明：<br>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p>示例 1:<br>输入: [2,2,1]<br>输出: 1</p><p><a href="https://leetcode.cn/problems/single-number">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>python版本<br>遍历nums数组中的每一个数num，并使用list.count(num)统计num在nums中出现的次数，如果次数为1，返回num。</li><li>java版本<br>遍历nums数组中的每一个数num，使用HashMap记录每个num出现的次数，然后返回出现次数为1的num。<span id="more"></span><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2></li><li>python代码</li></ol><pre><code>class Solution(object):    def singleNumber(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: int        &quot;&quot;&quot;        for num in nums:            if nums.count(num) == 1:                return numif __name__ == &quot;__main__&quot;:    slt = Solution()    nums = [2, 2, 1]    result = slt.singleNumber(nums)    print(result)</code></pre><ol start="2"><li>java代码</li></ol><pre><code>import java.util.*;class Solution &#123;    public int singleNumber(int[] nums) &#123;        Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();        for(int num : nums)&#123;            if(map.get(num) == null)&#123;                map.put(num, 1);            &#125;else&#123;                map.put(num, map.get(num)+1);            &#125;        &#125;                for(int key: map.keySet())&#123;            if(map.get(key)==1)&#123;                return key;            &#125;        &#125;        return -1;    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;136-只出现一次的数字&quot;&gt;&lt;a href=&quot;#136-只出现一次的数字&quot; class=&quot;headerlink&quot; title=&quot;136.只出现一次的数字&quot;&gt;&lt;/a&gt;136.只出现一次的数字&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。&lt;br&gt;说明：&lt;br&gt;你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br&gt;输入: [2,2,1]&lt;br&gt;输出: 1&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/single-number&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;python版本&lt;br&gt;遍历nums数组中的每一个数num，并使用list.count(num)统计num在nums中出现的次数，如果次数为1，返回num。&lt;/li&gt;
&lt;li&gt;java版本&lt;br&gt;遍历nums数组中的每一个数num，使用HashMap记录每个num出现的次数，然后返回出现次数为1的num。&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="数组" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    <category term="136.只出现一次的数字" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 283.移动零</title>
    <link href="http://example.com/2022/07/18/%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
    <id>http://example.com/2022/07/18/%E7%A7%BB%E5%8A%A8%E9%9B%B6/</id>
    <published>2022-07-18T11:50:37.000Z</published>
    <updated>2022-07-18T11:53:33.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283.移动零"></a>283.移动零</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。<br>请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p><p>示例 1:<br>输入: nums = [0,1,0,3,12]<br>输出: [1,3,12,0,0]</p><p><a href="https://leetcode.cn/problems/move-zeroes">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。<br>右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。</p><p>注意到以下性质：<br>（1）左指针左边均为非零数；<br>（2）右指针左边直到左指针处均为零。</p><p>因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。</p><span id="more"></span><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):    def moveZeroes(self, nums):        &quot;&quot;&quot;        双指针        :type nums: List[int]        :rtype: None Do not return anything, modify nums in-place instead.        &quot;&quot;&quot;        n = len(nums)        left = right = 0        while right &lt; n:            if nums[right] != 0:                nums[left], nums[right] = nums[right], nums[left]                left += 1            right += 1if __name__ == &quot;__main__&quot;:    slt = Solution()    nums = [0, 1, 0, 3, 12]    slt.moveZeroes(nums)    print(nums)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;283-移动零&quot;&gt;&lt;a href=&quot;#283-移动零&quot; class=&quot;headerlink&quot; title=&quot;283.移动零&quot;&gt;&lt;/a&gt;283.移动零&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。&lt;br&gt;请注意 ，必须在不复制数组的情况下原地对数组进行操作。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br&gt;输入: nums = [0,1,0,3,12]&lt;br&gt;输出: [1,3,12,0,0]&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/move-zeroes&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。&lt;br&gt;右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。&lt;/p&gt;
&lt;p&gt;注意到以下性质：&lt;br&gt;（1）左指针左边均为非零数；&lt;br&gt;（2）右指针左边直到左指针处均为零。&lt;/p&gt;
&lt;p&gt;因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。&lt;/p&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="数组" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    <category term="283.移动零" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/283-%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 448.找到所有数组中消失的数字</title>
    <link href="http://example.com/2022/07/18/%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://example.com/2022/07/18/%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2022-07-18T09:52:00.000Z</published>
    <updated>2022-07-18T09:55:34.362Z</updated>
    
    <content type="html"><![CDATA[<h1 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="448.找到所有数组中消失的数字"></a>448.找到所有数组中消失的数字</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。</p><p>示例 1：<br>输入：nums = [4,3,2,7,8,2,3,1]<br>输出：[5,6]</p><p><a href="https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>可以通过集合求差集的方式实现<br>set1 = {4,3,2,7,8,2,3,1}<br>set2 = {1,2,3,4,5,6}<br>set2 - set1即为题目所求</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):    def findDisappearedNumbers(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: List[int]        &quot;&quot;&quot;        # 超出时间限制        # result = []        # for i in range(1, len(nums)+1):        #     if i not in nums:        #         result.append(i)        # return result        # 超出时间限制        # return [i for i in range(1, len(nums)+1) if i not in nums]        # 集合求差集        set1 = set(nums)        set2 = set([i for i in range(1, len(nums) + 1)])        return list(set2.difference(set1))if __name__ == &quot;__main__&quot;:    slt = Solution()    nums = [4, 3, 2, 7, 8, 2, 3, 1]    result = slt.findDisappearedNumbers(nums)    print(result)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;448-找到所有数组中消失的数字&quot;&gt;&lt;a href=&quot;#448-找到所有数组中消失的数字&quot; class=&quot;headerlink&quot; title=&quot;448.找到所有数组中消失的数字&quot;&gt;&lt;/a&gt;448.找到所有数组中消失的数字&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="数组" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    <category term="448.找到所有数组中消失的数字" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/448-%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="集合" scheme="http://example.com/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 338.比特位计数</title>
    <link href="http://example.com/2022/07/18/%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/"/>
    <id>http://example.com/2022/07/18/%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/</id>
    <published>2022-07-18T08:05:16.000Z</published>
    <updated>2022-07-18T08:10:55.110Z</updated>
    
    <content type="html"><![CDATA[<h1 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="338.比特位计数"></a>338.比特位计数</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数 n ，对于 0 &lt;= i &lt;= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。</p><p>示例 1：<br>输入：n = 2<br>输出：[0,1,1]<br>解释：<br>0 –&gt; 0<br>1 –&gt; 1<br>2 –&gt; 10</p><p><a href="https://leetcode.cn/problems/counting-bits">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><a href="https://leetcode.cn/problems/counting-bits/solution/python-by-sentiment-wsy3/">我的题解</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):    def countBits(self, n):        &quot;&quot;&quot;        :type n: int        :rtype: List[int]        &quot;&quot;&quot;        # result = []        # for i in range(0, n+1):        #     result.append(bin(i).count(&#39;1&#39;))        # return result        return [bin(i).count(&#39;1&#39;) for i in range(0, n+1)]</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;338-比特位计数&quot;&gt;&lt;a href=&quot;#338-比特位计数&quot; class=&quot;headerlink&quot; title=&quot;338.比特位计数&quot;&gt;&lt;/a&gt;338.比特位计数&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="进制转换" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    
    <category term="338.比特位计数" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/338-%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="进制转换" scheme="http://example.com/tags/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 461.汉明距离</title>
    <link href="http://example.com/2022/07/17/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/"/>
    <id>http://example.com/2022/07/17/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/</id>
    <published>2022-07-18T07:56:55.000Z</published>
    <updated>2022-07-18T08:00:37.372Z</updated>
    
    <content type="html"><![CDATA[<h1 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="461.汉明距离"></a>461.汉明距离</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。<br>给你两个整数 x 和 y，计算并返回它们之间的汉明距离。</p><p>示例 1：<br>输入：x = 1, y = 4<br>输出：2<br>解释：<br>1   (0 0 0 1)<br>4   (0 1 0 0)<br>       ↑   ↑<br>上面的箭头指出了对应二进制位不同的位置。</p><p><a href="https://leetcode.cn/problems/hamming-distance">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><a href="https://leetcode.cn/problems/hamming-distance/solution/pythonyi-xing-gao-ding-by-sentiment-sfk0/">我的题解</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):    def hammingDistance(self, x, y):        &quot;&quot;&quot;        :type x: int        :type y: int        :rtype: int        &quot;&quot;&quot;        return bin(x ^ y).count(&#39;1&#39;)if __name__ == &quot;__main__&quot;:    # # 十进制转二进制：bin(10)    # print(bin(10))    # # 十进制转八进制：oct(10)    # print(oct(10))    # # 十进制转十六进制：hex(10)    # print(hex(10))    #    # # 二进制转十进制：int(&quot;1010&quot;,2)    # print(int(&quot;1010&quot;, 2))    # # 八进制转十进制：int(&quot;0o12&quot;,8)    # print(int(&quot;0o12&quot;, 8))    # # 十六进制转十进制：int(&quot;0xa&quot;,16)    # print(int(&quot;0xa&quot;, 16))        # print(str(bin(1 ^ 4)).count(&#39;1&#39;))    # print(str(bin(3 ^ 1)).count(&#39;1&#39;))        slt = Solution()    result = slt.hammingDistance(1, 4)    print(result)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;461-汉明距离&quot;&gt;&lt;a href=&quot;#461-汉明距离&quot; class=&quot;headerlink&quot; title=&quot;461.汉明距离&quot;&gt;&lt;/a&gt;461.汉明距离&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="进制转换" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    
    <category term="461.汉明距离" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/461-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="进制转换" scheme="http://example.com/tags/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    
    <category term="汉明距离" scheme="http://example.com/tags/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 617.合并二叉树</title>
    <link href="http://example.com/2022/07/17/%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://example.com/2022/07/17/%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2022-07-18T07:21:21.000Z</published>
    <updated>2022-07-18T07:28:55.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617.合并二叉树"></a>617.合并二叉树</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两棵二叉树： root1 和 root2 。<br>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。<br>返回合并后的二叉树。<br>注意: 合并过程必须从两个树的根节点开始。</p><p>示例 1：<br>输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]<br>输出：[3,4,5,5,4,null,7]</p><p><a href="https://leetcode.cn/problems/merge-two-binary-trees">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>深度优先搜索<br>使用深度优先搜索合并两个二叉树。从根节点开始遍历两个二叉树，并将对应的节点进行合并。</li></ol><p>两个二叉树的对应节点可能存在以下三种情况，对于每种情况使用不同的合并方式。<br>（1）如果两个二叉树的对应节点都为空，则合并后的二叉树的对应节点也为空；<br>（2）如果两个二叉树的对应节点只有一个为空，则合并后的二叉树的对应节点为其中的非空节点；<br>（3）如果两个二叉树的对应节点都不为空，则合并后的二叉树的对应节点的值为两个二叉树的对应节点的值之和，此时需要显性合并两个节点。<br>对一个节点进行合并之后，还要对该节点的左右子树分别进行合并。这是一个递归的过程。<br>2. 广度优先搜索<br>使用广度优先搜索合并两个二叉树。首先判断两个二叉树是否为空，如果两个二叉树都为空，则合并后的二叉树也为空，如果只有一个二叉树为空，则合并后的二叉树为另一个非空的二叉树。</p><p>如果两个二叉树都不为空，则首先计算合并后的根节点的值，然后从合并后的二叉树与两个原始二叉树的根节点开始广度优先搜索，从根节点开始同时遍历每个二叉树，并将对应的节点进行合并。</p><p>使用三个队列分别存储合并后的二叉树的节点以及两个原始二叉树的节点。初始时将每个二叉树的根节点分别加入相应的队列。每次从每个队列中取出一个节点，判断两个原始二叉树的节点的左右子节点是否为空。如果两个原始二叉树的当前节点中至少有一个节点的左子节点不为空，则合并后的二叉树的对应节点的左子节点也不为空。对于右子节点同理。</p><p>如果合并后的二叉树的左子节点不为空，则需要根据两个原始二叉树的左子节点计算合并后的二叉树的左子节点以及整个左子树。考虑以下两种情况：<br>（1）如果两个原始二叉树的左子节点都不为空，则合并后的二叉树的左子节点的值为两个原始二叉树的左子节点的值之和，在创建合并后的二叉树的左子节点之后，将每个二叉树中的左子节点都加入相应的队列；<br>（2）如果两个原始二叉树的左子节点有一个为空，即有一个原始二叉树的左子树为空，则合并后的二叉树的左子树即为另一个原始二叉树的左子树，此时也不需要对非空左子树继续遍历，因此不需要将左子节点加入队列。<br>对于右子节点和右子树，处理方法与左子节点和左子树相同。</p><span id="more"></span><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class TreeNode(object):  # Definition for a binary tree node.    def __init__(self, val=0, left=None, right=None):        self.val = val        self.left = left        self.right = right                class Solution(object):    def mergeTrees(self, root1, root2):        &quot;&quot;&quot;        深度优先搜索        :type root1: TreeNode        :type root2: TreeNode        :rtype: TreeNode        &quot;&quot;&quot;        if not root1:            return root2        if not root2:            return root1        merged = TreeNode(root1.val + root2.val)        merged.left = self.mergeTrees(root1.left, root2.left)        merged.right = self.mergeTrees(root1.right, root2.right)        return merged        def mergeTrees1(self, root1, root2):        &quot;&quot;&quot;广度优先搜索&quot;&quot;&quot;        import collections        if not root1:            return root2        if not root2:            return root1                merged = TreeNode(root1.val + root2.val)        queue = collections.deque([merged])        queue1 = collections.deque([root1])        queue2 = collections.deque([root2])                while queue1 and queue2:            node = queue.popleft()            node1 = queue1.popleft()            node2 = queue2.popleft()            left1, right1 = node1.left, node1.right            left2, right2 = node2.left, node2.right                        if left1 and left2:                left = TreeNode(left1.val + left2.val)                node.left = left                queue.append(left)                queue1.append(left1)                queue2.append(left2)            elif left1:                node.left = left1            elif left2:                node.left = left2                        if right1 and right2:                right = TreeNode(right1.val + right2.val)                node.right = right                queue.append(right)                queue1.append(right1)                queue2.append(right2)            elif right1:                node.right = right1            elif right2:                node.right = right2        return merged        def preorder_traverse(self, root):        if not root:            return        print(root.val, end=&quot; &quot;)        self.preorder_traverse(root.left)        self.preorder_traverse(root.right)                if __name__ == &quot;__main__&quot;:    slt = Solution()        root1 = TreeNode(1)    node12 = TreeNode(3)    node13 = TreeNode(2)    node14 = TreeNode(5)    root1.left = node12    root1.right = node13    node12.left = node14        print(&quot;root1:&quot;, end=&quot;[&quot;)    slt.preorder_traverse(root1)    print(&quot;]&quot;)        root2 = TreeNode(2)    node22 = TreeNode(1)    node23 = TreeNode(3)    node24 = TreeNode(4)    node25 = TreeNode(7)    root2.left = node22    root2.right = node23    node22.right = node24    node23.right = node25        print(&quot;root2:&quot;, end=&quot;[&quot;)    slt.preorder_traverse(root2)    print(&quot;]&quot;)        # merged_tree = slt.mergeTrees(root1, root2)    merged_tree = slt.mergeTrees1(root1, root2)        print(&quot;merger tree:&quot;, end=&quot;[&quot;)    slt.preorder_traverse(merged_tree)    print(&quot;]&quot;)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;617-合并二叉树&quot;&gt;&lt;a href=&quot;#617-合并二叉树&quot; class=&quot;headerlink&quot; title=&quot;617.合并二叉树&quot;&gt;&lt;/a&gt;617.合并二叉树&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你两棵二叉树： root1 和 root2 。&lt;br&gt;想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。&lt;br&gt;返回合并后的二叉树。&lt;br&gt;注意: 合并过程必须从两个树的根节点开始。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;br&gt;输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]&lt;br&gt;输出：[3,4,5,5,4,null,7]&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/merge-two-binary-trees&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;深度优先搜索&lt;br&gt;使用深度优先搜索合并两个二叉树。从根节点开始遍历两个二叉树，并将对应的节点进行合并。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;两个二叉树的对应节点可能存在以下三种情况，对于每种情况使用不同的合并方式。&lt;br&gt;（1）如果两个二叉树的对应节点都为空，则合并后的二叉树的对应节点也为空；&lt;br&gt;（2）如果两个二叉树的对应节点只有一个为空，则合并后的二叉树的对应节点为其中的非空节点；&lt;br&gt;（3）如果两个二叉树的对应节点都不为空，则合并后的二叉树的对应节点的值为两个二叉树的对应节点的值之和，此时需要显性合并两个节点。&lt;br&gt;对一个节点进行合并之后，还要对该节点的左右子树分别进行合并。这是一个递归的过程。&lt;br&gt;2. 广度优先搜索&lt;br&gt;使用广度优先搜索合并两个二叉树。首先判断两个二叉树是否为空，如果两个二叉树都为空，则合并后的二叉树也为空，如果只有一个二叉树为空，则合并后的二叉树为另一个非空的二叉树。&lt;/p&gt;
&lt;p&gt;如果两个二叉树都不为空，则首先计算合并后的根节点的值，然后从合并后的二叉树与两个原始二叉树的根节点开始广度优先搜索，从根节点开始同时遍历每个二叉树，并将对应的节点进行合并。&lt;/p&gt;
&lt;p&gt;使用三个队列分别存储合并后的二叉树的节点以及两个原始二叉树的节点。初始时将每个二叉树的根节点分别加入相应的队列。每次从每个队列中取出一个节点，判断两个原始二叉树的节点的左右子节点是否为空。如果两个原始二叉树的当前节点中至少有一个节点的左子节点不为空，则合并后的二叉树的对应节点的左子节点也不为空。对于右子节点同理。&lt;/p&gt;
&lt;p&gt;如果合并后的二叉树的左子节点不为空，则需要根据两个原始二叉树的左子节点计算合并后的二叉树的左子节点以及整个左子树。考虑以下两种情况：&lt;br&gt;（1）如果两个原始二叉树的左子节点都不为空，则合并后的二叉树的左子节点的值为两个原始二叉树的左子节点的值之和，在创建合并后的二叉树的左子节点之后，将每个二叉树中的左子节点都加入相应的队列；&lt;br&gt;（2）如果两个原始二叉树的左子节点有一个为空，即有一个原始二叉树的左子树为空，则合并后的二叉树的左子树即为另一个原始二叉树的左子树，此时也不需要对非空左子树继续遍历，因此不需要将左子节点加入队列。&lt;br&gt;对于右子节点和右子树，处理方法与左子节点和左子树相同。&lt;/p&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%A0%91/"/>
    
    <category term="617.合并二叉树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%A0%91/617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 543.二叉树的直径</title>
    <link href="http://example.com/2022/07/16/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
    <id>http://example.com/2022/07/16/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</id>
    <published>2022-07-17T03:09:43.000Z</published>
    <updated>2022-07-17T03:22:45.902Z</updated>
    
    <content type="html"><![CDATA[<h1 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543.二叉树的直径"></a>543.二叉树的直径</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><p>示例 :<br>给定二叉树</p><pre><code>      1     / \    2   3   / \       4   5    </code></pre><p>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。<br>注意：两结点之间的路径长度是以它们之间边的数目表示。</p><p><a href="https://leetcode.cn/problems/diameter-of-binary-tree">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>深度优先搜索<br>首先我们知道<strong>一条路径的长度为该路径经过的节点数减一，所以求直径（即求路径长度的最大值）等效于求路径经过节点数的最大值减一</strong>。<br>而任意一条路径均可以被看作由某个节点为起点，从其左儿子和右儿子向下遍历的路径拼接得到。</li></ol><p>假设我们知道对于该节点的左儿子向下遍历经过最多的节点数 LLL （即以左儿子为根的子树的深度） 和其右儿子向下遍历经过最多的节点数 RRR （即以右儿子为根的子树的深度），那么以该节点为起点的路径经过节点数的最大值即为 L+R+1L+R+1L+R+1 。<br>我们记节点 node 为起点的路径经过节点数的最大值为 dnode​ ，那么二叉树的直径就是所有节点 dnode​的最大值减一。</p><p>算法流程为：我们定义一个递归函数 depth(node) 计算 dnode​，函数返回该节点为根的子树的深度。先递归调用左儿子和右儿子求得它们为根的子树的深度 L 和 R ，则该节点为根的子树的深度即为<br>max(L,R)+1，该节点的 dnode​值为 L+R+1，递归搜索每个节点并设一个全局变量 ans 记录 dnode​的最大值，最后返回 ans-1 即为树的直径。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class TreeNode(object):  # Definition for a binary tree node.    def __init__(self, val=0, left=None, right=None):        self.val = val        self.left = left        self.right = rightclass Solution(object):    def diameterOfBinaryTree(self, root):        &quot;&quot;&quot;        这种解法路径必须经过根节点，由题目可知路径可能穿过        也可能不穿过根节点，故此解法不符合题意        :type root: TreeNode        :rtype: int        &quot;&quot;&quot;        left = self.get_depth(root.left)        right = self.get_depth(root.right)        return left + right        def get_depth(self, root):        if not root:            return 0        left_depth = self.get_depth(root.left)        right_depth = self.get_depth(root.right)        return max(left_depth, right_depth) + 1        def diameterOfBinaryTree1(self, root):        self.ans = 1        def depth(node):            if not node:                return 0            L = depth(node.left)            R = depth(node.right)            self.ans = max(self.ans, L + R + 1)            return max(L, R) + 1        depth(root)        return self.ans - 1  # 一条路径的长度为该路径经过的节点数减一if __name__ == &quot;__main__&quot;:    slt = Solution()    root = TreeNode(1)    node2 = TreeNode(2)    node3 = TreeNode(3)    node4 = TreeNode(4)    node5 = TreeNode(5)    root.left = node2    root.right = node3    node2.left = node4    node2.right = node5    # diameter = slt.diameterOfBinaryTree(root)    diameter = slt.diameterOfBinaryTree1(root)    print(&quot;diameter:&quot;, diameter)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;543-二叉树的直径&quot;&gt;&lt;a href=&quot;#543-二叉树的直径&quot; class=&quot;headerlink&quot; title=&quot;543.二叉树的直径&quot;&gt;&lt;/a&gt;543.二叉树的直径&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;head</summary>
      
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%A0%91/"/>
    
    <category term="543.二叉树的直径" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%A0%91/543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 226.翻转二叉树</title>
    <link href="http://example.com/2022/07/16/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://example.com/2022/07/16/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2022-07-16T13:47:31.000Z</published>
    <updated>2022-07-16T13:54:40.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226.翻转二叉树"></a>226.翻转二叉树</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</p><p>示例 1：<br>输入：root = [4,2,7,1,3,6,9]<br>输出：[4,7,2,9,6,3,1]</p><p><a href="https://leetcode.cn/problems/invert-binary-tree">题目链接</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>递归法<br>分析题目输入和输出发现，输出的左右子树的位置跟输入正好是相反的，于是我们可以递归的交换左右子树来实现。<br>其实就是交换一下左右节点，然后再递归的交换左节点，右节点<br>递归的两个条件如下：<br> 终止条件：当前节点为 null 时返回<br> 交换当前节点的左右节点，再递归的交换当前节点的左节点，递归的交换当前节点的右节点时间复杂度：每个元素都必须访问一次，所以是 O(n)<br>空间复杂度：最坏的情况下，需要存放 O(h) 个函数调用(h是树的高度)，所以是 O(h)<span id="more"></span></li><li>迭代法<br>递归实现也就是深度优先遍历的方式，那么对应的就是广度优先遍历。<br>广度优先遍历需要额外的数据结构–队列，来存放临时遍历到的元素。</li></ol><p>我们需要先将根节点放入到队列中，然后不断的迭代队列中的元素。<br>对当前元素调换其左右子树的位置，然后：<br>    判断其左子树是否为空，不为空就放入队列中<br>    判断其右子树是否为空，不为空就放入队列中</p><p>时间复杂度：同样每个节点都需要入队列/出队列一次，所以是 O(n)<br>空间复杂度：最坏的情况下会包含所有的叶子节点，完全二叉树叶子节点是 n/2个，所以时间复杂度是 0(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class TreeNode(object):  # Definition for a binary tree node.    def __init__(self, val=0, left=None, right=None):        self.val = val        self.left = left        self.right = rightclass Solution(object):    def invertTree(self, root):        &quot;&quot;&quot;        递归法（深度优先遍历方式）        :type root: TreeNode        :rtype: TreeNode        &quot;&quot;&quot;        if not root:            return root                left = self.invertTree(root.left)        right = self.invertTree(root.right)        root.left, root.right = right, left        return root        def invertTree1(self, root):        &quot;&quot;&quot;迭代法（广度优先遍历方式，需要辅助队列）&quot;&quot;&quot;        if not root:            return root        # 将二叉树的节点逐层放入队列中，再迭代处理队列中的元素        queue = [root]        while queue:            # 每次都从队列中拿一个节点，并交换这个节点的左右子树            tmp = queue.pop(0)            tmp.left, tmp.right = tmp.right, tmp.left            # 如果当前节点的左子树不空，则放入队列等待后续处理            if tmp.left:                queue.append(tmp.left)            if tmp.right:                queue.append(tmp.right)        return root        def preorder_traverse(self, root):        if not root:            return        print(root.val)        self.preorder_traverse(root.left)        self.preorder_traverse(root.right)if __name__ == &quot;__main__&quot;:    root = TreeNode(4)    node2 = TreeNode(2)    node3 = TreeNode(7)    node4 = TreeNode(1)    node5 = TreeNode(3)    node6 = TreeNode(6)    node7 = TreeNode(9)    root.left = node2    root.right = node3    node2.left = node4    node2.right = node5    node3.left = node6    node3.right = node7        slt = Solution()    # invertTree = slt.invertTree(root)    invertTree = slt.invertTree1(root)    slt.preorder_traverse(invertTree)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;226-翻转二叉树&quot;&gt;&lt;a href=&quot;#226-翻转二叉树&quot; class=&quot;headerlink&quot; title=&quot;226.翻转二叉树&quot;&gt;&lt;/a&gt;226.翻转二叉树&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;br&gt;输入：root = [4,2,7,1,3,6,9]&lt;br&gt;输出：[4,7,2,9,6,3,1]&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/invert-binary-tree&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;递归法&lt;br&gt;分析题目输入和输出发现，输出的左右子树的位置跟输入正好是相反的，于是我们可以递归的交换左右子树来实现。&lt;br&gt;其实就是交换一下左右节点，然后再递归的交换左节点，右节点&lt;br&gt;递归的两个条件如下：&lt;br&gt; 终止条件：当前节点为 null 时返回&lt;br&gt; 交换当前节点的左右节点，再递归的交换当前节点的左节点，递归的交换当前节点的右节点时间复杂度：每个元素都必须访问一次，所以是 O(n)&lt;br&gt;空间复杂度：最坏的情况下，需要存放 O(h) 个函数调用(h是树的高度)，所以是 O(h)&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%A0%91/"/>
    
    <category term="226.翻转二叉树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%A0%91/226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 101.对称二叉树</title>
    <link href="http://example.com/2022/07/16/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://example.com/2022/07/16/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2022-07-16T10:36:02.000Z</published>
    <updated>2022-07-16T10:38:13.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101.对称二叉树"></a>101.对称二叉树</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个二叉树的根节点 root ， 检查它是否轴对称。</p><p><a href="https://leetcode.cn/problems/symmetric-tree/">题目链接</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># Definition for a binary tree node.class TreeNode(object):    def __init__(self, val=0, left=None, right=None):        self.val = val        self.left = left        self.right = rightclass Solution(object):    def isSymmetric(self, root):        &quot;&quot;&quot;        递归法                两个树互为镜像：            它们的两个根结点具有相同的值            每个树的右子树都与另一个树的左子树镜像对称        :type root: TreeNode        :rtype: bool        &quot;&quot;&quot;        return self.check(root, root)        def check(self, p, q):        if not p and not q:            return True        if not p or not q:            return False        return p.val == q.val and self.check(p.left, q.right) and self.check(p.right, q.left)        def isSymmetric1(self, root):        &quot;&quot;&quot;迭代法&quot;&quot;&quot;        queue = list()        queue.append(root)        queue.append(root)        while len(queue) != 0:            t1 = queue.pop(0)            t2 = queue.pop(0)            if not t1 and not t2:                continue            if not t1 or not t2:                return False            if t1.val != t2.val:                return False            queue.append(t1.left)            queue.append(t2.right)            queue.append(t1.right)            queue.append(t2.left)        return Trueif __name__ == &quot;__main__&quot;:    root = TreeNode(1)    node2 = TreeNode(2)    node3 = TreeNode(2)    node4 = TreeNode(3)    node5 = TreeNode(4)    node6 = TreeNode(4)    node7 = TreeNode(3)        slt = Solution()    # result = slt.isSymmetric(root)    result = slt.isSymmetric(root)    print(result)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;101-对称二叉树&quot;&gt;&lt;a href=&quot;#101-对称二叉树&quot; class=&quot;headerlink&quot; title=&quot;101.对称二叉树&quot;&gt;&lt;/a&gt;101.对称二叉树&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%A0%91/"/>
    
    <category term="101.对称二叉树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%A0%91/101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode | 53.最大子数组和</title>
    <link href="http://example.com/2022/07/16/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/"/>
    <id>http://example.com/2022/07/16/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</id>
    <published>2022-07-16T09:28:28.000Z</published>
    <updated>2022-07-16T09:57:03.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53.最大子数组和"></a>53.最大子数组和</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>子数组 是数组中的一个连续部分。</p><p>示例 1：<br>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6<br>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</p><p><a href="https://leetcode.cn/problems/maximum-subarray/">题目链接</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution(object):    def maxSubArray(self, nums):        &quot;&quot;&quot;        动态规划                用f(i)代表以第i个数结尾的连续子数组的最大和，那么我们的目标就是求                            max&#123;f(i)&#125;,0&lt;=i&lt;=n-1        如何求 f(i) 呢？        我们可以考虑 nums[i] 单独成为一段还是加入 f(i−1)对应的那一段，这取决于 nums[i] 和 f(i−1)+nums[i] 的大小，        我们希望获得一个比较大的，于是可以写出这样的动态规划转移方程：                            f(i)=max&#123;f(i-1)+nums[i], nums[i]&#125;        :type nums: List[int]        :rtype: int        &quot;&quot;&quot;        # pre = 0        # maxAns = nums[0]        # for x in nums:        #     pre = max(pre + x, x)        #     maxAns = max(maxAns, pre)        # return maxAns                fi_array = [nums[0]]        for i in range(1, len(nums)):            fi_array.append(max(fi_array[i-1]+nums[i], nums[i]))        return max(fi_array)        def maxSubArray1(self, nums):        &quot;&quot;&quot;        动态规划                若前一个元素大于0，则将其加到当前元素上        &quot;&quot;&quot;        for i in range(1, len(nums)):            # 若前一个元素大于0，则将其加到当前元素上            if nums[i - 1] &gt; 0:                nums[i] += nums[i-1]        return max(nums)  # 返回修改过的数组中的最大值            def maxSubArray2(self, nums):        &quot;&quot;&quot;        贪心算法                # 若当前指针所指元素之前的和小于0，则丢弃当前元素之前的数列        &quot;&quot;&quot;        if not nums:  # 设置边界条件（列表为空）            return -2147483648        cur_sum = max_sum = nums[0]  # 当前和和最大和设置为列表第一个元素        for i in range(1, len(nums)):            # 若当前指针所指元素之前的和小于0，则丢弃当前元素之前的数列            cur_sum = max(nums[i], cur_sum+nums[i])                        # 将当前和与最大和作比较，取最大            max_sum = max(cur_sum, max_sum)                return max_sumif __name__ == &quot;__main__&quot;:    slt = Solution()    nums = list([-2, 1, -3, 4, -1, 2, 1, -5, 4])    res = slt.maxSubArray(nums)    # res = slt.maxSubArray1(nums)    print(res)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;53-最大子数组和&quot;&gt;&lt;a href=&quot;#53-最大子数组和&quot; class=&quot;headerlink&quot; title=&quot;53.最大子数组和&quot;&gt;&lt;/a&gt;53.最大子数组和&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/"/>
    
    <category term="数组" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    <category term="53.最大子数组和" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode/%E6%95%B0%E7%BB%84/53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
